---
name: 网络及安全防护面试题模板
about: 这是一个用于发布网络及安全防护面试题的模板
title: "[网络] "
labels: 网络安全
assignees: ''

---


---
name: 框架工程项目面试题模板
about: 这是一个用于发布框架工程项目面试题的模板
title: "[框架工程项目] "
labels: 框架工程项目
assignees: ''

---


---
name: Node面试题模板
about: 这是一个用于发布nodejs面试题的模板
title: "[node] "
labels: Node
assignees: ''

---


---
name: ES6面试题模板
about: 这是一个用于发布ES6面试题的模板
title: "[ES6] "
labels: ES6
assignees: ''

---


---
name: Git面试题模板
about: 这是一个用于发布Git面试题的模板
title: "[Git] "
labels: Git
assignees: ''

---


---
name: HTML面试题模板
about: 这是一个用于发布html面试题的模板
title: "[html] "
labels: HTML
assignees: ''

---


---
name: jQuery面试题模板
about: 这是一个用于发布jQuery面试题的模板
title: "[jQuery] "
labels: jQuery
assignees: ''

---


---
name: JS面试题模板
about: 这是一个用于发布js面试题的模板
title: "[js] "
labels: JS
assignees: ''

---


---
name: VUE面试题模板
about: 这是一个用于发布vue面试题的模板
title: "[vue] "
labels: VUE
assignees: ''

---


# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1.angular 的数据绑定采用什么机制？详述原理</summary></b>

参考答案：脏检查机制。

解析：
双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。

原理就是，Angular 在 scope 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。

[参与互动](https://github.com/yisainan/web-interview/issues/525)

</details>

<b><details><summary>2. AngularJS 的数据双向绑定是怎么实现的？</summary></b>

参考答案：

1、每个双向绑定的元素都有一个 watcher

2、在某些事件发生的时候，调用 digest 脏数据检测。

这些事件有：表单元素内容变化、Ajax 请求响应、点击按钮执行的函数等。

3、脏数据检测会检测 rootscope 下所有被 watcher 的元素。

\$digest 函数就是脏数据监测

[参与互动](https://github.com/yisainan/web-interview/issues/526)

</details>

<b><details><summary>3. 在使用 angularjs 项目开发中 你使用过那些第三方的插件</summary></b>

参考答案：AngularUi ui-router oclazyload 等等 附上一篇文章仔细去看看 https://segmentfault.com/a/1190000003858219

[参与互动](https://github.com/yisainan/web-interview/issues/527)

</details>

<b><details><summary>4.ng-show/ng-hide 与 ng-if 的区别？</summary></b>

参考答案：我们都知道 ng-show/ng-hide 实际上是通过 display 来进行隐藏和显示的。而 ng-if 实际上控制 dom 节点的增删除来实现的。因此如果我们是根据不同的条件来进行 dom 节点的加载的话，那么 ng-if 的性能好过 ng-show.

[参与互动](https://github.com/yisainan/web-interview/issues/528)

</details>

<b><details><summary>5. 解释下什么是$rootScrope以及和$scope 的区别？</summary></b>

参考答案：通俗的说$rootScrope 页面所有$scope 的父亲。

解析：

我们来看下如何产生$rootScope和$scope 吧。

step1: Angular 解析 ng-app 然后在内存中创建\$rootScope。

step2:angular 回继续解析，找到 `{{}}` 表达式，并解析成变量。

step3: 接着会解析带有 ng-controller 的 div 然后指向到某个 controller 函数。 这个时候在这个 controller 函数变成一个\$scope 对象实例。

[参与互动](https://github.com/yisainan/web-interview/issues/529)

</details>

<b><details><summary>6. 列出至少三种实现不同模块之间通信方式？</summary></b>

参考答案：

* Service
* events, 指定绑定的事件
* 使用 \$rootScope
* controller 之间直接使用$parent, $\$childHead 等
* directive 指定属性进行数据绑定

[参与互动](https://github.com/yisainan/web-interview/issues/530)

</details>

<b><details><summary>7. 表达式 `{{yourModel}}` 是如何工作的？</summary></b>

参考答案：

它依赖于 $interpolation服务，在初始化页面html后，它会找到这些表达式，并且进行标记，于是每遇见一个 `{{}}` ，则会设置一个 $watch 。而 $interpolation 会返回一个带有上下文参数的函数，最后该函数执行，则算是表达式 $parse 到那个作用域上。

[参与互动](https://github.com/yisainan/web-interview/issues/531)

</details>

<b><details><summary>8.angular 中的\$http</summary></b>

参考答案：\$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。

我们可以使用内置的$http服务直接同外部进行通信。$http 服务只是简单的封装了浏览器原生的 XMLHttpRequest 对象。

[参与互动](https://github.com/yisainan/web-interview/issues/532)

</details>

<b><details><summary>9.ng-repeat 迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？</summary></b>

参考答案：会提示 Duplicates in a repeater are not allowed. 加 track by \$index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联）

[参与互动](https://github.com/yisainan/web-interview/issues/533)

</details>

<b><details><summary>10.angularjs 是 mvc 还是 mvvm 框架</summary></b>

参考答案：mvvm

解析：

首先阐述下你对 mvc 和 mvvm 的理解:

首先为什么我们会需要 MVC？因为随着代码规模越来越大，切分职责是大势所趋，还有为了后期维护方便，修改一块功能不影响其他功能。还有为了复用，因为很多逻辑是一样的。而 MVC 只是手段，终极目标是模块化和复用。

mvvm 的优点

低耦合：View 可以独立于 Model 变化和修改，同一个 ViewModel 可以被多个 View 复用；并且可以做到 View 和 Model 的变化互不影响；

可重用性：可以把一些视图的逻辑放在 ViewModel，让多个 View 复用；

独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi 计人员可以专注于 UI(View)的设计；

可测试性：清晰的 View 分层，使得针对表现层业务逻辑的测试更容易，更简单。

在 angular 中 MVVM 模式主要分为四部分：

View：它专注于界面的显示和渲染，在 angular 中则是包含一堆声明式 Directive 的视图模板。

ViewModel：它是 View 和 Model 的粘合体，负责 View 和 Model 的交互和协作，它负责给 View 提供显示的数据，以及提供了 View 中 Command 事件操作 Model 的途径；在 angular 中\$scope 对象充当了这个 ViewModel 的角色；

Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model 并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在 web 页面中，大部分 Model 都是来自 Ajax 的服务端返回数据或者是全局的配置对象；而 angular 中的 service 则是封装和处理这些与 Model 相关的业务逻辑的场所，这类的业务服务是可以被多个 Controller 或者其他 service 复用的领域服务。

Controller：这并不是 MVVM 模式的核心元素，但它负责 ViewModel 对象的初始化，它将组合一个或者多个 service 来获取业务领域 Model 放在 ViewModel 对象上，使得应用界面在启动加载的时候达到一种可用的状态。

mvc 的界面和逻辑关联紧密，数据直接从数据库读取。mvvm 的界面与 viewmode 是松耦合，界面数据从 viewmodel 中获取。所以 angularjs 更倾向于 mvvm

[参与互动](https://github.com/yisainan/web-interview/issues/534)

</details>

<b><details><summary>11.angularjs 中\$scope，controller，directive，sevice 在 mvvm 中充当什么角色</summary></b>

参考答案：如果你不知道，第一题的分析以及很明确，仔细再仔细的看一遍

[参与互动](https://github.com/yisainan/web-interview/issues/535)

</details>

<b><details><summary>12. 在 angular 项目中你如何控制静态资源的合理加载</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/536)

</details>

<b><details><summary>13. 在写 controlloer 逻辑的时候 你需要注意什么？</summary></b>

参考答案：

1. 简化代码（这个是所有开发人员都要具备的）

2. 坚决不能操作 dom 节点 这个时候可能会问 为什么不能啊

你的回答是：DOM 操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular 倡导以测试驱动开发，在 service 或者 controller 中出现了 DOM 操作，那么也就意味着的测试是无法通过的。当然，这只是一点，重要的是使用 Angular 的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的 DOM 操作。如果在 Angular 的代码中还到处充斥着各种 DOM 操作，那为什么不直接使用 jquery 去开发呢。

测试驱动开发是什么呢？普及一下：

测试驱动开发，英文全称 Test-Driven Development，简称 TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。

[参与互动](https://github.com/yisainan/web-interview/issues/537)

</details>

<b><details><summary>14.controller 之间怎么通讯</summary></b>

参考答案：

1、event

这里可以有两种方式，一种是$scope.$emit，然后通过监听$rootScope的事件获取参数；另一种是$rootScope.$broadcast，通过监听$scope 的事件获取参数。

这两种方法在最新版本的 Angular 中已经没有性能区别了，主要就是事件发送的方向不同，可以按实际情况选择。

2、service

可以创建一个专用的事件 Service，也可以按照业务逻辑切分，将数据存储在相应的 Service 中

3、\$rootScope

这个方法可能会比较 dirty 一点，胜在方便，也就是把数据存在$rootScope中，这样各个子$scope 都可以调用，不过需要注意一下生命周期

4、直接使用$scope.$\$nextSibling 及类似的属性

类似的还有$scope.$parent。这个方法的缺点就更多了，官方不推荐使用任何\$\$开头的属性，既增加了耦合，又需要处理异步的问题，而且 scope 的顺序也不是固定的。不推荐

另外就是通过本地存储、全局变量或者现代浏览器的 postMessage 来传递参数了，除非特殊情况，请避免这类方式。

[参与互动](https://github.com/yisainan/web-interview/issues/538)

</details>

<b><details><summary>15. 自定义指令的几个参数</summary></b>

参考答案：

说几个常用的如：

restrict: 指令在 dom 中的声明形式 E（元素）A（属性）C（类名）M（注释）

template：两种形式，一种 HTML 文本；一个可以接受两个参数的函数，tElemetn 和 tAttrs，并返回一个代表模板的字符串。模板字符串必须存在一个根 DOM 元素

templateUrl: 两种形式，一种代表外部 HTML 文件路径的字符串；一个可以接受两个参数的函数，参数为 tElement 和 tAttrs，并返回一个外部 HTML 文件路径的字符串

compile (对象或函数)：compile 选项可以返回一个对象或函数。如果设置了 compile 函数, 说明我们希望在指令和实时数据被放到 DOM 中之前进行 DOM 操作, 在这个函数中进行诸如添加和删除节点等 DOM 操作是安全的。本质上, 当我们设置了 link 选项, 实际上是创建了一个 postLink() 链接函数, 以便 compile() 函数可以定义链接函数。

然后又是传送门：http://www.cnblogs.com/mliudong/p/4180680.html

compile 和 link 的区别：

编译的时候，compile 转换 dom，碰到绑定监听器的地方就先存着，有几个存几个，到最后汇总成一个 link 函数，一并执行，提升了性能。

[参与互动](https://github.com/yisainan/web-interview/issues/539)

</details>

<b><details><summary>16.angular 和 jquery 的区别</summary></b>

参考答案：

angular 是基于数据驱动，所以 angular 适合做数据操作比较繁琐的项目（这里可以再提一下单页面应用，如果你不会福利又来了 http://www.zhihu.com/question/20792064）

jquery 是基于 dom 驱动，jquery 适合做 dom 操作多的项目

[参与互动](https://github.com/yisainan/web-interview/issues/540)

</details>

<b><details><summary>17. 对 angular 中的 form 表单了解多少</summary></b>

参考答案：

Angular 对 input 元素的 type 进行了扩展，一共提供了以下 10 种类型：

text

number

url

email

radio

checkbox

hidden

button

submit

reset

Angular 为表单内置了 4 中 CSS 样式。

ng-valid 校验合法状态

ng-invalid 校验非法状态

ng-pristine 如果要使用原生的 form，需要设置这个值

ng-dirty      表单处于脏数据状态

Angular 在对表单进行自动校验的时候会校验 Model 上的属性，如果不设置 ng-model，则 Angular 无法知道 myForm.\$invalid 这个值是否为真。

校验的一下内容

required 表示是否输入内容

ng-maxlength 最大长度

ng-minlength 最小长度

例子：传送门https://github.com/18500047564/clutter

[参与互动](https://github.com/yisainan/web-interview/issues/541)

</details>

<b><details><summary>18.fliter 是什么你了解的有多少？实现一个自定义 fliter</summary></b>

参考答案：

date（日期）

currency（货币）

limitTo（限制数组或字符串长度）

orderBy（排序）

lowercase（小写）

uppercase（大写）

number（格式化数字，加上千位分隔符，并接收参数限定小数点位数）

filter（处理一个数组，过滤出含有某个子串的元素）

json（格式化 json 对象）

filter 有两种使用方法，

一种是直接在页面里：

```html
<p>`{{now | date : ‘yyyy-MM-dd’}}`</p>
```

另一种是在 js 里面用：

\$filter('过滤器名称')(需要过滤的对象, 参数 1, 参数 2, ...)

\$filter('date')(now, 'yyyy-MM-dd hh:mm:ss’); 

自定义一个去重数组的

```js
app.filter("unique", function() {
    return function(arr) {
        var n = [];
        var obj = {};

        for (var i = 0; i < arr.length; i++) {
            if (!obj[arr[i]]) {
                n.push(arr[i]);
                obj[arr[i]] = 1;
            }
        }

        return n;
    };
});
```

[参与互动](https://github.com/yisainan/web-interview/issues/542)

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</summary></b>

参考答案：

``` html
<div style="height:1px;overflow:hidden;background:red"></div>
```

[参与互动](https://github.com/yisainan/web-interview/issues/22)

</details>

<b><details><summary>2. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</summary></b>

参考答案：

（1）有两种， IE 盒子模型、W3C 盒子模型；

（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；

（3）区 别： IE 的 content 部分把 border 和 padding 计算了进去; 

相关知识点：

```
（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）
（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分

IE盒模型和W3C标准盒模型的区别：

（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding
（2）IE盒模型：属性width，height包含content、border和padding，指的是content
+padding+border。

在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；
如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE
盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。
```

回答：

```
盒模型都是由四个部分组成的，分别是margin、border、padding和content。

标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的
范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。

一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
```

详细的资料可以参考：
[《CSS 盒模型详解》](https://juejin.im/post/59ef72f5f265da4320026f76)

[参与互动](https://github.com/yisainan/web-interview/issues/23)

</details>

<b><details><summary>3. CSS 隐藏元素的几种方法（至少说出三种）</summary></b>

参考答案：

Opacity: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互; 

Visibility: 与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏; 

Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在; 

Position: 不会影响布局，能让元素保持可以操作; 

Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低; 

[参与互动](https://github.com/yisainan/web-interview/issues/24)

</details>

<b><details><summary>4. CSS 清除浮动的几种方法（至少两种）</summary></b>

参考答案：

``` 
清除浮动： 核心：clear:both;

1.使用额外标签法（不推荐使用）

在浮动的盒子下面再放一个标签，使用 clear:both;来清除浮动

a 内部标签：会将父盒子的高度重新撑开

b 外部标签：只能将浮动盒子的影响清除，但是不会撑开盒子

2.使用 overflow 清除浮动（不推荐使用）

先找到浮动盒子的父元素，给父元素添加一个属性：overflow:hidden;就会清除子元素对页面的影响

3.使用伪元素清除浮动(用的最多)

伪元素：在页面上不存在的元素，但是可以通过 css 添加上去

种类：
      :after(在。。。之后)
      :before(在。。。之前)

注意：每个元素都有自己的伪元素

.clearfix:after {
    content:"";
    height:0;
    line-height:0;
    display:block;
    clear:both;
    visibility:hidden;  /_将元素隐藏起来_/ 
      在页面的 clearfix 元素后面添加了一个空的块级元素
     （这个元素的高为 0 行高也为 0   并且这个元素清除了浮动）
}
.clearfix {
  zoom:1;/_为了兼容 IE6_/
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/25)

</details>

<b><details><summary>5. 页面导入样式时，使用 link 和@import 有什么区别？</summary></b>

参考答案：

1\. Link 属于 html 标签，而@import 是 CSS 中提供的

2\. 在页面加载的时候，link 会同时被加载，而@import 引用的 CSS 会在页面加载完成后才会加载引用的 CSS

3\. @import 只有在 ie5 以上才可以被识别，而 link 是 html 标签，不存在浏览器兼容性问题

4\. Link 引入样式的权重大于@import 的引用（@import 是将引用的样式导入到当前的页面中）

[参与互动](https://github.com/yisainan/web-interview/issues/26)

</details>

<b><details><summary>6. 伪元素和伪类的区别？</summary></b>

参考答案：

1、伪元素使用 2 个冒号，常见的有：::before，::after，::first-line，::first-letter，::selection、::placeholder 等；

      伪类使用1个冒号，常见的有：:hover，:link，:active，:target，:not()，:focus等。

2、伪元素添加了一个页面中没有的元素（只是从视觉效果上添加了，不是在文档树中添加）；

      伪类是给页面中已经存在的元素添加一个类。

解析：

CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（ `:first-line` ， `:first-letter` ）或将元素添加到标记中（与 content:... 组合），而不必修改标记（ `:before` ， `:after` ）。

* `:first-line` 和 `:first-letter` 可以用来修饰文字。
* 上面提到的 `.clearfix` 方法中，使用 `clear: both` 来添加不占空间的元素。
* 使用 `:before` 和 `after` 展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。

[参考](https://css-tricks.com/almanac/selectors/a/after-and-before/)

[参与互动](https://github.com/yisainan/web-interview/issues/27)

</details>

<b><details><summary>7. CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有那些？</summary></b>

参考答案：

``` 

（1）id选择器（#myid）
（2）类选择器（.myclassname）
（3）标签选择器（div,h1,p）
（4）后代选择器（h1 p）
（5）相邻后代选择器（子）选择器（ul>li）
（6）兄弟选择器（li~a）
（7）相邻兄弟选择器（li+a）
（8）属性选择器（a[rel="external"]）
（9）伪类选择器（a:hover,li:nth-child）
（10）伪元素选择器（::before、::after）
（11）通配符选择器（*）

 * 继承： font-size font-family color, UL LI DL DD DT;

 * 不可继承 ：border padding margin width height ;

 * 优先级就近原则，样式定义最近者为准;

 * 载入样式以最后载入的定位为准;

优先级为:

       !important >  id > class > tag  

       important 比 内联优先级高

CSS3新增伪类举例：

    p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。

    p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。

    p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。

    p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。

    p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。

    :enabled、:disabled 控制表单控件的禁用状态。

    :checked，单选框或复选框被选中。

```

[参与互动](https://github.com/yisainan/web-interview/issues/28)

</details>

<b><details><summary>8. 行内元素和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？</summary></b>

参考答案：

* 块级元素(block)特性：

  + 总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示; 
  + 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制; 

* 内联元素(inline)特性：
  + 和相邻的内联元素在同一行; 
  + 宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom)和外边距的 top/bottom(margin-top/margin-bottom)都不可改变（也就是 padding 和 margin 的 left 和 right 是可以设置的），就是里面文字或图片的大小。

那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？

参考答案： `<input> 、<img> 、<button> 、<texterea> 、<label>。` 

[参与互动](https://github.com/yisainan/web-interview/issues/29)

</details>

<b><details><summary>9. 什么是外边距重叠？重叠的结果是什么？</summary></b>

参考答案：

外边距重叠就是 margin-collapse。

在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。

折叠结果遵循下列计算规则：

1\. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。

2\. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。

3\. 两个外边距一正一负时，折叠结果是两者的相加的和。

[参与互动](https://github.com/yisainan/web-interview/issues/30)

</details>

<b><details><summary>10. rgba()和 opacity 的透明效果有什么不同？</summary></b>

参考答案：

rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度，

而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）

[参与互动](https://github.com/yisainan/web-interview/issues/31)

</details>

<b><details><summary>11. css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</summary></b>

参考答案：

垂直方向：line-height

水平方向：letter-spacing

那么问题来了，关于 letter-spacing 的妙用知道有哪些么？

参考答案: 可以用于消除 inline-block 元素间的换行符空格间隙问题。

[参与互动](https://github.com/yisainan/web-interview/issues/32)

</details>

<b><details><summary>12. px 和 em 的区别。</summary></b>

参考答案：px 和 em 都是长度单位，区别是，px 的值是固定的，指定是多少就是多少，计算比较容易。em 得值不是固定的，并且 em 会继承父级元素的字体大小。

浏览器的默认字体高都是 16px。所以未经调整的浏览器都符合: 1em=16px。那么 12px=0. 75em, 10px=0. 625em。

[参与互动](https://github.com/yisainan/web-interview/issues/33)

</details>

<b><details><summary>13. 如何垂直居中一个元素？</summary></b>

参考答案：

方法一：绝对定位居中（原始版之已知元素的高宽）

``` css
.content {
    width: 200px;
    height: 200px;
    background-color: #6699ff;
    position: absolute;
    /*父元素需要相对定位*/
    top: 50%;
    left: 50%;
    margin-top: -100px;
    /*设为高度的1/2*/
    margin-left: -100px;
    /*设为宽度的1/2*/
}
```

方法二：绝对定位居中（改进版之一未知元素的高宽）

``` css
.content {
    width: 200px;
    height: 200px;
    background-color: #6699ff;
    position: absolute;
    /*父元素需要相对定位*/
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    /*在水平和垂直方向上各偏移-50%*/
}
```

方法三：绝对定位居中（改进版之二未知元素的高宽）

``` css
.content {
    width: 200px;
    height: 200px;
    background-color: #6699ff;
    margin: auto;
    /*很关键的一步*/
    position: absolute;
    /*父元素需要相对定位*/
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    /*让四个定位属性都为0*/
}
```

方法四：flex 布局居中

``` css
body {
    display: flex;
    /*设置外层盒子display为flex*/
    align-items: center;
    /*设置内层盒子的垂直居中*/
    justify-content: center;

    /*设置内层盒子的水平居中*/
    .content {
        width: 200px;
        height: 200px;
        background-color: #6699ff;
    }
}
```

那么问题来了，如何垂直居中一个 img（用更简便的方法。）

``` css
.content {
    //img的容器设置如下
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/34)

</details>

<b><details><summary>14. BFC </summary></b>

参考答案：

* 什么是 BFC

  BFC（Block Formatting Context）格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。

* 形成 BFC 的条件

  + 浮动元素，float 除 none 以外的值
  + 定位元素，position（absolute，fixed）
  + display 为以下其中之一的值 inline-block，table-cell，table-caption
  + overflow 除了 visible 以外的值（hidden，auto，scroll）

* BFC 的特性
  + 内部的 Box 会在垂直方向上一个接一个的放置。
  + 垂直方向上的距离由 margin 决定
  + bfc 的区域不会与 float 的元素区域重叠。
  + 计算 bfc 的高度时，浮动元素也参与计算
  + bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

[参与互动](https://github.com/yisainan/web-interview/issues/35)

</details>

<b><details><summary>15. 用纯 CSS 创建一个三角形的原理是什么？ </summary></b>

参考答案：

``` css
span {
    width: 0;
    height: 0;
    border-top: 40px solid transparent;
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 40px solid #ff0000;
}
```

![css_001](../images/css_001.jpg)

[参与互动](https://github.com/yisainan/web-interview/issues/36)

</details>

<b><details><summary>16. Sass、LESS 是什么？大家为什么要使用他们？</summary></b>

参考答案：他们是 CSS 预处理器。他是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。

例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node. js)。

为什么要使用它们？

结构清晰，便于扩展。

可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。

可以轻松实现多重继承。

完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。

[参与互动](https://github.com/yisainan/web-interview/issues/37)

</details>

<b><details><summary>17. display:none 与 visibility:hidden 的区别是什么？</summary></b>

参考答案：

display :  隐藏对应的元素但不挤占该元素原来的空间。

visibility:  隐藏对应的元素并且挤占该元素原来的空间。

即是，使用 CSS display:none 属性后，HTML 元素（对象）的宽度、高度等各种属性值都将“丢失”; 而使用 visibility:hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。

[参与互动](https://github.com/yisainan/web-interview/issues/38)

</details>

<b><details><summary>18. 移动端 1px 问题的解决办法</summary></b>

参考答案：推荐解决方法：媒体查询 + transfrom

``` 
/* 2倍屏 */
@media only screen and (-webkit-min-device-pixel-ratio: 2.0) {
    .border-bottom::after {
        -webkit-transform: scaleY(0.5);
        transform: scaleY(0.5);
    }
}
/* 3倍屏 */
@media only screen and (-webkit-min-device-pixel-ratio: 3.0) {
    .border-bottom::after {
        -webkit-transform: scaleY(0.33);
        transform: scaleY(0.33);
    }
}
```

[其他解决方案参考](https://www.jianshu.com/p/31f8907637a6)

[参与互动](https://github.com/yisainan/web-interview/issues/39)

</details>

<b><details><summary>19. 哪些 css 属性可以继承？</summary></b>

参考答案：

可继承： font-size font-family color, ul li dl dd dt; 

不可继承 ：border padding margin width height ; 

[参与互动](https://github.com/yisainan/web-interview/issues/40)

</details>

<b><details><summary>20. 几种常见的 CSS 布局</summary></b>

参考答案：

* 单列布局
* 两列自适应布局
* 圣杯布局和双飞翼布局
* 伪等高布局
* 粘连布局

[参与互动](https://github.com/yisainan/web-interview/issues/41)

</details>

<b><details><summary>21. li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</summary></b>

参考答案：浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab）渲染成一个空格，也就是我们上面的代码<li>换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。

解决方案：

方法一：既然是因为 `<li>` 换行导致的，那就可以将 `<li>` 代码全部写在一排，如下

``` html
<div class="wrap">
    <h3>li标签空白测试</h3>
    <ul>
        <li class="part1"></li>
        <li class="part2"></li>
        <li class="part3"></li>
        <li class="part4"></li>
    </ul>
</div>
```

方法二：我们为了代码美观以及方便修改，很多时候我们不可能将 `<li>` 全部写在一排，那怎么办？既然是空格占一个字符的宽度，那我们索性就将 `<ul>` 内的字符尺寸直接设为 0，将下面样式放入样式表，问题解决。

``` css
.wrap ul {
    font-size: 0px;
}
```

但随着而来的就是 `<ul>` 中的其他文字就不见了，因为其尺寸被设为 0px 了，我们只好将他们重新设定字符尺寸。
方法三：本来以为方法二能够完全解决问题，但经测试，将 li 父级标签字符设置为 0 在 Safari 浏览器依然出现间隔空白；既然设置字符大小为 0 不行，那咱就将间隔消除了，将下面代码替换方法二的代码，目前测试完美解决。同样随来而来的问题是 li 内的字符间隔也被设置了，我们需要将 li 内的字符间隔设为默认。

``` css
.wrap ul {
    letter-spacing: -5px;
}
```

之后记得设置 li 内字符间隔

``` css
.wrap ul li {
    letter-spacing: normal;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/90)

</details>

<b><details><summary>22. 设置元素浮动后，该元素的 display 值是多少？</summary></b>

参考答案：

自动变成 display:block

[参与互动](https://github.com/yisainan/web-interview/issues/91)

</details>

<b><details><summary>23. 怎么让 Chrome 支持小于 12px 的文字？</summary></b>

参考答案：

css3 的 transform 属性，设置值为 scale(x, y) 定义 2D 缩放转换

示例：

-webkit-transform: scale(0. 50); 

[参与互动](https://github.com/yisainan/web-interview/issues/92)

</details>

<b><details><summary>24. display:inline-block 什么时候会显示间隙？</summary></b>

参考答案：间隙产生的原因是因为，换行或空格会占据一定的位置

推荐解决方法：

父元素中设置
font-size:0; letter-spaceing:-4px; 

[参与互动](https://github.com/yisainan/web-interview/issues/93)

</details>

<b><details><summary>25.png、jpg、gif 这些图片格式解释一下，分别什么时候用？，webp 呢</summary></b>

参考答案：

gif 图形交换格式，索引颜色格式，颜色少的情况下，产生的文件极小，支持背景透明，动画，图形渐进，无损压缩（适合线条，图标等），缺点只有 256 种颜色

jpg 支持上百万种颜色，有损压缩，压缩比可达 180：1，而且质量受损不明显，不支持图形渐进与背景透明，不支持动画

png 为替代 gif 产生的，位图文件，支持透明，半透明，不透明。不支持动画，无损图像格式。Png8 简单说是静态 gif，也只有 256 色，png24 不透明，但不止 256 色。

webp 谷歌开发的旨在加快图片加载速度的图片格式，图片压缩体积是 jpeg 的 2/3，有损压缩。高版本的 W3C 浏览器才支持，google39+，safari7+

[参与互动](https://github.com/yisainan/web-interview/issues/94)

</details>

<b><details><summary>26. style 标签写在 body 后与 body 前有什么区别？</summary></b>

参考答案：

从上向下加载，加载顺序不同

[参与互动](https://github.com/yisainan/web-interview/issues/95)

</details>

<b><details><summary>27. 超链接访问过后 hover 样式就不出现的问题是什么？如何解决？</summary></b>

参考答案：被点击访问过的超链接样式不在具有 hover 和 active 了, 解决方法是改变 CSS 属性的排列顺序: L-V-H-A（link, visited, hover, active）

[参与互动](https://github.com/yisainan/web-interview/issues/96)

</details>

<b><details><summary>28. 什么是 Css Hack？ie6, 7, 8 的 hack 分别是什么？</summary></b>

参考答案：针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack。

示例如下：

``` css
#test {
    width: 300px;
    height: 300px;
    background-color: blue;/_firefox_/ background-color: red\9;/_all ie_/ background-color: yellow;/_ie8_/+background-color: pink;/_ie7_/ \_background-color: orange;/_ie6_/
}

:root #test {
    background-color: purple\9;
}

/*ie9*/

@media all and (min-width:0px) {
    #test {
        background-color: black;
    }
}

/*opera*/

@media screen and (-webkit-min-device-pixel-ratio:0) {
    #test {
        background-color: gray;
    }
}

/*chrome and safari*/
```

[参与互动](https://github.com/yisainan/web-interview/issues/97)

</details>

<b><details><summary>29. 重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？</summary></b>

参考答案：

* **重置（Resetting）**： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像 `margin` 、 `padding` 、 `font-size` 这些样式全部置成一样。你将必须重新定义各种元素的样式。
* **标准化（Normalizing）**： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。

当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。

解析：[参考](https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css)

[参与互动](https://github.com/yisainan/web-interview/issues/98)

</details>

<b><details><summary>30. css sprite 是什么, 有什么优缺点</summary></b>

参考答案：概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。

优点：

* 减少 HTTP 请求数，极大地提高页面加载速度。
* 增加图片信息重复度，提高压缩比，减少图片大小。
* 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现。

缺点：

* 图片合并麻烦。
* 维护麻烦，修改一个图片可能需要从新布局整个图片，样式。

[参与互动](https://github.com/yisainan/web-interview/issues/99)

</details>

<b><details><summary>31. 什么是 FOUC? 如何避免</summary></b>

参考答案：

1\. 什么是 Fouc\(文档样式短暂失效\)？

在引用 css 的过程中，如果方法不当或者位置引用不对，会导致某些页面在 windows 下的 ie 出现一些奇怪的现象，以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效，简称 FOCU。

2\. 原因大致为：

* 使用 import 方法导入样式表
* 将样式表放在页面底部
* 有几个样式表，放在 html 结构的不同位置。

3\. 其实原理很清楚：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。

4\. 解决方法：使用 link 标签将样式表放在文档 head 中。

[参与互动](https://github.com/yisainan/web-interview/issues/100)

</details>

<b><details><summary>32. css3 有哪些新特性</summary></b>

参考答案：

1\. 选择器

* E:last-child 匹配父元素的最后一个子元素 E。
* E:nth-child(n)匹配父元素的第 n 个子元素 E。
* E:nth-last-child(n) CSS3 匹配父元素的倒数第 n 个子元素 E。

2\. RGBA

回答此问题，面试官很可能继续问：rgba()和 opacity 的透明效果有什么不同？

3\. 多栏布局

``` html
<div class="mul-col">
    <div>
        <h3>新手上路</h3>
        <p>新手专区 消费警示 交易安全 24小时在线帮助 免费开店</p>
    </div>
    <div>
        <h3>付款方式</h3>
        <p>快捷支付 信用卡 余额宝 蚂蚁花呗 货到付款</p>
    </div>
    <div>
        <h3>淘宝特色</h3>
        <p>手机淘宝 旺信 大众评审 B格指南</p>
    </div>
</div>
```

``` css
.mul-col {
    column-count: 3;
    column-gap: 5px;
    column-rule: 1px solid gray;
    border-radius: 5px;
    border: 1px solid gray;
    padding: 10px;
}
```

4\. 多背景图

``` css
/* backgroundimage:url('1.jpg),url('2.jpg') */
```

5\. CSS3 word-wrap 属性

``` css
p.test {
    word-wrap: break-word;
}
```

6\. 文字阴影

``` css
text-shadow: 5px 2px 6px rgba(64, 64, 64, 0.5);
```

7\. @font-face 属性

Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

``` css
@font-face {
    font-family: BorderWeb;
    src: url(BORDERW0.eot);
}

@font-face {
    font-family: Runic;
    src: url(RUNICMT0.eot);
}

.border {
    font-size: 35px;
    color: black;
    font-family: "BorderWeb";
}

.event {
    font-size: 110px;
    color: black;
    font-family: "Runic";
}

/* 淘宝网字体使用 */

@font-face {
    font-family: iconfont;
    src: url(//at.alicdn.com/t/font_1465189805_4518812.eot);
}
```

8\. 圆角

``` css
border-radius: 15px;
```

9\. 边框图片

CSS3 border-image 属性

10. 盒阴影

``` css
/* box-shadow: 水平方向的偏移量 垂直方向的偏移量 模糊程度 扩展程度 颜色 是否具有内阴影 */
```

11. 盒子大小

CSS3 box-sizing 属性

12. 媒体查询

CSS3 @media 查询

13. CSS3 动画

@keyframes

``` css
@keyframes abc {
    from {
        transform: rotate(0);
    }

    50% {
        transform: rotate(90deg);
    }

    to {
        transform: rotate(360deg);
    }
}
```

animation 属性

``` css
/* animation ： name duration timing-function delay interation-count direction play-state */
```

14. 渐变效果

``` css
background-image: -webkit-gradient(linear,
    0% 0%,
    100% 0%,
    from(#2a8bbe),
    to(#fe280e));
```

15. CSS3 弹性盒子模型

* 弹性盒子是 CSS3 的一种新的布局模式。
* CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。
* 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。

16. CSS3 过渡

``` css
div {
    transition: width 2s;
    -moz-transition: width 2s;
    /* Firefox 4 */
    -webkit-transition: width 2s;
    /* Safari 和 Chrome */
    -o-transition: width 2s;
    /* Opera */
}
```

17. CSS3 变换

* rotate()旋转
* translate()平移
* scale( )缩放
* skew()扭曲/倾斜
* 变换基点
* 3d 转换

[参考](https://www.w3school.com.cn/css3/index.asp)

[参与互动](https://github.com/yisainan/web-interview/issues/101)

</details>

<b><details><summary>33. display 有哪些值？说明他们的作用</summary></b>

参考答案：

display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex

解析：

默认值：inline

``` 
none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间
inline： 指定对象为内联元素。
block： 指定对象为块元素。
list-item： 指定对象为列表项目。
inline-block： 指定对象为内联块元素。（CSS2）
table： 指定对象作为块元素级的表格。类同于html标签<table>（CSS2）
inline-table： 指定对象作为内联元素级的表格。类同于html标签<table>（CSS2）
table-caption： 指定对象作为表格标题。类同于html标签<caption>（CSS2）
table-cell： 指定对象作为表格单元格。类同于html标签<td>（CSS2）
table-row： 指定对象作为表格行。类同于html标签<tr>（CSS2）
table-row-group： 指定对象作为表格行组。类同于html标签<tbody>（CSS2）
table-column： 指定对象作为表格列。类同于html标签<col>（CSS2）
table-column-group： 指定对象作为表格列组显示。类同于html标签<colgroup>（CSS2）
table-header-group： 指定对象作为表格标题组。类同于html标签<thead>（CSS2）
table-footer-group： 指定对象作为表格脚注组。类同于html标签<tfoot>（CSS2）
run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）
box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）
inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）
flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）
inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）
flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）
inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）
```

[参考](https://www.jianshu.com/p/77e1c36c0895)

[参与互动](https://github.com/yisainan/web-interview/issues/102)

</details>

<b><details><summary>34. display:inline-block 什么时候不会显示间隙？(携程)</summary></b>

参考答案：inline-block 布局的元素在编辑器里写在同一行

[参与互动](https://github.com/yisainan/web-interview/issues/103)

</details>

<b><details><summary>35. PNG, GIF, JPG 的区别及如何选</summary></b>

参考答案：

GIF：

* 1：256 色
* 2： 无损，编辑 保存时候，不会损失。
* 3：支持简单动画。
* 4：支持 boolean 透明，也就是要么完全透明，要么不透明

JPEG：

* 1：millions of colors
* 2： 有损压缩， 意味着每次编辑都会失去质量。
* 3：不支持透明。
* 4：适合照片，实际上很多相机使用的都是这个格式。

PNG：

* 1：无损，其实 PNG 有好几种格式的，一般分为两类：PNG8 和 truecolor PNGs；

* 与 GIF 相比：

  + 它通常会产生较小的文件大小。
  + 它支持阿尔法（变量）透明度。
  + 无动画支持

* 与 JPEG 相比：

  + 文件更大
  + 无损
  + 因此可以作为 JPEG 图片中间编辑的中转格式。

* 结论：

  + JPEG 适合照片
  + GIF 适合动画
  + PNG 适合其他任何种类——图表，buttons，背景，图表等等。

[参考](https://www.cnblogs.com/yadiblogs/p/9546935.html)

[参与互动](https://github.com/yisainan/web-interview/issues/104)

</details>

<b><details><summary>36. 行内元素 float:left 后是否变为块级元素？</summary></b>

参考答案：

* 行内元素设置成浮动之后变得更加像是 inline-block
* 行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100%，行内元素默认 100%宽度占据一行
* 这时候给行内元素设置 padding-top 和 padding-bottom 或者 width、height 都是有效果的

[参与互动](https://github.com/yisainan/web-interview/issues/105)

</details>

<b><details><summary>37. 在网页中的应该使用奇数还是偶数的字体？为什么呢？</summary></b>

参考答案：应该使用偶数字体

1\. 比例关系

相对来说偶数字号比较容易和页面中其他部分的字号构成一个比例关系。如我使用 14px 的字体作为正文字号，那么其他部分的字体（如标题）就可以使用 14×1. 5 =21px 的字体，或者在一些地方使用到了 14×0. 5=7px 的 padding 或者 margin，如果你是在用 sass 或者 less 编写 css，这时候用处就凸显出来了。

2\. UI 设计师的缘故

大多数设计师用的软件如 ps 提供的字号是偶数，自然到了   前端那边也是用的是偶数。

3\. 浏览器缘故

其一是低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。

其二是为了平分字体。偶数宽的汉字，如 12px 的汉子，去掉 1 像素的字体间距，填充了的字体像素宽度其实就是 11px，这样的汉字中竖线左右是平分的，如“中”子，左右就是 5px 了。

4\. 系统差别

Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。

而在 Linux 和其他手持设备上，奇数偶数的渲染效果其实相差不大。

解析：[参考](https://blog.csdn.net/jian_xi/article/details/79346477)

[参与互动](https://github.com/yisainan/web-interview/issues/106)

</details>

<b><details><summary>38. CSS 合并方法</summary></b>

参考答案：@import url(css 文件地址)

[参与互动](https://github.com/yisainan/web-interview/issues/107)

</details>

<b><details><summary>39. 列出你所知道可以改变页面布局的属性</summary></b>

参考答案：width、height、float、position、等

[参与互动](https://github.com/yisainan/web-interview/issues/108)

</details>

<b><details><summary>40. CSS 在性能优化方面的实践</summary></b>

参考答案：

1\. 内联首屏关键 CSS（Critical CSS）

内联 CSS 能够使浏览器开始页面渲染的时间提前，只将渲染首屏内容所需的关键 CSS 内联到 HTML 中

2\. 异步加载 CSS

3\. 文件压缩

4\. 去除无用 CSS

解析：[参考](https://www.cnblogs.com/heroljy/p/9412704.html)

[参与互动](https://github.com/yisainan/web-interview/issues/109)

</details>

<b><details><summary>41. CSS3 动画（简单动画的实现，如旋转等）</summary></b>

参考答案：

让一个 div 元素旋转 360 度示例

1\. div 的样式结构:

``` css
div {
    margin: 50px auto;
    width: 200px;
    height: 200px;
    background-color: pink;
}
```

2\. 设置旋转属性的类名:

``` css
div.rotate {
    /* 旋转360度 */
    transform: rotate(360deg);
    /* all表示所有属性,1s表示在一秒的时间完成动画 */
    transition: all 1s;
}
```

``` 
transition 有四个属性:

property: 规定应用过渡的 CSS 属性的名称。

duration: 定义过渡效果花费的时间。默认是 0,单位是 s。

timing-function: 规定过渡效果的时间曲线。默认是 "ease"。匀速'linear',加速'ease-in',减速'ease-out',先快后慢'ease-in-out'。

delay: 规定过渡效果何时开始。默认是 0。单位 s。

可以连写: transition: property duration timing-function delay;
```

3\. 给 div 元素设置鼠标移入时旋转, 也就是给它加上\. rotate 类名\. 鼠标移出时移除类名

``` js
$(function() {
    $("div")
        .mouseenter(function() {
            $(this).addClass("rotate");
        })
        .mouseleave(function() {
            $(this).removeClass("rotate");
        });
});
```

解析：[参考](https://blog.csdn.net/qq_42209630/article/details/80338578)

[参与互动](https://github.com/yisainan/web-interview/issues/110)

</details>

<b><details><summary>42. base64 的原理及优缺点</summary></b>

参考答案：

1\. 什么是 Base64

Base64 是一种基于 64 个可打印字符来表示二进制数据的编码方式，是从二进制数据到字符的过程。
原则上，计算机中所有内容都是二进制形式存储的，所以所有内容（包括文本、影音、图片等）都可以用 base64 来表示。

2\. 适用场景

``` 
1.Base64一般用于在HTTP协议下传输二进制数据，由于HTTP协议是文本协议，所以在HTTP写一下传输二进制数据需要将二进制数据转化为字符数据，
网络传输只能传输可打印字符，
在ASCII码中规定，0-31、128这33个字符属于控制字符，
32~127这95个字符属于可打印字符
那么其它字符怎么传输呢，Base64就是其中一种方式，
2.将图片等资源文件以Base64编码形式直接放于代码中，使用的时候反Base64后转换成Image对象使用。
3.偶尔需要用这条纯文本通道传一张图片之类的情况发生的时候，就会用到Base64，比如多功能Internet 邮件扩充服务（MIME）就是用Base64对邮件的附件进行编码的。
```

3\. Base64 编码原理

Base64 编码之所以称为 Base64，是因为其使用 64 个字符来对任意数据进行编码，同理有 Base32、Base16 编码。标准 Base64 编码使用的 64 个字符为：

![css_008](../images/css_008.png)

有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64 编码又有很多变种，比如用于编码 URL 的 Base64 URL 编码。

Base64 编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续 6 比特（2 的 6 次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。

假设我们要对 Hello! 进行 Base64 编码，按照 ASCII 表，其转换过程如下图所示：

![css_009](../images/css_009.png)

可知 Hello! 的 Base64 编码结果为 SGVsbG8h，每 3 个原始字符经 Base64 编码成 4 个字符。那么，当原始字符串长度不能被 3 整除时，怎么办呢？

以 Hello!! 为例，其转换过程为：

![css_010](../images/css_010.png)

Hello!! Base64 编码的结果为 SGVsbG8hIQAA。可见，不能被 3 整除时会采用来来补 0 的方式来完成编码。
需要注意的是：标准 Base64 编码通常用 = 字符来替换最后的 A，即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在 Base64 编码索引表中，其意义在于结束符号，在 Base64 解码时遇到 = 时即可知道一个 Base64 编码字符串结束。

4\. 优缺点

优点: 可以将二进制数据转化为可打印字符，方便传输数据，对数据进行简单的加密，肉眼安全。
缺点：内容编码后体积变大，编码和解码需要额外工作量。

解析：[参考 1](https://segmentfault.com/a/1190000012654771)、[参考 2](https://blog.csdn.net/fightingitpanda/article/details/83305100)

[参与互动](https://github.com/yisainan/web-interview/issues/111)

</details>

<b><details><summary>43. stylus/sass/less 区别</summary></b>

参考答案：

1\. 后缀

默认 Sass 使用 . sass 扩展名，而 Less 使用 . less 扩展名，Stylus 默认使用 . styl 的文件扩展名

2\. 语法

3\. 变量

* sass 变量必须是以\$开头的，然后变量和值之间使用冒号（：）隔开，和 css 属性是一样的
* Less css 中变量都是用@开头的，其余与 sass 都是一样的
* stylus 对变量是没有任何设定的，可以是以\$开头，或者任何的字符，而且与变量之间可以用冒号，空格隔开，但是在 stylus 中不能用@开头

解析：[参考](https://blog.csdn.net/pedrojuliet/article/details/72887490)

[参与互动](https://github.com/yisainan/web-interview/issues/112)

</details>

<b><details><summary>44. position 的值， relative 和 absolute 分别是相对于谁进行定位的？</summary></b>

参考答案：

* absolute : 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。
* fixed （老 IE 不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。
* relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
* static 默认值。没有定位，元素出现在正常的流中
* sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出

[参与互动](https://github.com/yisainan/web-interview/issues/113)

</details>

<b><details><summary>45. 对偏移、卷曲、可视的理解</summary></b>

参考答案：

``` 
偏移
offsetWidth	  width  +  padding  +  border
offsetHeight	height +  padding  +  border
offsetLeft
offsetTop
offsetParent
注意：没有offsetRight和offsetBottom
************************************************************************************************

卷曲
scrollWidth    width  +  padding
scrollHeight   当内部的内容溢出盒子的时候， 顶边框的底部，计算到内容的底部；如果内容没有溢出盒子，计算方式为盒子内部的真实高度（边框到边框）
scrollLeft     这个scroll系列属性不是只读的
scrollTop
scroll()

此函数可以获取卷曲的高度和卷曲的宽度
function myScroll() {
   return {
      top: window.pageYOffset  || document.documentElement.scrollTop  || document.body.scrollTop  || 0,
      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
    };

}

滚动滚动条的时候触发事件
box（window）.onscroll = function () {}
************************************************************************************************

可视
clientWidth   获取的是元素内部的真实宽度 width  +  padding
clientHeight  边框之间的高度
clientLeft    相当于左边框的宽度  如果元素包含了滚动条，并且滚动条显示在元素的左侧。这时，clientLeft属性会包含滚动条的宽度17px
clientTop     相当于顶边框的宽度
client()

此函数可以获取浏览器可视区域的宽高
function myClient() {
    return {
        wid: window.innerWidth  || document.documentElement.clientWidth  || document.body.clientWidth  || 0,
       heit: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
    };
}

----------------------------------------------------------------------------------------------
@offsetHeight和style.height的区别

demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取
style.height是字符串（而且带单位），offsetHeight是数值
demo.style.height可以设置行内样式，offsetHeight是只读属性
因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度

----------------------------------------------------------------------------------------------
@offsetLeft和style.left的区别

一、style.left只能获取行内样式
二、offsetLeft只读，style.left可读可写
三、offsetLeft是数值，style.left是字符串并且有单位px
四、如果没有加定位，style.left获取的数值可能是无效的
五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准

----------------------------------------------------------------------------------------------
@scrollHeight和scrollWidth

标签内部实际内容的高度/宽度
不计算边框，如果内容不超出盒子，值为盒子的宽高（不带边框）
如果内容超出了盒子，就是从顶部或左部边框内侧一直到内容a的最外部分

----------------------------------------------------------------------------------------------
@scrollTop和scrollLeft

被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离
```

解析：

![offset大全](../images/css_002.png)

![scroll大全](../images/css_003.png)

![三个height比较](../images/css_004.png)

![style. left和offsetLeft](../images/css_005.png)

![client大全](../images/css_006.png)

[参与互动](https://github.com/yisainan/web-interview/issues/114)

</details>

<b><details><summary>46. 精灵图和 base64 如何选择？</summary></b>

参考答案：

## Css Sprites：

介绍：
Css Sprites（雪碧图或 css 精灵），是网页图片处理的一种方式，它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。

原理：
将许多的小图片整合到一张大图片中，利用 css 中的 background-image 属性，background-position 属性定位某个图片位置，来达到在大图片中引用某个部位的小图片的效果。

优点：
减少网页的 http 请求，提升网页加载速度。
合并多张小图片成大图，能减少字节总数（大图大小<=多张小图大小）. 

缺点：
前期需要处理图片将小图合并，多些许工程量。
对于需要经常改变的图片维护起来麻烦。

## base64：

介绍：
base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一，要求把每三个 8Bit 的字节转换为四个 6Bit 的字节，Base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一。

通俗点讲：将资源原本二进制形式转成以 64 个字符基本单位，所组成的一串字符串。
比如一张图片转成 base64 编码后就像这样，图片直接以 base64 形式嵌入文件中（很长没截完）：

![css_007](../images/css_007.jpg)

生成 base64 编码：
图片生成 base64 可以用一些工具，如在线工具，但在项目中这样一个图片这样生成是挺繁琐。
特别说下，webpack 中的 url-loader 可以完成这个工作，可以对限制大小的图片进行 base64 的转换，非常方便。

优点：
base64 的图片会随着 html 或者 css 一起下载到浏览器, 减少了请求. 
可避免跨域问题

缺点：
老东西（低版本）的 IE 浏览器不兼容。
体积会比原来的图片大一点。
css 中过多使用 base64 图片会使得 css 过大，不利于 css 的加载。

适用场景：
应用于小的图片几 k 的，太大的图片会转换后的大小太大，得不偿失。
用于一些 css sprites 不利处理的小图片，如一些可以通过 background-repeat 平铺来做成背景的图片

解析：[参考](https://www.cnblogs.com/wangqi2019/p/10498627.html)

[参与互动](https://github.com/yisainan/web-interview/issues/115)

</details>

<b><details><summary>47. 如果设计中使用了非标准的字体，你该如何去实现？</summary></b>

参考答案：使用 `@font-face` 并为不同的 `font-weight` 定义 `font-family` 。

[参与互动](https://github.com/yisainan/web-interview/issues/116)

</details>

<b><details><summary>48. 知道 css 有个 content 属性吗？有什么作用？有什么应用？</summary></b>

参考答案：知道。css 的 content 属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。

``` css
//一种常见利用伪类清除浮动的代码
.clearfix:after {
    content: "."; //这里利用到了content属性
    display: block;
    height: 0;
    visibility: hidden;
    clear: both;
}

.clearfix {
    zoom: 1;
}
```

after 伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用 clear:both 清除浮动。
那么问题继续还有，知道 css 计数器（序列数字字符自动递增）吗？如何通过 css content 属性实现 css 计数器？

参考答案：css 计数器是通过设置 counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合 after / before 伪类实现。

[参与互动](https://github.com/yisainan/web-interview/issues/117)

</details>

<b><details><summary>49. CSS 选择器的优先级是如何计算的？</summary></b>

参考答案：浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以 `a、b、c、d` 命名，分别代表以下含义：

1\. `a` 表示是否使用内联样式（inline style）。如果使用， `a` 为 1，否则为 0。
2\. `b` 表示 ID 选择器的数量。
3\. `c` 表示类选择器、属性选择器和伪类选择器数量之和。
4\. `d` 表示标签（类型）选择器和伪元素选择器之和。

优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。 `a、b、c、d` 权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果 `b` 的值不同，那么 `c` 和 `d` 不管多大，都不会对结果产生影响。比如 `0，1，0，0` 的优先级高于 `0，0，10，10` 。

当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。

在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用 `!important` 的方式，去覆盖组件的样式了。

解析：[参考](https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/)、[参考](https://www.sitepoint.com/web-foundations/specificity/)

[参与互动](https://github.com/yisainan/web-interview/issues/118)

</details>

<b><details><summary>50. 请阐述 `Float` 定位的工作原理。</summary></b>

参考答案：

浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。

CSS 的 `clear` 属性通过使用 `left` 、 `right` 、 `both` ，让该元素向下移动（清除浮动）到浮动元素下面。

如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。

有一种 hack 的方法，是自定义一个 `.clearfix` 类，利用伪元素选择器 `::after` 清除浮动。[另外还有一些方法](https://css-tricks.com/all-about-floats/#article-header-id-4)，比如添加空的 `<div></div>` 和设置浮动元素父元素的 `overflow` 属性。与这些方法不同的是， `clearfix` 方法，只需要给父元素添加一个类，定义如下：

``` css
.clearfix::after {
    content: "";
    display: block;
    clear: both;
}
```

值得一提的是，把父元素属性设置为 `overflow: auto` 或 `overflow: hidden` ，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。

解析：[参考](https://css-tricks.com/all-about-floats/)

[参与互动](https://github.com/yisainan/web-interview/issues/119)

</details>

<b><details><summary>51. 请阐述 `z-index` 属性，并说明如何形成层叠上下文（stacking context）</summary></b>

参考答案：

CSS 中的 `z-index` 属性控制重叠元素的垂直叠加顺序。 `z-index` 只能影响 `position` 值不是 `static` 的元素。

没有定义 `z-index` 的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。

层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的 `z-index` 值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的 `z-index` 值，元素 C 也永远不会在元素 B 之上. 

每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如 `opacity` 小于 1， `filter` 不是 `none` ， `transform` 不是 `none` 。

解析：[参考 1](https://css-tricks.com/almanac/properties/z/z-index/)、[参考 2](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)、[参考 3](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)

[参与互动](https://github.com/yisainan/web-interview/issues/120)

</details>

<b><details><summary>52. 如何解决不同浏览器的样式兼容性问题？</summary></b>

参考答案：

* 在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。
* 使用已经处理好此类问题的库，比如 Bootstrap。
* 使用 `autoprefixer` 自动生成 CSS 属性前缀。
* 使用 Reset CSS 或 Normalize. css。

[参与互动](https://github.com/yisainan/web-interview/issues/121)

</details>

<b><details><summary>53. 如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？</summary></b>

参考答案：

* 优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。
* Progressivepx enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it. 
* 渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。
* 利用 [caniuse. com](https://caniuse.com/) 检查特性支持。
* 使用 `autoprefixer` 自动生成 CSS 属性前缀。
* 使用 [Modernizr](https://modernizr.com/)进行特性检测。

[参与互动](https://github.com/yisainan/web-interview/issues/122)

</details>

<b><details><summary>54. 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？</summary></b>

参考答案：

这些方法与可访问性（a11y）有关。

* `visibility: hidden` ：元素仍然在页面流中，并占用空间。
* `width: 0; height: 0` ：使元素不占用屏幕上的任何空间，导致不显示它。
* `position: absolute; left: -99999px` ： 将它置于屏幕之外。
* `text-indent: -9999px` ：这只适用于 `block` 元素中的文本。
* Metadata： 例如通过使用 Schema. org，RDF 和 JSON-LD。
* WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。

即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。

解析：[参考 1](https://www.w3.org/TR/wai-aria-1.1/)、[参考 2](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)、[参考 3](http://a11yproject.com/)

[参与互动](https://github.com/yisainan/web-interview/issues/123)

</details>

<b><details><summary>55. 除了 `screen` ，你还能说出一个 @media 属性的例子吗？</summary></b>

参考答案：

* all

  适用于所有设备。

* print

  为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。

* screen

  主要适用于彩色的电脑屏幕

* speech

  speech 这个合成器. 注意: CSS2 已经有一个相似的媒体类型叫 aural. <br>

解析：[参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media)

[参与互动](https://github.com/yisainan/web-interview/issues/124)

</details>

<b><details><summary>56. 编写高效的 CSS 应该注意什么？</summary></b>

参考答案：

首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

[BEM (Block Element Modifier)](https://bem.info/) methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override. 
[BEM (Block Element Modifier)](https://bem.info/)原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。

解析：[参考 1](https://developers.google.com/web/fundamentals/performance/rendering/)、[参考 2](https://csstriggers.com/)

[参与互动](https://github.com/yisainan/web-interview/issues/125)

</details>

<b><details><summary>57. 使用 CSS 预处理的优缺点分别是什么？</summary></b>

参考答案：

优点：

* 提高 CSS 可维护性。
* 易于编写嵌套选择器。
* 引入变量，增添主题功能。可以在不同的项目中共享主题文件。
* 通过混合（Mixins）生成重复的 CSS。
* Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file. 
* 将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。

缺点：

* 需要预处理工具。
* 重新编译的时间可能会很慢。

[参与互动](https://github.com/yisainan/web-interview/issues/126)

</details>

<b><details><summary>58. 对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？</summary></b>

参考答案：

喜欢：

* 绝大部分优点上题以及提过。
* Less 用 JavaScript 实现，与 NodeJS 高度结合。

不喜欢：

* 我通过 `node-sass` 使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。
* Less 中，变量名称以 `@` 作为前缀，容易与 CSS 关键字混淆，如 `@media` 、 `@import` 和 `@font-face` 。

[参与互动](https://github.com/yisainan/web-interview/issues/127)

</details>

<b><details><summary>59. 解释浏览器如何确定哪些元素与 CSS 选择器匹配。</summary></b>

参考答案：

浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。

例如，对于形如 `p span` 的选择器，浏览器首先找到所有 `<span>` 元素，并遍历它的父元素直到根元素以找到 `<p>` 元素。对于特定的 `<span>` ，只要找到一个 `<p>` ，就知道'<span>`已经匹配并停止继续匹配。

解析：[参考](https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left)

[参与互动](https://github.com/yisainan/web-interview/issues/128)

</details>

<b><details><summary>60. 说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。</summary></b>

参考答案：

CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的 `padding` 、 `border` 和 `margin` 区域。

CSS 盒模型负责计算：

* 块级元素占用多少空间。
* 边框是否重叠，边距是否合并。
* 盒子的尺寸。

盒模型有以下规则：

* 块级元素的大小由 `width` 、 `height` 、 `padding` 、 `border` 和 `margin` 决定。
* 如果没有指定 `height` ，则块级元素的高度等于其包含子元素的内容高度加上 `padding` （除非有浮动元素，请参阅下文）。
* 如果没有指定 `width` ，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的 `padding` 。
* 元素的 `height` 是由内容的 `height` 来计算的。
* 元素的 `width` 是由内容的 `width` 来计算的。
* 默认情况下， `padding` 和 `border` 不是元素 `width` 和 `height` 的组成部分。

解析：[参考](https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model)

[参与互动](https://github.com/yisainan/web-interview/issues/129)

</details>

<b><details><summary>61. `* { box-sizing: border-box; }` 会产生怎样的效果？</summary></b>

参考答案：

* 元素默认应用了 `box-sizing: content-box` ，元素的宽高只会决定内容（content）的大小。
* `box-sizing: border-box` 改变计算元素 `width` 和 `height` 的方式， `border` 和 `padding` 的大小也将计算在内。
* 元素的 `height` = 内容（content）的高度 + 垂直方向的 `padding` + 垂直方向 `border` 的宽度
* 元素的 `width` = 内容（content）的宽度 + 水平方向的 `padding` + 水平方向 `border` 的宽度

[参与互动](https://github.com/yisainan/web-interview/issues/130)

</details>

<b><details><summary>62. `relative` 、 `fixed` 、 `absolute` 和 `static` 四种定位有什么区别？</summary></b>

参考答案：

经过定位的元素，其 `position` 属性值必然是 `relative` 、 `absolute` 、 `fixed` 或 `static` 。

* `static` ：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。
* `relative` ：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。
* `absolute` ：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。
* `fixed` ：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。
* `static` ：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 `table` 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。 `position: static` 对 `table` 元素的效果与 `position: relative` 相同。

解析：[参考](https://developer.mozilla.org/en/docs/Web/CSS/position)

[参与互动](https://github.com/yisainan/web-interview/issues/131)

</details>

<b><details><summary>63. 你使用过哪些现有的 CSS 框架？你是如何改进它们的？</summary></b>

参考答案：

* **Bootstrap**： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。
* **Semantic UI**：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。
* **Bulma**： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。

[参与互动](https://github.com/yisainan/web-interview/issues/132)

</details>

<b><details><summary>64. 你了解 CSS Flex 和 Grid 吗？</summary></b>

参考答案：Flex 主要用于一维布局，而 Grid 则用于二维布局。

解析：

### Flex

flex 容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为 flex item。

在容器上可以设置 6 个属性：

* flex-direction
* flex-wrap
* flex-flow
* justify-content
* align-items
* align-content

注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。

#### Flex 项目属性

有六种属性可运用在 item 项目上:

1\. order
2\. flex-basis
3\. flex-grow
4\. flex-shrink
5\. flex
6\. align-self

### Grid

CSS 网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。

像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用 CSS 网格可能还是比 CSS 表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像 CSS 定位的元素一样，真正的有重叠和层次。

[参与互动](https://github.com/yisainan/web-interview/issues/133)

</details>

<b><details><summary>65. 响应式设计与自适应设计有何不同？</summary></b>

参考答案：

响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。

响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。

自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。

解析：[参考 1](https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design)、[参考 2](http://mediumwell.com/responsive-adaptive-mobile/)、[参考 3](https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/)

[参与互动](https://github.com/yisainan/web-interview/issues/134)

</details>

<b><details><summary>66. 你有没有使用过视网膜分辨率的图形？当中使用什么技术？</summary></b>

参考答案：我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像 `@media only screen and (min-device-pixel-ratio: 2) { ... }` ，然后改变 `background-image` 。

对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。

还有一种方法是，在检查了 `window.devicePixelRatio` 的值后，利用 JavaScript 将 `<img>` 的 `src` 属性修改，用更高分辨率的版本进行替换。

解析：[参考](https://www.sitepoint.com/css-techniques-for-retina-displays/)

[参与互动](https://github.com/yisainan/web-interview/issues/135)

</details>

<b><details><summary>67. 什么情况下，用 `translate()` 而不用绝对定位？什么时候，情况相反。</summary></b>

参考答案： `translate()` 是 `transform` 的一个值。改变 `transform` 或 `opacity` 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。 `transform` 使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此 `translate()` 更高效，可以缩短平滑动画的绘制时间。

当使用 `translate()` 时，元素仍然占据其原始空间（有点像 `position：relative` ），这与改变绝对定位不同。

解析：[参考 1](https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/)、[参考 2](https://neal.codes/blog/front-end-interview-css-questions)、[参考 3](https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/)、[参考 4](http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/)

[参与互动](https://github.com/yisainan/web-interview/issues/136)

</details>

<b><details><summary>68. 一边固定宽度一边宽度自适应</summary></b>

参考答案：可以使用 flex 布局 复制下面的 HTML 和 CSS 代码 用浏览器打开可以看到效果

``` html
<div class="wrap">
    <div class="div1"></div>
    <div class="div2"></div>
</div>
```

``` css
.wrap {
    display: flex;
    justify-content: space-between;
}

.div1 {
    min-width: 200px;
}

.div2 {
    width: 100%;
    background: #e6e6e6;
}

html,
body,
div {
    height: 100%;
    margin: 0;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/137)

</details>

<b><details><summary>69. display:none、visibile:hidden、opacity:0 的区别</summary></b>

参考答案：

|                  | 是否隐藏 | 是否在文档中占用空间 | 是否会触发事件 |
| ---------------- | -------- | -------------------- | -------------- |
| display: none    | 是       | 否                   | 否             |
| visibile: hidden | 是       | 是                   | 否             |
| opacity: 0       | 是       | 是                   | 是             |

[参与互动](https://github.com/yisainan/web-interview/issues/138)

</details>

<b><details><summary>70. 文本超出部分显示省略号</summary></b>

参考答案：

#### 单行

``` css
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```

#### 多行

``` css
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3; // 最多显示几行
overflow: hidden;
```

[参与互动](https://github.com/yisainan/web-interview/issues/139)

</details>

<b><details><summary>71. 利用伪元素画三角</summary></b>

参考答案：

``` css
.info-tab {
    position: relative;
}

.info-tab::after {
    content: "";
    border: 4px solid transparent;
    border-top-color: #2c8ac2;
    position: absolute;
    top: 0;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/140)

</details>

<b><details><summary>72. 过渡与动画的区别是什么</summary></b>

参考答案：

* transition

  可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟以一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果而动画属性

* animation

  可以制作类似 Flash 动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。

[参与互动](https://github.com/yisainan/web-interview/issues/141)

</details>

<b><details><summary>73. 去除 inline-block 元素间间距的方法</summary></b>

参考答案：

* 移除空格
* 使用 margin 负值
* 使用 font-size:0
* letter-spacing
* word-spacing

解析：更详细的介绍请看[去除 inline-block 元素间间距的 N 种方法](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)

[参与互动](https://github.com/yisainan/web-interview/issues/142)

</details>

<b><details><summary>74. 为什么要初始化 CSS 样式</summary></b>

参考答案：

* 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。
* 去掉标签的默认样式如：margin, padding，其他浏览器默认解析字体大小，字体设置。

[参与互动](https://github.com/yisainan/web-interview/issues/143)

</details>

<b><details><summary>75. 行内元素和块级元素有哪些</summary></b>

参考答案：

### 行内元素

一个行内元素只占据它对应标签的边框所包含的空间<br>
一般情况下，行内元素只能包含数据和其他行内元素

``` 
b, big, i, small, tt
abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var
a, bdo, br, img, map, object, q, script, span, sub, sup
button, input, label, select, textarea
```

### 块级元素

占据一整行，高度、行高、内边距和外边距都可以改变，可以容纳块级标签和其他行内标签<br>

``` 
header,form,ul,ol,table,article,div,hr,aside,figure,canvas,video,audio,footer
```

[参与互动](https://github.com/yisainan/web-interview/issues/144)

</details>

<b><details><summary>76. 设备像素比</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/145)

</details>

<b><details><summary>77. ::bofore 和 :after 中双冒号和单冒号有什么区别？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/146)

</details>

<b><details><summary>78. 说下 CSS3 中一些样式的兼容，分别指兼容哪些浏览器</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/147)

</details>

<b><details><summary>79. 有哪些手段可以优化 CSS, 提高性能</summary></b>

参考答案：

1, 首推的是合并css文件，如果页面加载10个css文件，每个文件1k，那么也要比只加载一个100k的css文件慢。

2，减少css嵌套，最好不要套三层以上。

3，不要在ID选择器前面进行嵌套，ID本来就是唯一的而且人家权值那么大，嵌套完全是浪费性能。

4，建立公共样式类，把相同样式提取出来作为公共类使用，比如我们常用的清除浮动等。

5，减少通配符*或者类似[hidden="true"]这类选择器的使用，挨个查找所有... 这性能能好吗？当然重置样式这些必须 的东西是不能少的。

6，巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。

7，拆分出公共css文件，对于比较大的项目我们可以将大部分页面的公共结构的样式提取出来放到单独css文件里， 这样一次下载后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。

8，不用css表达式，表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的。

9，少用css rest，可能你会觉得重置样式是规范，但是其实其中有很多的操作是不必要不友好的，有需求有兴趣的 朋友可以选择normolize. css

10，cssSprite，合成所有icon图片，用宽高加上bacgroud-position的背景图方式显现出我们要的icon图，这是一种 十分实用的技巧，极大减少了http请求。

11，当然我们还需要一些善后工作，CSS压缩(这里提供一个在线压缩 YUI Compressor ，当然你会用其他工具来压缩是十 分好的)，

12，GZIP压缩，Gzip是一种流行的文件压缩算法，详细做法可以谷歌或者百度。

[参与互动](https://github.com/yisainan/web-interview/issues/148)

</details>

<b><details><summary>80. 怎么样实现边框 0. 5 个像素？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/149)

</details>

<b><details><summary>81. transform translate transition 的区别</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/150)

</details>

<b><details><summary>82. 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）, 以及适用场景？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/151)

</details>

<b><details><summary>83. 用纯 CSS 创建一个三角形的原理是什么？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/152)

</details>

<b><details><summary>84. 一个满屏 品 字布局 如何设计?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/153)

</details>

<b><details><summary>85. 全屏滚动的原理是什么？用到了 CSS 的那些属性？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/154)

</details>

<b><details><summary>86. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/155)

</details>

<b><details><summary>87. 如何修改 chrome 记住密码后自动填充表单的黄色背景？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/156)

</details>

<b><details><summary>88. 用 css 分别实现某个 div 元素上下居中和左右居中</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/157)

</details>

<b><details><summary>89. 你对 line-height 是如何理解的？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/158)

</details>

<b><details><summary>90. 让页面里的字体变清晰，变细用 CSS 怎么做？</summary></b>

参考答案：

-webkit-font-smoothing: antialiased; 

[参与互动](https://github.com/yisainan/web-interview/issues/159)

</details>

<b><details><summary>91. font-style 属性可以让它赋值为“oblique” oblique 是什么意思？</summary></b>

参考答案：Italic是使用文字的斜体,Oblique是让没有斜体属性的文字倾斜

[参与互动](https://github.com/yisainan/web-interview/issues/160)

</details>

<b><details><summary>92 . position:fixed; 在 android 下无效怎么处理？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/161)

</details>

<b><details><summary>93. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</summary></b>

参考答案：16.7ms。多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms ＝ 16.7ms

[参与互动](https://github.com/yisainan/web-interview/issues/162)

</details>

<b><details><summary>94. overflow: scroll 时不能平滑滚动的问题怎么处理？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/163)

</details>

<b><details><summary>95. 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/164)

</details>

<b><details><summary>96. postcss 的作用</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/165)

</details>

<b><details><summary>97. 自定义字体的使用场景</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/166)

</details>

<b><details><summary>98. 如何美化 CheckBox</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/167)

</details>

<b><details><summary>99. float 和 display:inline-block 的区别是什么？</summary></b>

参考答案：对元素设置display：inline-block ，元素不会脱离文本流，而float就会使得元素脱离文本流，且还有父元素高度坍塌的效果。

[参与互动](https://github.com/yisainan/web-interview/issues/168)

</details>

<b><details><summary>100. rem 布局字体太大怎么处理?</summary></b>

参考答案：getComputedStyle方法能够获取到计算后的样式、大小。

最后优化完的代码如下。

``` js
(function(doc, win) {

    var isAndroid = win.navigator.appVersion.match(/android/gi);
    var isIPhone = win.navigator.appVersion.match(/iphone/gi);

    var scale = 1.0;
    var ratio = 1;
    if (isIPhone) {
        if (window.devicePixelRatio == 2) {
            scale *= 0.5;
            ratio *= 2;
        }
        if (window.devicePixelRatio == 3) {
            scale *= (1 / 3);
            ratio *= 3;
        }
    }
    var text = '<meta name="viewport" content="initial-scale=' + scale + ', maximum-scale=' + scale + ',' + ' minimum-scale=' + scale + ', width=device-width,' + ' user-scalable=no" />';
    document.write(text);

    var docEl = doc.documentElement
    var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'
    var recalc = function() {
        var clientWidth = docEl.clientWidth
        if (!clientWidth) return
        docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'

        // 解决部分rem特别大的问题
        var docElFontSize = docEl.style.fontSize.replace(/px/gi, '')
        var computedFontSize = win.getComputedStyle(docEl)['font-size'].replace(/px/gi, '')
        docElFontSize != computedFontSize && (docEl.style.fontSize = docElFontSize * docElFontSize / computedFontSize + 'px')
    }
    if (!doc.addEventListener) return
    recalc()
    win.addEventListener(resizeEvt, recalc, false)
})(document, window);
```

[参与互动](https://github.com/yisainan/web-interview/issues/169)

</details>

<b><details><summary>101. 标准模式与怪异模式的区别</summary></b>

参考答案：浏览器解析 CSS 的两种模式：标准模式(strict mode)和怪异模式(quirks mode)

标准模式：浏览器按 W3C 标准解析执行代码；

怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。

浏览器解析时使用标准模式还是怪异模式，与网页中的 DTD 声明直接相关，DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相关的方式加载网页并显示，忽略 DTD 声明，将使网页进入怪异模式（quirks mode）。

区别是：

1、盒模型：

在怪异模式下，盒模型为 IE 模型

![html_001.jpg](../../images/html_001.jpg)

而在 W3C 标准的盒模型中为：

![html_002.jpg](../../images/html_002.jpg)

2、图片元素的垂直对齐方式

对于 inline 元素和 table-cell 元素，标准模式下 vertical-align 属性默认取值是 baseline；在怪异模式下，table 单元格中的图片的 vertical-align 属性默认取值是 bottom。因此在图片底部会有及像素的空间。

3、 `<table>` 元素中的字体
CSS 中，对于 font 的属性都是可以继承的。怪异模式下，对于 table 元素，字体的某些元素将不会从 body 等其他封装元素继承中的得到，特别是 font-size 属性。

4、内联元素的尺寸

* 标准模式下，non-replaced inline 元素无法自定义大写；
* 怪异模式下，定义这些元素的 width、height 属性可以影响这些元素显示的尺寸。

5、元素的百分比高度

* CSS 中对于元素的百分比高度规定：百分比为元素包含块的高度，不可为负值；如果包含块的高度没有显示给出，该值等同于 auto，所以百分比的高度必须是在元素有高度声明的情况下使用。
* 当一个元素使用百分比高度是，标准模式下，高度取决于内容变化，怪异模式下，百分比高度被准确应用

6、元素溢出的处理

标准模式下，overflow 取值默认为 visible；在怪异模式在，该溢出会被当做扩展 box 来对待，即元素的大小由内容决定，溢出不会裁剪，元素框自动调整，包含溢出内容。

</details>

<b><details><summary>102. css reset 与 css sprites</summary></b>

参考答案：

css reset ：重置浏览器默认属性

css sprites ：由多个小图片组成的大图，减少服务器对图片的请求数

</details>

<b><details><summary>103. IE6 遇到什么 bug？解决办法是？</summary></b>

参考答案：

一、IE6 双倍边距 bug

当页面上的元素使用 float 浮动时，不管是向左还是向右浮动; 只要该元素带有 margin 像素都会使该值乘以 2，例如“margin-left:10px” 在 IE6 中，该值就会被解析为 20px。想要解决这个 BUG 就需要在该元素中加入 display:inline 或 display:block 明确其元素类型即可解决双倍边距的 BUG

二、IE6 中 3 像素问题及解决办法

当元素使用 float 浮动后，元素与相邻的元素之间会产生 3px 的间隙。诡异的是如果右侧的容器没设置高度时 3px 的间隙在相邻容器的内部，当设定高度后又跑到容器的相反侧了。要解决这类 BUG 的话，需要使布局在同一行的元素都加上 float 浮动。

三、IE6 中奇数宽高的 BUG

IE6 中奇数的高宽显示大小与偶数高宽显示大小存在一定的不同。其中要问题是出在奇数高宽上。要解决此类问题，只需要尽量将外部定位的 div 高宽写成偶数即可。

四、IE6 中图片链接的下方有间隙

IE6 中图片的下方会存在一定的间隙，尤其在图片垂直挨着图片的时候，即可看到这样的间隙。要解决此类问题，需要将 img 标签定义为 display:block 或定义 vertical-align 对应的属性。也可以为 img 对应的样式写入 font-size:0

五、IE6 下空元素的高度 BUG

如果一个元素中没有任何内容，当在样式中为这个元素设置了 0-19px 之间的高度时。此元素的高度始终为 19px。

解决的方法有四种:

1\. 在元素的 css 中加入：overflow:hidden

2\. 在元素中插入 html 注释：

3\. 在元素中插入 html 的空白符：

4\. 在元素的 css 中加入：font-size:0

六、重复文字的 BUG

在某些比较复杂的排版中，有时候浮动元素的最后一些字符会出现在 clear 清除元素的下面。

解决方法如下：

1\. 确保元素都带有 display:inline

2\. 在最后一个元素上使用“margin-right:-3px

3\. 为浮动元素的最后一个条目加上条件注释，xxx

4\. 在容器的最后元素使用一个空白的 div，为这个 div 指定不超过容器的宽度。

七、IE6 中 z-index 失效

具体 BUG 为，元素的父级元素设置的 z-index 为 1，那么其子级元素再设置 z-index 时会失效，其层级会继承父级元素的设置，造成某些层级调整上的 BUG。

写在最后：实际上 IE6 中，很多 BUG 的解决方法都可以使用 display:inline、font-size:0、float 解决。因此我们在书写代码时要记住，一旦使用了 float 浮动，就为元素增加一个 display:inline 样式，可以有效的避免浮动造成的样式错乱问题。使用空 DIV 时，为了避免其高度影响布局美观，也可以为其加上 font-size:0 这样就很容易避免一些兼容上的问题。

解析：[参考](https://www.cnblogs.com/rightzhao/p/3474162.html)

</details>

<b><details><summary>104. 介绍css3中position:sticky（网易）</summary></b>

参考答案：position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。

</details>

<b><details><summary>105. 使用css实现一个持续的动画效果</summary></b>

参考答案：

``` css
animation:mymove 5s infinite;

@keyframes mymove {
    from {
        top: 0px;
    }

    to {
        top: 200px;
    }
}
```

</details>



<b><details><summary>106.CSS 优先级算法如何计算？</summary></b>

参考答案：

相关知识点：

```
CSS的优先级是根据样式声明的特殊性值来判断的。

选择器的特殊性值分为四个等级，如下：

（1）标签内选择符x,0,0,0
（2）ID选择符0,x,0,0
（3）class选择符/属性选择符/伪类选择符	0,0,x,0
（4）元素和伪元素选择符0,0,0,x

计算方法：

（1）每个等级的初始值为0
（2）每个等级的叠加为选择器出现的次数相加
（3）不可进位，比如0,99,99,99
（4）依次表示为：0,0,0,0
（5）每个等级计数之间没关联
（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值
（7）如果两个优先级相同，则最后出现的优先级高，!important也适用
（8）通配符选择器的特殊性值为：0,0,0,0
（9）继承样式优先级最低，通配符样式优先级高于继承样式
（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。

计算实例：

（1）#demo a{color: orange;}/*特殊性值：0,1,0,1*/
（2）div#demo a{color: red;}/*特殊性值：0,1,0,2*/


注意：
（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。

（2）特殊性值越大的声明优先级越高。

（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）

 (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑
```

回答：

```
判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，
那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。

一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，
第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，
第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等
级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。
比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引
入的顺序，后出现的规则的优先级最高。
```

对于组合声明的特殊性值计算可以参考：
[《CSS 优先级计算及应用》](https://www.jianshu.com/p/1c4e639ff7d5)
[《CSS 优先级计算规则》](http://www.cnblogs.com/wangmeijian/p/4207433.html)
[《有趣：256 个 class 选择器可以干掉 1 个 id 选择器》](https://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/)

</details>

<b><details><summary>107.关于伪类 LVHA 的解释?</summary></b>

参考答案：

```
a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；

当链接未访问过时：

（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪
类后面声明；
（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），
必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。

当链接访问过时，情况基本同上，只不过需要将:link换成:visited。

这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，
也就不存在覆盖的问题。
```

</details>

<b><details><summary>108.CSS3 新增伪类有那些？</summary></b>

参考答案：

```
（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数
值，也可以接受函数。

（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。

（3）elem:last-child选中最后一个子元素。

（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。

（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。

（6）elem:first-of-type选中父元素下第一个elem类型元素。

（7）elem:last-of-type选中父元素下最后一个elem类型元素。

（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。

（9）elem:empty选中不包含子元素和内容的elem类型元素。

（10）elem:target选择当前活动的elem元素。

（11）:not(elem)选择非elem元素的每个元素。

（12）:enabled 控制表单控件的禁用状态。

（13）:disabled	控制表单控件的禁用状态。

(14):checked单选框或复选框被选中。

```

详细的资料可以参考：
[《CSS3 新特性总结(伪类)》](https://www.cnblogs.com/SKLthegoodman/p/css3.html)
[《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》](https://blog.csdn.net/zhouziyu2011/article/details/58605705)

</details>

<b><details><summary>109.如何居中 div？</summary></b>

参考答案：

-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性

```css
div {
  width: 200px;
  margin: 0 auto;
}
```

-水平居中，利用 text-align:center 实现

```css
.container {
  background: rgba(0, 0, 0, 0.5);
  text-align: center;
  font-size: 0;
}

.box {
  display: inline-block;
  width: 500px;
  height: 400px;
  background-color: pink;
}
```

-让绝对定位的 div 居中

```css
div {
  position: absolute;
  width: 300px;
  height: 300px;
  margin: auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: pink; /*方便看效果*/
}
```

-水平垂直居中一

```css
/*确定容器的宽高宽500高300的层设置层的外边距div{*/
position: absolute;/*绝对定位*/
width: 500px;
height: 300px;
top: 50%;
left: 50%;
margin: -150px00-250px;/*外边距为自身宽高的一半*/
background-color: pink;/*方便看效果*/
}
```

-水平垂直居中二

```css
/*未知容器的宽高，利用`transform`属性*/
div {
  position: absolute; /*相对定位或绝对定位均可*/
  width: 500px;
  height: 300px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: pink; /*方便看效果*/
}
```

-水平垂直居中三

```css
/*利用flex布局实际使用时应考虑兼容性*/
.container {
  display: flex;
  align-items: center; /*垂直居中*/
  justify-content: center; /*水平居中*/
}
.containerdiv {
  width: 100px;
  height: 100px;
  background-color: pink; /*方便看效果*/
}
```

-水平垂直居中四

```css
/*利用text-align:center和vertical-align:middle属性*/
.container {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: rgba(0, 0, 0, 0.5);
  text-align: center;
  font-size: 0;
  white-space: nowrap;
  overflow: auto;
}

.container::after {
  content: '';
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}

.box {
  display: inline-block;
  width: 500px;
  height: 400px;
  background-color: pink;
  white-space: normal;
  vertical-align: middle;
}
```

回答：

```
一般常见的几种居中的方法有：

对于宽高固定的元素

（1）我们可以利用margin:0 auto来实现元素的水平居中。

（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水
平和垂直方向上的居中。

（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素
的中心点到页面的中心。

（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素
的中心点到页面的中心。

（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对
齐，然后它的子元素也可以实现垂直和水平的居中。

对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。
```

</details>

<b><details><summary>110.display 有哪些值？说明他们的作用。</summary></b>

参考答案：

```
block	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
none	元素不显示，并从文档流中移除。
inline	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。
list-item	像块类型元素一样显示，并添加样式列表标记。
table	此元素会作为块级表格来显示。
inherit	规定应该从父元素继承display属性的值。
```

详细资料可以参考：
[《CSS display 属性》](http://www.w3school.com.cn/css/pr_class_display.asp)

</details>

<b><details><summary>111.position 的值 relative 和 absolute 定位原点是？</summary></b>

参考答案：

相关知识点：

```
absolute
生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的
一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。

fixed（老IE不支持）
生成绝对定位的元素，相对于浏览器窗口进行定位。

relative
生成相对定位的元素，相对于其元素本身所在正常位置进行定位。

static
默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。

inherit
规定从父元素继承position属性的值。
```

回答：

```
relative定位的元素，是相对于元素本身的正常位置来进行定位的。

absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话
我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元
素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。
```

</details>

<b><details><summary>112.CSS3 有哪些新特性？（根据项目回答）</summary></b>

参考答案：

```
新增各种CSS选择器	（:not(.input)：所有class不是“input”的节点）
圆角		（border-radius:8px）
多列布局	（multi-column layout）
阴影和反射	（Shadow\Reflect）
文字特效		（text-shadow）
文字渲染		（Text-decoration）
线性渐变		（gradient）
旋转			（transform）
缩放，定位，倾斜，动画，多背景
例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:
```

</details>

<b><details><summary>113.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</summary></b>

参考答案：

相关知识点：

```
Flex是FlexibleBox的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。

任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、cl
ear和vertical-align属性将失效。

采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为Flex
项目（flex item），简称"项目"。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。


以下6个属性设置在容器上。

flex-direction属性决定主轴的方向（即项目的排列方向）。

flex-wrap属性定义，如果一条轴线排不下，如何换行。

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

justify-content属性定义了项目在主轴上的对齐方式。

align-items属性定义项目在交叉轴上如何对齐。

align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。


以下6个属性设置在项目上。

order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认
值为auto，即项目的本来大小。

flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。

align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父
元素的align-items属性，如果没有父元素，则等同于stretch。
```

回答：

```
flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex
容器，它的所有子元素都会成为它的项目。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。
我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还
可以使用flex-wrap来规定当一行排列不下时的换行方式。

对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，
项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。
```

详细资料可以参考：
[《Flex 布局教程：语法篇》](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
[《Flex 布局教程：实例篇》](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

</details>

<b><details><summary>114.用纯 CSS 创建一个三角形的原理是什么？</summary></b>

参考答案：

```css
采用的是相邻边框连接处的均分原理。
  将元素的宽高设为0，只设置
  border
  ，把任意三条边隐藏掉（颜色设为
  transparent），剩下的就是一个三角形。
  #demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

</details>

<b><details><summary>115.一个满屏品字布局如何设计?</summary></b>

参考答案：

```
简单的方式：
	上面的div宽100%，
	下面的两个div分别宽50%，
	然后用float或者inline使其不换行即可
```

</details>

<b><details><summary>116.CSS 多列等高如何实现？</summary></b>

参考答案：

```
（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:
hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则
父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。

（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。

（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度
的特性，来实现多列等高。

```

详细资料可以参考：
[《前端应该掌握的 CSS 实现多列等高布局》](https://juejin.im/post/5b0fb34151882515662238fd)
[《CSS：多列等高布局》](https://codepen.io/yangbo5207/post/equh)

</details>

<b><details><summary>117.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</summary></b>

参考答案：

```
（1）png24位的图片在iE6浏览器上出现背景
解决方案：做成PNG8，也可以引用一段脚本处理。

（2）浏览器默认的margin和padding不同
解决方案：加一个全局的*{margin:0;padding:0;}来统一。

（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或
margin-right，margin值会加倍。

#box{float:left;width:10px;margin:0 0 0 10px;}

这种情况之下IE会产生20px的距离
解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

（4）渐进识别的方式，从总体中逐渐排除局部。
首先，巧妙的使用"\9"这一标记，将IE游览器从所有情况中分离出来。
接着，再次使用"+"将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
.bb{
background-color:#f1ee18;/*所有识别*/
.background-color:#00deff\9;/*IE6、7、8识别*/
+background-color:#a200ff;/*IE6、7识别*/
_background-color:#1e0bd1;/*IE6识别*/
}

（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义
属性；Firefox下，只能使用getAttribute()获取自定义属性
解决方法：统一通过getAttribute()获取自定义属性。

（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有
pageX、pageY属性，但是没有x、y属性。
解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示
解决方法：

1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome
更新到27版本之后就不可以用了。

2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);
收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；

（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了
解决方法：改变CSS属性的排列顺序L-V-H-A

（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模
式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。
```

</details>

<b><details><summary>118.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</summary></b>

参考答案：

```
浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，
这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

解决办法：

（1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。

（2）将所有<li>写在同一行。不足：代码不美观。

（3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他
字符尺寸，且在Safari浏览器依然会出现空白间隔。

（4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符
间隔设为默认letter-spacing:normal。
```

详细资料可以参考：
[《li 与 li 之间有看不见的空白间隔是什么原因引起的？》](https://blog.csdn.net/sjinsa/article/details/70919546)

</details>

<b><details><summary>119.为什么要初始化 CSS 样式？</summary></b>

参考答案：

```
-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

最简单的初始化方法：*{padding:0;margin:0;}（强烈不建议）

淘宝的样式初始化代码：
body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend
,button,input,textarea,th,td{margin:0;padding:0;}
body,button,input,select,textarea{font:12px/1.5tahoma,arial,\5b8b\4f53;}
h1,h2,h3,h4,h5,h6{font-size:100%;}
address,cite,dfn,em,var{font-style:normal;}
code,kbd,pre,samp{font-family:couriernew,courier,monospace;}
small{font-size:12px;}
ul,ol{list-style:none;}
a{text-decoration:none;}
a:hover{text-decoration:underline;}
sup{vertical-align:text-top;}
sub{vertical-align:text-bottom;}
legend{color:#000;}
fieldset,img{border:0;}
button,input,select,textarea{font-size:100%;}
table{border-collapse:collapse;border-spacing:0;}
```

</details>

<b><details><summary>120.什么是包含块，对于包含块的理解?</summary></b>

参考答案：

```
包含块（containing block）就是元素用来计算和定位的一个框。

（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。

（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box
边界形成。

（3）如果元素position:fixed，则“包含块”是“初始包含块”。

（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：

如果该祖先元素是纯inline元素，则规则略复杂：
•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包
围盒就是内联元素的“包含块”；
•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥
否则，“包含块”由该祖先的padding box边界形成。

如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。
```

</details>

<b><details><summary>121.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</summary></b>

参考答案：

```
（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。

（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的
表现却跟display:none一样，也就是说，它们占用的空间也会释放。

在不同浏览器下的区别：

在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。

在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位
置。

```

详细资料可以参考：
[《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》](http://www.webhek.com/post/visibility-collapse.html)

</details>

<b><details><summary>122.width:auto 和 width:100%的区别</summary></b>

参考答案：

```
一般而言

width:100%会使元素box的宽度等于父元素的content box的宽度。

width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。
```

</details>

<b><details><summary>123.绝对定位元素与非绝对定位元素的百分比计算的区别</summary></b>

参考答案：

```
绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。

非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。
```

</details>

<b><details><summary>124.简单介绍使用图片 base64 编码的优点和缺点。</summary></b>

参考答案：

```
base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的
url属性。

使用base64的优点是：

（1）减少一个图片的HTTP请求

使用base64的缺点是：

（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体
积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。

（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要
差很多。

（3）兼容性的问题，ie8以前的浏览器不支持。

一般一些网站的小图标可以使用base64图片来引入。
```

详细资料可以参考：
[《玩转图片 base64 编码》](https://www.cnblogs.com/coco1s/p/4375774.html)
[《前端开发中，使用 base64 图片的弊端是什么？》](https://www.zhihu.com/question/31155574)
[《小 tip:base64:URL 背景图片与 web 页面性能优化》](https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)

</details>

<b><details><summary>125.'display'、'position'和'float'的相互关系？</summary></b>

参考答案：

```
（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。

（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被
设置为table或者block，具体转换需要看初始转换值。

（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display
的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对
于浮动后的最终位置定位。

（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，
则保持指定的display属性值不变。

总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在
的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素
的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。

```

详细资料可以参考：
[《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》](https://www.cnblogs.com/jackyWHJ/p/3756087.html)

</details>

<b><details><summary>126.margin 重叠问题的理解。</summary></b>

参考答案：

相关知识点：

```
块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合
并”。

产生折叠的必备条件：margin必须是邻接的!

而根据w3c规范，两个margin是邻接的必须满足以下条件：

•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。
•没有线盒，没有空隙，没有padding和border将他们分隔开
•都属于垂直方向上相邻的外边距，可以是下面任意一种情况
•元素的margin-top与其第一个常规文档流的子元素的margin-top
•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top
•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom
•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top
和margin-bottom


margin合并的3种场景：

（1）相邻兄弟元素margin合并。

解决办法：
•设置块状格式化上下文元素（BFC）

（2）父级和第一个/最后一个子元素的margin合并。

解决办法：

对于margin-top合并，可以进行如下操作（满足一个条件即可）：
•父元素设置为块状格式化上下文元素；
•父元素设置border-top值；
•父元素设置padding-top值；
•父元素和第一个子元素之间添加内联元素进行分隔。

对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：
•父元素设置为块状格式化上下文元素；
•父元素设置border-bottom值；
•父元素设置padding-bottom值；
•父元素和最后一个子元素之间添加内联元素进行分隔；
•父元素设置height、min-height或max-height。

（3）空块级元素的margin合并。

解决办法：
•设置垂直方向的border；
•设置垂直方向的padding；
•里面添加内联元素（直接Space键空格是没用的）；
•设置height或者min-height。
```

回答：

```
margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。

一般来说可以分为四种情形：

第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC
来解决。

第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这
一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC
来解决。

第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相
邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为
父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。

第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、pa
dding或者高度来解决这个问题。
```

</details>

<b><details><summary>127.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</summary></b>

参考答案：

相关知识点：

```
块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒
子的区域，也是浮动元素与其他元素的交互限定区域。

通俗来讲

•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。
•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。

创建BFC

（1）根元素或包含根元素的元素
（2）浮动元素float＝left|right或inherit（≠none）
（3）绝对定位元素position＝absolute或fixed
（4）display＝inline-block|flex|inline-flex|table-cell或table-caption
（5）overflow＝hidden|auto或scroll(≠visible)

```

回答：

```
BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也
不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。

一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些
属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。
```

详细资料可以参考：
[《深入理解 BFC 和 MarginCollapse》](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)
[《前端面试题-BFC（块格式化上下文）》](https://segmentfault.com/a/1190000013647777)

</details>

<b><details><summary>128.IFC 是什么？</summary></b>

参考答案：

```
IFC指的是行级格式化上下文，它有这样的一些布局规则：

（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。
（2）当一行不够的时候会自动切换到下一行。
（3）行级上下文的高度由内部最高的内联盒子的高度决定。
```

详细资料可以参考：
[《[译]:BFC 与 IFC》](https://segmentfault.com/a/1190000004466536#articleHeader5)
[《BFC 和 IFC 的理解（布局）》](https://blog.csdn.net/paintandraw/article/details/80401741)

</details>

<b><details><summary>129.请解释一下为什么需要清除浮动？清除浮动的方式</summary></b>

参考答案：

```
浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，
不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框
的高度小于浮动框的时候，此时就会出现“高度塌陷”。

清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。

清除浮动的方式

（1）使用clear属性清除浮动。参考28。

（2）使用BFC块级格式化上下文来清除浮动。参考26。

因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元
素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。
```

</details>

<b><details><summary>130.使用 clear 属性清除浮动的原理？</summary></b>

参考答案：

```
使用clear属性清除浮动，其语法如下：

clear:none|left|right|both

如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问
题的，因为浮动一直还在，并没有清除。

官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素
对该元素的影响，而不是清除掉浮动。

还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属
性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear
属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left
等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和cle
ar:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。

一般使用伪元素的方式清除浮动

.clear::after{
content:'';
display:table;//也可以是'block'，或者是'list-item'
clear:both;
}

clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置disp
lay属性值的原因。
```

</details>

<b><details><summary>131.zoom:1 的清除浮动原理?</summary></b>

参考答案：

```
清除浮动，触发hasLayout；
zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）
的重叠，浮动清除，触发ie的haslayout属性等。

来龙去脉大概如下：
当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发
生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。

zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标
准化，出现在CSS3.0规范草案中。

目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。
```

</details>

<b><details><summary>132.移动端的布局用过媒体查询吗？</summary></b>

参考答案：

```
假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些
媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法

当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被
下载（只不过不会被应用）。

包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改
内容便可以使样式应用于某些特定的设备范围。
```

详细资料可以参考：
[《CSS3@media 查询》](http://www.runoob.com/cssref/css3-pr-mediaquery.html)
[《响应式布局和自适应布局详解》](http://caibaojian.com/356.html)

</details>

<b><details><summary>133.使用 CSS 预处理器吗？喜欢哪个？</summary></b>

参考答案：

```
SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS）
```

</details>

<b><details><summary>134.CSS 优化、提高性能的方法有哪些？</summary></b>

参考答案：

```
加载性能：

（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。
（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bot
tom;margin-left:left;执行的效率更高。
（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

选择器性能：

（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到
左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；

（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹
配它们了）。

（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。

（4）尽量少的去对标签进行选择，而是用class。

（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过
三层，更多的使用类来关联每一个标签元素。

（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

渲染性能：

（1）慎重使用高性能属性：浮动、定位。

（2）尽量减少页面重排、重绘。

（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。

（4）属性值为0时，不加单位。

（5）属性值为浮动小数0.**，可以省略小数点之前的0。

（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。

（7）不使用@import前缀，它会影响css的加载速度。

（8）选择器优化嵌套，尽量避免层级过深。

（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清
楚，再使用。

（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。

（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏
览器在下载web fonts时会阻塞页面渲染损伤性能。

可维护性、健壮性：

（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。
（2）样式与内容分离：将css代码定义到外部css中。
```

详细资料可以参考：
[《CSS 优化、提高性能的方法有哪些？》](https://www.zhihu.com/question/19886806)
[《CSS 优化，提高性能的方法》](https://www.jianshu.com/p/4e673bf24a3b)

</details>

<b><details><summary>135.浏览器是怎样解析 CSS 选择器的？</summary></b>

参考答案：

```
样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直
到和规则匹配，或者是因为不匹配而放弃该规则。

试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，
最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。
```

详细资料可以参考：
[《探究 CSS 解析原理》](https://juejin.im/entry/5a123c55f265da432240cc90)

</details>

<b><details><summary>136.在网页中应该使用奇数还是偶数的字体？为什么呢？</summary></b>

参考答案：

```
（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14
×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。
（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。
（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。
```

详细资料可以参考：
[《谈谈网页中使用奇数字体和偶数字体》](https://blog.csdn.net/jian_xi/article/details/79346477)
[《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》](https://www.zhihu.com/question/20440679)

</details>

<b><details><summary>137.margin 和 padding 分别适合什么场景使用？</summary></b>

参考答案：

```
margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。
margin用于布局分开元素使元素与元素互不相干。
padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。

何时应当使用margin：
•需要在border外侧添加空白时。
•空白处不需要背景（色）时。
•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。

何时应当时用padding：
•需要在border内测添加空白时。
•空白处需要背景（色）时。
•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。
```

</details>

<b><details><summary>138.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</summary></b>

参考答案：

```
我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放
进业务相关的库里面做成对应功能的模块儿。
```

详细资料可以参考：
[《CSS 规范-分类方法》](http://nec.netease.com/standard/css-sort.html)

</details>

<b><details><summary>139.简单说一下 css3 的 all 属性。</summary></b>

参考答案：

```
all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction
这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。

initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始
值。

inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。

unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则
使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。

```

详细资料可以参考：
[《简单了解 CSS3 的 all 属性》](https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/)

</details>

<b><details><summary>140.为什么不建议使用统配符初始化 css 样式。</summary></b>

参考答案：

```
采用*{padding:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，
样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一
套初始化样式。

出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即
可，并不需使用通配符*来初始化。
```

</details>

<b><details><summary>141.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</summary></b>

参考答案：

```
（1）内联元素也可以作为“包含块”所在的元素；

（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；

（3）边界是padding box而不是content box。
```

</details>

<b><details><summary>142.对于 hasLayout 的理解？</summary></b>

参考答案：

```
hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进
行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可
能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完
成这些工作。
```

详细资料可以参考：
[《CSS 基础篇--CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》](https://segmentfault.com/a/1190000010883974)
[《CSS 魔法堂：hasLayout 原来是这样的！》](https://segmentfault.com/a/1190000004632071)

</details>

<b><details><summary>143.元素竖向的百分比设定是相对于容器的高度吗？</summary></b>

参考答案：

```
如果是height的话，是相对于包含块的高度。

如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。
```

</details>

<b><details><summary>144.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</summary></b>

参考答案：

```
原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容
器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全
屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。

overflow：hidden；transition：all 1000 ms ease；
```

详细资料可以参考：
[《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》](https://blog.csdn.net/liona_koukou/article/details/52680409)
[《用 ES6 写全屏滚动插件》](https://juejin.im/post/5aeef41cf265da0ba0630de0)

</details>

<b><details><summary>145.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</summary></b>

参考答案：

```
响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏
幕尺寸做处理。页面头部必须有meta声明的viewport。
```

详细资料可以参考：
[《响应式布局原理》](https://blog.csdn.net/dreamerframework/article/details/8994741)
[《响应式布局的实现方法和原理》](http://www.mahaixiang.cn/wzsj/278.html)

</details>

<b><details><summary>146.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么</summary></b>

参考答案：做？）

```
视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。
```

详细资料可以参考：
[《如何实现视差滚动效果的网页？》](https://www.zhihu.com/question/20990029)

</details>

<b><details><summary>147.如何修改 chrome 记住密码后自动填充表单的黄色背景？</summary></b>

参考答案：

```
chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的in
put表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：

{
background-color:rgb(250,255,189)!important;
background-image:none!important;
color:rgb(0,0,0)!important;
}

对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是
其他属性可使用。

使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下

input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{
-webkit-box-shadow:000px 1000px white inset;
border:1px solid #CCC !important;
}

```

详细资料可以参考：
[《去掉 chrome 记住密码后的默认填充样式》](https://blog.csdn.net/zsl_955200/article/details/78276209)
[《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》](https://blog.csdn.net/M_agician/article/details/73381706)

</details>

<b><details><summary>148.怎么让 Chrome 支持小于 12px 的文字？</summary></b>

参考答案：

```
在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。

解决办法：

（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size
-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器
已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。

（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.
75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/
inline-block/...；

（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
```

详细资料可以参考：
[《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》](https://570109268.iteye.com/blog/2406562)

</details>

<b><details><summary>149.让页面里的字体变清晰，变细用 CSS 怎么做？</summary></b>

参考答案：

```
webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。

在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设
置后无效。
```

详细资料可以参考：
[《让字体变的更清晰 CSS 中-webkit-font-smoothing》](https://blog.csdn.net/huo_bao/article/details/50251585)

</details>

<b><details><summary>150.font-style 属性中 italic 和 oblique 的区别？</summary></b>

参考答案：

```
italic和oblique这两个关键字都表示“斜体”的意思。

它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，
则退而求其次，解析为oblique，也就是单纯形状倾斜。
```

</details>

<b><details><summary>151.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</summary></b>

参考答案：

```
设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。

css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相
对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。

dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr
为2。屏幕的缩放会改变dpr的值。

ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。
```

详细资料可以参考：
[《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》](https://www.cnblogs.com/libin-1/p/7148377.html)
[《前端工程师需要明白的「像素」》](https://www.jianshu.com/p/af6dad66e49a)
[《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》](https://github.com/jawil/blog/issues/21)
[《前端开发中像素的概念》](https://github.com/wujunchuan/wujunchuan.github.io/issues/15)

</details>

<b><details><summary>152.layout viewport、visual viewport 和 ideal viewport 的区别？</summary></b>

参考答案：

相关知识点：

```
如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定
默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。
ppk把这个浏览器默认的viewport叫做layout viewport。

layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把
这个viewport叫做visual viewport。

ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元
素的宽度设为ideal viewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。i
deal viewport的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也
不需要出现横向滚动条，都可以完美的呈现给用户。
```

回答：

```
移动端一共需要理解三个viewport的概念的理解。

第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整
个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展
示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。

第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu
al viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口
中的网页内容。

第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才
能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在
不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个
宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。
```

详细资料可以参考：
[《移动前端开发之 viewport 的深入理解》](https://www.cnblogs.com/2050/p/3877280.html)
[《说说移动前端中 viewport（视口）》](https://www.html.cn/archives/5975)
[《移动端适配知识你到底知多少》](https://juejin.im/post/5b6d21daf265da0f9d1a2ed7#heading-14)

</details>

<b><details><summary>153.position:fixed;在 android 下无效怎么处理？</summary></b>

参考答案：

```
因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕
的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的
，所以会出现感觉fixed无效的情况。

如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：

<metaname="viewport"content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-sca
le=1.0,user-scalable=no"/>
```

</details>

<b><details><summary>154.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</summary></b>

参考答案：

```
多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms
```

</details>

<b><details><summary>155.如何让去除 inline-block 元素间间距？</summary></b>

参考答案：

```
移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing
```

详细资料可以参考：
[《去除 inline-block 元素间间距的 N 种方法》](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)

</details>

<b><details><summary>156.overflow:scroll 时不能平滑滚动的问题怎么处理？</summary></b>

参考答案：

```
以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流
畅。
```

详细资料可以参考：
[《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》](https://www.jianshu.com/p/1f4693d0ad2d)

</details>

<b><details><summary>157.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</summary></b>

参考答案：

```
（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;
left:0;right:0;

（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。
```

详细资料可以参考：
[《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》](https://blog.csdn.net/xutongbao/article/details/79408522)

</details>

<b><details><summary>158.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</summary></b>

参考答案：

相关知识点：

```
（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。

（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。

（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。

（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。

（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。

（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。

（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。

•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
```

回答：

```
我了解到的一共有七种常见的图片的格式。

（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。

（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。

（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。

（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。

（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。

（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。

（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。
```

详细资料可以参考：
[《图片格式那么多，哪种更适合你？》](https://www.cnblogs.com/xinzhao/p/5130410.html)

</details>

<b><details><summary>159.浏览器如何判断是否支持 webp 格式图片</summary></b>

参考答案：

```
（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如
果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格
式的图片。

（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断
返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。
```

详细资料可以参考：
[《判断浏览器是否支持 WebP 图片》](https://blog.csdn.net/jesslu/article/details/82495061)
[《toDataURL()》](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL)

</details>

<b><details><summary>160.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</summary></b>

参考答案：

```
网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。

如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开
，静态资源放CDN。

因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请
求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的
http请求的解析速度。
```

详细资料可以参考：
[《CDN 是什么？使用 CDN 有什么优势？》](https://www.zhihu.com/question/36514327?rf=37353035)

</details>

<b><details><summary>161.style 标签写在 body 后与 body 前有什么区别？</summary></b>

参考答案：

```
页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式
表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可
能会出现FOUC现象（即样式失效导致的页面闪烁问题）
```

</details>

<b><details><summary>162.什么是 CSS 预处理器/后处理器？</summary></b>

参考答案：

```
CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成
文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然
后再编译成正常的CSS文件。

预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、
变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。

CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后
处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，
以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。

后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏
览器私有前缀，实现跨浏览器兼容性的问题。
```

详细资料可以参考：
[《CSS 预处理器和后处理器》](https://blog.csdn.net/yushuangyushuang/article/details/79209752)

</details>

<b><details><summary>163.阐述一下 CSSSprites</summary></b>

参考答案：

```
将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background
-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites
能减少图片的字节。

优点：

减少HTTP请求数，极大地提高页面加载速度
增加图片信息重复度，提高压缩比，减少图片大小
更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：

图片合并麻烦
维护麻烦，修改一个图片可能需要重新布局整个图片，样式
```

</details>

<b><details><summary>164.使用 rem 布局的优缺点？</summary></b>

参考答案：

```
优点：
在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。
而且现在浏览器基本都已经支持rem了，兼容性也非常的好。

缺点：
（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
（2）使用iframe引用也会出现问题。
（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问
题。
```

详细资料可以参考：
[《css3 的字体大小单位 rem 到底好在哪？》](https://www.zhihu.com/question/21504656)
[《VW:是时候放弃 REM 布局了》](https://www.jianshu.com/p/e8ae1c3861dc)
[《为什么设计稿是 750px》](https://blog.csdn.net/Honeymao/article/details/76795089)
[《使用 Flexible 实现手淘 H5 页面的终端适配》](https://github.com/amfe/article/issues/17)

</details>

<b><details><summary>165.几种常见的 CSS 布局</summary></b>

参考答案：

详细的资料可以参考：
[《几种常见的 CSS 布局》](https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12)

</details>

<b><details><summary>166.画一条 0.5px 的线</summary></b>

参考答案：

```
采用meta viewport的方式

采用border-image的方式

采用transform:scale()的方式
```

详细资料可以参考：
[《怎么画一条 0.5px 的边（更新）》](https://juejin.im/post/5ab65f40f265da2384408a95)

</details>

<b><details><summary>167.transition 和 animation 的区别</summary></b>

参考答案：

```
transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。

animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。
```

详细资料可以参考：
[《CSSanimation 与 CSStransition 有何区别？》](https://www.zhihu.com/question/19749045)
[《CSS3Transition 和 Animation 区别及比较》](https://blog.csdn.net/cddcj/article/details/53582334)
[《CSS 动画简介》](http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html)
[《CSS 动画：animation、transition、transform、translate》](https://juejin.im/post/5b137e6e51882513ac201dfb)

</details>

<b><details><summary>168.什么是首选最小宽度？</summary></b>

参考答案：

```
“首选最小宽度”，指的是元素最适合的最小宽度。

东亚文字（如中文）最小宽度为每个汉字的宽度。

西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短
横线、问号以及其他非英文字符等。

如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。
```

</details>

<b><details><summary>169.为什么 height:100%会无效？</summary></b>

参考答案：

```
对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。

原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，
所以无法参与计算。

使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。
```

</details>

<b><details><summary>170.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</summary></b>

参考答案：

```
（1）max-width会覆盖width，即使width是行类样式或者设置了!important。

（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。
```

</details>

<b><details><summary>171.内联盒模型基本概念</summary></b>

参考答案：

```
（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子
（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些
元素，内容区域可以看成元素自身。

（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒
子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。

（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。

（4）包含块（containing box），由一行一行的“行框盒子”组成。
```

</details>

<b><details><summary>172.什么是幽灵空白节点？</summary></b>

参考答案：

```
“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同
每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵
一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。
```

</details>

<b><details><summary>173.什么是替换元素？</summary></b>

参考答案：

```
通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，<img>、<object>、<video>、<iframe>或者表
单元素<textarea>和<input>和<select>都是典型的替换元素。

替换元素除了内容可替换这一特性以外，还有以下一些特性。

（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要
类似appearance属性，或者浏览器自身暴露的一些样式接口，

（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像
素，如<video>、<iframe>或者<canvas>等，也有少部分替换元素为0像素，如<img>图片，而表单元素的替换元素
的尺寸则和浏览器有关，没有明显的规律。

（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve
rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，
被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。

（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认
的display值却是不一样的，有的是inline，有的是inline-block。
```

</details>

<b><details><summary>174.替换元素的计算规则？</summary></b>

参考答案：

```
替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。

（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。

（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<img>的width和height属性、<input>的s
ize属性、<textarea>的cols和rows属性等。

（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的
尺寸，对应盒尺寸中的content box。

这3层结构的计算规则具体如下

（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。

（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。

（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。

（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。

（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。

（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。
```

</details>

<b><details><summary>175.content 与替换元素的关系？</summary></b>

参考答案：

```
content属性生成的对象称为“匿名替换元素”。

（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本
却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是
地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。

（2）content生成的内容不能左右:empty伪类。

（3）content动态生成值无法获取。
```

</details>

<b><details><summary>176.margin:auto 的填充规则？</summary></b>

参考答案：

```
margin的'auto'可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar
gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。

（1）如果一侧定值，一侧auto，则auto为剩余空间大小。
（2）如果两侧均是auto，则平分剩余空间。
```

</details>

<b><details><summary>177.margin 无效的情形</summary></b>

参考答案：

```
（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma
rgin合并的问题。

（2）表格中的<tr>和<td>元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。

（3）绝对定位元素非定位方位的margin值“无效”。

（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。
```

</details>

<b><details><summary>178.border 的特殊性？</summary></b>

参考答案：

```
（1）border-width却不支持百分比。

（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col
or没有边框显示的原因。

（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。

（4）border-color默认颜色就是color色值。

（5）默认background背景图片是相对于padding box定位的。
```

</details>

<b><details><summary>179.什么是基线和 x-height？</summary></b>

参考答案：

```
字母x的下边缘（线）就是我们的基线。

x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C
SS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。

ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影
响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。
```

</details>

<b><details><summary>180.line-height 的特殊性？</summary></b>

参考答案：

```
（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高
度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。

（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作
用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是
有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。

（3）行距=line-height-font-size。

（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下
边距，则向上取整。

（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。

（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是
通过改变块级元素里面内联级别元素占据的高度实现的。

（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si
ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。

（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为
属性值，那么所有的子元素继承的是最终的计算值。

（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。

（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个
“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。
```

</details>

<b><details><summary>181.vertical-align 的特殊性？</summary></b>

参考答案：

```
（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字
母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面
没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行
内联元素的基线。

（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display
计算值是table-cell的元素，我们不妨脑补成<td>元素，则和<tr>元素上边缘对齐。

（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对
于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。

（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上
偏移。

（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。

（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元
素。

（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。
```

</details>

<b><details><summary>182.overflow 的特殊性？</summary></b>

参考答案：

```
（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度
高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。

（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素<html>，另一个是文本域<textarea>。

（3）滚动条会占用容器的可用宽度或高度。

（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！
```

</details>

<b><details><summary>183.无依赖绝对定位是什么？</summary></b>

参考答案：

```
没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。

无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。
```

</details>

<b><details><summary>184.absolute 与 overflow 的关系？</summary></b>

参考答案：

```
（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute
元素进行剪裁。

（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也
都不会出现滚动条。

（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。
```

</details>

<b><details><summary>185.clip 裁剪是什么？</summary></b>

参考答案：

```
所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。

clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。
```

</details>

<b><details><summary>186.relative 的特殊性？</summary></b>

参考答案：

```
（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。

（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。

（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。
```

</details>

<b><details><summary>187.什么是层叠上下文？</summary></b>

参考答案：

```
层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元
素在z轴上就“高人一等”。

层叠上下文元素有如下特性：

（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。
（2）层叠上下文可以阻断元素的混合模式。
（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。
（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。
（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。


层叠上下文的创建：

（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是<html>元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。

（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。

（3）其他一些CSS3属性，比如元素的opacity值不是1。
```

</details>

<b><details><summary>188.什么是层叠水平？</summary></b>

参考答案：

```
层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。

显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上
下文元素中。
```

</details>

<b><details><summary>189.元素的层叠顺序？</summary></b>

参考答案：

层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。

![层叠顺序](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png)

</details>

<b><details><summary>190.层叠准则？</summary></b>

参考答案：

```
（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。

（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。
```

</details>

<b><details><summary>191.font-weight 的特殊性？</summary></b>

参考答案：

```
如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。
```

</details>

<b><details><summary>192.text-indent 的特殊性？</summary></b>

参考答案：

```
（1）text-indent仅对第一行内联盒子内容有效。

（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inli
ne-table则会生效。

（3）<input>标签按钮text-indent值无效。

（4）<button>标签按钮text-indent值有效。

（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。
```

</details>

<b><details><summary>193.letter-spacing 与字符间距？</summary></b>

参考答案：

```
letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。

letter-spacing具有以下一些特性。

（1）继承性。
（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。
（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。
（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。
（5）支持小数值，即使0.1px也是支持的。
（6）暂不支持百分比值。
```

</details>

<b><details><summary>194.word-spacing 与单词间距？</summary></b>

参考答案：

```
letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙
宽度。
```

</details>

<b><details><summary>195.white-space 与换行和空格的控制？</summary></b>

参考答案：

```
white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）
键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否
生效）等。

其属性值包括下面这些。
•normal：合并空白字符和换行符。
•pre：空白字符不合并，并且内容只在有换行符的地方换行。
•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。
•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。
•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。
```

</details>

<b><details><summary>196.隐藏元素的 background-image 到底加不加载？</summary></b>

参考答案：

相关知识点：

```
根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Fire
fox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片
依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使
用的。

如果不是background-image，而是<img>元素，则设置display:none在所有浏览器下依旧都会请求图片资源。

还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触
发时加载。
```

回答：

-（1）元素的背景图片

-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求
-:hover 样式下，触发时请求

-（2）img 标签图片任何情况下都会请求图片

详细资料可以参考：
[《CSS 控制前端图片 HTTP 请求的各种情况示例》](https://www.jb51.net/css/469033.html)

</details>

<b><details><summary>197.如何实现单行／多行文本溢出的省略（...）？</summary></b>

参考答案：

```css
/*单行文本溢出*/
p {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/*多行文本溢出*/
p {
  position: relative;
  line-height: 1.5em;
  /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/
  height: 3em;
  overflow: hidden;
}

p:after {
  content: '...';
  position: absolute;
  bottom: 0;
  right: 0;
  background-color: #fff;
}
```

详细资料可以参考：
[《【CSS/JS】如何实现单行／多行文本溢出的省略》](https://zhuanlan.zhihu.com/p/30707916)
[《CSS 多行文本溢出省略显示》](https://juejin.im/entry/587f453e1b69e60058555a5f)

</details>

<b><details><summary>198.常见的元素隐藏方式？</summary></b>

参考答案：

-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。

-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。

-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。

-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。

-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。

-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

详细资料可以参考：
[《CSS 隐藏元素的八种方法》](https://juejin.im/post/584b645a128fe10058a0d625#heading-2)

</details>

<b><details><summary>199.css 实现上下固定中间自适应布局？</summary></b>

参考答案：

```css
利用绝对定位实现body {
  padding: 0;
  margin: 0;
}

.header {
  position: absolute;
  top: 0;
  width: 100%;
  height: 100px;
  background: red;
}

.container {
  position: absolute;
  top: 100px;
  bottom: 100px;
  width: 100%;
  background: green;
}

.footer {
  position: absolute;
  bottom: 0;
  height: 100px;
  width: 100%;
  background: red;
}

利用flex布局实现html,
body {
  height: 100%;
}

body {
  display: flex;
  padding: 0;
  margin: 0;
  flex-direction: column;
}

.header {
  height: 100px;
  background: red;
}

.container {
  flex-grow: 1;
  background: green;
}

.footer {
  height: 100px;
  background: red;
}
```

详细资料可以参考：
[《css 实现上下固定中间自适应布局》](https://www.jianshu.com/p/30bc9751e3e8)

</details>

<b><details><summary>200.css 两栏布局的实现？</summary></b>

参考答案：

相关资料：

```css
/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/
/*以左边宽度固定为200px为例*/

/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/
.outer {
  height: 100px;
}

.left {
  float: left;

  height: 100px;
  width: 200px;

  background: tomato;
}

.right {
  margin-left: 200px;

  width: auto;
  height: 100px;

  background: gold;
}

/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/
.outer {
  display: flex;

  height: 100px;
}

.left {
  flex-shrink: 0;
  flex-grow: 0;
  flex-basis: 200px;

  background: tomato;
}

.right {
  flex: auto;
  /*11auto*/

  background: gold;
}

/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为
200px。将右边元素的margin-left的值设置为200px。*/
.outer {
  position: relative;

  height: 100px;
}

.left {
  position: absolute;

  width: 200px;
  height: 100px;

  background: tomato;
}

.right {
  margin-left: 200px;
  height: 100px;

  background: gold;
}

/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/
.outer {
  position: relative;

  height: 100px;
}

.left {
  width: 200px;
  height: 100px;

  background: tomato;
}

.right {
  position: absolute;

  top: 0;
  right: 0;
  bottom: 0;
  left: 200px;

  background: gold;
}
```

[《两栏布局 demo 展示》](http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html)

回答：

两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。

以左边宽度固定为 200px 为例

-（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。

-（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。

-（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。

-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。

</details>

<b><details><summary>201.css 三栏布局的实现？</summary></b>

参考答案：

相关资料：

```css
/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。

这里以左边宽度固定为100px，右边宽度固定为200px为例。*/

/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/
.outer {
  position: relative;
  height: 100px;
}

.left {
  position: absolute;

  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  position: absolute;
  top: 0;
  right: 0;

  width: 200px;
  height: 100px;
  background: gold;
}

.center {
  margin-left: 100px;
  margin-right: 200px;
  height: 100px;
  background: lightgreen;
}

/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/
.outer {
  display: flex;
  height: 100px;
}

.left {
  flex: 00100px;
  background: tomato;
}

.right {
  flex: 00200px;
  background: gold;
}

.center {
  flex: auto;
  background: lightgreen;
}

/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/
.outer {
  height: 100px;
}

.left {
  float: left;
  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  float: right;
  width: 200px;
  height: 100px;
  background: gold;
}

.center {
  height: 100px;
  margin-left: 100px;
  margin-right: 200px;
  background: lightgreen;
}

/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/
.outer {
  height: 100px;
  padding-left: 100px;
  padding-right: 200px;
}

.left {
  position: relative;
  left: -100px;

  float: left;
  margin-left: -100%;

  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  position: relative;
  left: 200px;

  float: right;
  margin-left: -200px;

  width: 200px;
  height: 100px;
  background: gold;
}

.center {
  float: left;

  width: 100%;
  height: 100px;
  background: lightgreen;
}

/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元
素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/

.outer {
  height: 100px;
}

.left {
  float: left;
  margin-left: -100%;

  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  float: left;
  margin-left: -200px;

  width: 200px;
  height: 100px;
  background: gold;
}

.wrapper {
  float: left;

  width: 100%;
  height: 100px;
  background: lightgreen;
}

.center {
  margin-left: 100px;
  margin-right: 200px;
  height: 100px;
}
```

[《三栏布局 demo 展示》](http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html)

回答：

```
三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。

这里以左边宽度固定为100px，右边宽度固定为200px为例。

（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。

（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。

（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。

（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。

（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。
```

</details>

<b><details><summary>202.实现一个宽高自适应的正方形</summary></b>

参考答案：

```css
/*1.第一种方式是利用vw来实现*/
.square {
  width: 10%;
  height: 10vw;
  background: tomato;
}

/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/
.square {
  width: 20%;
  height: 0;
  padding-top: 20%;
  background: orange;
}

/*3.第三种方式是利用子元素的margin-top的值来实现的*/
.square {
  width: 30%;
  overflow: hidden;
  background: yellow;
}

.square::after {
  content: '';
  display: block;
  margin-top: 100%;
}
```

[《自适应正方形 demo 展示》](http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html)

</details>

<b><details><summary>203.实现一个三角形</summary></b>

参考答案：

```css
/*三角形的实现原理是利用了元素边框连接处的等分原理。*/
.triangle {
  width: 0;
  height: 0;
  border-width: 100px;
  border-style: solid;
  border-color: tomatotransparenttransparenttransparent;
}
```

[《三角形 demo 展示》](http://cavszhouyou.top/Demo-Display/Triangle/index.html)

</details>

<b><details><summary>204.一个自适应矩形，水平垂直居中，且宽高比为 2:1</summary></b>

参考答案：

```css
/*实现原理参考自适应正方形和水平居中方式*/
.box {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  margin: auto;

  width: 10%;
  height: 0;
  padding-top: 20%;
  background: tomato;
}
```

</details>

<b><details><summary>205.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</summary></b>

参考答案：

```
公式：当前元素某CSS属性值 = 基准 * 对应的百分比
元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width
元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width
元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width
元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）
元素的 border-width，不支持百分比
元素的 text-indent，基准为包含块的 width

元素的 border-radius，基准为分别为自身的height、width
元素的 background-size，基准为分别为自身的height、width
元素的 translateX、translateY，基准为分别为自身的height、width
元素的 line-height，基准为自身的 font-size

元素的 font-size，基准为父元素字体
```
</details>

<b><details><summary>206.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</summary></b>

参考答案：

相关知识点：

```
单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）
双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，
比如:first-line、:first-letter、:before、:after等，
而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。

想让插入的内容出现在其它内容前，使用::before，否者，使用::after；
在代码顺序上，::after生成的内容也比::before生成的内容靠后。
如果按堆栈视角，::after生成的内容会在::before生成的内容之上。
```

回答：

```
在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号
来表示伪元素。

伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。
```

</details>

<b><details><summary>207.伪类与伪元素的区别</summary></b>

参考答案：

```
css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句
话中的第一个字母，或者是列表中的第一个元素。

伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的
元素时，我们可以通过:hover来描述这个元素的状态。

伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be
fore来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览
器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行
特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。
```

详细资料可以参考：
[《总结伪类与伪元素》](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)

</details>

<b><details><summary>208.CSS 中哪些属性可以继承？</summary></b>

参考答案：

相关资料：

```
每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。

当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。

当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。

有继承性的属性：

（1）字体系列属性
font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust

（2）文本系列属性
text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color

（3）表格布局属性
caption-side border-collapse empty-cells

（4）列表属性
list-style-type、list-style-image、list-style-position、list-style

（5）光标属性
cursor

（6）元素可见性
visibility

（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性


注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地
指定继承性，可用于任何继承性/非继承性属性。
```

回答：

```
每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。

一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。
表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。

当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。
```

详细的资料可以参考：
[《继承属性》](https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance)
[《CSS 有哪些属性可以继承？》](https://www.jianshu.com/p/34044e3c9317)

</details>

<b><details><summary>209.png-8和png-24有什么区别？</summary></b>

参考答案：

```
1、“PNG8”是指8位索引色位图，“PNG24”是24位索引色位图；

2、png8：每一张“png8”图像，都最多只能展示256种颜色，所以“png8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；

png24：每一张“png24”图像，可展示的颜色就远远多于“png8”了，最多可展示的颜色数量多大1600万；所以“png24”所展示的图片颜色会更丰富，图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“png24”的图片比较适合像摄影作品之类颜色比较丰富的图片。
```

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 简单对比 git pull 和 git pull --rebase 的使用</summary></b>

参考答案：

git pull = git fetch + git merge
git pull --rebase = git fetch + git rebase

解析：现在来看看[git merge 和 git rebase 的区别](https://www.cnblogs.com/kevingrace/p/5896706.html)

[参与互动](https://github.com/yisainan/web-interview/issues/997)

</details>

<b><details><summary>2. 什么时候使用“git rebase”代替“git merge”？</summary></b>

参考答案：你自己开发分支一直在做，然后你想把主线的修改合到你的分支上，做一次集成，这种情况就用rebase比较好，把你的提交都放在主线修改的头上

1. rebase会把你当前分支的commit放到公共分支的最后，所以叫做变基。就如同你从公共分支又重新拉出来这个分支一样。
2. merge会把公共分支和你当前的commit合并在一起，形成一个新的commit提交。

[参与互动](https://github.com/yisainan/web-interview/issues/998)

</details>

<b><details><summary>3. “拉取请求（pull request）”和“分支（branch）”之间有什么区别？</summary></b>

参考答案：

* 分支（branch） 是代码的一个独立版本。

* 拉取请求（pull request） 是当有人用仓库，建立了自己的分支，做了些修改并合并到该分支（把自己修改应用到别人的代码仓库）。

[参与互动](https://github.com/yisainan/web-interview/issues/999)

</details>

<b><details><summary>4. 什么是 Git 复刻（fork）？复刻（fork）、分支（branch）和克隆（clone）之间有什么区别？</summary></b>

参考答案：

* 复刻（fork） 是对存储仓库（repository）进行的远程的、服务器端的拷贝，从源头上就有所区别。复刻实际上不是 Git 的范畴。它更像是个政治/社会概念。

* 克隆（clone） 不是复刻，克隆是个对某个远程仓库的本地拷贝。克隆时，实际上是拷贝整个源存储仓库，包括所有历史记录和分支。

* 分支（branch） 是一种机制，用于处理单一存储仓库中的变更，并最终目的是用于与其他部分代码合并。

[参与互动](https://github.com/yisainan/web-interview/issues/1000)

</details>

<b><details><summary>5. 使用过 git cherry-pick，有什么作用？</summary></b>

参考答案：

命令 git cherry-pick 通常用于把特定提交从存储仓库的一个分支引入到其他分支中。常见的用途是从维护的分支到开发分支进行向前或回滚提交。
这与其他操作（例如：合并（merge）、变基（rebase））形成鲜明对比，后者通常是把许多提交应用到其他分支中。

```

git cherry-pick <commit-hash>
```

[参与互动](https://github.com/yisainan/web-interview/issues/1001)

</details>

<b><details><summary>6. git 跟其他版本控制器有啥区别？</summary></b>

参考答案：

Git比svn快，而且更加的流畅。

Git在本地就可以使用，可以随便保存各种历史记录，不用担心污染服务器。

Git在branch和branch之间切换非常简单。

Git没有被lock不能commit 的情况。

[参与互动](https://github.com/yisainan/web-interview/issues/1002)

</details>

<b><details><summary>7. 我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行 git status 时都让这些文件显示出来，我们该如何操作？</summary></b>

参考答案：在 Git 工作区的跟目录下创建一个特殊的. gitignore 文件，然后把忽略的文件名编辑进去，Git 就会自动忽略这些文件。

[参与互动](https://github.com/yisainan/web-interview/issues/1003)

</details>

<b><details><summary>8. 如何把本地仓库的内容推向一个空的远程仓库？</summary></b>

参考答案：

git init //生成. git 文件
git remote add origin 远程仓库地址 // 将本地和远程厂库关联起来
git add . 
git commit -m '提交信息'
git push origin master // 将本地代码推送到库上

[参与互动](https://github.com/yisainan/web-interview/issues/1004)

</details>

<b><details><summary>9. 提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？</summary></b>

参考答案：

#### 1. 冲突是如何产生的

我们都知道，Git 的实现途径是 1 棵树。比如有一个节点树(point1), 

* 我们基于 point1 进行开发，开发出了结点 point2；
* 我们基于 point1 进行开发，开发出了结点 point3；

  如果我们在 point2 和 point3 内操作了同一类元素，那么势必会导致冲突的存在。
  主要的思想如下图 1 所示:

point1. js

```js
function test() {
    console.log(a);
    var a = 1;
}
```

人物甲 更新了版本 2
代码: poin2. js

```js
function test() {
    console.log(a);
    var a = 2;
}
```

人物乙 更新了版本 3
代码: poin3. js

```js
function test() {
    console.log(a);
    var a = 3;
}
```

场景如下，甲乙都是根据 point. js 文件进行了开发。甲开发出了版本 2，并且提交了代码；乙开发出了版本 3，也需要提交了代码，此时将会报错存在冲突。

为什么呢？因为甲开发完了版本，提交了版本之后，此时远端的代码已经是版本 2 点代码了，而乙是基于版本 1 进行的开发出了版本 3。所以，乙想要提交代码，势必要将自己的代码更新为版本 2 的代码，然后再进行提交，如果存在冲突则解决冲突后提交

#### 2. 冲突是如何解决的

上面已经详细的说明了冲突时如何产生的，那么又该如何解决冲突呢?

解决冲突通常使用如下的步骤即可:

* 情况 1 无冲突

先拉取远端的代码，更新本地代码。然后提交自己的更新代码即可。

* 情况 2 有冲突

拉取远端代码。存在冲突，会报错。
此时我们需要将本地代码暂存起来 stash；
更新本地代码，将本地代码版本更新和远端的代码一致即可；
将暂存的代码合并到更新后的代码后，有冲突解决冲突(需要手动进行解决冲突)；
提交解决冲突后的代码。

[参与互动](https://github.com/yisainan/web-interview/issues/1005)

</details>

<b><details><summary>10. 列举工作中常用的几个 git 命令？</summary></b>

参考答案：

```
git init                     // 新建 git 代码库
git add                      // 添加指定文件到暂存区
git rm                       // 删除工作区文件，并且将这次删除放入暂存区
git commit -m [message]      // 提交暂存区到仓库区
git branch                   // 列出所有分支
git checkout -b [branch]     // 新建一个分支，并切换到该分支
git status                   // 显示有变更的文件
```
详细资料可以参考：
[《常用 Git 命令清单》](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)

[参与互动](https://github.com/yisainan/web-interview/issues/1006)

</details>

<b><details><summary>11. git提交代码时候写错commit信息后，如何重新设置commit信息？</summary></b>

参考答案：可以通过git commit --amend 来对本次commit进行修改。

[参与互动](https://github.com/yisainan/web-interview/issues/1007)

</details>

<b><details><summary>12. 说明新建一个GIT功能分支的步骤，提供每个步骤的指令，并对指令进行说明</summary></b>

参考答案：

git branch name     创建名字为name的branch

git checkout xxx_dev    切换到名字为xxx_dev的分支

git pull    从远程分支拉取代码到本地分支

git checkout -b main_furture_xxx    创建并切换到main_furture_xxx

git push origin main_furture_xxx    执行推送的操作，完成本地分支向远程分支的同步

[参与互动](https://github.com/yisainan/web-interview/issues/1008)

</details>

<b><details><summary>13. 说明git合并的两种方法以及区别</summary></b>

参考答案：

git代码合并有两种：git Merge 和 git ReBase

Git Merge：这种合并方式是将两个分支的历史合并到一起，现在的分支不会被更改，它会比对双方不同的文件缓存下来，生成一个commit，去push。

Git ReBase：这种合并方法通常被称为“衍合”。他是提交修改历史，比对双方的commit，然后找出不同的去缓存，然后去push，修改commit历史。

[参与互动](https://github.com/yisainan/web-interview/issues/1009)

</details>

<b><details><summary>14. 如何查看文件的提交历史和分支的提交历史</summary></b>

参考答案：

使用git log查看文件提交历史

git log filename

使用git log查看分支提交历史

git log branch file

[参与互动](https://github.com/yisainan/web-interview/issues/1010)

</details>

<b><details><summary>15. 当GIT出现如下情况时，该如何处理？</summary></b>

## your-branch-is-ahead-of-origin-master-by-3-commits

参考答案：

Git commit

Git pull

Git push

[参与互动](https://github.com/yisainan/web-interview/issues/1011)

</details>

<b><details><summary>16. 如何从 git 中删除文件，而不将其从文件系统中删除？</summary></b>

参考答案：

如果你在 git add 过程中误操作，你最终会添加不想提交的文件。但是，git rm 则会把你的文件从你暂存区（索引）和文件系统（工作树）中删除，这可能不是你想要的。

换成 git reset 操作：

```

git reset filename          # or
echo filename >> .gitingore # add it to .gitignore to avoid re-adding it
```

上面意思是， `git reset <paths>` 是 `git add <paths>` 的逆操作

[参与互动](https://github.com/yisainan/web-interview/issues/1011)

</details>

<b><details><summary>17. 什么时候应使用 “git stash”？</summary></b>

参考答案：

git stash 命令把你未提交的修改（已暂存（staged）和未暂存的（unstaged））保存以供后续使用，以后就可以从工作副本中进行还原。

[参与互动](https://github.com/yisainan/web-interview/issues/1011)

</details>

<b><details><summary>18. 你能解释下 Gitflow 工作流程吗？</summary></b>

参考答案：

Gitflow 工作流程使用两个并行的、长期运行的分支来记录项目的历史记录，分别是 master 和 develop 分支。

* Master，随时准备发布线上版本的分支，其所有内容都是经过全面测试和核准的（生产就绪）。

Hotfix，维护（maintenance）或修复（hotfix）分支是用于给快速给生产版本修复打补丁的。修复（hotfix）分支很像发布（release）分支和功能（feature）分支，除非它们是基于 master 而不是 develop 分支。

* Develop，是合并所有功能（feature）分支，并执行所有测试的分支。只有当所有内容都经过彻底检查和修复后，才能合并到 master 分支。

Feature，每个功能都应留在自己的分支中开发，可以推送到 develop 分支作为功能（feature）分支的父分支。

[参与互动](https://github.com/yisainan/web-interview/issues/1011)

</details>

<b><details><summary>19. Git 中 HEAD、工作树和索引之间的区别？</summary></b>

参考答案：

* 该工作树/工作目录/工作空间是你看到和编辑的（源）文件的目录树。
* 该索引/中转区（staging area）是个在 /. git/index，单一的、庞大的二进制文件，该文件列出了当前分支中所有文件的 SHA1 检验和、时间戳和文件名，它不是个带有文件副本的目录。
* HEAD是当前检出分支的最后一次提交的引用/指针。

[参与互动](https://github.com/yisainan/web-interview/issues/1011)

</details>

<b><details><summary>20. 解释 Forking 工作流程的优点？</summary></b>

参考答案：

* Forking 工作流程 与其他流行的 Git 工作流程有着根本的区别。它不是用单个服务端仓库充当“中央”代码库，而是为每个开发者提供自己的服务端仓库。Forking 工作流程最常用于公共开源项目中。

* Forking 工作流程的主要优点是可以汇集提交贡献，又无需每个开发者提交到一个中央仓库中，从而实现干净的项目历史记录。开发者可以推送（push）代码到自己的服务端仓库，而只有项目维护人员才能直接推送（push）代码到官方仓库中。

* 当开发者准备发布本地提交时，他们的提交会推送到自己的公共仓库中，而不是官方仓库。然后他们向主仓库提交请求拉取（pull request），这会告知项目维护人员有可以集成的更新。

[参与互动](https://github.com/yisainan/web-interview/issues/1011)

</details>

<b><details><summary>21. 我想丢弃本地未提交的变化(uncommitted changes)</summary></b>

参考答案：

> git reset --hard HEAD^

</details>

<b><details><summary>22. 我意外的做了一次硬重置(hard reset)，我想找回我的内容</summary></b>

参考答案：

如果你意外的做了 git reset --hard, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。

> (main)$ git reflog

你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次:

> (main)$ git reset --hard SHA1234

这样就完成了。

</details>

<b><details><summary>23. 我的提交信息(commit message)写错了</summary></b>

参考答案：如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):

> git commit --amend --only -m 'fix: 新的提交信息'

</details>

<b><details><summary>24.git 与 svn 的区别在哪里？</summary></b>

参考答案：

   ```
   git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器
   出现问题，我们就没有办法使用 svn 来提交我们的代码。

   svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小
   并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。

   svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。
   ```
   详细资料可以参考：
   [《常见工作流比较》](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83)
   [《对比 Git 与 SVN，这篇讲的很易懂》](https://juejin.im/post/5bd95bf4f265da392c5307eb)
   [《GIT 与 SVN 世纪大战》](https://blog.csdn.net/github_33304260/article/details/80171456)
   [《Git 学习小记之分支原理》](https://www.jianshu.com/p/e8ad60710017)

</details>

<b><details><summary>25.git pull 和 git fetch 的区别 </summary></b>

参考答案：

   ```
   git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。

   git pull 会将远程仓库的变化下载下来，并和当前分支合并。
   ```
   [《详解 git pull 和 git fetch 的区别》](https://blog.csdn.net/weixin_41975655/article/details/82887273)

</details>

<b><details><summary>26.git rebase 和 git merge 的区别</summary></b>

参考答案：

   ```
   git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。

   git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会
   保留之前每个分支的 commit 历史。

   git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后
   将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记
   录了。
   ```
   [《git rebase 和 git merge 的区别》](https://www.jianshu.com/p/f23f72251abc)
   [《git merge 与 git rebase 的区别》](https://blog.csdn.net/liuxiaoheng1992/article/details/79108233)

</details>

<b><details><summary>27. 删除/添加远程地址</summary></b>

参考答案：

```
删除远程地址
git remote rm origin

添加远程地址
git remote add origin git@github.com:qiilee/vue3.git
```

</details>

<b><details><summary>28. 只是提交信息里有一个单词写错了，可以使用以下命令进行修补</summary></b>

git commit --amend -m “xxx”

</details>

<b><details><summary>29. 撤销提交历史中的某一次指定的提交</summary></b>

git revert 711bb0b

</details>

<b><details><summary>30. 合并出现冲突时，撤销合并操作</summary></b>

git merge --abort

</details>

<b><details><summary>31. 暂存区的文件加多了，想移除，又不想删掉本地的文件</summary></b>

git rm --cached src/test.md

</details>

<b><details><summary>32. 分支重命名</summary></b>

git br -m [old_br] [new_br]

</details>

<b><details><summary>33. </summary></b>

</details>

<b><details><summary>34. </summary></b>

</details>---
name: 微信小程序面试题模板
about: 这是一个用于发布微信小程序面试题的模板
title: "[微信小程序] "
labels: 微信小程序
assignees: ''

---


# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 简述一下你对 HTML 语义化的理解？</summary></b>

参考答案：

①**用正确的标签做正确的事情。**

②html 语义化让页面的**内容结构化，结构更清晰**，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 

③ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，**利于 SEO**; 

④ 使阅读源代码的人对网站更容易将网站分块，**便于阅读维护理解**。

[参与互动](https://github.com/yisainan/web-interview/issues/2)

</details>

<b><details><summary>2. Label 的作用是什么？是怎么用的？</summary></b>

参考答案：label 标签来定义表单控制间的关系, **当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上**。

解析：两种用法：**一种是 id 绑定，一种是嵌套**

```html
<label for="Name">Number:</label>

<input type=“text“name="Name" id="Name" />

<label>Date:<input type="text" name="B" /></label>
```

[参与互动](https://github.com/yisainan/web-interview/issues/3)

</details>

<b><details><summary>3.iframe 框架有哪些优缺点？</summary></b>

参考答案：

#### 优点：

* iframe 能够原封不动的把嵌入的网页展现出来。
* 如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
* 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。
* 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。

#### 缺点：

* 框架结构中出现各种滚动条
* iframe 会阻塞主页面的 Onload 事件
* 搜索引擎的检索程序无法解读这种页面，不利于 SEO
* iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

[参与互动](https://github.com/yisainan/web-interview/issues/4)

</details>

<b><details><summary>4. HTML 与 XHTML 二者有什么区别，你觉得应该使用哪一个并说出理由。</summary></b>

参考答案：

```

应该使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：

1、XHTML中所有的标记都必须有一个相应的结束标签；

2、XHTML所有标签的元素和属性的名字都必须使用小写；

3、所有的XML标记都必须合理嵌套；

4、所有的属性都必须用引号“”括起来；

5、把所有<和&特殊符号用编码表示；

6、给所有属性附一个值；

7、不要在注释内容中使用“--”；

8、图片必须使用说明文字。

```

[参与互动](https://github.com/yisainan/web-interview/issues/5)

</details>

<b><details><summary>5. HTML5 的 form 如何关闭自动完成功能？</summary></b>

参考答案：将不想要自动完成的 `form` 或 `input` 设置为 `autocomplete=off`

解析：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion)

[参与互动](https://github.com/yisainan/web-interview/issues/6)

</details>

<b><details><summary>6.title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</summary></b>

参考答案：

```

①title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，seo权重高于H1；H1概括的是文章主题，一个页面最好只用一个H1，seo权重低于title。

解析：

A.从网站角度而言，title则重于网站信息标题，突出网站标题或关键字用title，一篇文章，一个页面最好只

用一个H1，H1用得太多，会稀释主题；一个网站可以有多个title，最好一个单页用一个title以便突出网站页面

主题信息。

B.从文章角度而言，H1则概括的是文章主题，突出文章主题，用H1，面对的用户，要突出其视觉效果。

C.从SEO角度而言，title的权重高于H1，其适用性要比H1广。

②b为了加粗而加粗，strong为了标明重点而加粗

解析：

A.b这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；

B.strong这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；

③ 同②i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i要重视的多

```

[参与互动](https://github.com/yisainan/web-interview/issues/7)

</details>

<b><details><summary>7. 请描述下 SEO 中的 TDK？</summary></b>

参考答案：在 SEO 中，所谓的 TDK 其实就是 title、description、keywords 这三个标签，title 标题标签，description 描述标签，keywords 关键词标签

[参与互动](https://github.com/yisainan/web-interview/issues/8)

</details>

<b><details><summary>8. 每个 HTML 文件头里都有个很重要的东西，Doctype，知道这是干什么的么？</summary></b>

参考答案： `<! DOCTYPE>` 声明位于文档中的最前面的位置，处于 `<html>` 标签之前。

01. 告知浏览器文档使用哪种 HTML 或 XHTML 规范。

02. 告诉浏览器按照何种规范解析页（如果你的页面没有 DOCTYPE 的声明，那么 compatMode 默认就是 BackCompat, 浏览器按照自己的方式解析渲染页面）

解析：

doctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。

<! DOCTYPE>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。

<! DOCTYPE>声明必须是HTML文档的第一行，位于html标签之前。

浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 doctype 来区分这两种模式，doctype 在 html 中的作用就是触发浏览器的标准模式，如果 html 中省略了 doctype，浏览器就会进入到 Quirks 模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而 html 标准和 dom 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 html 开头使用 doctype。

[参与互动](https://github.com/yisainan/web-interview/issues/9)

</details>

<b><details><summary>9. 简述一下 src 与 href 的区别。</summary></b>

参考答案：src 用于引用资源，替换当前元素；href 用于在当前文档和引用资源之间确立联系。

解析：

* href <br>
  href 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，是在当前元素和引用资源之间建立联系<br>
  若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。
* src <br>
  src 表示引用资源，替换当前元素，用在 img，script，iframe 上，src 是页面内容不可缺少的一部分。<br>
  当浏览器解析到 src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。

[参考](https://blog.csdn.net/lhjuejiang/article/details/80795081)

[参与互动](https://github.com/yisainan/web-interview/issues/10)

</details>

<b><details><summary>10. 严格模式与混杂模式</summary></b>

参考答案：

严格模式：以浏览器支持的最高标准运行

混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为

[参与互动](https://github.com/yisainan/web-interview/issues/11)

</details>

<b><details><summary>11. 对于 WEB 标准以及 W3C 的理解与认识问题</summary></b>

参考答案：

<b>web 标准</b>简单来说可以分为<b>结构、表现和行为</b>。其中结构主要是有 HTML 标签组成。或许通俗点说，在页面 body 里面我们写入的标签都是为了页面的结构。表现即指 css 样式表，通过 css 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 js 组成。

web 标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。

W3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点

01. 对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）

1）标签字母要小写

2）标签要闭合

3）标签不允许随意嵌套

02. 对于 css 和 js 来说

1）尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。

2）样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版

3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。

[参与互动](https://github.com/yisainan/web-interview/issues/12)

</details>

<b><details><summary>12. 列举 IE 与其他浏览器不一样的特性？</summary></b>

参考答案：

a. IE 的排版引擎是 Trident （又称为 MSHTML）

b. Trident 内核曾经几乎与 W3C 标准脱节（2005 年）

c. Trident 内核的大量 Bug 等安全性问题没有得到及时解决

d. JS 方面，有很多独立的方法，例如绑定事件的 attachEvent、创建事件的 createEventObject 等

e. CSS 方面，也有自己独有的处理方式，例如设置透明，低版本 IE 中使用滤镜的方式

[参与互动](https://github.com/yisainan/web-interview/issues/13)

</details>

<b><details><summary>13. 前端页面有哪三层构成，分别是什么？作用是什么？</summary></b>

参考答案：分成：结构层、表示层、行为层。

01. 结构层（structural layer）

由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”

02. 表示层（presentation layer）

由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。

03. 行为层（behaviorlayer）

负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。

[参与互动](https://github.com/yisainan/web-interview/issues/14)

</details>

<b><details><summary>14. 网页验证码是干嘛的，是为了解决什么安全问题？</summary></b>

参考答案：

* 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
* 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试

[参与互动](https://github.com/yisainan/web-interview/issues/15)

</details>

<b><details><summary>15. 为什么用多个域名存储网站资源更有效？</summary></b>

参考答案：

1、CDN 缓存更方便

2、突破浏览器并发限制

3、节约 cookie 带宽

4、节约主域名的连接数，优化页面响应速度

5、防止不必要的安全问题

[参与互动](https://github.com/yisainan/web-interview/issues/16)

</details>

<b><details><summary>16. 页面可见性（Page Visibility）API 可以有哪些用途？</summary></b>

参考答案：

页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是.........，(把浏览器最小化，所有的页面就都不可见了)。

API 很简单，document.hidden 就返回一个布尔值，如果是 true, 表示页面可见，false 则表示，页面隐藏。 不同页面之间来回切换，触发 visibilitychange 事件。 还有一个 document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。

```js
document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
        document.title = "hidden";
    } else {
        document.title = "visibile";
    }
});
```

我们打开这个页面，然后再打开另一个页面，来回点击这两个页面，当我们看到这个页面时，标题显示 visiable , 当我们看另一个页面时，标题显示 hidden; 

动画，视频，音频都可以在页面显示时打开，在页面隐藏时关闭

解析：[参考](https://www.cnblogs.com/king18181753985/p/6510315.html)

[参与互动](https://github.com/yisainan/web-interview/issues/17)

</details>

<b><details><summary>17. Quirks(怪癖）模式是什么？它和 Standards（标准）模式有什么区别</summary></b>

参考答案：

1 以 ie6 为例，如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。

2 区别：总体会有布局、样式解析和脚本执行三个方面的区别。

设置一个元素的宽度和高度

给 `<span>` 等行内元素设置 width 和 height

用 margin:0 auto 设置水平居中

从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。

在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6  支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？

在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数   不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定   如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。

区别：

总体会有布局、样式解析和脚本执行三个方面的区别。

盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks  模式下，IE 的宽度和高度还包含了 padding 和 border。

设置行内元素的高宽：在 Standards 模式下，给 `<span>` 等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。

设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的

用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。

（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）

[参与互动](https://github.com/yisainan/web-interview/issues/18)

</details>

<b><details><summary>18. div+css 的布局较 table 布局有什么优点？</summary></b>

参考答案：分离 方便改版 快清晰简洁 seo

01. 改版的时候更方便 只要改 css 文件。

02. 页面加载速度更快、结构化清晰、页面显示简洁。

03. 表现与结构相分离。

04. 易于优化（seo）搜索引擎更友好，排名更容易靠前。

[参与互动](https://github.com/yisainan/web-interview/issues/19)

</details>

<b><details><summary>19. 你能描述一下渐进增强和优雅降级之间的不同吗?</summary></b>

参考答案：

渐进增强  progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

（一开始保证最基本的功能，再改进和追加功能）

优雅降级  graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

（一开始就构建完整的功能，再针对低版本浏览器进行兼容。）

区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。

[参与互动](https://github.com/yisainan/web-interview/issues/20)

</details>

<b><details><summary>20. 请谈一下你对网页标准和标准制定机构重要性的理解。</summary></b>

参考答案：降低开发难度及开发成本，减少各种 BUG、安全问题， 提高网站易用性

[参与互动](https://github.com/yisainan/web-interview/issues/21)

</details>

<b><details><summary>21. 知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</summary></b>

参考答案：微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。

优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行 google）

[参与互动](https://github.com/yisainan/web-interview/issues/42)

</details>

<b><details><summary>22. html 常见兼容性问题？</summary></b>

参考答案：

01. 双边距 BUG float 引起的，解决办法: 使用 display解决

2.3 像素问题 使用 float 引起的，解决办法: 使用 dislpay:inline -3px

03. 超链接 hover 点击后失效，解决办法: 使用正确的书写顺序 link visited hover active

04. Ie z-index 问题，解决办法: 给父级添加 position:relative

05. Png 透明 ，解决办法: 使用 js 代码

06. Min-height 最小高度 ，解决办法: ！Important 解决

7.select 在 ie6 下遮盖，解决办法: 使用 iframe 嵌套

08. 为什么没有办法定义 1px 左右的宽度容器，解决办法: （IE6 默认的行高造成的，使用 over:hidden, zoom:0.08 line-height:1px）

09. IE5-8 不支持 opacity，解决办法：

```css
.opacity {
    opacity: 0.4;
    filter: alpha(opacity=60);/_ for IE5-7 _/ -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)";/_ for IE 8_/
}
```

10. IE6 不支持 PNG 透明背景，解决办法: IE6 下使用 gif 图片

[参与互动](https://github.com/yisainan/web-interview/issues/43)

</details>

<b><details><summary>23. 对 WEB 标准以及 W3C 的理解与认识</summary></b>

参考答案：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。

[参与互动](https://github.com/yisainan/web-interview/issues/44)

</details>

<b><details><summary>24. 如何在页面上实现一个圆形的可点击区域？</summary></b>

参考答案：css3、js、map 加 area

一.border-radius (css3)

对于圆形，最直接的方法想到的就是 css3 的圆角属性，这个属性可以将 html 元素的形状设置为圆形，这之后你想对该圆形区域设置什么事件就设置什么事件(当然包括点击)。（这里就不做具体的 test 了）

二. 通过事件坐标来实现（js）

也就是通过 js 来进行一个区域判断，进而简介地的形成可点区域，以下给出主要的 js 测试代码：

```js
// 获取目标元素
var box = document.getElementById("box");

// 对目标元素target的圆形区域进行一个点击事件绑定
function bindClickOnCircleArea(target, callback) {
    target.onclick = function(e) {
        e = e || window.event;

        // target中心点的坐标
        var x1 = 100;
        var y1 = 100;

        // 事件源坐标
        var x2 = e.offsetX;
        var y2 = e.offsetY;

        // 校验是否在圆形点击区，在的话就执行callback回调
        // 计算事件触发点与target中心的位置
        var len = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));
        // 通过半径进行校验
        if (len <= 100) {
            callback();
        } else {
            alert("死鬼，跑哪去啊，你老婆我是黄皮肤还是白皮肤都分不清了吗");
        }
    };
}

// 执行
bindClickOnCircleArea(box, function() {
    alert("老婆，你让我好找啊，呜呜呜");
});
```

三. 通过 map 加 area

```html
<img src="../imgs/test.jpg" width="200" border="0" usemap="#Map" />
<map name="Map" id="Map">
    <area shape="circle" coords="100,100,100" href="http://www.baidu.com" target="_blank" />
</map>
```

[参考](https://zhuanlan.zhihu.com/p/48168812)

[参与互动](https://github.com/yisainan/web-interview/issues/45)

</details>

<b><details><summary>25. 前端需要注意哪些 SEO</summary></b>

参考答案：

01. 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可

02. 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页

03. 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取

04. 重要内容不要用 js 输出：爬虫不会执行 js 获取内容

05. 少用 iframe：搜索引擎不会抓取 iframe 中的内容

06. 非装饰性图片必须加 alt

07. 提高网站速度：网站速度是搜索引擎排序的一个重要指标

解析：[参考](https://www.cnblogs.com/passkey/p/10081589.html)

[参与互动](https://github.com/yisainan/web-interview/issues/46)

</details>

<b><details><summary>26.html5 有哪些新特性、移除了那些元素？</summary></b>

参考答案：

新特性：

01. 拖拽释放(Drag and drop) API

02. 语义化更好的内容标签（header,nav,footer,aside,article,section）

03. 音频、视频 API(audio,video)

04. 画布(Canvas) API

05. 地理(Geolocation) API

06. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；

07. sessionStorage 的数据在浏览器关闭后自动删除

08. 表单控件，calendar、date、time、email、url、search

09. 新的技术 webworker, websocket, Geolocation

移除的元素：

01. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；

02. 对可用性产生负面影响的元素：frame，frameset，noframes；

支持 HTML5 新标签：

* IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，
  可以利用这一特性让这些浏览器支持 HTML5 新标签，
  浏览器支持新标签后，还需要添加标签默认的样式：
* 当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架

```html
<!--[if lt IE 9]>
  <script>
    src = "http://html5shim.googlecode.com/svn/trunk/html5.js";
  </script>
<![endif]-->
```

[参与互动](https://github.com/yisainan/web-interview/issues/47)

</details>

<b><details><summary>27. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</summary></b>

参考答案：

在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

使用方法

只要在头部加一个 manifest 属性就 ok 了

```html
<!DOCTYPE html>
<html manifest="cache.manifest">
...

</html>
```

然后 cache.manifest 文件的书写方式如下：

```
CACHE MANIFEST
#v0.11

CACHE:

js/app.js
css/style.css

NETWORK:
resourse/logo.png

FALLBACK:
/ /offline.html
```

解析：

代码说明：

离线存储的 manifest 一般由三个部分组成:

01. CACHE:表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。
02. NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。
03. FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html。

[参考](https://www.cnblogs.com/zhangym118/archive/2016/09/22/5897056.html)

[参与互动](https://github.com/yisainan/web-interview/issues/48)

</details>

<b><details><summary>28. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢</summary></b>

参考答案：在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。

[参与互动](https://github.com/yisainan/web-interview/issues/49)

</details>

<b><details><summary>29. HTML 全局属性(global attribute)有哪些</summary></b>

参考答案：

* accesskey: 设置快捷键，提供快速访问元素如<a href="#" accesskey=“a”>aaa</a>在 windows 下的 firefox 中按 alt + shift + a 可激活元素
* class: 为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素
* contenteditable: 指定元素内容是否可编辑
* contextmenu: 自定义鼠标右键弹出菜单内容
* data-\*: 为元素增加自定义属性
* dir: 设置元素文本方向
* draggable: 设置元素是否可拖拽
* dropzone: 设置元素拖放类型： copy, move, link
* hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
* id: 元素 id，文档内唯一
* lang: 元素内容的的语言
* spellcheck: 是否启动拼写和语法检查
* style: 行内 css 样式
* tabindex: 设置元素可以获得焦点，通过 tab 可以导航
* title: 元素相关的建议信息
* translate: 元素和子孙节点内容是否需要本地化

解析：[参考](https://funteas.com/topic/5906a8bc8783c1370b809c2a)

[参与互动](https://github.com/yisainan/web-interview/issues/50)

</details>

<b><details><summary>30. Canvas 和 SVG 有什么区别？</summary></b>

参考答案：Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。

## Canvas

描述：

通过 Javascript 来绘制 2D 图形。
是逐像素进行渲染的。
其位置发生改变，会重新进行绘制。

## SVG

描述：

一种使用 XML 描述的 2D 图形的语言
SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。
在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

## 比较

Canvas

* 依赖分辨率
* 不支持事件处理器
* 弱的文本渲染能力
* 能够以 .png 或 .jpg 格式保存结果图像
* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

SVG

* 不依赖分辨率
* 支持事件处理器
* 最适合带有大型渲染区域的应用程序（比如谷歌地图）
* 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
* 不适合游戏应用

解析：[参考](http://www.w3school.com.cn/html5/html_5_canvas_vs_svg.asp)

[参与互动](https://github.com/yisainan/web-interview/issues/51)

</details>

<b><details><summary>31. HTML5 为什么只需要写 `<! DOCTYPE HTML>` ？</summary></b>

参考答案：HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML 是标准通用标记语言, 简单的说，就是比 HTML, XML 更老的标准，这两者都是由 SGML 发展而来的。BUT，HTML5 不是的。

`<! DOCTYPE>` 声明位于位于 HTML 文档中的第一行，处于 `<html>` 标签之前。作用：告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以怪异模式呈现。

[参与互动](https://github.com/yisainan/web-interview/issues/52)

</details>

<b><details><summary>32.meta viewport 原理是什么？</summary></b>

参考答案：

meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放

viewport的原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户；

解析：

Viewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。

在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。
举个例子：如果我们的屏幕是 320 像素 \* 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。

为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。

### Viewport 属性值

* width 设置 layout viewport 的宽度，为一个正整数，或字符串"width-device"
* initial-scale 设置页面的初始缩放值，为一个数字，可以带小数
* minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数
* maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数
* height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用
* user-scalable 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。

[参与互动](https://github.com/yisainan/web-interview/issues/53)

</details>

<b><details><summary>33. 对 web 标准、可用性、可访问性的理解</summary></b>

参考答案：

可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。

可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性

可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。

[参与互动](https://github.com/yisainan/web-interview/issues/54)

</details>

<b><details><summary>34. HTML5 引入什么新的表单属性？</summary></b>

参考答案：Datalist datetime output keygen date month week time number range emailurl

[参与互动](https://github.com/yisainan/web-interview/issues/55)

</details>

<b><details><summary>35. 新的 HTML5 文档类型和字符集是？</summary></b>

参考答案：

```
HTML5文档类型：<!doctype html>
HTML5使用的编码<meta charset=”UTF-8”>
```

[参与互动](https://github.com/yisainan/web-interview/issues/56)

</details>

<b><details><summary>36. HTML5 Canvas 元素有什么用？</summary></b>

参考答案：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。

[参与互动](https://github.com/yisainan/web-interview/issues/57)

</details>

<b><details><summary>37. HTML5 存储类型有什么区别？</summary></b>

参考答案：Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API

[参与互动](https://github.com/yisainan/web-interview/issues/58)

</details>

<b><details><summary>38.iframe 的作用</summary></b>

参考答案：iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载。

优点

01. 便于修改，模拟分离，像一些信息管理系统会用到。
02. 但现在基本不推荐使用。除非特殊需要，一般不推荐使用。

缺点

01. iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级
02. iframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。
03. iframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。

[参与互动](https://github.com/yisainan/web-interview/issues/59)

</details>

<b><details><summary>39. 为什么最好把 CSS 的 `<link>` 标签放在 `<head></head>` 之间？为什么最好把 JS 的 `<script>` 标签恰好放在 `</body>` 之前，有例外情况吗？</summary></b>

参考答案：

**把 `<link>` 放在 `<head>` 中**

把 `<link>` 标签放在 `<head></head>` 之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。

**把 `<script>` 标签恰好放在 `</body>` 之前**

脚本在下载和执行期间会阻止 HTML 解析。把 `<script>` 标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。

例外情况是当你的脚本里包含 `document.write()` 时。但是现在， `document.write()` 不推荐使用。同时，将 `<script>` 标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是， `<script>` 使用 `defer` 属性，放在 `<head>` 中。

[参与互动](https://github.com/yisainan/web-interview/issues/60)

</details>

<b><details><summary>40. 什么是渐进式渲染（progressive rendering）？</summary></b>

参考答案：渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。

在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。

一些举例：

* 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。
* 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听`DOMContentLoaded`/`load`事件加载其他资源和内容。
* 异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。

解析：更多相关细节可以在[这里](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/)找到。

[参与互动](https://github.com/yisainan/web-interview/issues/61)

</details>

<b><details><summary>41. DOM 和 BOM 有什么区别</summary></b>

参考答案：

* DOM

Document Object Model，文档对象模型

DOM 是为了操作文档出现的 API，document 是其的一个对象

DOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容。

* BOM

Browser Object Model，浏览器对象模型

BOM 是为了操作浏览器出现的 API，window 是其的一个对象

window 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象

</details>

<b><details><summary>42.img 上 title 与 alt</summary></b>

参考答案：title 指图片的信息、alt 指图片不显示时显示的文字

</details>

<b><details><summary>43. 一个iframe，内嵌了一个A页面，iframe的宽高不停变化，如何让A页面的宽高实时自适应这个iframe的宽高大小。请说出至少3种方法，越难越好</summary></b>

参考答案：

01. css的方案
02. onresize
03. 监听鼠标动作，鼠标释放后重新定宽

</details>

<b><details><summary>44. DOM Tree是如何构建的？</summary></b>

参考答案：

01. HTML 解释器

HTML 解释器的工作就是将网络或者本地磁盘获取的 HTML 网页和资源从字节流解释成 DOM 树结构。

02. JavaScript 的执行

在 HTML 解释器的工作过程中，可能会有 JavaScript 代码需要执行，它发生在将字符串解释成词语之后、创建各种节点的时候。这也是为什么全局执行的 JavaScript 代码不能访问 DOM 的原因——因为 DOM 树还没有被创建完呢。

</details>

<b><details><summary>45.100*100的 canvas 占多少内存？</summary></b>

参考答案：[参考](https://www.jianshu.com/p/27dd0e802809)

</details>

<b><details><summary>46. `<noscript>` 标签的作用</summary></b>

参考答案：noscript 元素用来定义在脚本未被执行时的替代内容（文本）。

此标签可被用于可识别 `<script>` 标签但无法支持其中的脚本的浏览器。

</details>

<b><details><summary>47. DOCTYPE 的作用是什么？</summary></b>

参考答案：

   
   相关知识点：
   ```
   IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。

   <!DOCTYPE>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。

   DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。
   ```

   回答（参考1-5）：
   ```
   <!DOCTYPE>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来
   进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏
   览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。

   在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文
   档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。
   ```
  </details>

<b><details><summary>48. 标准模式与兼容模式各有什么区别？</summary></b>

参考答案：

   ``` 
   标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示
   ，模拟老式浏览器的行为以防止站点无法工作。
   ```
</details>

<b><details><summary>49. HTML5 为什么只需要写 `<!DOCTYPE HTML>`，而不需要引入 DTD？</summary></b>

参考答案：

   ```
   HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运
   行）。
   
   而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。
   ```
</details>

<b><details><summary>50. SGML 、 HTML 、XML 和 XHTML 的区别？</summary></b>

参考答案：

   ```
   SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。
   
   HTML 是超文本标记语言，主要是用于规定怎么显示网页。
   
   XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，
   而 HTML 的标签都是固定的而且数量有限。
   
   XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 
   更严格，比如标签必须都用小写，标签都必须有闭合标签等。
   ```
</details>

<b><details><summary>51. DTD 介绍</summary></b>

参考答案：

   ```
   DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元
   素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。
   
   DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。
   ```
</details>

<b><details><summary>52. 行内元素定义</summary></b>

参考答案：

   ```
   HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空
   间。
   
   常见的行内元素有 a b span img strong sub sup button input label select textarea
   ```
   
</details>

<b><details><summary>53. 块级元素定义</summary></b>

参考答案：

   ```
   块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。

   常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p 
   ```

</details>

<b><details><summary>54. 行内元素与块级元素的区别？</summary></b>

参考答案：

   ```
   HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。
   
   （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。
   （2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
   （3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei
        ght），设置 margin 和 padding 的上下不会对其他元素产生影响。
   ```
</details>

<b><details><summary>55. HTML5 元素的分类</summary></b>

参考答案：

   ```
   HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前
   端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为
   inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为
   inline 与 block 已经不再符合实际需求。

   HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive
   ```
</details>

<b><details><summary>56. 空元素定义</summary></b>

参考答案：

   ```
   标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。

   常见的空元素有：br hr img input link meta
   ```
</details>

<b><details><summary>57. link 标签定义</summary></b>

参考答案：

   ```
   link 标签定义文档与外部资源的关系。

   link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。

   link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。
   ```
</details>

<b><details><summary>58. 页面导入样式时，使用 link 和 @import 有什么区别？</summary></b>

参考答案：

   ```
   （1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加
        载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。

   （2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。

   （3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容
        性问题。

   （4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i
       mport 的方式插入样式。
   ```
</details>


<b><details><summary>59. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</summary></b>

参考答案：

   ```
    （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执
        行。

    （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。
        当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。

    （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执
        行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。
   ```
   详细资料可以参考：
   [《defer 和 async 的区别》](https://segmentfault.com/q/1010000000640869)
</details>

<b><details><summary>60. 什么是文档的预解析？（浏览器解析过程）</summary></b>

参考答案：

   ```
    Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加
    载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析
    过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。
   ```
</details>

<b><details><summary>61. CSS 如何阻塞文档解析？（浏览器解析过程） </summary></b>

参考答案：

   ```
    理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可
    能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。

    所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档
    的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，
    最后再继续文档的解析。
   ```
</details>

<b><details><summary>62. 渲染页面时常见哪些不良现象？（浏览器渲染过程）</summary></b>

参考答案：

   ```
    FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示
          出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底
          部。

    白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 
         尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面
         文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。
   ```
   详细资料可以参考：
    [《前端魔法堂：解秘 FOUC》](https://juejin.im/entry/58f867045c497d0058e2ff3a)
    [《白屏问题和 FOUC》](https://www.jianshu.com/p/6617efa874b0)
</details>

<b><details><summary>63. 如何优化关键渲染路径？（浏览器渲染过程）</summary></b>

参考答案：

   ```
    为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

    （1）关键资源的数量。
    （2）关键路径长度。
    （3）关键字节的数量。

    关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

    同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，
    并且资源越大，下载所需的往返次数就越多。

    最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它
    们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

    优化关键渲染路径的常规步骤如下：

    （1）对关键路径进行分析和特性描述：资源数、字节数、长度。
    （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
    （3）优化关键字节数以缩短下载时间（往返次数）。
    （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。
   ```
   详细资料可以参考：
   [《优化关键渲染路径》](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn)
</details>

<b><details><summary>64. 什么是重绘和回流？（浏览器绘制过程）</summary></b>

参考答案：

  
   ```
    重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。
    
    回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。

    常见引起回流属性和方法：

    任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。

    （1）添加或者删除可见的 DOM 元素；
    （2）元素尺寸改变——边距、填充、边框、宽度和高度
    （3）内容变化，比如用户在 input 框中输入文字
    （4）浏览器窗口尺寸改变——resize事件发生时
    （5）计算 offsetWidth 和 offsetHeight 属性
    （6）设置 style 属性的值
    （7）当你修改网页的默认字体时。

    回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

   ```
   常见引起重绘属性和方法：

   ![常见引起回流属性和方法](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png)

   常见引起回流属性和方法：

   ![常见引起重绘属性和方法](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png)

   详细资料可以参考：
   [《浏览器的回流与重绘》](https://juejin.im/post/5a9923e9518825558251c96a)
</details>

<b><details><summary>65. 如何减少回流？（浏览器绘制过程）</summary></b>

参考答案：

   ```
    （1）使用 transform 替代 top

    （2）不要把节点的属性值放在一个循环里当成循环里的变量

    （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

    （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM

    （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
   ```
</details>

<b><details><summary>66. 为什么操作 DOM 慢？（浏览器绘制过程）</summary></b>

参考答案：

   ```
    一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。
   ```
</details>

<b><details><summary>67. DOMContentLoaded 事件和 Load 事件的区别？</summary></b>

参考答案：

   ```
    当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和
    子框架的加载完成。

    Load 事件是当所有资源加载完成后触发的。
   ```
   详细资料可以参考：
   [《DOMContentLoaded 事件 和 Load 事件的区别？》](https://www.jianshu.com/p/ca8dae435a2c)

</details>

<b><details><summary>68. HTML5 有哪些新特性、移除了那些元素？</summary></b>

参考答案：

   ```
    HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

    新增的有：
     
    绘画 canvas;
    用于媒介回放的 video 和 audio 元素;
    本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
    sessionStorage 的数据在浏览器关闭后自动删除;
    语意化更好的内容元素，比如 article、footer、header、nav、section;
    表单控件，calendar、date、time、email、url、search;
    新的技术 webworker, websocket;
    新的文档属性 document.visibilityState

    移除的元素有：

    纯表现的元素：basefont，big，center，font, s，strike，tt，u;
    对可用性产生负面影响的元素：frame，frameset，noframes；
   ```
</details>

<b><details><summary>69. 如何处理 HTML5 新标签的浏览器兼容问题？</summary></b>

参考答案：

   ```html
    （1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器
        支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。

    （2） 当然也可以直接使用成熟的框架，比如 html5shiv ;
         `<!--[if lt IE 9]>
         <script> src="https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js"</script>
         <![endif]-->`

         [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。
   ```
</details>

<b><details><summary>70. 简述一下你对 HTML 语义化的理解？</summary></b>

参考答案：

    
   相关知识点：
   ```
    （1） 用正确的标签做正确的事情。
    （2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
    （3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;
    （4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;
    （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
   ```

   回答：
   ```
    我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，
    一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进
    行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。
    对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的
    话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会
    依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，
    从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、fo
    oter 这些语义标签，删除了 big 、font 这些没有语义的标签。
   ```
   详细资料可以参考：
   [《语义化的 HTML 结构到底有什么好处？》](https://www.html.cn/archives/1668)
   [《如何理解 Web 语义化？》](https://www.zhihu.com/question/20455165)
   [《我的 HTML 会说话——从实用出发，谈谈 HTML 的语义化》](https://juejin.im/post/5a9c8866f265da23741072bf#heading-5)
</details>

<b><details><summary>71. b 与 strong 的区别和 i 与 em 的区别？</summary></b>

参考答案：

   ```
    从页面显示效果来看，被 <b> 和 <strong> 包围的文字将会被加粗，而被 <i> 和 <em> 包围的文字将以斜体的形式呈现。

    但是 <b> <i> 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder}，仅仅表示「这
    里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。

    而 <em> 和 <strong> 是语义样式标签。 <em> 表示一般的强调文本，而 <strong> 表示比 <em> 语义更强的强调文本。
    
    使用阅读设备阅读网页时：<strong> 会重读，而 <b> 是展示强调内容。
   ``` 
    
   详细资料可以参考：
   [《HTML5 中的 b/strong，i/em 有什么区别？》](https://www.zhihu.com/question/19551271)

</details>

<b><details><summary>72. 前端需要注意哪些 SEO ？</summary></b>

参考答案：

   ```
    （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超
        过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不
        同页面 description 有所不同；keywords 列举出重要关键词即可。

    （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。

    （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被
        抓取。
 
    （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容

    （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容

    （6）非装饰性图片必须加 alt

    （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标
   ```
</details>

<b><details><summary>73. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</summary></b>

参考答案：

   ```
    在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

    原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资
         源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面
         展示。

    如何使用：

    （1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。

        <html lang="en" manifest="index.manifest">

    （2）在如下 cache.manifest 文件的编写离线存储的资源。
      	CACHE MANIFEST
      	#v0.11
      	CACHE:
      	js/app.js
      	css/style.css
      	NETWORK:
      	resourse/logo.png
      	FALLBACK:
      	/ /offline.html

        CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出
               来。

        NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些
                 资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C
                 ACHE 的优先级更高。

        FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下
                  任何一个资源失败了，那么就去访问 offline.html 。

    （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。


    如何更新缓存：

    （1）更新 manifest 文件
    （2）通过 javascript 操作
    （3）清除浏览器缓存

    注意事项：

    （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。
    （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。
    （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。
    （4）FALLBACK 中的资源必须和 manifest 文件同源。
    （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。
    （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。
    （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。

   ```

   详细的使用可以参考：
   [《HTML5 离线缓存-manifest 简介》](https://yanhaijing.com/html/2014/12/28/html5-manifest/)
   [《有趣的 HTML5：离线存储》](https://segmentfault.com/a/1190000000732617)

</details>

<b><details><summary>74. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</summary></b>

参考答案：

   ```
    在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器
    就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器
    就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做
    任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

    离线的情况下，浏览器就直接使用离线存储的资源。
   ```
</details>

<b><details><summary>75. 常见的浏览器端的存储技术有哪些？</summary></b>

参考答案：

   ```
    浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。

    还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。

    IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。
   ```
   详细的资料可以参考：
   [《很全很全的前端本地存储讲解》](https://segmentfault.com/a/1190000012578794#articleHeader0)
</details>

<b><details><summary>76. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</summary></b>

参考答案：


   相关资料：
   ```
    SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别
    在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户
    本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会
    在浏览器和服务器间来回传递。
    
    
    存储大小：
      	cookie 数据大小不能超过4 k 。
      	sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。

    有期时间：
      	localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
      	sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会
                        保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
      	cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
     
    作用域：
        sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
        localStorage    在所有同源窗口中都是共享的。
        cookie          在所有同源窗口中都是共享的。
   ```

   回答：
   ```
    浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。

    cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服
    务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。

    sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保
    存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源
    页面所访问共享。

    localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 
    不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

    上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏
    览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。
   ```

   详细的资料可以参考：
   [《请描述一下 cookies，sessionStorage 和 localStorage 的区别？》](https://segmentfault.com/a/1190000017423117)
   [《浏览器数据库 IndexedDB 入门教程》](http://www.ruanyifeng.com/blog/2018/07/indexeddb.html)
</details>

<b><details><summary>77. iframe 有那些缺点？</summary></b>

参考答案：

   ```
    iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

    主要缺点有：

    （1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才
         会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。
    （2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。
    （3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
    （4） 浏览器的后退按钮失效。
    （5） 小型的移动设备无法完全显示框架。
   ```
   详细的资料可以参考：
   [《使用 iframe 的优缺点》](https://blog.csdn.net/yintianqin/article/details/72625785)
   [《iframe 简单探索以及 iframe 跨域处理》](https://segmentfault.com/a/1190000009891683)
</details>

<b><details><summary>78. Label 的作用是什么？是怎么用的？</summary></b>

参考答案：

   ```
    label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

    <label for="Name">Number:</label>
    <input type=“text“ name="Name" id="Name"/>
   ```
</details>

<b><details><summary>79. HTML5 的 form 的自动完成功能是什么？</summary></b>

参考答案：

   ```
    autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。

    自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。

    autocomplete 属性适用于 <form>，以及下面的 <input> 类型：text, search, url, telephone, email, password, 
    datepickers, range 以及 color。
   ```
</details>

<b><details><summary>80. 如何实现浏览器内多个标签页之间的通信? </summary></b>

参考答案：


   相关资料：
   ```
    （1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。

    （2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标
        签页之间的双向通行。

    （3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触
        发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；

    （4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。
   ```
    
   回答：
   ```
    实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，
    让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

    第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。
    标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。

    第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使
    用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交
    换。

    第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页
    修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。

    还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。
   ```
   详细的资料可以参考：

   [《WebSocket 教程》](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
   [《WebSocket 协议：5分钟从入门到精通》](https://www.cnblogs.com/chyingp/p/websocket-deep-in.html)
   [《WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室》](https://segmentfault.com/a/1190000011538416)
   [《使用 Web Storage API》](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API)
   [《JavaScript 的多线程，Worker 和 SharedWorker》](https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5)
   [《实现多个标签页之间通信的几种方法》](https://juejin.im/post/5acdba01f265da23826e5633#heading-1)
  
</details>

<b><details><summary>81. webSocket 如何兼容低版本浏览器？</summary></b>

参考答案：

   ```
    Adobe Flash Socket 、
    ActiveX HTMLFile (IE) 、
    基于 multipart 编码发送 XHR 、
    基于长轮询的 XHR
   ```
</details>

<b><details><summary>82. 页面可见性（Page Visibility API） 可以有哪些用途？</summary></b>

参考答案：

   ```
    这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户
    不看网页，下面这些网页行为都是可以暂停的。

    （1）对服务器的轮询
    （2）网页动画
    （3）正在播放的音频或视频
   ```

   详细资料可以参考：
   [《Page Visibility API 教程》](http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html)
</details>

<b><details><summary>83. 如何在页面上实现一个圆形的可点击区域？</summary></b>

参考答案：

   ```
    （1）纯 html 实现，使用 <area> 来给 <img> 图像标记热点区域的方式，<map> 标签用来定义一个客户端图像映射，<area> 
        标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击
        的圆形区域。

    （2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的
        点击区域。

    （3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我
        们规定的圆形区域内。
   ```
   详细资料可以参考：
   [《如何在页面上实现一个圆形的可点击区域？》](https://maizi93.github.io/2017/08/29/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%EF%BC%9F/)
   [《HTML <area><map> 标签及在实际开发中的应用》](https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/)

</details>

<b><details><summary>84. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效</summary></b>

参考答案：
果。
    
   ```html
     <div style="height:1px;overflow:hidden;background:red"></div>
   ```
</details>

<b><details><summary>85. title 与 h1 的区别？</summary></b>

参考答案：

   ```
    title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。
   ```
</details>

<b><details><summary>86. `<img>` 的 title 和 alt 有什么区别？</summary></b>

参考答案：

   ```
    title 通常当鼠标滑动到元素上的时候显示

    alt 是 <img> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装
    饰图片外都必须设置有意义的值，搜索引擎会重点分析。
   ```
</details>

<b><details><summary>87. Canvas 和 SVG 有什么区别？</summary></b>

参考答案：

   ```
    Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，
    会出现锯齿或者失真的情况。
    
    SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素
    附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。
   ```
   详细资料可以参考：
   [《SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？》](https://www.zhihu.com/question/19690014)
</details>

<b><details><summary>88. 网页验证码是干嘛的，是为了解决什么安全问题？</summary></b>

参考答案：

   ```
    （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
    （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试
   ```  
</details>

<b><details><summary>89. 渐进增强和优雅降级的定义</summary></b>

参考答案：

   ```
    渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的
            用户体验。

    优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。
   ```
   </details>

<b><details><summary>90. attribute 和 property 的区别是什么？</summary></b>

参考答案：

   ```
    attribute 是 dom 元素在文档中作为 html 标签拥有的属性；
    property 就是 dom 元素在 js 中作为对象拥有的属性。
    对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，
    但是对于自定义的属性来说，他们是不同步的。
   ```
</details>

<b><details><summary>91. 对 web 标准、可用性、可访问性的理解</summary></b>

参考答案：

   ```
    可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看
    产品的质量。可用性好意味着产品质量高，是企业的核心竞争力

    可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性
    
    可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。
    二是代码是否容易被人理解，是否容易修改和增强功能。
   ```
</details>

<b><details><summary>92. IE 各版本和 Chrome 可以并行下载多少个资源？</summary></b>

参考答案：

   ```
    （1）  IE6 2 个并发
    （2）  iE7 升级之后的 6 个并发，之后版本也是 6 个
    （3）  Firefox，chrome 也是6个
   ```
</details>

<b><details><summary>93. Flash、Ajax 各自的优缺点，在使用中如何取舍？</summary></b>

参考答案：

   ```
    Flash：
    （1） Flash 适合处理多媒体、矢量图形、访问机器
    （2） 对 CSS、处理文本上不足，不容易被搜索

    Ajax：
    （1） Ajax 对 CSS、文本支持很好，支持搜索
    （2） 多媒体、矢量图形、机器访问不足

    共同点：
    （1） 与服务器的无刷新传递消息
    （2） 可以检测用户离线和在线状态
    （3） 操作 DOM
   ```
</details>

<b><details><summary>94. 怎么重构页面？</summary></b>

参考答案：

   ```
    （1） 编写 CSS
    （2） 让页面结构更合理化，提升用户体验
    （3） 实现良好的页面效果和提升性能
   ```
</details>

<b><details><summary>95. 浏览器架构</summary></b>

参考答案：

   ```
    * 用户界面
      * 主进程
      * 内核
          * 渲染引擎
          * JS 引擎
              * 执行栈
          * 事件触发线程
              * 消息队列
                  * 微任务
                  * 宏任务
          * 网络异步线程
          * 定时器线程
   ```
</details>

<b><details><summary>96. 常用的 meta 标签</summary></b>

参考答案：

   ```
    <meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。
    <meta> 标签位于文档的头部，不包含任何内容。<meta> 标签的属性定义了与文档相关联的名称/值对。

    <!DOCTYPE html>  H5标准声明，使用 HTML5 doctype，不区分大小写
    <head lang="en"> 标准的 lang 属性写法
    <meta charset="utf-8">    声明文档使用的字符编码
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>   优先使用 IE 最新版本和 Chrome
    <meta name="description" content="不超过150个字符"/>       页面描述
    <meta name="keywords" content=""/>      页面关键词者
    <meta name="author" content="name, email@gmail.com"/>    网页作
    <meta name="robots" content="index,follow"/>      搜索引擎抓取
    <meta name="viewport" content="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"> 为移动设备添加 viewport
    <meta name="apple-mobile-web-app-title" content="标题"> iOS 设备 begin
    <meta name="apple-mobile-web-app-capable" content="yes"/>  添加到主屏后的标题（iOS 6 新增）
    是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏
    <meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">
    添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）
    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
    <meta name="format-detection" content="telphone=no, email=no"/>  设置苹果工具栏颜色
    <meta name="renderer" content="webkit">  启用360浏览器的极速模式(webkit)
    <meta http-equiv="X-UA-Compatible" content="IE=edge">     避免IE使用兼容模式
    <meta http-equiv="Cache-Control" content="no-siteapp" />    不让百度转码
    <meta name="HandheldFriendly" content="true">     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓
    <meta name="MobileOptimized" content="320">   微软的老式浏览器
    <meta name="screen-orientation" content="portrait">   uc强制竖屏
    <meta name="x5-orientation" content="portrait">    QQ强制竖屏
    <meta name="full-screen" content="yes">              UC强制全屏
    <meta name="x5-fullscreen" content="true">       QQ强制全屏
    <meta name="browsermode" content="application">   UC应用模式
    <meta name="x5-page-mode" content="app">    QQ应用模式
    <meta name="msapplication-tap-highlight" content="no">    windows phone 点击无高光
    设置页面不缓存
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="expires" content="0">
   ```
   详细资料可以参考：
   [《Meta 标签用法大全》](http://www.cnblogs.com/qiumohanyu/p/5431859.html)
</details>

<b><details><summary>97. css reset 和 normalize.css 有什么区别？</summary></b>

参考答案：

    
   相关知识点：
   ```
    为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多
    兼容性问题。

    reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。

    normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。


    1.Normalize.css 保护了有价值的默认值

    Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏
    览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali
    ze.css 会力求让这些样式保持一致并尽可能与现代标准相符合。


    2.Normalize.css 修复了浏览器的 bug

    它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题
    包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中
    的与表单相关的 bug。


    3.Normalize.css 没有复杂的继承链

    使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在
    我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。


    4.Normalize.css 是模块化的

    这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己
    选择性地移除掉某些永远不会用到部分（比如表单的一般化）。


    5.Normalize.css 拥有详细的文档

    Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的
    说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己
    的测试。

   ```

   回答：
   ```
    css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器
    样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成
    画蛇添足的效果。

    后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原
    有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默
    认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。

   ```
   详细资料可以参考：
   [《关于CSS Reset 那些事（一）之 历史演变与 Normalize.css》](https://segmentfault.com/a/1190000003021766#articleHeader0)
   [《Normalize.css 和 Reset CSS 有什么本质区别没？》](https://segmentfault.com/q/1010000000117189)
</details>

<b><details><summary>98. 用于预格式化文本的标签是？</summary></b>

参考答案：

   ```
    预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。

    <pre> 定义预格式文本，保持文本原有的格式
   ```
</details>

<b><details><summary>99. DHTML 是什么？</summary></b>

参考答案：

   ```
    DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能
    够动态地改变 HTML 元素的样式。

    DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功
    能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链
    接目录等。

    包括：
    （1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。

    （2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、
        文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样
        式”即可以“动态”地改变排版样式。
   ```
</details>

<b><details><summary>100. head 标签中必不少的是？</summary></b>

参考答案：

   ```
    <head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供
    元信息等等。

    文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数
    据都不会真正作为内容显示给读者。

    下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, 以及 <title>。

    <title> 定义文档的标题，它是 head 部分中唯一必需的元素。
   ``` 
</details>

<b><details><summary>101. HTML5 新增的表单元素有？</summary></b>

参考答案：

   ```
    datalist 规定输入域的选项列表，通过 option 创建！ 
    
    keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！
    
    output 元素用于不同类型的输出！
   ```
</details>

<b><details><summary>102. 在 HTML5 中，哪个方法用于获得用户的当前位置？</summary></b>

参考答案：

   ```
    getCurrentPosition()
   ```
</details>

<b><details><summary>103. 文档的不同注释方式？</summary></b>

参考答案：

   ```
    HTML 的注释方法 <!--注释内容--> 
    
    CSS 的��释方法 /*注释内容*/ 
    
    JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式
   ```
</details>

<b><details><summary>104. disabled 和 readonly 的区别？</summary></b>

参考答案：

   ```
    disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。
     
    readonly 规定输入字段为只读。input 内容会随着表单提交。

    无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value
   ```  
</details>

<b><details><summary>105. 主流浏览器内核私有属性 css 前缀？</summary></b>

参考答案：

   ```
    mozilla 内核 （firefox,flock 等）    -moz
    webkit  内核 （safari,chrome 等）   -webkit
    opera   内核 （opera 浏览器）        -o
    trident 内核 （ie 浏览器）           -ms
   ```
</details>

<b><details><summary>106. 前端性能优化？</summary></b>

参考答案：

   ```
    前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

    第一个方面是页面的内容方面

    （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。

    （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。

    （3）通过设置缓存策略，对常用不变的资源进行缓存。

    （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。

    （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

    第二个方面是服务器方面

    （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。

    （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。

    （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

    第三个方面是 CSS 和 JavaScript 方面

    （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。

    （2）避免使用 @import 标签。

    （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。

    （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。
   ```
   详细的资料可以参考：
   [《前端性能优化之雅虎35条军规》](https://juejin.im/post/5b73ef38f265da281e048e51#heading-10)
   [《你真的了解 gzip 吗？》](https://juejin.im/entry/58709b9a128fe1006b29cd5d)
   [《前端性能优化之 gzip》](https://segmentfault.com/a/1190000012571492)

</details>

<b><details><summary>107. Chrome 中的 Waterfall ？</summary></b>

参考答案：

   详细资料可以参考：
   [《前端性能之 Chrome 的 Waterfall》](https://blog.csdn.net/carian_violet/article/details/84954360)
   [《教你读懂网络请求的瀑布图》](https://blog.csdn.net/csdn_girl/article/details/54911632)    [《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》](https://www.zhihu.com/question/27085552/answer/35194131)

</details>

<b><details><summary>108. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</summary></b>

参考答案：

   ```
    核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 serv
    er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备
    上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。

    我的理解

    二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 
    的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只
    有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据
    先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，
    服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够
    很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成
    有效的安全防护。
   ```
   详细资料可以参考：
   [《微信扫描二维码登录网页》](https://www.zhihu.com/question/20368066)
</details>

<b><details><summary>109. Html 规范中为什么要求引用资源不加协议头`http`或者`https`？</summary></b>

参考答案：

   ```
    如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现
    警告信息，不同浏览器警告信息展现形式不同。

    为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为
     protocol-relative URL，暂且可译作协议相对 URL。

    如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似
    的警告信息，同时还可以节省5字节的数据量。
   ```
   详细资料可以参考：
   [《协议相对 URL》](https://www.ludou.org/the-protocol-relative-url.html)
   [《Why you need protocol-relative URLs *now*》](https://www.tuicool.com/articles/nEjU7b)

</details>

<b><details><summary>110. Data URI scheme 是什么 ？</summary></b>

参考答案：

Data URI scheme 是在 RFC2397 中定义的，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。减少对 HTTP 的请求次数。达到优化网页的效果。

base64 后面那一串字符，其实是一张图片，将这些字符串复制粘贴到浏览器的中打开，就能看到图片了

假设你有的图像：A.jpg ，把它在网页上显示出来的标准方法是：
```html
<img src="http://sjolzy.cn/images/A.jpg"/>
```
这种取得数据的方法称为 http URI scheme 。
```html
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAAGElEQVQIW2P4DwcMDAxAfBvMAhEQMYgcACEHG8ELxtbPAAAAAElFTkSuQmCC" />
```
这种取得数据的方法称为 Data URI scheme 。

</details>

<b><details><summary>111. Data URI scheme 的语法</summary></b>

参考答案：

在上面的 Data URI scheme 中：

data 表示取得数据的协定名称；

image/png 是数据类型名称；

base64 是数据的编码方法，逗号后面就是这个image/png文件base64编码后的数据。

目前，Data URI scheme支持的类型有：
```
data: 文本数据
data: text/plain, ------- 文本数据
data: text/html, -------- HTML代码
data: text/html;base64, -------- base64编码的HTML代码
data: text/css, ---------- CSS代码
data: text/css;base64, ---------- base64编码的CSS代码
data: text/javascript, ------------ Javascript代码
data: text/javascript;base64, --------- base64编码的Javascript代码
data: image/gif;base64, ---------------- base64编码的gif图片数据
data: image/png;base64, -------------- base64编码的png图片数据
data: image/jpeg;base64, ------------- base64编码的jpeg图片数据
data: image/x-icon;base64, ---------- base64编码的icon图片数据
```

① 在 HTML 中使用 data URL （不建议这样使用）
```html
<img src="data:image/png;base64,image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAAGElEQVQIW2P4DwcMDAxAfBvMAhEQMYgcACEHG8ELxtbPAAAAAElFTkSuQmCC"/>
```
② 在 CSS 中使用 data URL
```css
body { 
   background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAAGElEQVQIW2P4DwcMDAxAfBvMAhEQMYgcACEHG8ELxtbPAAAAAElFTkSuQmCC")
};
```
③ 在 script 中使用 data URL
```js
   _captchaImage() {
		captchaImage().then(res => {  //请求接口
			if (res.code == 200) {
				this.codeUrl = 'data:image/gif;base64,' + res.img; // 拼接请求回来的数据
				this.formModel.uuid = res.uuid;
		   }
	   });
	}
```	

</details>

<b><details><summary>112. Data URI scheme 的优缺点</summary></b>

参考答案：

优点：

```
减少HTTP请求数，没有了TCP连接消耗和同一域名下浏览器的并发数限制。对于小文件会降低带宽。虽然编码后数据量会增加，但是却减少了http头，当http头的数据量大于文件编码的增量，那么就会降低带宽。 对于HTTPS站点，HTTPS和HTTP混用会有安全提示，而HTTPS相对于HTTP来讲开销要大更多，所以Data URI在这方面的优势更明显。可以把整个多媒体页面保存为一个文件。
```

缺点：

```
1.无法被重复利用，同一个文档多次被应用到同一内容中，数据被大量增加，消耗了下载时间。
2.无法被独自缓存，其包含文档重新加载时，它也要重新加载。
3.耗时，客户端需要重新解码和显示，增加消耗。
4.不支持数据压缩，base64编码会增加1/3大小，而urlencode后数据量会增加更多
5.不安全，不利于安全软件的过滤，同时也存在一定的安全隐患。
```

解析：[参考](https://blog.csdn.net/weixin_50339217/article/details/113387229?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.searchformbaiduhighlight&spm=1001.2101.3001.4242)

</details>

<b><details><summary>113. 你有使用过MediaRecorder吗？说说它的运用场景有哪些？</summary></b>

参考答案：录屏

</details>

<b><details><summary>114.H5的哪些特性需要https支持呢？</summary></b>

参考答案：service workers

```
service worker 是什么？

一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker那么它可以拦截当前网站所有的请求，并且可以让开发者自己控制管理缓存的内容以及版本
```

</details>

<b><details><summary>115.你知道短链接的生成原理吗？</summary></b>

参考答案：

```
目的将长度较长的链接压缩成较短的链接，并通过跳转的方式，将用户请求由短链接重定向到长链接上去

1.二种方式生成短链

    hash-可能会重复
    发号器发号压缩 URL

2.短链跳转方式

    301 - 用户第一次访问某个短链接后，如果服务器返回301状态码，则这个用户在后续多次访问统一短链接，浏览器会直接请求跳转地址，而不是短链接地址，这样一来服务器端就无法收到用户的请求
    缺点：有缓存情况下直接跳转原地址，无法记录准确的访问

    302-浏览器不缓存短链接请求，那么用户每次访问短链接，都会先去短链接服务端取回长链接地址，然后在跳转。
    缺点：服务器压力大
```

</details>

<b><details><summary>116.HTML5拖拽事件的顺序是什么？</summary></b>

参考答案：

```
ondragstart ：源对象开始被拖动
ondrag：源对象被拖动过程中
ondragend：源对象被拖动结束

ondragenter：源对象拖动着进入目标对象
ondragover：源对象拖动着悬停在目标对方上方
ondragleave：源对象拖动着离开了目标对象
ondrop：源对象拖动着目标对象上方释放
```

</details>

<b><details><summary>117. 为什么我们要使用web workers？</summary></b>

参考答案：

```
因为js是单线程，如果存在大数据运算的时候会影响用户使用体验，出现卡顿的情况。
使用web workers 可以开启一个线程，在运算的同时，不影响用户体验。
web workers的几个使用场景可以参考下：

    当大图片canvas转base64的时候非常耗时，就可以使用wokers
    端对端加密的时候，要大量计算，可以使用wokers
    拼写检查，检索的所有工作可以让wokers来完成，不会阻塞UI
    indexdb ，在网络不稳定情况下,使用indexdb api的时候，可以交给wokers，这样不会阻塞主线UI
```

</details>

<b><details><summary>118. 使用svg画一个微信的logo</summary></b>

参考答案：

```
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <!--绿色大椭圆下的小尾巴-->
  <polygon points="70,92 85,97 65,107"
  style="fill:#84d845;"/>
  <!--绿色大椭圆-->
  <ellipse cx="100" cy="60" rx="50" ry="42" style="fill:#84d845;" />
  <!--灰色小椭圆下的小尾巴-->
  <polygon points="150,115 160,110 165,120"
  style="fill:#f1f2f4;"/>
  <!--灰色小椭圆-->
  <ellipse cx="135" cy="85" rx="40" ry="32" style="fill:#f1f2f4;" />
  <!--两只大眼睛-->
  <ellipse cx="82" cy="45" rx="5" ry="5" style="fill:#136f1a;" />
  <ellipse cx="115" cy="45" rx="5" ry="5" style="fill:#136f1a;" />
  <!--两只小眼睛-->
  <ellipse cx="120" cy="75" rx="4" ry="4" style="fill:#797d7e;" />
  <ellipse cx="145" cy="75" rx="4" ry="4" style="fill:#797d7e;" />
</svg>
```

</details>

<b><details><summary>119. 如何在不同的端口间共享cookie？</summary></b>

参考答案：根据同源策略，cookie是区分端口的，但是浏览器实现来说，“cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的。

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. Ajax 是什么? 如何创建一个 Ajax？</summary></b>

参考答案：Ajax 全称是 asychronous javascript and xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步交互，实现页面的局部刷新。

基本步骤 4 步走：（创建对象、建立连接、发送数据、接收数据）

解析：

```

    1：我要创建一个XMLHttpRequest 对象。
    var xhr=new XMLHttpRequest() 创建对象

    2：我要发送请求，我要跟服务器建立一个连接。

    xhr.open("type 提交方式", "url  提交的地址")

    2.1:如果是post请求，需要设置请求头

    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");

    3：我要发送数据给服务器。

    如果说是get 请求，请求的数据在地址的后面。
    xhr.send() 发送数据，这一步不能省略

    4：接收服务器的数据。
        服务端返回数据会调用一个回调函数。
        通过回调函数去接收数据.
    xhr.onreadystatechange=function(){
            if(xhr.readyState==4){ 响应完成了
                    if(xhr.status==200){ //响应成功了
                          responseText 属性接收服务端返回的数据.
                    }
            }
    }

```

[参与互动](https://github.com/yisainan/web-interview/issues/62)

</details>

<b><details><summary>2. 同步和异步的区别?</summary></b>

参考答案：同步：阻塞的；异步：非阻塞的。

解析：

同步：阻塞的

举例：张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭；

浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面。

异步：非阻塞的

举例：张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃；

​浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新。

[参与互动](https://github.com/yisainan/web-interview/issues/63)

</details>

<b><details><summary>3. 如何解决跨域问题?</summary></b>

参考答案：

1. jsonp ，允许 script 加载第三方资源
2. 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin \*）
3. cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
4. iframe 嵌套通讯，postmessage

解析：

理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域

[参考](https://zhuanlan.zhihu.com/p/41479807)
[跨域资源共享 CORS 阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors.html)

[参与互动](https://github.com/yisainan/web-interview/issues/64)

</details>

<b><details><summary>4. 页面编码和被请求的资源编码如果不一致如何处理？</summary></b>

参考答案：get 请求中的中文需要 encodeURIComponent 编码处理，post 请求不需要进行编码

[参与互动](https://github.com/yisainan/web-interview/issues/65)

</details>

<b><details><summary>5. 创建 ajax 过程</summary></b>

参考答案：

1. 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象

2. 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息

3. 设置响应 HTTP 请求状态变化的函数

4. 发送 HTTP 请求

5. 获取异步调用返回的数据

6. 使用 JavaScript 和 DOM 实现局部刷新

[参与互动](https://github.com/yisainan/web-interview/issues/66)

</details>

<b><details><summary>6. 阐述一下异步加载 JS</summary></b>

参考答案：

1. 异步加载的方案： 动态插入 script 标签

2. 通过 ajax 去获取 js 代码，然后通过 eval 执行

3. script 标签上添加 defer 或者 async 属性

4. 创建并插入 iframe，让它异步执行 js

[参与互动](https://github.com/yisainan/web-interview/issues/67)

</details>

<b><details><summary>7. 请解释一下 JavaScript 的同源策略</summary></b>

参考答案：同源策略是客户端脚本（尤其是 Javascript）的重要的安全度量标准。它最早出自 Netscape Navigator2. 0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。

[参与互动](https://github.com/yisainan/web-interview/issues/68)

</details>

<b><details><summary>8. GET 和 POST 的区别，何时使用 POST？</summary></b>

参考答案：

GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符，有的浏览器是 8000 个字符

POST：一般用于修改服务器上的资源，对所发送的信息没有限制

在以下情况中，请使用 POST 请求：

1. 无法使用缓存文件（更新服务器上的文件或数据库）

2. 向服务器发送大量数据（POST 没有数据量限制）

3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

[参与互动](https://github.com/yisainan/web-interview/issues/69)

</details>

<b><details><summary>9. ajax 的优点</summary></b>

参考答案：

1. 页面无刷新更新数据：Ajax最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验；
2. 异步与服务器通信：Ajax使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量；
3. 前端和后端负载平衡：Ajax可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，Ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能；
4. 基于标准被广泛支持：Ajax基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能；
5. 界面与应用分离：Ajax使Web中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。

[参与互动](https://github.com/yisainan/web-interview/issues/70)

</details>

<b><details><summary>10. Ajax 的最大的特点是什么？</summary></b>

参考答案：

* Ajax 可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；
* 按需获取数据，节约带宽资源；

[参与互动](https://github.com/yisainan/web-interview/issues/71)

</details>

<b><details><summary>11. ajax 的缺点</summary></b>

参考答案：

1. Ajax干掉了Back和History功能，即对浏览器机制的破坏：在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现的 ，后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是Ajax所带来的一个比较严重的问题；
2. Ajax的安全问题：Ajax技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等；
3. 对搜索引擎支持较弱：对搜索引擎的支持比较弱。如果使用不当，Ajax会增大网络数据的流量，从而降低整个系统的性能；
4. 破坏程序的异常处理机制：至少从目前看来，像Ajax.dll，Ajaxpro.dll这些Ajax框架是会破坏程序的异常机制的；
5. 违背URL和资源定位的初衷：我给你一个URL地址，如果采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的；
6. Ajax不能很好支持移动设备：一些手持设备（如手机、PDA等）现在还不能很好的支持Ajax；
7. 客户端过肥，太多客户端代码造成开发上的成本：编写复杂、容易出错；冗余代码比较多（层层包含js文件是Ajax的通病，再加上以往的很多服务端代码现在放到了客户端）；破坏了Web的原有标准；
8. 如果用户禁用了JS，网站就取不到数据。

[参与互动](https://github.com/yisainan/web-interview/issues/72)

</details>

<b><details><summary>12. ajax 请求的时候 get 和 post 方式的区别</summary></b>

参考答案：

get 一般用来进行查询操作，url 地址有长度限制，请求的参数都暴露在 url 地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。

post 请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于 http 请求体中，数据不会暴漏在 url 地址中。

[参与互动](https://github.com/yisainan/web-interview/issues/73)

</details>

<b><details><summary>13. 解释 jsonp 的原理，以及为什么不是真正的 ajax, 以及优缺点</summary></b>

参考答案：

1. jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术

2. 优缺点

* jsonp 优点:

  + 完美解决在测试或者开发中获取不同域下的数据, 用户传递一个 callback 参数给服务端，然后服务端返回数据时会将这个 callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。简单来说数据的格式没有发生很大变化

* jsonp 缺点:

  + 1. jsonp 只支持 get 请求而不支持 post 请求, 也即是说如果想传给后台一个 json 格式的数据, 此时问题就来了, 浏览器会报一个 http 状态码 415 错误, 告诉你请求格式不正确, 这让我很蛋疼(在登录注册中需要给后台传一大串数据), 如果都用参数的形式拼接在 url 后面的话不太现实, 后台取值也会显得繁琐, 
  + 2. 在登录模块中需要用到 session 来判断当前用户的登录状态, 这时候由于是跨域的原因, 前后台的取到的 session 是不一样的, 那么就不能就行 session 来判断. 
  + 3. 由于 jsonp 存在安全性问题(不知 qq 空间的跨域是怎么解决的, 还是另有高招?)，后来考虑到上面的一系列问题, 采用的是后台进行设置允许跨域请求(但还是存在缺陷的, 实质上还是跨域, 如上面说的 session 问题). Header set Access-Control-Allow-Origin \*为了防止 XSS 攻击我们的服务器， 我们可以限制域，比如 Access-Control-Allow-Origin: http://blog.csdn.net

[参与互动](https://github.com/yisainan/web-interview/issues/74)

</details>

<b><details><summary>14. 什么是 Ajax 和 JSON，它们的优缺点。</summary></b>

参考答案：

* Ajax 是全称是 asynchronous JavaScript andXML，即异步 JavaScript 和 xml，用于在 Web 页面中实现异步数据交互，实现页面局部刷新。

  + 优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验

  + 缺点：对搜索引擎不友好；要实现 ajax 下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；

* JSON 是一种轻量级的数据交换格式，ECMA 的一个子集

  + 优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）

[参与互动](https://github.com/yisainan/web-interview/issues/75)

</details>

<b><details><summary>15. 什么是 json，优缺点</summary></b>

参考答案：

JSON (JavaScript Object Notation)

优点:

1. 数据格式比较简单, 易于读写, 格式都是压缩的, 占用带宽小
2. 易于解析这种语言, 客户端 javascript 可以简单的通过 eval()进行 JSON 数据的读取搜索
3. 支持多种语言, 包括 ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, php, Python, Ruby 等语言服务器端语言, 便于服务器端的解析
4. 在 PHP 世界, 已经有 PHP-JSON 和 JSON-PHP 出现了, 便于 PHP 序列化后的程序直接调用. PHP 服务器端的对象、数组等能够直接生 JSON 格式, 便于客户端的访问提取. 另外 PHP 的 PEAR 类已经提出了支持 (http://pear.php.net/pepr/pepr-proposal-show.php?id=198)
5. 因为 JSON 格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护

缺点:

1. 没有 XML 格式这么推广的深入人心和使用广泛, 没有 XML 那么通用性
2. JSON 格式目前在 Web Service 中推广还属于初级阶段 PS: 据说 Google 的 Ajax 是使用 JSON+模板 做的

[参与互动](https://github.com/yisainan/web-interview/issues/76)

</details>

<b><details><summary>16. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</summary></b>

参考答案：

1. 浏览器地址栏输入 url

2. 浏览器会先查看浏览器缓存--系统缓存--路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步

3. 域名解析（DNS）获取相应的 ip

4. 浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手

5. 握手成功，浏览器向服务器发送 http 请求，请求数据包

6. 服务器请求数据，将数据返回到浏览器

7. 浏览器接收响应，读取页面内容，解析 html 源码，生成 DOM 树

8. 解析 css 样式. 浏览器渲染，js 交互绑定多个域名，数量不限；

[参与互动](https://github.com/yisainan/web-interview/issues/77)

</details>

<b><details><summary>17. XML 和 JSON 的区别？</summary></b>

参考答案：

(1). 数据体积方面。

JSON 相对于 XML 来讲，数据的体积小，传递的速度更快些。

(2). 数据交互方面。

JSON 与 JavaScript 的交互更加方便，更容易解析处理，更好的数据交互。

(3). 数据描述方面。

JSON 对数据的描述性比 XML 较差。

(4). 传输速度方面。

JSON 的速度要远远快于 XML。

[参与互动](https://github.com/yisainan/web-interview/issues/78)

</details>

<b><details><summary>18. ajax 请求时，如何解析 json 数据</summary></b>

参考答案：使用 eval() 或者 JSON. parse() 鉴于安全性考虑，推荐使用 JSON. parse()更靠谱，对数据的安全性更好。

[参与互动](https://github.com/yisainan/web-interview/issues/79)

</details>

<b><details><summary>19. 同步加载、异步加载、延迟加载、预加载的区别</summary></b>

参考答案：

一、同步加载

　　平常默认用的都是同步加载。如：<script src="http://yourdomain.com/script.js"></script> 
　　同步模式又称阻塞模式，会阻止浏览器的后续处理，停止了后续的文件的解析，执行，如图像的渲染。流览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来

二、异步加载

```js
(function() {
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = 'http://yourdomain.com/script.js';
var x = document.getElementsByTagName('script')[0];
 x.parentNode.insertBefore(s, x);
})();
```

异步加载也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。
在script标签内，用js创建一个script元素并插入到document中，这种就是异步加载js文件了。

同步加载流程是瀑布模型，异步加载流程是并发模型。

三、延迟加载（lazy loading）

前面解决了异步加载（async loading）问题，再谈谈什么是延迟加载。
延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。
也就是将 js 切分成许多模块，页面初始化时只加载需要立即执行的 js ，然后其它 js 的加载延迟到第一次需要用到的时候再加载。
特别是页面有大量不同的模块组成，很多可能暂时不用或根本就没用到。
就像图片的延迟加载，在图片出现在可视区域内时（在滚动条下拉）才加载显示图片

四、预加载

预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源，当用户访问某个预加载的链接时，如果从缓存命中,页面就得以快速呈现。

[参与互动](https://github.com/yisainan/web-interview/issues/80)

</details>

<b><details><summary>20. eval 是做什么的？</summary></b>

参考答案：它的功能是把对应的字符串解析成 JS 代码并运行；

解析：应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。

[参与互动](https://github.com/yisainan/web-interview/issues/81)

</details>

<b><details><summary>21. AMD 和 CMD 规范的区别</summary></b>

参考答案：

1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行

2. CMD 推崇依赖就近，AMD 推崇依赖前置

[参与互动](https://github.com/yisainan/web-interview/issues/82)

</details>

<b><details><summary>22. HTTP 状态码</summary></b>

参考答案：

100 ? Continue ? 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息

200 ? OK ? 正常返回信息

201 ? Created ? 请求成功并且服务器创建了新的资源

202 ? Accepted ? 服务器已接受请求，但尚未处理

301 ? Moved Permanently ? 请求的网页已永久移动到新位置。

302 Found ? 临时性重定向。

303 See Other ? 临时性重定向，且总是使用 GET 请求新的 URI。

304 ? Not Modified ? 自从上次请求后，请求的网页未修改过。

400 Bad Request ? 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。

401 Unauthorized ? 请求未授权。

403 Forbidden ? 禁止访问。

404 Not Found ? 找不到如何与 URI 相匹配的资源。

500 Internal Server Error ? 最常见的服务器端错误。

503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

[参与互动](https://github.com/yisainan/web-interview/issues/83)

</details>

<b><details><summary>23. 栈和队列的区别?</summary></b>

参考答案：

* 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。
* 队列先进先出，栈先进后出。
* 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

拓展：

栈和堆的区别？

栈区（stack）—    由编译器自动分配释放，存放函数的参数值，局部变量的值等。

堆区（heap）—    一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。

[参与互动](https://github.com/yisainan/web-interview/issues/84)

</details>

<b><details><summary>24. ajax 加载的页面，跳转到另外一个页面再跳转回来，内容相同，如何节约读取请求?</summary></b>

参考答案：后台做缓存，读取缓存里面的数据、CDN

[参与互动](https://github.com/yisainan/web-interview/issues/85)

</details>

<b><details><summary>25. Ajax 实现的原理</summary></b>

参考答案：浏览器提供的 XMLHttpRequest 对象

[参与互动](https://github.com/yisainan/web-interview/issues/86)

</details>

<b><details><summary>26. ajax 如何实现，readyState 的五种状态的含义？</summary></b>

参考答案：

* 0 － （未初始化）还没有调用 send()方法
* 1 － （载入）已调用 send()方法，正在发送请求
* 2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
* 3 － （交互）正在解析响应内容
* 4 － （完成）响应内容解析完成，可以在客户端调用了

解析：

(0)未初始化

此阶段确认 XMLHttpRequest 对象是否创建，并为调用 open()方法进行未初始化作好准备。值为 0 表示对象已经存在，否则浏览器会报错－－对象不存在。

(1)载入

此阶段对 XMLHttpRequest 对象进行初始化，即调用 open()方法，根据参数(method, url, true)完成对象状态的设置。并调用 send()方法开始向服务端发送请求。值为 1 表示正在向服务端发送请求。

(2)载入完成

此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为 2 表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。

(3)交互

此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的 MIME 类型把数据转换成能通过 responseBody、responseText 或 responseXML 属性存取的格式，为在客户端调用作好准备。状态 3 表示正在解析数据。

(4)完成

此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为 4 表示数据解析完毕，可以通过 XMLHttpRequest 对象的相应属性取得数据。

[参考](https://blog.csdn.net/u011565547/article/details/78979030)

[参与互动](https://github.com/yisainan/web-interview/issues/87)

</details>

<b><details><summary>27. 什么是RESTful？</summary></b>

参考答案：REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。

* GET<br>

  get 方法在 Rest 中主要用于获取资源，能够发送参数，不过有限制，且参数都会以? 开头的形 式附加在 URL 尾部。
  规范的 get 方法处理器应该是幂等的，也就是说对一个资源不论发送多少次 get 请求都不会更改数据或造成破坏。

* POST<br>

  post 方法在 Rest 请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息

* PUT<br>

  put 方法在 Rest 中主要用于更新资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post. 因此为了使用 put 和 delete 方法, 
  需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。
  put 方法的参数是同 post 一样是存放在消息中的，同样具有安全性，可发送较大信息。
  put 方法是幂等的，对同一 URL 资源做出的同一数据的任意次 put 请求其对数据的改变都是一致的。

* DELETE<br>

  Delete 在 Rest 请求中主要用于删除资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post。
  因此为了使用 put 和 delete 方法, 需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。
  Delete 方法的参数同 post 一样存放在消息体中, 具有安全性，可发送较大信息 Delete 方法是幂等的，不论对同一个资源进行多少次 delete 请求都不会破坏数据

解析：[参考](https://blog.csdn.net/jnshu_it/article/details/80203696)

[参与互动](https://github.com/yisainan/web-interview/issues/88)

</details>

<b><details><summary>28. Ajax 和 Fetch 区别</summary></b>

参考答案：

* ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。
* 使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。
* 在默认情况下，fetch 不会接受或者发送 cookies
* fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以
* fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理
* fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest

[参与互动](https://github.com/yisainan/web-interview/issues/89)

</details>

<b><details><summary>29. ajax是同步还是异步？</summary></b>

参考答案：可以同步也可以异步，jquery默认为异步，也推荐异步执行。可通过async: true修改。

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. ES6 都有什么 Iterator 遍历器</summary></b>

参考答案：Set、Map

解析：

1、遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）

2、Iterator 的作用有三个：

* 一是为各种数据结构，提供一个统一的、简便的访问接口；
* 二是使得数据结构的成员能够按某种次序排列；
* 三是 ES6 创造了一种新的遍历命令 for... of 循环，Iterator 接口主要供 for... of 消费。

3、默认部署了 Iterator 的数据有 Array、Map、Set、String、TypedArray、arguments、NodeList 对象，ES6 中有的是 Set、Map、

解析：[参考](https://es6.ruanyifeng.com/#docs/iterator)

[参与互动](https://github.com/yisainan/web-interview/issues/332)

</details>

<b><details><summary>2. ES6 中类的定义</summary></b>

参考答案：

```js
// 1、类的基本定义
class Parent {
    constructor(name = "小白") {
        this.name = name;
    }
}
```

```js
// 2、生成一个实例
let g_parent = new Parent();
console.log(g_parent); //{name: "小白"}
let v_parent = new Parent("v"); // 'v'就是构造函数name属性 , 覆盖构造函数的name属性值
console.log(v_parent); // {name: "v"}
```

```js
// 3、继承
class Parent {
    //定义一个类
    constructor(name = "小白") {
        this.name = name;
    }
}

class Child extends Parent {}

console.log("继承", new Child()); // 继承 {name: "小白"}
```

```js
// 4、继承传递参数
class Parent {
    //定义一个类
    constructor(name = "小白") {
        this.name = name;
    }
}

class Child extends Parent {
    constructor(name = "child") {
        // 子类重写name属性值
        super(name); // 子类向父类修改 super一定放第一行
        this.type = "preson";
    }
}
console.log("继承", new Child("hello")); // 带参数覆盖默认值  继承{name: "hello", type: "preson"}
```

```js
// 5、ES6重新定义的ES5中的访问器属性
class Parent {
    //定义一个类
    constructor(name = "小白") {
        this.name = name;
    }

    get longName() {
        // 属性
        return "mk" + this.name;
    }

    set longName(value) {
        this.name = value;
    }
}

let v = new Parent();
console.log("getter", v.longName); // getter mk小白

v.longName = "hello";
console.log("setter", v.longName); // setter mkhello
```

```js
// 6、类的静态方法
class Parent {
    //定义一个类
    constructor(name = "小白") {
        this.name = name;
    }

    static tell() {
        // 静态方法:通过类去调用，而不是实例
        console.log("tell");
    }
}

Parent.tell(); // tell
```

```js
// 7、类的静态属性：

class Parent {
    //定义一个类
    constructor(name = "小白") {
        this.name = name;
    }

    static tell() {
        // 静态方法:通过类去调用，而不是实例
        console.log("tell"); // tell
    }
}

Parent.type = "test"; // 定义静态属性

console.log("静态属性", Parent.type); // 静态属性 test

let v_parent = new Parent();
console.log(v_parent); // {name: "小白"}  没有tell方法和type属性
```

解析：[参考](https://es6.ruanyifeng.com/#docs/class)
[参与互动](https://github.com/yisainan/web-interview/issues/333)

</details>

<b><details><summary>3. 谈谈你对 ES6 的理解</summary></b>

参考答案：es6 是一个新的标准，它包含了许多新的语言特性和库，是 JS 最实质性的一次升级。
比如'箭头函数'、'字符串模板'、'generators(生成器)'、'async/await'、'解构赋值'、'class'等等，还有就是引入 module 模块的概念。

箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数

* （1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
* （2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。
* （3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。
* （4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

* async/await 是写异步代码的新方式，以前的方法有回调函数和 Promise。
* async/await 是基于 Promise 实现的，它不能用于普通的回调函数。async/await 与 Promise 一样，是非阻塞的。
* async/await 使得异步代码看起来像同步代码，这正是它的魔力所在。

解析：[参考](https://www.cnblogs.com/heweijain/p/7073553.html)

[参与互动](https://github.com/yisainan/web-interview/issues/334)

</details>

<b><details><summary>4. 说说你对 promise 的了解</summary></b>

参考答案：Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。

所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

Promise 对象有以下两个特点:

1. 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。

2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

解析：[参考](https://es6.ruanyifeng.com/#docs/promise)

[参与互动](https://github.com/yisainan/web-interview/issues/335)

</details>

<b><details><summary>5. 解构赋值及其原理</summary></b>

参考答案：

解构赋值：其实就是分解出一个对象的解构，分成两个步骤：

1. 变量的声明
2. 变量的赋值

原理：ES6 变量的解构赋值本质上是“模式匹配”, 只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于 undefined

解析：

一、 数组的解构赋值

```js
// 对于数组的解构赋值，其实就是获得数组的元素，而我们一般情况下获取数组元素的方法是通过下标获取，例如：
let arr = [1, 2, 3];
let a = arr[0];
let b = arr[1];
let c = arr[2];

// 而数组的解构赋值给我们提供了极其方便的获取方式，如下：
let [a, b, c] = [1, 2, 3];
console.log(a, b, c); //1,2,3
```

1. 模式匹配解构赋值

```js
let [foo, [
    [bar], baz
]] = [1, [
    [2], 3
]];
console.log(foo, bar, baz); //1,2,3
```

2. 省略解构赋值

```js
let [, , a, , b] = [1, 2, 3, 4, 5];
console.log(a, b); //3,5
```

3. 含剩余参数的解构赋值

```js
let [a, ...reset] = [1, 2, 3, 4, 5];
console.log(a, reset); //1,[2,3,4,5]
```

其转成 ES5 的原理如下：

```js
var a = 1,
    reset = [2, 3, 4, 5];
console.log(a, reset); //1,[2,3,4,5]
```

注意：如果剩余参数是对应的值为 undefined，则赋值为[]，因为找不到对应值的时候，是通过 slice 截取的，如下：

```js
let [a, ...reset] = [1];
console.log(a, reset); //1,[]
```

其转成 ES5 的原理如下：

```js
var _ref = [1],
    a = _ref[0],
    reset = _ref.slice(1);
console.log(a, reset); //1,[]
```

4. 非数组解构成数组(重点，难点)

一条原则：要解构成数组的前提：如果等号右边，不是数组(严格地说，不是可遍历的解构)，则直接报错，例如：

```js
let [foo] = 1; //报错
let [foo1] = false; //报错
let [foo2] = NaN; //报错
let [foo3] = undefined; //报错
let [foo4] = null; //报错
let [foo5] = {}; //报错
```

为什么？转成 ES5 看下原理就一清二楚了：

```js
var _ = 1,
    foo = _[0]; //报错
var _false = false,
    foo1 = _false[0]; //报错
var _NaN = NaN,
    foo2 = _NaN[0]; //报错
var _undefined = undefined,
    foo3 = _undefined[0]; //报错
var _ref = null;
foo4 = _ref[0]; //报错
var _ref2 = {},
    foo5 = _ref2[0]; //报错
```

5. Set 的解构赋值

先执行 new Set()去重，然后对得到的结果进行解构

```js
let [a, b, c] = new Set([1, 2, 2, 3]);
console.log(a, b, c); //1,2,3
```

6. 迭代器解构

```js
function* fibs() {
    let a = 0;
    let b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth; // 5
```

### 总结 1：只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

7. 解构赋值的默认值

当变量严格等于 undefined 的时候，会读取默认值，所谓的严格等于，就是“===”

```js
-- -- -- -- --

let [a, b = 'default'] = [1];
console.log(a, b); //1,'default'

-- -- -- -- --

let [c = 'default'] = [undefined];
console.log(c); //'default'

-- -- -- -- --

function f() {
    console.log('aaa');
}

let [x = f()] = [1];
console.log(x); //1

-- -- -- -- --

function f() {
    console.log('aaa'); //'aaa'
}

let [a, x = f()] = [1];
console.log(a, x); //1,undefined
```

### 总结 2：如果不使用默认值，则不会执行默认值的函数

二、对象的解构赋值

1. 解构赋值的举例：

```js
let p1 = {
    name: "zhuangzhuang",
    age: 25
};
let {
    name,
    age
} = p1; //注意变量必须为属性名
console.log(name, age); //"zhuangzhuang",25
```

其转成 es5 的原理则为：

```js
var _p1 = p1,
    name = _p1.name,
    age = _p1.age;
console.log(name, age); //"zhuangzhuang",25
```

2. 解构赋值的别名

如果使用别名，则不允许再使用原有的解构出来的属性名，看以下举例则会明白：

```js
let p1 = {
    name: "zhuangzhuang",
    age: 25
};
let {
    name: aliasName,
    age: aliasAge
} = p1; //注意变量必须为属性名
console.log(aliasName, aliasAge); //"zhuangzhuang",25
console.log(name, age); //Uncaught ReferenceError: age is not defined
```

为何打印原有的属性名则会报错？让我们看看转成 es5 后的原理是如何实现的：

```js
var _p1 = p1,
    aliasName = _p1.name,
    aliasAge = _p1.age;
console.log(aliasName, aliasAge); //"zhuangzhuang",25
console.log(name, age); //所以打印name和age会报错——“Uncaught ReferenceError: age is not defined”，但是为何只报错age，不报错name呢？
```

只报错 age，不报错 name，这说明其实 name 是存在的，那么根据 js 的解析顺序，当在当前作用域 name 无法找到时，会向上找，直到找到 window 下的 name, 而我们打印 window 可以发现，其下面确实有一个 name，值为“”，而其下面并没有属性叫做 age，所以在这里 name 不报错，只报 age 的错。类似 name 的属性还有很多，比如 length 等。

3. 解构赋值的默认值

有些情况下，我们解构出来的值并不存在，所以需要设定一个默认值，例如：

```js
let obj = {
    name: "zhuangzhuang"
};
let {
    name,
    age
} = obj;
console.log(name, age); //"zhuangzhuang",undefined
```

我们可以看到当 age 这个属性并不存在于 obj 的时候，解构出来的值为 undefined，那么为了避免这种尴尬的情况，我们常常会设置该属性的默认值，如下：

```js
let obj = {
    name: "zhuangzhuang"
};
let {
    name,
    age = 18
} = obj;
console.log(name, age); //"zhuangzhuang",18
```

当我们取出来的值不存在，即为 undefined 的时候，则会取默认值(假设存在默认值)，ES6 的默认值是使用**“变量=默认值”**的方式。

注意：只有当为 undefined 的时候才会取默认值，null 等均不会取默认值

```js
let obj = {
    name: "zhuangzhuang",
    age: 27,
    gender: null, //假设未知使用null
    isFat: false
};
let {
    name,
    age = 18,
    gender = "man",
    isFat = true,
    hobbies = "study"
} = obj;
console.log(name, age, gender, isFat, hobbies); //"zhuangzhuang"，27，null，false，"study"
```

4. 解构赋值的省略赋值

当我们并不是需要取出所有的值的时候，其实可以省略一些变量，这就是省略赋值，如下

```js
let arr = [1, 2, 3];
let [, , c] = arr;
console.log(c); //3
```

注意：省略赋值并不存在与对象解构，因为对象解构，明确了需要的属性

```js
let obj = {
    name: "zhuangzhuang",
    age: 27,
    gender: "man"
};
let {
    age
} = obj;
console.log(age); //27
```

5. 解构赋值的嵌套赋值(易错点，重点，难点)

```js
let obj = {},
    arr = [];

({
    foo: obj.prop,
    bar: arr[0]
} = {
    foo: 123,
    bar: true
});
console.log(obj, arr); //{prop:123},[true]
```

注意当解构出来是 undefined 的时候，如果再给子对象的属性，则会报错，如下

```js
let {
    foo: {
        bar
    }
} = {
    baz: "baz"
};
//报错，原因很简单，看下原理即可，如下：
//原理:
let obj = {
    baz: "baz"
};
let foo = obj.foo; //foo为undefined
let bar = foo.bar; //undefined的bar，可定报错
```

6. {}是块还是对象？

当我们写解构赋值的时候，很容易犯一个错误——{}的作用是块还是对象混淆，举例如下：

```js
//举例一：
let {
    a
} = {
    a: "a"
};
console.log(a); //'a',这个很简单
//很多人觉得，以下这种写法也是可以的：
let a; {
    a
} = {
    a: "a"
}; //直接报错，因为此时a已经声明过了，在语法解析的时候，会将这一行的{}看做块结构，而“块=对象”，显然是语法错误，所以正确的做法是不将大括号写在开头，如下：
let a;
({
    a
} = {
    a: "a"
})
```

7. 空解构

按照之前写的，解构赋值，左边则为解构出来的属性名，当然，在这里，我们也可以不写任何属性名称，也不会又任何的语法错误，即便这样没有任何意义，如下：

```js
({} = [true, false]);
({} = "abc");
({} = []);
```

8. 解构成对象的原则

如果解构成对象，右侧不是 null 或者 undefined 即可!
之前说过，要解构成数组，右侧必须是可迭代对象，但是如果解构成对象，右侧不是 null 活着 undefined 即可!

三、字符串的解构赋值

字符串也是可以解构赋值的

```js
const [a, b, c, d, e] = "hello";
console.log(a, b, c, d, e); //'h','e','l','l','o'
```

转成 es5 的原理如下:

```js
var _hello = "hello",
    a = _hello[0],
    b = _hello[1],
    c = _hello[2];

console.log(a, b, c);
```

注意：字符串有一个属性 length，也可以被解构出来，但是要注意，解构属性一定是对象解构

```js
let {
    length
} = "hello";
console.log(length); //5
```

4. 布尔值和数值的解构

布尔值和数值的解构，其实就是对其包装对象的解构，取的是包装对象的属性

```js
{
    toString: s
} = 123;
console.log(s); //s === Number.prototype.toString

{
    toString: s
} = true;
console.log(s); //s === Boolean.prototype.toString
```

### 总结：解构赋值的规则是：

> 1. 解构成对象，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。
> 2. 解构成数组，等号右边必须为可迭代对象

[参考](https://blog.csdn.net/qq_17175013/article/details/81490923)

[参与互动](https://github.com/yisainan/web-interview/issues/336)

</details>

<b><details><summary>6. Array.from() 与 Array.reduce()</summary></b>

参考答案：

Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组
Array.reduce()方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。

解析：

### Array.from()

```js
// 那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。

// 1、将类数组对象转换为真正数组：

let arrayLike = {
    0: "tom",
    1: "65",
    2: "男",
    3: ["jane", "john", "Mary"],
    length: 4
};
let arr = Array.from(arrayLike);
console.log(arr); // ['tom','65','男',['jane','john','Mary']]

// 那么，如果将上面代码中length属性去掉呢？实践证明，参考答案会是一个长度为0的空数组。

// 这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：

let arrayLike = {
    name: "tom",
    age: "65",
    sex: "男",
    friends: ["jane", "john", "Mary"],
    length: 4
};
let arr = Array.from(arrayLike);
console.log(arr); // [ undefined, undefined, undefined, undefined ]

// 会发现结果是长度为4，元素均为undefined的数组

// 由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：

// 1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。

// 2、该类数组对象的属性名必须为数值型或字符串型的数字

// ps: 该类数组对象的属性名可以加引号，也可以不加引号

// 2、将Set结构的数据转换为真正的数组：

let arr = [12, 45, 97, 9797, 564, 134, 45642];
let set = new Set(arr);
console.log(Array.from(set)); // [ 12, 45, 97, 9797, 564, 134, 45642 ]

// 　Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：

let arr = [12, 45, 97, 9797, 564, 134, 45642];
let set = new Set(arr);
console.log(Array.from(set, item => item + 1)); // [ 13, 46, 98, 9798, 565, 135, 45643 ]

// 3、将字符串转换为数组：

let str = "hello world!";
console.log(Array.from(str)); // ["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", "!"]

// 4、Array.from参数是一个真正的数组：

console.log(Array.from([12, 45, 47, 56, 213, 4654, 154]));
// 像这种情况，Array.from会返回一个一模一样的新数组
```

[参考](https://www.cnblogs.com/jf-67/p/8440758.html)

### Array.reduce()

```

语法：

array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)；

accumulator：累加器，即函数上一次调用的返回值。第一次的时候为 initialValue || arr[0]

currentValue：数组中函数正在处理的的值。第一次的时候initialValue || arr[1]

currentIndex：数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始

array： 调用 reduce 的数组

initialValue：可选项，累加器的初始值。没有时，累加器第一次的值为currentValue；注意：在对没有设置初始值的空数组调用reduce方法时会报错。
```

```js
//无初始值
[1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) {
    return accumulator + currentValue;
}); // 10
```

| callback    | accumulator       | currentValue      | currentIndex    | array        | return value |
| ----------- | ----------------- | ----------------- | --------------- | ------------ | ------------ |
| first call  | 1(数组第一个元素) | 2(数组第二个元素) | 1(无初始值为 1) | [1, 2, 3, 4] | 3            |
| second call | 3                 | 3                 | 2               | [1, 2, 3, 4] | 6            |
| third call  | 6                 | 4                 | 3               | [1, 2, 3, 4] | 10           |

```js
//有初始值
[1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) {
    return accumulator + currentValue;
}, 10); // 20
```

| callback    | accumulator | currentValue      | currentIndex    | array        | return value |
| ----------- | ----------- | ----------------- | --------------- | ------------ | ------------ |
| first call  | 10(初始值)  | 1(数组第一个元素) | 0(有初始值为 0) | [1, 2, 3, 4] | 11           |
| second call | 11          | 2                 | 1               | [1, 2, 3, 4] | 13           |
| third call  | 13          | 3                 | 2               | [1, 2, 3, 4] | 16           |
| fourth call | 16          | 4                 | 3               | [1, 2, 3, 4] | 20           |

```js
//1.数组元素求和
[1, 2, 3, 4].reduce((a, b) => a + b); //10

//2.二维数组转化为一维数组
[
    [1, 2],
    [3, 4],
    [5, 6]
]
.reduce((a, b) => a.concat(b), []) //[1, 2, 3, 4, 5, 6]

[
    //3.计算数组中元素出现的次数
    (1, 2, 3, 1, 2, 3, 4)
].reduce((items, item) => {
    if (item in items) {
        items[item]++;
    } else {
        items[item] = 1;
    }
    return items;
}, {}) //{1: 2, 2: 2, 3: 2, 4: 1}

[
    //数组去重①
    (1, 2, 3, 1, 2, 3, 4, 4, 5)
].reduce((init, current) => {
    if (init.length === 0 || init.indexOf(current) === -1) {
        init.push(current);
    }
    return init;
}, []) //[1, 2, 3, 4, 5]
[
    //数组去重②
    (1, 2, 3, 1, 2, 3, 4, 4, 5)
].sort()
    .reduce((init, current) => {
        if (init.length === 0 || init[init.length - 1] !== current) {
            init.push(current);
        }
        return init;
    }, []); //[1, 2, 3, 4, 5]
```

[参考](https://www.cnblogs.com/xuejiangjun/p/8523313.html)

[参与互动](https://github.com/yisainan/web-interview/issues/337)

</details>

<b><details><summary>7. var let 在 for 循环中的区别</summary></b>

参考答案：

```js
//使用var声明，得到3个3
var a = [];
for (var i = 0; i < 3; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[0](); //3
a[1](); //3
a[2](); //3

//使用let声明，得到0,1,2
var a = [];
for (let i = 0; i < 3; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[0](); //0
a[1](); //1
a[2](); //2
```

```js
for(var i=0;i<5;i++){
   setTimeout(()=>{
        console.log(i);//5个5
    },100)
}
console.log(i);//5
console.log('=============')

for(let j=0;j<5;j++){
   setTimeout(()=>{
        console.log(j);//0,1,2,3,4
    },100)
}
console.log(j);//报错 j is not defined
```

var是全局作用域，有变量提升的作用，所以在for中定义一个变量，全局可以使用，循环中的每一次给变量i赋值都是给全局变量i赋值。

let是块级作用域,只能在代码块中起作用，在js中一个{}中的语句我们也称为叫一个代码块，每次循环会产生一个代码块，每个代码块中的都是一个新的变量i;

解析：[参考](https://www.cnblogs.com/fanfanZhao/p/12179508.html)
[参与互动](https://github.com/yisainan/web-interview/issues/338)

</details>

<b><details><summary>8. Set 数据结构</summary></b>

参考答案：- es6 方法, Set 本身是一个构造函数，它类似于数组，但是成员值都是唯一的。

```js
const set = new Set([1, 2, 3, 4, 4]);
console.log([...set]); // [1,2,3,4]
console.log(Array.from(new Set([2, 3, 3, 5, 6]))); //[2,3,5,6]
```

[参与互动](https://github.com/yisainan/web-interview/issues/339)

</details>

<b><details><summary>9. Class 的讲解</summary></b>

参考答案：

* class 语法相对原型、构造函数、继承更接近传统语法，它的写法能够让对象原型的写法更加清晰、面向对象编程的语法更加通俗

  这是 class 的具体用法。

解析：[参考](https://www.cnblogs.com/fengxiongZz/p/8191503.html)

[参与互动](https://github.com/yisainan/web-interview/issues/340)

</details>

<b><details><summary>10. 模板字符串</summary></b>

参考答案：

* 就是这种形式${varible}, 在以往的时候我们在连接字符串和变量的时候需要使用这种方式'string' + varible + 'string'但是有了模版语言后我们可以使用string${varible}string 这种进行连接。基本用途有如下：

1、基本的字符串格式化，将表达式嵌入字符串中进行拼接，用\${}来界定。

```js
//es5
var name = "lux";
console.log("hello" + name);
//es6
const name = "lux";
console.log(`hello ${name}`); //hello lux
```

2、在 ES5 时我们通过反斜杠(\)来做多行字符串或者字符串一行行拼接，ES6 反引号(``)直接搞定。

```js
//ES5
var template =
    "hello \
world";
console.log(template); //hello world

//ES6
const template = `hello
world`;
console.log(template); //hello 空行 world
```

[参与互动](https://github.com/yisainan/web-interview/issues/341)

</details>

<b><details><summary>11. 箭头函数需要注意的地方</summary></b>

参考答案：

```

箭头函数有几个使用注意点。
（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。
（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

```

上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。

```js
function foo() {
    setTimeout(() => {
        console.log("id:", this.id);
    }, 100);
}

var id = 21;

foo.call({
    id: 42
});
// id: 42
```

解析：[参考](https://www.jianshu.com/p/bc28e4f67ef9)

[参与互动](https://github.com/yisainan/web-interview/issues/342)

</details>

<b><details><summary>12. ES6 如何动态加载 import</summary></b>

参考答案：

```js
import("lodash").then(_ => {
    // Do something with lodash (a.k.a '_')...
});
```

解析：[参考](https://webpack.js.org/api/module-methods/#import)

[参与互动](https://github.com/yisainan/web-interview/issues/343)

</details>

<b><details><summary>13. ECMAScript6 怎么写class么，为什么会出现class这种东西?</summary></b>

参考答案：

```js
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/344)

</details>

<b><details><summary>14. 谈一谈你对ECMAScript6的了解？</summary></b>

参考答案：ES6新的语法糖，类，模块化等新特性

[参与互动](https://github.com/yisainan/web-interview/issues/345)

</details>

<b><details><summary>15. 箭头函数和普通函数有什么区别</summary></b>

参考答案：

* 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象，用 `call`  `apply`  `bind` 也不能改变 `this` 指向
* 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误。
* 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替。
* 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数。
* 箭头函数没有原型对象 `prototype`

[参与互动](https://github.com/yisainan/web-interview/issues/346)

</details>

<b><details><summary>16. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</summary></b>

参考答案：

```js
const promise = new Promise((resolve, reject) => {
    console.log(1)
    resolve()
    console.log(2)
})

promise.then(() => {
    console.log(3)
})

console.log(4)
```

执行结果是：1243 

promise构造函数是同步执行的，then方法是异步执行的

</details>

<b><details><summary>17. ES5/ES6 的继承除了写法以外还有什么区别？</summary></b>

参考答案：

</details>

<b><details><summary>18. 对Promise的理解</summary></b>

参考答案：

</details>

<b><details><summary>19. generator 原理</summary></b>

参考答案：

</details>

<b><details><summary>20. 说说箭头函数的特点</summary></b>

参考答案：

</details>

<b><details><summary>21. 请介绍Promise，异常捕获（网易）</summary></b>

参考答案：

</details>

<b><details><summary>22. promise如何实现then处理（宝宝树）</summary></b>

参考答案：

</details>

<b><details><summary>23. Promise. all并发限制</summary></b>

参考答案：

</details>

<b><details><summary>24. 介绍下 Promise. all 使用、原理实现及错误处理</summary></b>

参考答案：

</details>

<b><details><summary>25. 设计并实现 Promise. race()</summary></b>

参考答案：

```js
Promise._race = promises => new Promise((resolve, reject) => {
    promises.forEach(promise => {
        promise.then(resolve, reject)
    })
})
```

基本和上面的例子差不多，不同点是每个传入值使用Promise. resolve转为Promise对象，兼容非Promise对象

```js
const _race = (p) => {
    return new Promise((resolve, reject) => {
        p.forEach((item) => {
            Promise.resolve(item).then(resolve, reject)
        })
    })
}
```

</details>

<b><details><summary>26. 模拟实现一个 Promise. finally</summary></b>

参考答案：

```js
Promise.prototype.finally = function(callback) {
    let P = this.constructor;
    return this.then(
        value => P.resolve(callback()).then(() => value),
        reason => P.resolve(callback()).then(() => {
            throw reason
        })
    );
};
```

</details>

<b><details><summary>27. 用Promise对象实现的 Ajax</summary></b>

参考答案：

```js
const getJSON = function(url) {
    const promise = new Promise(function(resolve, reject) {
        const handler = function() {
            if (this.readyState !== 4) {
                return;
            }
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        };
        const client = new XMLHttpRequest();
        client.open("GET", url);
        client.onreadystatechange = handler;
        client.responseType = "json";
        client.setRequestHeader("Accept", "application/json");
        client.send();
    });
    return promise;
};
getJSON("/posts.json").then(function(json) {
    console.log('Contents: ' + json);
}, function(error) {
    console.error('出错了', error);
});
```

上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。

</details>

<b><details><summary>28. 简单实现async/await中的async函数</summary></b>

参考答案：async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里

```js
function spawn(genF) {
    return new Promise(function(resolve, reject) {
        const gen = genF();

        function step(nextF) {
            let next;
            try {
                next = nextF();
            } catch (e) {
                return reject(e);
            }
            if (next.done) {
                return resolve(next.value);
            }
            Promise.resolve(next.value).then(
                function(v) {
                    step(function() {
                        return gen.next(v);
                    });
                },
                function(e) {
                    step(function() {
                        return gen.throw(e);
                    });
                }
            );
        }
        step(function() {
            return gen.next(undefined);
        });
    });
}
```

</details>

<b><details><summary>29. setTimeout、Promise、Async/Await 的区别</summary></b>

这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。

 * 其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
 * promise. then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；
 * async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

参考答案：

1. setTimeout

```js
console.log('script start') //1. 打印 script start

setTimeout(function() {
    console.log('settimeout') // 4. 打印 settimeout
}) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数

console.log('script end') //3. 打印 script start

// 输出顺序：
// ->script start
// ->script end
// ->settimeout
```

2. Promise

Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。

```js
console.log('script start')
let promise1 = new Promise(function(resolve) {
    console.log('promise1')
    resolve()
    console.log('promise1 end')
}).then(function() {
    console.log('promise2')
})
setTimeout(function() {
    console.log('settimeout')
})
console.log('script end')

// 输出顺序: 
// ->script start
// ->promise1
// ->promise1 end
// ->script end
// ->promise2
// ->settimeout
```

当JS主线程执行到Promise对象时，

  + promise1. then() 的回调就是一个 task
  + promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue
  + promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中
  + setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况

3. async/await

```js
async function async1() {
    console.log('async1 start');

    await async2();
    console.log('async1 end')

}
async function async2() {

    console.log('async2')

}

console.log('script start');
async1();
console.log('script end')

// 输出顺序：

// ->script start
// ->async1 start
// ->async2
// ->script end
// ->async1 end
``
`  

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

举个例子：

```js
async function func1() {
    return 1
}

console.log(func1())
```

控制台查看打印，很显然，func1的运行结果其实就是一个Promise对象。因此我们也可以使用then来处理后续逻辑。

```js
func1().then(res => {
    console.log(res); // 30
})
```

await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。

</details>

<b><details><summary>30.ES5构造函数用ES6的class改写</summary></b>

JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};

var p = new Point(1, 2);
```

基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。


参考答案：

```js
class Point {
  // 构造方法
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```

上面代码定义了一个“类”，可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数Point是一致的。

Point类除了构造方法，还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。

ES6 的类，完全可以看作构造函数的另一种写法。

```js
class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
}

// 等同于

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};
```

解析：[参考](https://es6.ruanyifeng.com/#docs/class)

</details>

<b><details><summary>31.什么是Generator 函数</summary></b>

参考答案：如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。

Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。

ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。

```js
function * foo(x, y) { ··· }
function *foo(x, y) { ··· }
function* foo(x, y) { ··· }
function*foo(x, y) { ··· }
```

由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。

解析：[参考](https://es6.ruanyifeng.com/#docs/generator)

</details>

<b><details><summary>32.什么是yield 表达式</summary></b>

参考答案：由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。

</details>

<b><details><summary>33.ES6 引入Symbol的原因</summary></b>

参考答案：ES5 的对象属性名都是字符串，这容易造成属性名的冲突。

比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。

ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

解析：[参考](https://es6.ruanyifeng.com/#docs/symbol)

</details>

<b><details><summary>34.</summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 说下 jQuery/Zepto 中的 on 方法有哪些参数，分别代表什么意思？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/347)

</details>

<b><details><summary>2. 谈一下 Jquery 中的 bind(), live(), delegate(), on()的区别？</summary></b>

参考答案：

* bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回 jQuery 对象。
* live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回 jQuery 对象。
* delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。

[参与互动](https://github.com/yisainan/web-interview/issues/348)

</details>

<b><details><summary>3.jQuery 的队列是如何实现的？队列可以用在哪些地方？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/349)

</details>

<b><details><summary>4.jquery.extend 与 jquery.fn.extend 的区别？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/350)

</details>

<b><details><summary>5.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/351)

</details>

<b><details><summary>6.jquery 中如何将数组转化为 json 字符串，然后再转化回来？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/352)

</details>

<b><details><summary>7.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/353)

</details>

<b><details><summary>8.jQuery 与 jQuery UI、jQuery Mobile 区别？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/354)

</details>

<b><details><summary>9.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/355)

</details>

<b><details><summary>10. 你觉得 jQuery 源码有哪些写的好的地方</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/356)

</details>

<b><details><summary>11. 你觉得 zepto 源码有哪些写的好的地方</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/357)

</details>

<b><details><summary>12.jQuery 的实现原理和核心？</summary></b>

参考答案：

1、jQuery 的实现原理

```js
var jQuery = function(selector, context) {
    return new jQuery.fn.init(selector, context);
};
```

1)jQuery 采用的是构造函数模式进行开发的, jQuery 是一个类

2)上面说的常用的方法(CSS、属性、筛选、事件、动画、文档处理)都是定义在 jQuery.prototype 上的 ->只有 jQuery 的实例才能使用这些方法

2、选择器/筛选

1)我们的选择器其实就是创造 jQuery 类的一个实例 ->获取页面中元素用的 jQuery(); -> \$()

\$()就是 jQuery 的选择器, 就是创建 jQuery 这个类的一个实例

2)执行的时候需要传递两个参数

```
selector -> 选择器的类型 一般都是string类型
context -> 获取的上下文  第二个参数一般不传，不传默认为document
$("#div1")
$(".box")
$("#div1 span") -> $("span", div1)
console.log($("#div1 span:first"))
```

3)通过选择器获取的是一个 jQuery 类的实例->jQuery 对象

```
console. log($( #div1"))

[jQuery对象的私有的属性]

$("#div1")[0] -> div1这个元素对象
S(#div1").selector -> "#div1"
S(#div1").context -> document
("#div1").length-)1 获取元素的个数

[jQuery对象的公有的属性]
jQuery.prototype
```

4)我们获取的是 jQuery 对象(他是 jQuery 的实例)不是我们的原生 js 对象

jQuery:$("#div1")
JS:document.getElementById("div1") 原生JS的对象不能直接的使用jQuery的方法, 同理, jQuery的对象也不能使用原生js的方法
$("#div1").className = "box"; no
document.getElementById("div1").addClass(); 

5)互相转化

```
var $oDiv =$("#div1")
var oDiv = document.getElementById("div1")
Js->jQuery: $(oDiv).addClass()
jQuery->Js: $oDiv[o]/ $oDiv.get(0)
```

3、核心

```js
$(document).ready(function() {
    //HTML结构加载完成就执行这里的代码
});
$(function() {});
```

```
each

$("selector").each( function(){})遍历获取的这些元素 jQuery.prototype
$.each(ary)遍历数组中的每一项 jQuery.each
```

我们的 jQuery 不仅仅是一个类(在它的原型上定义了很多的方法, 每一个 jQuery 的实例都可以使用这些方法), 它还是一个普通的对象, 在 jQuery 本身的属性中还增加了一系列的方法: Ajax、each、工具

\$.unique(ary)

\$.ajax()

```
$.extend()->把 jQuery当做一个对象,给它扩展属性->完善类库

$.fn.extend()->在 jQuery的原型上扩展属性和方法->编写 jQuery插件

$.extend({
    a: function(){

    }
})
$.a()

$.fn.extend({
    b: function(){

    }
})
$().b()
```

[参与互动](https://github.com/yisainan/web-interview/issues/358)

</details>

<b><details><summary>13. 是否知道自定义事件？ jQuery 里的 fire 函数是什么意思，什么时候用？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/359)

</details>

<b><details><summary>14.jQuery 通过哪个方法和 Sizzle 选择器结合的？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/360)

</details>

<b><details><summary>15.jQuery 一个对象可以同时绑定多个事件，这是如何实现的？</summary></b>

参考答案：jQuery 可以给一个对象同时绑定多个事件，低层实现方式是使用 addEventListner 或 attachEvent 兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。

[参与互动](https://github.com/yisainan/web-interview/issues/361)

</details>

<b><details><summary>16. 针对 jQuery 的优化方法？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/362)

</details>

<b><details><summary>17.jQuery UI 如何自定义组件？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/363)

</details>

<b><details><summary>18.jQuery 和 Zepto 的区别？ 各自的使用场景？</summary></b>

参考答案：

01. Zepto 对象 不能自定义事件

```
例如执行： $({}).bind('cust', function(){});
结果：  TypeError: Object has no method 'addEventListener'
解决办法是创建一个脱离文档流的节点作为事件对象：
例如： $('').bind('cust', function(){});
```

02. Zepto 的选择器表达式: [name=value]   中 value 必须用 双引号 "  or 单引号 ' 括起来

```
例如执行：$('[data-userid=123123123]')
结果：Error: SyntaxError: DOM Exception 12
解决办法： $('[data-userid="123123123]"') or \$("[data-userid='123123123']")

2-1.zepto 的选择器没有办法选出 \$("div[name!='abc']") 的元素
2-2.zepto获取select元素的选中option不能用类似jq的方法$('option[selected]'),因为selected属性不是css的标准属性

应该使用$('option').not(function(){ return !this.selected })
比如：jq:$this.find('option[selected]').attr('data-v') * 1
zepto:$this.find('option').not(function() {return !this.selected}).attr('data-v') * 1
但是获取有select中含有disabled属性的元素可以用 $this.find("option:not(:disabled)") 因为disabled是标准属性
参考网址：https://github.com/madrobby/zepto/issues/503

2-3、zepto在操作dom的selected和checked属性时尽量使用prop方法

```

03. Zepto 是根据标准浏览器写的，所以对于节点尺寸的方法只提供 width() 和 height()，省去了 innerWidth(), innerHeight(),outerWidth(),outerHeight()

```
Zepto.js: 由盒模型（ box-sizing ）决定
jQery: 忽略盒模型，始终返回内容区域的宽/高（不包含 padding 、 border ）解决方式就是使用 .css('width') 而不是 .width() 。

3-1.边框三角形宽高的获取
假设用下面的 HTML 和 CSS 画了一个小三角形：
```

```css
<div class="caret"></div>.caret {
    width: 0;
    height: 0;
    border-width: 0 20px 20px;
    border-color: transparent transparent blue;
    border-style: none dotted solid;
}
```

```
jQuery 使用 .width() 和 .css('width') 都返回 ，高度也一样；
Zepto 使用 .width() 返回 ，使用 .css('width') 返回 0px 。
所以，这种场景，jQuery 使用 .outerWidth() / .outerHeight() ；Zepto 使用 .width() / .height() 。

3-2.offset()

Zepto.js: 返回 top 、 left 、 width 、 height
jQuery: 返回 width 、 height

3-3.隐藏元素

Zepto.js: 无法获取宽高；
jQuery: 可以获取。
```

04. Zepto 的 each 方法只能遍历 数组，不能遍历 JSON 对象
05. Zepto 的 animate 方法参数说明 ：详情点击-> [zepto 中 animate 的用法](https://blog.csdn.net/kongjiea/article/details/38534435)

06. zepto 的 jsonp callback 函数名无法自定义

07. DOM 操作区别

jq 代码：

```js
(function($) {
    $(function() {
        var $list = $("<ul><li>jQuery 插入</li></ul>", {
            id: "insert-by-jquery"
        });
        $list.appendTo($("body"));
    });
})(window.jQuery);
```

jQuery 操作 ul 上的 id 不会被添加。

zepto 代码：

```js
Zepto(function($) {
    var $list = $("<ul><li>Zepto 插入</li></ul>", {
        id: "insert-by-zepto"
    });
    $list.appendTo($("body"));
});
```

Zepto 可以在 ul 上添加 id 。

08. 事件触发区别

jq 代码：

```js
(function($) {
    $(function() {
        $script = $("<script />", {
            src: "http://cdn.amazeui.org/amazeui/1.0.1/js/amazeui.min.js",
            id: "ui-jquery"
        });

        $script.appendTo($("body"));

        $script.on("load", function() {
            console.log("jQ script loaded");
        });
    });
})(window.jQuery);
```

使用 jQuery 时 load 事件的处理函数 不会 执行

zepto 代码：

```js
Zepto(function($) {
    $script = $("<script />", {
        src: "http://cdn.amazeui.org/amazeui/1.0.1/js/amazeui.js",
        id: "ui-zepto"
    });

    $script.appendTo($("body"));

    $script.on("load", function() {
        console.log("zepto script loaded");
    });
});
```

使用 Zepto 时 load 事件的处理函数 会 执行。

09. zepto 阻止事件冒泡

10. zepto 的 slideUP 和 slidedown 事件到底部才能触发

```js
document.addEventListener(
    "touchmove",
    function(event) {
        event.preventDefault();
    },
    false
);
```

解析：[参考](https://blog.csdn.net/kongjiea/article/details/42522305#)

[参与互动](https://github.com/yisainan/web-interview/issues/364)

</details>

<b><details><summary>19.jQuery 对象的特点</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/365)

</details>

<b><details><summary>20. Zepto 的点透问题如何解决？</summary></b>

参考答案：点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()；这个时候当点击上面的 div 的时候就会影响到下面的那个 div；
解决办法主要有 2 种：

01. github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应，https://github.com/ftlabs/fastclick
   将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如 require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上，
02. 根据分析，如果不引入其它类库，也不想自己按照上述 fastclcik 的思路再开发一套东西，需要 1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对 click 事件的捕获，在 ios 的 safari，click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被 event.preventDefault()阻止的行为）。

[参与互动](https://github.com/yisainan/web-interview/issues/366)

</details>

<b><details><summary>21. 一个 div，有几种方式得到这个 div 的 jQuery 对象？</summary></b>

`<div class='aabbcc' id='nodesView'></div>` 想直接获取这个 div 的 dom 对象，如何获取？dom 对象如何转化为 jQuery 对象？

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/367)

</details>

<b><details><summary>22.jQuery 框架中\$.ajax()的常用参数有哪些？写一个 post 请求并带有发送数据和返回数据的样例</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/368)

</details>

<b><details><summary>23.jQuery 的优点</summary></b>

参考答案：

1、轻量级

JQuery 非常轻巧，采用 Dean Edwards 编写的 Packer 压缩后，大小不到 30KB, 如果使用 Min 版并且在服务器端启用 Gzip 压缩后，大小只有 18KB。

gzip： 每天一个 linux 命令（32）：gzip 减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起构成 Linux 操作系统中比较流行的压缩文件格式。据统计，gzip 命令对文本文件有 60%～ 70%的压缩率。

2、强大的选择器

JQuery 允许开发者使用从 CSS1 到 CSS3 几乎所有的选择器，以及 JQuery 独创的高级而且复杂的选择器，另外还可以加入插件使其支持 XPath 选择器，甚至开发者可以编写属于自己的选择器。由于 JQuery 支持选择器这一特性，因此有一定 CSS 经验的开发人员可以很容易的切入到 JQuery 的学习中来。

XPath：
XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。

     XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。

     因此，对 XPath 的理解是很多高级 XML 应用的基础。

3、出色的 DOM 操作的封装

JQuery 封装了大量常用的 DOM 操作，使开发者在编写 DOM 操作相关程序的时候能够得心应手。JQuery 轻松地完成各种原本非常复杂的操作，让 JavaScript 新手也能写出出色的程序。

4、可靠的事件处理机制

JQuery 的事件处理机制吸收了 JavaScript 专家 Dean Edwards 编写的事件处理函数的精华，是的 JQuery 在处理事件绑定的时候相当可靠。在预留退路、循序渐进以及非入侵式编程思想方面，JQuery 也做得非常不错。

5、完善的 Ajax

JQuery 将所有的 Ajax 操作封装到一个函数\$.ajax()里，使得开发者处理 Ajax 的时候能够专心处理业务逻辑而无需关心复杂的浏览器兼容性和 XMLHttpRequest 对象的创建和使用的问题。

6、不污染顶级变量

JQuery 只建立一个名为 JQuery 的对象，其所有的函数方法都在这个对象之下。其别名\$也可以随时交流控制权，绝对不会污染其他的对象。该特性是 JQuery 可以与其他 JavaScript 库共存，在项目中放心地引用而不需要考虑到后期的冲突。

7、出色的浏览器兼容性

作为一个流行的 JavaScript 库，浏览器的兼容性是必须具备的条件之一。JQuery 能够在 IE6.0+, FF 2+, Safari2.+和 Opera9.0+下正常运行。JQuery 同时修复了一些浏览器之间的的差异，使开发者不必在开展项目前建立浏览器兼容库。

8、链式操作方式

JQuery 中最有特色的莫过于它的链式操作方式——即对发生在同一个 JQuery 对象上的一组动作，可以直接接连写无需要重复获取对象。这一特点使得 JQuery 的代码无比优雅。

09. 隐式迭代

当用 JQuery 找到带有“.myClass”类的全部元素，然后隐藏他们时。无需循环遍历每一个返回的元素。相反，JQuery 里的方法都被设计成自动操作的对象集合，而不是单独的对象，这使得大量的循环结构变得不再必要，从而大幅度地减少代码量。

10、行为层与结构层的分离

开发者可以使用选择器选中元素，然后直接给元素添加事件。这种将行为层与结构层完全分离的思想，可以使 JQuery 开发人员和 HTML 或其他页面开发人员各司其职，摆脱过去开发冲突或个人单干的开发模式。同时，后期维护也非常方便，不需要在 HTML 代码中寻找某些函数和重复修改 HTML 代码。

11、丰富的插件支持

JQuery 的易扩展性，吸引了来自全球开发者来编写 JQuery 的扩展插件。目前已经有超过几百种官方插件支持，而且还不断有新插件面试。

12、完善的文档

JQuery 的文档非常丰富，现阶段多位英文文档，中文文档相对较少。很多热爱 JQuery 的团队都在努力完善 JQuery 中文文档，例如 JQuery 的中文 API。

13、开源

JQuery 是一个开源的产品，任何人都可以自由地使用并提出修改意见。

[参与互动](https://github.com/yisainan/web-interview/issues/369)

</details>

<b><details><summary>24. Jquery 如何获取子元素</summary></b>

参考答案：

Jquery 获取子元素的方法有 2 种，分别是 children()方法和 find()方法。下面我们分别来使用这两种方法，看看它们有何差异。

解析：

1、children()方法：获取该元素下的直接子集元素

2、find()方法：获取该元素下的所有子集元素

3、children()方法获取最外层 ul 下面直接子集元素 li：\$("#ul").children("li")

需要注意的是，如果 li 元素下还有 li 元素，children 方法将不会被获取。我们可以用 length 来测试获取的个数“\$("#ul").children("li").length”，最后输出结果为 3

4、find()方法获取 ul 下所有元素 li：\$("#ul").find("li")

需要注意的是，find 方法会无限循环查找 ul 标签节点下的 li，一直找到没有为止，用 length 来测试获取个数“\$("#ul").find("li").length”，最后输出结果为 9

5、children 和 find 的区别：children 只会查找直接子集，而 find 会跨越层级查找，一直找到没有为止。

示例：

```html
<ul id="ul">
    <li>
        list1
        <ul>
            <li>
                list1-1
            </li>
            <li>
                list1-2
            </li>
        </ul>
    </li>
    <li>
        list2
        <ul>
            <li>
                list2-1
            </li>
            <li>
                list2-2
            </li>
        </ul>
    </li>
    <li>
        list3
        <ul>
            <li>
                list3-1
            </li>
            <li>
                list3-2
            </li>
        </ul>
    </li>
</ul>
```

```js
console.log($("#ul").find("li").length); // 9
console.log($("#ul").children("li").length); // 3
```

[参与互动](https://github.com/yisainan/web-interview/issues/370)

</details>

<b><details><summary>25.jQuery 库中的 $() 是什么？</summary></b>

参考答案：$() 函数是 jQuery() 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。

</details>

<b><details><summary>26. 如何找到所有 HTML select 标签的选中项？</summary></b>

参考答案：$('[name=selectname] :selected')

</details>

<b><details><summary>27. $(this) 和 this 关键字在 jQuery 中有何不同？</summary></b>

参考答案：

```
$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。

而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。
```

</details>

<b><details><summary>28. jquery怎么移除标签onclick属性？</summary></b>

参考答案：

```
获得a标签的onclick属性: $("a").attr("onclick")
删除onclick属性：$("a").removeAttr("onclick");
设置onclick属性：$("a").attr("onclick","test();");
```

</details>

<b><details><summary>29.jquery中addClass, removeClass, toggleClass的使用。</summary></b>

参考答案：

```
$(selector).addClass(class)：为每个匹配的元素添加指定的类名
$(selector).removeClass(class)：从所有匹配的元素中删除全部或者指定的类，删除class中某个值；
$(selector).toggleClass(class)：如果存在（不存在）就删除（添加）一个类
$(selector).removeAttr(class);删除class这个属性；
```

</details>

<b><details><summary>30. JQuery有几种选择器?</summary></b>

参考答案：

```
(1)、基本选择器：#id，class,element,*;
(2)、层次选择器：parent > child，prev + next ，prev ~ siblings
(3)、基本过滤器选择器：:first，:last ，:not ，:even ，:odd ，:eq ，:gt ，:lt
(4)、内容过滤器选择器： :contains ，:empty ，:has ，:parent
(5)、可见性过滤器选择器：:hidden ，:visible
(6)、属性过滤器选择器：[attribute] ，[attribute=value] ，[attribute!=value] ，[attribute^=value] ，[attribute$=value] ，[attribute*=value]
(7)、子元素过滤器选择器：:nth-child ，:first-child ，:last-child ，:only-child
(8)、表单选择器： :input ，:text ，:password ，:radio ，:checkbox ，:submit 等；
(9)、表单过滤器选择器：:enabled ，:disabled ，:checked ，:selected
```

</details>

<b><details><summary>31.jQuery中的Delegate()函数有什么作用？</summary></b>

参考答案：

```
delegate()会在以下两个情况下使用到：
 1、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：
$("ul").delegate("li", "click", function(){ $(this).hide(); });
 2、当元素在当前页面中不可用时，可以使用delegate()
```

</details>

<b><details><summary>32. 如何用jQuery禁用浏览器的前进后退按钮？</summary></b>

参考答案：

```js
< script type = "text/javascript"
language = "javascript" >
    $(document).ready(function() {
        window.history.forward(1);
        //OR window.history.forward(-1);
    }); <
/script>
```

</details>

<b><details><summary>33. jquery中$.get()提交和$.post()提交有区别吗？</summary></b>

参考答案：

```
相同点：都是异步请求的方式来获取服务端的数据；
异同点：
1、请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。
2、参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。
3、数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多
4、安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。
```

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1.document load 和 document ready 的区别</summary></b>

参考答案：文档解析过程中，ready在加载图片等外部资源前触发，load在之后触发。如果页面中要是没有图片之类的媒体文件的话ready与load是差不多的，但是页面中有文件就不一样了，所以还是推荐大家在工作中用ready

解析：

DOM文档解析：

1. 解析html结构
2. 加载脚本和样式文件
3. 解析并执行脚本
4. 构造html的DOM模型 // ready
5. 加载图片等外部资源文件
6. 页面加载完毕 // load

页面加载完成有两种事件

1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数

缺点：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响

代码形式：

```js
//document load
$(document).load(function(){
    ...code...
})
```

2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行

在原生的jS中不包括ready()这个方法，Jquery才有，jquery中有 $().ready(function)。

代码形式为：

```js
//document ready
$(document).ready(function(){
    ...code...
})
//document ready 简写
$(function(){
    ...code...
})
```

[参与互动](https://github.com/yisainan/web-interview/issues/170)

</details>

<b><details><summary>2.JavaScript 中如何检测一个变量是一个 String 类型？</summary></b>

参考答案：三种方法（typeof、constructor、Object.prototype.toString.call()）

解析：

```js
①
typeof

typeof('123') === "string" // true

typeof '123' === "string" // true

②
constructor

    '123'.constructor === String // true

③ Object.prototype.toString.call()

Object.prototype.toString.call('123') === '[object String]' // true
```

[参与互动](https://github.com/yisainan/web-interview/issues/171)

</details>

<b><details><summary>3.请用 js 去除字符串空格？</summary></b>

参考答案：replace 正则匹配方法、str.trim()方法、JQ 方法：\$.trim(str)方法

解析：

方法一：replace 正则匹配方法

去除字符串内所有的空格：str = str.replace(/\s\*/g, ""); 

去除字符串内两头的空格：str = str.replace(/^\s*|\s*\$/g, ""); 

去除字符串内左侧的空格：str = str.replace(/^\s\*/, ""); 

去除字符串内右侧的空格：str = str.replace(/(\s\*\$)/g, ""); 

示例：

```js
var str = " 6 6 ";
var str_1 = str.replace(/\s*/g, "");
console.log(str_1); //66

var str = " 6 6 ";
var str_1 = str.replace(/^\s*|\s*$/g, "");
console.log(str_1); //6 6//输出左右侧均无空格

var str = " 6 6 ";
var str_1 = str.replace(/^\s*/, "");
console.log(str_1); //6 6 //输出右侧有空格左侧无空格

var str = " 6 6 ";
var str_1 = str.replace(/(\s*$)/g, "");
console.log(str_1); // 6 6//输出左侧有空格右侧无空格
```

方法二：str.trim()方法

trim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串。

缺陷：只能去除字符串两端的空格，不能去除中间的空格

示例：

```js
var str = " 6 6 ";
var str_1 = str.trim();
console.log(str_1); //6 6//输出左右侧均无空格
```

方法三：JQ 方法：\$.trim(str)方法

\$.trim() 函数用于去除字符串两端的空白字符。

注意：\$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。

示例：

```js
var str = " 6 6 ";
var str_1 = $.trim(str);
console.log(str_1); //6 6//输出左右侧均无空格
```

[参与互动](https://github.com/yisainan/web-interview/issues/172)

</details>

<b><details><summary>4.js 是一门怎样的语言，它有什么特点</summary></b>

参考答案：

1\.脚本语言。JavaScript 是一种解释型的脚本语言, C、C\+\+等语言先编译后执行, 而 JavaScript 是在程序的运行过程中逐行进行解释。

2\.基于对象。JavaScript 是一种基于对象的脚本语言, 它不仅可以创建对象, 也能使用现有的对象。

3\.简单。JavaScript 语言中采用的是弱类型的变量类型, 对使用的数据类型未做出严格的要求, 是基于 Java 基本语句和控制的脚本语言, 其设计简单紧凑。

4\.动态性。JavaScript 是一种采用事件驱动的脚本语言, 它不需要经过 Web 服务器就可以对用户的输入做出响应。

5\.跨平台性。JavaScript 脚本语言不依赖于操作系统, 仅需要浏览器的支持。

[参与互动](https://github.com/yisainan/web-interview/issues/173)

</details>

<b><details><summary>5.== 和 === 的不同</summary></b>

参考答案： `==` 是抽象相等运算符，而 `===` 是严格相等运算符。 `==` 运算符是在进行必要的类型转换后，再比较。 `===` 运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回 `false` 。使用 `==` 时，可能发生一些特别的事情，例如：

```js
1 == "1"; // true
1 == [1]; // true
1 == true; // true
0 == ""; // true
0 == "0"; // true
0 == false; // true
```

如果你对 `==` 和 `===` 的概念不是特别了解，建议大多数情况下使用 `===`

[参与互动](https://github.com/yisainan/web-interview/issues/174)

</details>

<b><details><summary>6.怎样添加、移除、移动、复制、创建和查找节点？</summary></b>

参考答案：

1）创建新节点

* createDocumentFragment() //创建一个 DOM 片段
* createElement() //创建一个具体的元素
* createTextNode() //创建一个文本节点

2）添加、移除、替换、插入

* appendChild() //添加
* removeChild() //移除
* replaceChild() //替换
* insertBefore() //插入

3）查找

* getElementsByTagName() //通过标签名称
* getElementsByName() //通过元素的 Name 属性的值
* getElementById() //通过元素 Id，唯一性

[参与互动](https://github.com/yisainan/web-interview/issues/175)

</details>

<b><details><summary>7.事件委托是什么</summary></b>

参考答案：利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！

解析：

1、那什么样的事件可以用事件委托，什么样的事件不可以用呢？

* 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。
* 值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。
* 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不用事件委托了。

2、为什么要用事件委托

* 1.提高性能

```

<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

// good
document.querySelector('ul').onclick = (event) => {
  let target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
})
```

* 2.新添加的元素还会有之前的事件。

3、事件冒泡与事件委托的对比

* 事件冒泡：box 内部无论是什么元素，点击后都会触发 box 的点击事件
* 事件委托：可以对 box 内部的元素进行筛选

4、事件委托怎么取索引？

```html
    <ul id="ul">
        <li> aaaaaaaa </li>
        <li> 事件委托了 点击当前， 如何获取 这个点击的下标 </li>
        <li> cccccccc </li>
    </ul>
```

```js
    window.onload = function() {
        var oUl = document.getElementById("ul");
        var aLi = oUl.getElementsByTagName("li");
        oUl.onclick = function(ev) {
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if (target.nodeName.toLowerCase() == "li") {
                var that = target;
                var index;
                for (var i = 0; i < aLi.length; i++)
                    if (aLi[i] === target) index = i;
                if (index >= 0) alert('我的下标是第' + index + '个');
                target.style.background = "red";
            }
        }
    }
```

拓展：

* 键盘事件：keydown keypress keyup
* 鼠标事件：mousedown mouseup mousemove mouseout mouseover

[参考](https://github.com/qiilee/js/tree/master/JS/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98)

[参与互动](https://github.com/yisainan/web-interview/issues/176)

</details>

<b><details><summary>8.require 与 import 的区别</summary></b>

参考答案：两者的加载方式不同、规范不同

第一、两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载

require('./a')(); // a 模块是一个函数，立即执行 a 模块函数

var data = require('./a').data; // a 模块导出的是一个对象

var a = require('./a')[0]; // a 模块导出的是一个数组 ======> 哪都行

import \$ from 'jquery'; 

import \* as _ from '_'; 

import {a, b, c} from './a'; 

import {default as alias, a as a_a, b, c} from './a'; ======>用在开头

第二、规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范

第三、require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。

import 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。

[参与互动](https://github.com/yisainan/web-interview/issues/177)

</details>

<b><details><summary>9.javascript 对象的几种创建方式</summary></b>

参考答案：

第一种：Object 构造函数创建

```js
var Person = new Object();
Person.name = "Nike";
Person.age = 29;
```

这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。

第二种：使用对象字面量表示法

```js
var Person = {}; //相当于 var Person = new Object();
var Person = {
    name: 'Nike';
    age: 29;
}
```

对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同

在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。

第三种：使用工厂模式创建对象

```js
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        alert(this.name);
    };
    return o;
}
var person1 = createPerson("Nike", 29, "teacher");
var person2 = createPerson("Arvin", 20, "student");
```

在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。

第四种: 使用构造函数创建对象

```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        alert(this.name);
    };
}
var person1 = new Person("Nike", 29, "teacher");
var person2 = new Person("Arvin", 20, "student");
```

对比工厂模式，我们可以发现以下区别：

1\.没有显示地创建对象

2\.直接将属性和方法赋给了 this 对象

3\.没有 return 语句

4\.终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测：

```js
alert(person1 instanceof Object); //ture

alert(person1 instanceof Person); //ture

alert(person2 instanceof Object); //ture

alert(person2 instanceof Object); //ture
```

同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。

那么构造函数确实挺好用的，但是它也有它的缺点：

就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法

第五种：原型创建对象模式

```js
function Person() {}
Person.prototype.name = "Nike";
Person.prototype.age = 20;
Person.prototype.jbo = "teacher";
Person.prototype.sayName = function() {
    alert(this.name);
};
var person1 = new Person();
person1.sayName();
```

使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。

如果是使用原型创建对象模式，请看下面代码：

```js
function Person() {}
Person.prototype.name = "Nike";
Person.prototype.age = 20;
Person.prototype.jbo = "teacher";
Person.prototype.sayName = function() {
    alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
person1.name = "Greg";
alert(person1.name); //'Greg' --来自实例
alert(person2.name); //'Nike' --来自原型
```

当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。

这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性

第六种：组合使用构造函数模式和原型模式

```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}
Person.prototype = {
    constructor: Person,
    sayName: function() {
        alert(this.name);
    };
}
var person1 = new Person('Nike', 20, 'teacher');
```

解析：
[参考](https://zhidao.baidu.com/question/1180348878138910499.html)

[参与互动](https://github.com/yisainan/web-interview/issues/178)

</details>

<b><details><summary>10.JavaScript 继承的方式和优缺点</summary></b>

参考答案：六种方式

* 一、原型链继承

  + 缺点：
  + 1.引用类型的属性被所有实例共享
  + 2.在创建 Child 的实例时，不能向 Parent 传参

* 二、借用构造函数(经典继承)

  + 优点：
  + 1.避免了引用类型的属性被所有实例共享
  + 2.可以在 Child 中向 Parent 传参

  + 缺点：
  + 1.方法都在构造函数中定义，每次创建实例都会创建一遍方法。

* 三、组合继承

  + 优点：
  + 1.融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

* 四、原型式继承

  + 缺点：
  + 1.包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

* 五、寄生式继承

  + 缺点：
  + 1.跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

* 六、寄生组合式继承
  + 优点：
  + 1.这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。
  + 2.与此同时，原型链还能保持不变；
  + 3.因此，还能够正常使用 instanceof 和 isPrototypeOf。
  + 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式

解析：[参考](https://www.jianshu.com/p/09ad43c7fe8f)

[参与互动](https://github.com/yisainan/web-interview/issues/179)

</details>

<b><details><summary>11.什么是原型链？ </summary></b>

参考答案：通过一个对象的__proto__可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的__proto__，最后找到了我们的 Object.prototype, 从实例的原型对象开始一直到 Object.prototype 就是我们的原型链

解析：

![js_001](../../images/js_001.png)
![js_005](../../images/js_005.png)

[参与互动](https://github.com/yisainan/web-interview/issues/180)

</details>

<b><details><summary>12.复杂数据类型如何转变为字符串 </summary></b>

参考答案：

* 首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值，
* 如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法，
* 如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，
* 如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。

解析：

```js
// 1;
var obj = {
    valueOf: function() {
        return 1;
    }
};
console.log(obj + ""); //'1'
// 2;
var obj = {
    valueOf: function() {
        return [1, 2];
    }
};
console.log(obj + ""); //'[object Object]';
// 3;
var obj = {
    valueOf: function() {
        return [1, 2];
    },
    toString: function() {
        return 1;
    }
};
console.log(obj + ""); //'1';
// 4;
var obj = {
    valueOf: function() {
        return [1, 2];
    },
    toString: function() {
        return [1, 2, 3];
    }
};
console.log(obj + ""); // 报错 Uncaught TypeError: Cannot convert object to primitive value
```

拓展：

```js
var arr = [new Object(), new Date(), new RegExp(), new String(), new Number(), new Boolean(), new Function(), new Array(), Math] console.log(arr.length) // 9
for (var i = 0; i < arr.length; i++) {
    arr[i].valueOf = function() {
        return [1, 2, 3]
    }
    arr[i].toString = function() {
        return 'toString'
    }
    console.log(arr[i] + '')
}
```

1、若 return [1, 2, 3]处为 return "valueof"，得到的返回值是 valueof toString 7valueof
说明：其他八种复杂数据类型是先调用 valueOf 方法，时间对象是先调用 toString 方法

2、改成 return [1, 2, 3]，得到的返回值是 9toString
说明：执行 valueof 后都来执行 toString

[参与互动](https://github.com/yisainan/web-interview/issues/181)

</details>

<b><details><summary>13.javascript 的 typeof 返回哪些数据类型</summary></b>

参考答案：7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)、

示例：

1、number

```js
typeof(10);
typeof(NaN); // NaN在JavaScript中代表的是特殊非数字值,它本身是一个数字类型。
typeof(Infinity)
```

2、boolean

```js
typeof(true);
typeof(false);
```

3、string

```js
typeof("abc");
```

4、undefined

```js
typeof(undefined);
typeof(a); // 不存在的变量
```

5、object

```js
// 对象，数组，null返回object
typeof(null);
typeof(window);
```

6、function

```js
typeof(Array);
typeof(Date);
```

7、symbol

```js
typeof Symbol() // ES6提供的新的类型
```

[参与互动](https://github.com/yisainan/web-interview/issues/182)

</details>

<b><details><summary>14.一次js请求一般情况下有哪些地方会有缓存处理？</summary></b>

参考答案：DNS缓存，CDN缓存，浏览器缓存，服务器缓存。

解析：

#### 1、DNS缓存

DNS缓存指DNS返回了正确的IP之后，系统就会将这个结果临时储存起来。并且它会为缓存设定一个失效时间 (例如N小时)，在这N小时之内，当你再次访问这个网站时，系统就会直接从你电脑本地的DNS缓存中把结果交还给你，而不必再去询问DNS服务器，变相“加速”了网址的解析。当然，在超过N小时之后，系统会自动再次去询问DNS服务器获得新的结果。
所以，当你修改了 DNS 服务器，并且不希望电脑继续使用之前的DNS缓存时，就需要手动去清除本地的缓存了。

本地DNS迟迟不生效或者本地dns异常等问题，都会导致访问某些网站出现无法访问的情况，这个时候我们就需要手动清除本地dns缓存，而不是等待！

#### 2、CDN缓存

和Http类似，客户端请求数据时，先从本地缓存查找，如果被请求数据没有过期，拿过来用，如果过期，就向CDN边缘节点发起请求。CDN便会检测被请求的数据是否过期，如果没有过期，就返回数据给客户端，如果过期，CDN再向源站发送请求获取新数据。和买家买货，卖家没货，卖家再进货一个道理^^。

CDN边缘节点缓存机制，一般都遵守http标准协议，通过http响应头中的Cache-Control和max-age的字段来设置CDN边缘节点的数据缓存时间。

#### 3、浏览器缓存

浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。

浏览器缓存主要有两类：缓存协商：Last-modified ，Etag 和彻底缓存：cache-control，Expires。浏览器都有对应清除缓存的方法。

#### 4、服务器缓存

服务器缓存有助于优化性能和节省宽带，它将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。

[参与互动](https://github.com/yisainan/web-interview/issues/183)

</details>

<b><details><summary>15.列举 3 种强制类型转换和 2 种隐式类型转换</summary></b>

参考答案：

强制: parseInt(), parseFloat(), Number(), Boolean(), String()

隐式: +, -

解析：

```js
// 1.parseInt() 把值转换成整数
parseInt("1234blue"); // 1234
parseInt("0xA"); // 10
parseInt("22.5"); // 22
parseInt("blue"); // NaN
// parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：
parseInt("AF", 16); // 175
parseInt("10", 2); // 2
parseInt("10", 8); // 8
parseInt("10", 10); // 10
// 如果十进制数包含前导0，那么最好采用基数10，这样才不会意外地得到八进制的值。例如：
parseInt("010"); // 8
parseInt("010", 8); // 8
parseInt("010", 10); // 10

// 2.parseFloat() 把值转换成浮点数,没有基模式
parseFloat("1234blue"); // 1234.0
parseFloat("0xA"); // NaN
parseFloat("22.5"); // 22.5
parseFloat("22.34.5"); // 22.34
parseFloat("0908"); // 908
parseFloat("blue"); // NaN

// 3.Number() 把给定的值转换成数字（可以是整数或浮点数）,Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。示例如下：
Number(false) // 0
Number(true) // 1
Number(undefined) // NaN
Number(null) // 0
Number("5.5") // 5.5
Number("56") // 56
Number("5.6.7") // NaN
Number(new Object()) // NaN
Number(100) // 100

// 4.Boolean() 把给定的值转换成Boolean型
Boolean(""); // false 
Boolean("hi"); // true
Boolean(100); // true
Boolean(null); // false
Boolean(0); // false
Boolean(new Object()); // true

// 5.String() 把给定的值转换成字符串
String(123) // "123"

// 6.+ -
console.log(0 + '1') // "01"
console.log(2 - '1') // 1
```

[参与互动](https://github.com/yisainan/web-interview/issues/184)

</details>

<b><details><summary>16.你对闭包的理解？优缺点？</summary></b>

参考答案：

概念：闭包就是能够读取其他函数内部变量的函数。

三大特性：

* 函数嵌套函数。
* 函数内部可以引用外部的参数和变量。
* 参数和变量不会被垃圾回收机制回收。

优点：

* 希望一个变量长期存储在内存中。
* 避免全局变量的污染。
* 私有成员的存在。

缺点：

* 常驻内存，增加内存使用量。
* 使用不当会很容易造成内存泄露。

示例：

```js
function outer() {
    var name = "jack";

    function inner() {
        console.log(name);
    }
    return inner;
}
outer()(); // jack
```

```js
function sayHi(name) {
    return () => {
        console.log(`Hi! ${name}`);
    };
}
const test = sayHi("xiaoming");
test(); // Hi! xiaoming
```

虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。<br>
但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。

解析：

由于在 ECMA2015 中，只有函数才能分割作用域，函数内部可以访问当前作用域的变量，但是外部无法访问函数内部的变量，所以闭包可以理解成“定义在一个函数内部的函数，外部可以通过内部返回的函数访问内部函数的变量“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

[参与互动](https://github.com/yisainan/web-interview/issues/185)

</details>

<b><details><summary>17.如何判断 NaN</summary></b>

参考答案：isNaN()方法

解析：isNaN(NaN) // true

[参与互动](https://github.com/yisainan/web-interview/issues/186)

</details>

<b><details><summary>18.new 一个对象的过程中发生了什么</summary></b>

参考答案：

```js
function Person(name) {
    this.name = name;
}
var person = new Person("qilei");
```

new一个对象的四个过程：

```js
// 1.创建空对象；
var obj = {};
// 2.设置原型链: 设置新对象的 constructor 属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的 prototype 对象；
obj.constructor = Person;
obj.__proto__ = Person.prototype;
// 3.改变this指向：使用新对象调用函数，函数中的 this 指向新实例对象obj：
var result = Person.call(obj); //{}.构造函数();
// 4.返回值：如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接返回该对象。
if (typeof(result) == "object") {
    person = result;
} else {
    person = obj;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/187)

</details>

<b><details><summary>19.for in 和 for of的区别</summary></b>

参考答案：

1、for in

* 1.一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。
* 2.不建议使用 for in 遍历数组，因为输出的顺序是不固定的。
* 3.如果迭代的对象的变量值是 null 或者 undefined, for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是 null 或者 undefined。

2、for of

* 1.for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。

解析：

```js
var s = {
    a: 1,
    b: 2,
    c: 3
};
var s1 = Object.create(s);
for (var prop in s1) {
    console.log(prop); //a b c
    console.log(s1[prop]); //1 2 3
}
for (let prop of s1) {
    console.log(prop); //报错如下 Uncaught TypeError: s1 is not iterable
}
for (let prop of Object.keys(s1)) {
    console.log(prop); // a b c
    console.log(s1[prop]); //1 2 3
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/188)

</details>

<b><details><summary>20.如何判断 JS 变量的一个类型（至少三种方式）</summary></b>

参考答案：typeof、instanceof、 constructor、 prototype

解析：

1、typeof

typeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型。如果是判断一个基本的类型用typeof就是可以的。

```js
typeof ''; // string 有效
typeof 1; // number 有效
typeof true; //boolean 有效
typeof undefined; //undefined 有效
typeof null; //object 无效
typeof []; //object 无效
typeof new Function(); // function 有效
typeof new Date(); //object 无效
typeof new RegExp(); //object 无效
```

2、instanceof

instanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true, 否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，

```js
[] instanceof Array; //true
{}
instanceof Object; //true
new Date() instanceof Date; //true
```

3、constractor

每一个对象实例都可以通过 constrcutor 对象来访问它的构造函数 。JS 中内置了一些构造函数：Object、Array、Function、Date、RegExp、String等。我们可以通过数据的 constrcutor 是否与其构造函数相等来判断数据的类型。

```js
var arr = [];
var obj = {};
var date = new Date();
var num = 110;
var str = 'Hello';
var getName = function() {};
var sym = Symbol();
var set = new Set();
var map = new Map();

arr.constructor === Array; // true
obj.constructor === Object; // true
date.constructor === Date; // true
str.constructor === String; // true
getName.constructor === Function; // true
sym.constructor === Symbol; // true
set.constructor === Set; // true
map.constructor === Map // true
```

4、Object.prototype.toString

toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object, xxx], xxx是具体的数据类型，其中包括：String, Number, Boolean, Undefined, Null, Function, Date, Array, RegExp, Error, HTMLDocument, ...基本上所有对象的类型都可以通过这个方法获取到。

```js
Object.prototype.toString.call(''); // [object String]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(undefined); // [object Undefined]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(new Function()); // [object Function]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call([]); // [object Array]
Object.prototype.toString.call(new RegExp()); // [object RegExp]
Object.prototype.toString.call(new Error()); // [object Error]
```

[参与互动](https://github.com/yisainan/web-interview/issues/189)

</details>

<b><details><summary>21.for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？</summary></b>

参考答案：

* for in 会遍历自身及原型链上的可枚举属性
* Object.keys 会将对象自身的可枚举属性的 key 输出
* Object.getOwnPropertyNames会将自身所有的属性的 key 输出

解析：

ECMAScript 将对象的属性分为两种：数据属性和访问器属性。

```js
var parent = Object.create(Object.prototype, {
    a: {
        value: 123,
        writable: true,
        enumerable: true,
        configurable: true
    }
});
// parent继承自Object.prototype，有一个可枚举的属性a（enumerable:true）。

var child = Object.create(parent, {
    b: {
        value: 2,
        writable: true,
        enumerable: true,
        configurable: true
    },
    c: {
        value: 3,
        writable: true,
        enumerable: false,
        configurable: true
    }
});
//child 继承自 parent ，b可枚举，c不可枚举
```

### for in

```js
for (var key in child) {
    console.log(key);
}
// b
// a
// for in 会遍历自身及原型链上的可枚举属性
```

如果只想输出自身的可枚举属性，可使用 hasOwnProperty 进行判断(数组与对象都可以，此处用数组做例子)

```js
let arr = [1, 2, 3];
Array.prototype.xxx = 1231235;
for (let i in arr) {
    if (arr.hasOwnProperty(i)) {
        console.log(arr[i]);
    }
}
// 1
// 2
// 3
```

### Object.keys

```js
console.log(Object.keys(child));
// ["b"]
// Object.keys 会将对象自身的可枚举属性的key输出
```

### Object.getOwnPropertyNames

```js
console.log(Object.getOwnPropertyNames(child));
// ["b","c"]
// 会将自身所有的属性的key输出
```

[参与互动](https://github.com/yisainan/web-interview/issues/190)

</details>

<b><details><summary>22.iframe 跨域通信和不跨域通信</summary></b>

参考答案：

### 不跨域通信

主页面

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title></title>
</head>

<body>
    <iframe name="myIframe" id="iframe" class="" src="flexible.html" width="500px" height="500px">
    </iframe>
</body>
<script type="text/javascript" charset="utf-8">
    function fullscreen() {
        alert(1111);
    }
</script>

</html>
```

子页面 flexible.html

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title></title>
</head>

<body>
    我是子页面
</body>
<script type="text/javascript" charset="utf-8">
    // window.parent.fullScreens()
    function showalert() {
        alert(222);
    }
</script>

</html>
```

1、主页面要是想要调取子页面的 showalert 方法

```js
myIframe.window.showalert();
```

2、子页面要掉主页面的 fullscreen 方法

```js
window.parent.fullScreens();
```

3、js 在 iframe 子页面获取父页面元素:

```js
window.parent.document.getElementById("元素id");
```

4、js 在父页面获取 iframe 子页面元素代码如下:

```js
window.frames["iframe_ID"].document.getElementById("元素id");
```

### 跨域通信

使用[postMessage(官方用法）](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)

子页面

```js
window.parent.postMessage("hello", "http://127.0.0.1:8089");
```

父页面接收

```js
window.addEventListener("message", function(event) {
    alert(123);
});
```

解析：[参考](https://blog.csdn.net/weixin_41229588/article/details/93719894)

[参与互动](https://github.com/yisainan/web-interview/issues/191)

</details>

<b><details><summary>23.H5 与 Native 如何交互</summary></b>

参考答案：jsBridge

解析：[参考](https://segmentfault.com/a/1190000010356403)

[参与互动](https://github.com/yisainan/web-interview/issues/192)

</details>

<b><details><summary>24.如何判断一个对象是否为数组</summary></b>

参考答案：

第一种方法：使用 instanceof 操作符。

第二种方法：使用 ECMAScript 5 新增的 Array.isArray()方法。

第三种方法：使用使用 Object.prototype 上的原生 toString()方法判断。

[参与互动](https://github.com/yisainan/web-interview/issues/193)

</details>

<b><details><summary>25.`<script>` 标签的 defer 和 asnyc 属性的作用以及二者的区别？</summary></b>

参考答案：

* 1、defer 和 async 的网络加载过程是一致的，都是异步执行。
* 2、区别在于加载完成之后什么时候执行，可以看出 defer 是文档所有元素解析完成之后才执行的。
* 3、如果存在多个 defer 脚本，那么它们是按照顺序执行脚本的，而 async，无论声明顺序如何，只要加载完成就立刻执行

解析：

无论 `<script>` 标签是嵌入代码还是引用外部文件，只要不包含 defer 属性和 async 属性（这两个属性只对外部文件有效），浏览器会按照 `<script>` 的出现顺序对他们依次进行解析，也就是说，只有在第一个 `<script>` 中的代码执行完成之后，浏览器才会执行第二个 `<script>` 中的代码，并且在解析时，页面的处理会暂时停止。

嵌入代码的解析=执行
外部文件的解析=下载+执行

script 标签存在两个属性，defer 和 async，这两个属性只对外部文件有效

## 只有一个脚本的情况

```

<script src = "a.js" />
```

没有 defer 或 async 属性，浏览器会立即下载并执行相应的脚本，并且在下载和执行时页面的处理会停止。

```

<script defer src = "a.js" />
```

有了 defer 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，等到文档解析完成脚本才会执行。

```

<script async src = "a.js" />
```

有了 async 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，下载完成后立即执行，执行过程中页面处理会停止。

```

<script defer async src = "a.js" />
```

如果同时指定了两个属性, 则会遵从 async 属性而忽略 defer 属性。

下图可以直观的看出三者之间的区别:

![js_002](../../images/js_002.png)

其中蓝色代表 js 脚本网络下载时间，红色代表 js 脚本执行，绿色代表 html 解析。

## 多个脚本的情况

这里只列举两个脚本的情况：

```

<script src = "a.js"> </script>
<script src = "b.js"> </script>
```

没有 defer 或 async 属性，浏览器会立即下载并执行脚本 a.js，在 a.js 脚本执行完成后才会下载并执行脚本 b.js，在脚本下载和执行时页面的处理会停止。

```

<script defer src = "a.js"> </script>
<script defer src = "b.js"> </script>
```

有了 defer 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，等到文档解析完成才会执行这两个脚本。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。
在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。

```

<script async src = "a.js"> </script>
<script async src = "b.js"> </script>
```

有了 async 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，a.js 和 b.js 哪个先下载完成哪个就立即执行，执行过程中页面处理会停止，但是其他脚本的下载不会停止。标记为 async 的脚本并不保证按照制定它们的先后顺序执行。异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。

[参考](https://blog.csdn.net/weixin_42561383/article/details/86564715)

[参与互动](https://github.com/yisainan/web-interview/issues/194)

</details>

<b><details><summary>26.Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏</summary></b>

参考答案：

* Object.prototype.toString.call()
  + 优点：这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。
  + 缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]
* instanceOf
  + 优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。
  + 缺点： instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。
* Array.isArray()
  + 优点：当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes
  + 缺点：只能判别数组

解析：

### Object.prototype.toString.call()

每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。

```js
const an = ["Hello", "An"];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"
```

这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

```js
Object.prototype.toString.call("An"); // "[object String]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call(Symbol(1)); // "[object Symbol]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(function() {}); // "[object Function]"
Object.prototype.toString.call({
    name: "An"
}); // "[object Object]"
```

缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]

```js
function f(name) {
    this.name = name;
}
var f1 = new f("martin");
console.log(Object.prototype.toString.call(f1)); //[object Object]

Object.prototype.toString.call(); // 常用于判断浏览器内置对象。
```

### instanceof

instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。

```js
[] instanceof Array; // true
```

但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```js
[] instanceof Object; // true
```

优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。

缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。

```js
function f(name) {
    this.name = name;
}
var f1 = new f("martin");
console.log(f1 instanceof f); //true
```

### Array.isArray()

* 功能：用来判断对象是否为数组

* instanceof 与 isArray

当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes

```js
var iframe = document.createElement("iframe");
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length - 1].Array;
var arr = new xArray(1, 2, 3); // [1,2,3]

// Correctly checking for Array
Array.isArray(arr); // true
Object.prototype.toString.call(arr); // true
// Considered harmful, because doesn't work though iframes
arr instanceof Array; // false
```

缺点：只能判别数组

* Array.isArray() 与 Object.prototype.toString.call()

Array.isArray()是 ES5 新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。

```js
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
    };
}
```

[参考](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23)

[参与互动](https://github.com/yisainan/web-interview/issues/195)

</details>

<b><details><summary>27.什么是面向对象？</summary></b>

参考答案：面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

解析：

* 面向对象和面向过程的异同
  + 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
  + 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

[参与互动](https://github.com/yisainan/web-interview/issues/196)

</details>

<b><details><summary>28.你对松散类型的理解</summary></b>

参考答案：

JavaScript 中的变量为松散类型，所谓松散类型就是指当一个变量被申明出来就可以保存任意类型的值，就是不像 SQL 一样申明某个键值为 int 就只能保存整型数值，申明 varchar 只能保存字符串。一个变量所保存值的类型也可以改变，这在 JavaScript 中是完全有效的，只是不推荐。相比较于将变量理解为“盒子“，《JavaScript 编程精解》中提到应该将变量理解为“触手”，它不保存值，而是抓取值。这一点在当变量保存引用类型值时更加明显。

JavaScript 中变量可能包含两种不同的数据类型的值：基本类型和引用类型。基本类型是指简单的数据段，而引用类型指那些可能包含多个值的对象。

[参与互动](https://github.com/yisainan/web-interview/issues/197)

</details>

<b><details><summary>29.JS 严格模式和正常模式</summary></b>

参考答案：严格模式使用"use strict"; 

作用：

* 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 
* 消除代码运行的一些不安全之处，保证代码运行的安全；
* 提高编译器效率，增加运行速度；
* 为未来新版本的 Javascript 做好铺垫。

表现：

* 严格模式下, delete 运算符后跟随非法标识符(即 delete 不存在的标识符)，会抛出语法错误； 非严格模式下，会静默失败并返回 false
* 严格模式中，对象直接量中定义同名属性会抛出语法错误； 非严格模式不会报错
* 严格模式中，函数形参存在同名的，抛出错误； 非严格模式不会
* 严格模式不允许八进制整数直接量（如：023）
* 严格模式中，arguments 对象是传入函数内实参列表的静态副本；非严格模式下，arguments 对象里的元素和对应的实参是指向同一个值的引用
* 严格模式中 eval 和 arguments 当做关键字，它们不能被赋值和用作变量声明
* 严格模式会限制对调用栈的检测能力，访问 arguments.callee.caller 会抛出异常
* 严格模式 变量必须先声明，直接给变量赋值，不会隐式创建全局变量，不能用 with, 
* 严格模式中 call apply 传入 null undefined 保持原样不被转换为 window

解析：

一、概述

除了正常运行模式，ECMAscript 5 添加了第二种运行模式："严格模式"（strict mode）。顾名思义，这种模式使得 Javascript 在更严格的条件下运行。

设立"严格模式"的目的，主要有以下几个：

* 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 

* 消除代码运行的一些不安全之处，保证代码运行的安全；

* 提高编译器效率，增加运行速度；

* 为未来新版本的 Javascript 做好铺垫。

"严格模式"体现了 Javascript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。

另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内容，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。

本文将对"严格模式"做详细介绍。

二、进入标志

进入"严格模式"的标志，是下面这行语句：

"use strict"; 

老版本的浏览器会把它当作一行普通字符串，加以忽略。

三、如何调用

"严格模式"有两种调用方法，适用于不同的场合。

3\.1 针对整个脚本文件

将"use strict"放在脚本文件的第一行，则整个脚本都将以"严格模式"运行。如果这行语句不在第一行，则无效，整个脚本以"正常模式"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。

(严格地说，只要前面不是产生实际运行结果的语句，"use strict"可以不在第一行，比如直接跟在一个空的分号后面。)

```

　　<script>
　　　　"use strict";
　　　　console.log("这是严格模式。");
　　</script>

　　<script>
　　　　console.log("这是正常模式。");kly, it's almost 2 years ago now.I can admit it now - I run it on my school's network that has about 50 computers.
　　</script>
```

上面的代码表示，一个网页中依次有两段 Javascript 代码。前一个 script 标签是严格模式，后一个不是。

3\.2 针对单个函数

将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行。

```js
function strict() {
    "use strict";
    return "这是严格模式。";
}

function notStrict() {
    return "这是正常模式。";
}
```

3\.3 脚本文件的变通写法

因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。

```js
(function() {
    "use strict"; // some code here

})();
```

四、语法和行为改变

严格模式对 Javascript 的语法和行为，都做了一些改变。

4\.1 全局变量显式声明

在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

```js
"use strict";

v = 1; // 报错，v未声明

for (i = 0; i < 2; i++) {
    // 报错，i未声明
}
```

因此，严格模式下，变量都必须先用 var 命令声明，然后再使用。

4\.2 静态绑定

Javascript 语言的一个特点，就是允许"动态绑定"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。

严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。

具体来说，涉及以下几个方面。

（1）禁止使用 with 语句

因为 with 语句无法在编译时就确定，属性到底归属哪个对象。

```js
"use strict";

var v = 1;

with(o) { // 语法错误
    v = 2;
}
```

（2）创设 eval 作用域

正常模式下，Javascript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。

正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。

```js
"use strict";

var x = 2;

console.info(eval("var x = 5; x")); // 5

console.info(x); // 2
```

4\.3 增强的安全措施

（1）禁止 this 关键字指向全局对象

```js
function f() {
    return !this;
} // 返回false，因为"this"指向全局对象，"!this"就是false
function f() {
    "use strict";
    return !this;
} // 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。
```

因此，使用构造函数时，如果忘了加 new，this 不再指向全局对象，而是报错。

```js
function f() {
    "use strict";

    this.a = 1;
}

f(); // 报错，this未定义
```

（2）禁止在函数内部遍历调用栈

```js
function f1() {
    "use strict";

    f1.caller; // 报错

    f1.arguments; // 报错
}

f1();
```

4\.4 禁止删除变量

严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除。

```js
"use strict";

var x;

delete x; // 语法错误

var o = Object.create(null, {
    'x': {
        value: 1,
        configurable: true
    }
});

delete o.x; // 删除成功
```

4\.5 显式报错

正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。

```js
"use strict";

var o = {};

Object.defineProperty(o, "v", {
    value: 1,
    writable: false
});

o.v = 2; // 报错
```

严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。

```js
"use strict";

var o = {
    get v() {
        return 1;
    }
};

o.v = 2; // 报错
```

严格模式下，对禁止扩展的对象添加新属性，会报错。

```js
"use strict";

var o = {};

Object.preventExtensions(o);

o.v = 1; // 报错
```

严格模式下，删除一个不可删除的属性，会报错。

```js
"use strict";

delete Object.prototype; // 报错
```

4\.6 重名错误

严格模式新增了一些语法错误。

（1）对象不能有重名的属性

正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。

```js
"use strict";

var o = {
    p: 1,
    p: 2
}; // 语法错误
```

（2）函数不能有重名的参数

正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。

```js
"use strict";

function f(a, a, b) { // 语法错误

    return;

}
```

4\.7 禁止八进制表示法

正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。

```js
"use strict";

var n = 0100; // 语法错误
```

4\.8 arguments 对象的限制

arguments 是函数的参数对象，严格模式对它的使用做了限制。

（1）不允许对 arguments 赋值

```js
"use strict";

arguments++; // 语法错误

var obj = {
    set p(arguments) {}
}; // 语法错误

try {} catch (arguments) {} // 语法错误

function arguments() {} // 语法错误

var f = new Function("arguments", "'use strict'; return 17;"); // 语法错误
```

（2）arguments 不再追踪参数的变化

```js
function f(a) {
    a = 2;

    return [a, arguments[0]];
}

f(1); // 正常模式为[2,2]

function f(a) {
    "use strict";

    a = 2;

    return [a, arguments[0]];
}

f(1); // 严格模式为[2,1]
```

（3）禁止使用 arguments.callee

这意味着，你无法在匿名函数内部调用自身了。

```js
"use strict";

var f = function() {
    return arguments.callee;
};

f(); // 报错
```

4\.9 函数必须声明在顶层

将来 Javascript 的新版本会引入"块级作用域"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。

```js
"use strict";

if (true) {
    function f() {} // 语法错误
}

for (var i = 0; i < 5; i++) {
    function f2() {} // 语法错误
}
```

4\.10 保留字

为了向将来 Javascript 的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。

使用这些词作为变量名将会报错。

```js
function package(protected) { // 语法错误

    "use strict";

    var implements; // 语法错误

}
```

此外，ECMAscript 第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的 const 保留字，也是不能作为变量名的。

[参考](https://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)

[参与互动](https://github.com/yisainan/web-interview/issues/198)

</details>

<b><details><summary>30.移动端 click 事件、touch 事件、tap 事件的区别</summary></b>

参考答案：

1\.click 事件在移动端会有 200-300ms 的延迟，主要原因是苹果手机在设计时，考虑到用户在浏览网页时需要放大，所以，在用户点击的 200-300ms 之后，才触发 click，如果 200-300ms 之内还有 click，就会进行放大缩小。

2\.touch 事件是针对触屏手机上的触摸事件。现今大多数触屏手机 webkit 内核提供了 touch 事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。其中包括：touchstart, touchmove, touchend, touchcancel 这四个事件，touchstart touchmove touchend 事件可以类比于 mousedown mouseover mouseup 的触发

3\.tap 事件在移动端，代替 click 作为点击事件，tap 事件被很多框架（如 zepto）封装，来减少这延迟问题， tap 事件不是原生的，所以是封装的，那么具体是如何实现的呢？

```js
  < script >
      function tap(ele, callback) {
          // 记录开始时间
          var startTime = 0,
              // 控制允许延迟的时间
              delayTime = 200,
              // 记录是否移动，如果移动，则不触发tap事件
              isMove = false;

          // 在touchstart时记录开始的时间
          ele.addEventListener('touchstart', function(e) {
              startTime = Date.now();
          });

          // 如果touchmove事件被触发，则isMove为true
          ele.addEventListener('touchmove', function(e) {
              isMove = true;
          });

          // 如果touchmove事件触发或者中间时间超过了延迟时间，则返回，否则，调用回调函数。
          ele.addEventListener('touchend', function(e) {
              if (isMove || (Date.now() - startTime > delayTime)) {
                  return;
              } else {
                  callback(e);
              }
          })
      }

  var btn = document.getElementById('btn');
  tap(btn, function() {
      alert('taped');
  }); <
  /script>
```

拓展：

点透问题

如果我们在移动端所有的 click 都替换为了 tap 事件，还是会触发点透问题的，因为实质是： 在同一个 z 轴上，z-index 不同的两个元素，上面的元素是一个绑定了 tap 事件的，下面是一个 a 标签，一旦 tap 触发，这个元素就会 display: none，而从上面的 tap 可以看出，有 touchstart、touchend，所以会 300ms 之后触发 click 事件，而 z-index 已经消失了，所以，触发了下面的 a 的 click 事件，注意： 我们认为 a 标签默认是绑定了 click 事件的。而这种现象不是我们所期待的。

解决方案： （1）使用 fastclick。 （2）添加一个延迟。

（1）直接引入 fastclick 库。

```js
window.addEventListener(
    "load",
    function() {
        FastClick.attach(document.body);
    },
    false
);
```

这样，就可以成功解决问题了。

（2）对于上一个 tap 做延迟。

```js
tap(ele, function() {
    setTimeout(function() {
        ele.style.display = "none";
    }, 300);
});
```

这样，过了 300ms，那么 click 事件就不会触发在下面的 a 标签上了。

[参与互动](https://github.com/yisainan/web-interview/issues/199)

</details>

<b><details><summary>31.JS 单线程还是多线程，如何显示异步操作</summary></b>

参考答案：JS 本身是单线程的，他是依靠浏览器完成的异步操作。

解析：

具体步骤，

1、主线程 执行 js 中所有的代码。

2、主线程 在执行过程中发现了需要异步的任务任务后扔给浏览器（浏览器创建多个线程执行），并在  callback queue  中创建对应的回调函数（回调函数是一个对象，包含该函数是否执行完毕等）。

3、主线程 已经执行完毕所有同步代码。开始监听  callback queue 一旦 浏览器 中某个线程任务完成将会改变回调函数的状态。主线程查看到某个函数的状态为已完成，就会执行该函数。

![js_003](../../images/js_003.png)

[参与互动](https://github.com/yisainan/web-interview/issues/200)

</details>

<b><details><summary>32.JavaScript 数组的函数 map/forEach/reduce/filter</summary></b>

参考答案：

1\.map

```js
// map
//作用：对数组进行遍历
//返回值：新的数组
// 是否改变：否
var arr = [2, 5, 3, 4];
var ret = arr.map(function(value) {
    return value + 1;
});
console.log(ret); //[3,6,4,5]
console.log(arr); //[2,5,3,4]
```

2\.forEach

```js
// forEach 方法
// 作用：遍历数组的每一项
// 返回值：undefined
// 是否改变：否
var arr = [2, 5, 3, 4];
var ret = arr.forEach(function(value) {
    console.log(value); // 2, 5, 3, 4
});
console.log(ret); //undefined
console.log(arr); //[2,5,3,4]
```

3\.reduce

```js
// reduce 方法
// 作用：对数组进行迭代，然后两两进行操作，最后返回一个值
// 返回值：return出来的结果
// 是否改变：不会
var arr = [1, 2, 3, 4];
var ret = arr.reduce(function(a, b) {
    return a * b;
});
console.log(ret); // 24
console.log(arr); // [1, 2, 3, 4]
```

4\.filter

```js
// filter 过滤
// 作用： 筛选一部分元素
// 返回值： 一个满足筛选条件的新数组
// 是否改变原有数组：不会

var arr = [2, 5, 3, 4];
var ret = arr.filter(function(value) {
    return value > 3;
});
console.log(ret); //[5,4]
console.log(arr); //[2,5,3,4]
```

[参与互动](https://github.com/yisainan/web-interview/issues/201)

</details>

<b><details><summary>33.JS 块级作用域、变量提升</summary></b>

参考答案：

1\.块级作用域

JS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称 ES6)中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。

2\.变量提升

* 如果变量声明在函数里面，则将变量声明提升到函数的开头
* 如果变量声明是一个全局变量，则将变量声明提升到全局作用域的开头

解析：

```js
< script type = "text/javascript" > {
    var a = 1;
    console.log(a); // 1
}
console.log(a); // 1
// 可见，通过var定义的变量可以跨块作用域访问到。

(function A() {
    var b = 2;
    console.log(b); // 2
})();
// console.log(b); // 报错，
// 可见，通过var定义的变量不能跨函数作用域访问到

if (true) {
    var c = 3;
}
console.log(c); // 3
for (var i = 0; i < 4; i++) {
    var d = 5;
};
console.log(i); // 4   (循环结束i已经是4，所以此处i为4)
console.log(d); // 5
// if语句和for语句中用var定义的变量可以在外面访问到，
// 可见，if语句和for语句属于块作用域，不属于函数作用域。

{
    var a = 1;
    let b = 2;
    const c = 3;

    {
        console.log(a); // 1	子作用域可以访问到父作用域的变量
        console.log(b); // 2	子作用域可以访问到父作用域的变量
        console.log(c); // 3	子作用域可以访问到父作用域的变量

        var aa = 11;
        let bb = 22;
        const cc = 33;
    }

    console.log(aa); // 11	// 可以跨块访问到子 块作用域 的变量
    // console.log(bb);	// 报错	bb is not defined
    // console.log(cc);	// 报错	cc is not defined
} <
/script>
```

拓展：

var、let、const 的区别

* var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
* let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
* const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。
* 同一个变量只能使用一种方式声明，不然会报错

```js
< script type = "text/javascript" >
    // 块作用域
    {
        var a = 1;
        let b = 2;
        const c = 3;
        // c = 4; // 报错

        // let a = 'a';	// 报错  注：是上面 var a = 1; 那行报错
        // var b = 'b';	// 报错：本行报错
        // const a = 'a1';	// 报错  注：是上面 var a = 1; 那行报错
        // let c = 'c';	// 报错：本行报错

        var aa;
        let bb;
        // const cc; // 报错
        console.log(a); // 1
        console.log(b); // 2
        console.log(c); // 3
        console.log(aa); // undefined
        console.log(bb); // undefined
    }
console.log(a); // 1
// console.log(b); // 报错
// console.log(c); // 报错

// 函数作用域
(function A() {
    var d = 5;
    let e = 6;
    const f = 7;
    console.log(d); // 5
    console.log(e); // 6  (在同一个{ }中,也属于同一个块，可以正常访问到)
    console.log(f); // 7  (在同一个{ }中,也属于同一个块，可以正常访问到)
})();
// console.log(d); // 报错
// console.log(e); // 报错
// console.log(f); // 报错
<
/script>
```

[参与互动](https://github.com/yisainan/web-interview/issues/202)

</details>

<b><details><summary>34.null/undefined 的区别</summary></b>

参考答案：

null： Null 类型，代表“空值"，代表一个空对象指针，使用 typeof 运算得到 “object"，所以你可以认为它是一个特殊的对象值。

undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。

[参与互动](https://github.com/yisainan/web-interview/issues/203)

</details>

<b><details><summary>35.JS 哪些操作会造成内存泄露</summary></b>

参考答案：

1）意外的全局变量引起的内存泄露

```js
function leak() {
    leak = "xxx"; //leak成为一个全局变量，不会被回收
}
```

2）闭包引起的内存泄露

```js
function bindEvent() {
    var obj = document.createElement("XXX");
    obj.οnclick = function() {
        //Even if it's a empty function
    };
}
```

闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。
解决之道，将事件处理函数定义在外部，解除闭包, 或者在定义事件处理函数的外部函数中，删除对 dom 的引用。

```js
//将事件处理函数定义在外部
function onclickHandler() {
    //do something
}

function bindEvent() {
    var obj = document.createElement("XXX");
    obj.οnclick = onclickHandler;
}

//在定义事件处理函数的外部函数中，删除对dom的引用
function bindEvent() {
    var obj = document.createElement("XXX");
    obj.οnclick = function() {
        //Even if it's a empty function
    };
    obj = null;
}
```

3）没有清理的 DOM 元素引用

```js
var elements = {
    button: document.getElementById("button"),
    image: document.getElementById("image"),
    text: document.getElementById("text")
};

function doStuff() {
    image.src = "http://some.url/image";
    button.click():
        console.log(text.innerHTML)
}

function removeButton() {
    document.body.removeChild(document.getElementById('button'))
}
```

4）被遗忘的定时器或者回调

```js
var someResouce = getData();
setInterval(function() {
    var node = document.getElementById("Node");
    if (node) {
        node.innerHTML = JSON.stringify(someResouce);
    }
}, 1000);
```

这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。

5）子元素存在引起的内存泄露

![js_004](../../images/js_004.png)

黄色是指直接被 js 变量所引用，在内存里，红色是指间接被 js 变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。

6）IE7/8 引用计数使用循环引用产生的问题

```js
function fn() {
    var a = {};
    var b = {};
    a.pro = b;
    b.pro = a;
}
fn();
```

fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn 函数被大量调用，就会造成内存泄漏。在 IE7 与 IE8 上，内存直线上升。
IE 中有一部分对象并不是原生 js 对象。例如，其内存泄漏 DOM 和 BOM 中的对象就是使用 C++以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使 IE 的 js 引擎采用标记清除策略来实现，但 js 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.e = element;
element.o = myObject;
```

上面的例子在一个 DOM 元素（element)与一个原生 js 对象（myObject)之间创建了循环引用。其中，变量 myObject 有一个名为 e 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。

看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做

```js
window.οnlοad = function outerFunction() {
    var obj = document.getElementById("element"):
        obj.οnclick = function innerFunction() {};
};
```

这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(“element”)，而 document.getElementById(“element”)的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。

最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样

```js
myObject.element = null;
element.o = null;
window.οnlοad = function outerFunction() {
    var obj = document.getElementById("element"):
        obj.οnclick = function innerFunction() {};
    obj = null;
};
```

将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致 Dom 内存泄漏问题，可能是微软做了优化，或者 Dom 的回收方式已经改变

解析：

1、JS 的回收机制

JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔, 周期性的执行。

到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。

2、标记清除（mark and sweep）

js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

```js
function test() {
    var a = 10; //被标记，进入环境
    var b = 20; //被标记，进入环境
}
test(); //执行完毕之后a、b又被标记离开环境，被回收
```

3、引用计数(reference counting)

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。

```js
function test() {
    var a = {}; //a的引用次数为0
    var b = a; //a的引用次数加1，为1
    var c = a; //a的引用次数加1，为2
    var b = {}; //a的引用次数减1，为1
}
```

4、如何分析内存的使用情况

Google Chrome 浏览器提供了非常强大的 JS 调试工具，Memory 视图 profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。 summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。

5、怎样避免内存泄露

1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；

2）注意程序逻辑，避免“死循环”之类的 ；

3）避免创建过多的对象 原则：不用了的东西要及时归还。

[参考](https://blog.csdn.net/michael8512/article/details/77888000)

[参与互动](https://github.com/yisainan/web-interview/issues/204)

</details>

<b><details><summary>36.重排与重绘的区别，什么情况下会触发？</summary></b>

参考答案：

1\.简述重排的概念

   浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。

2\.简述重绘的概念

   重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。

3\.简述重绘和重排的关系

   重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。

4\.什么情况下会触发重排？

* 页面渲染初始化时；（这个无法避免）
* 浏览器窗口改变尺寸；
* 元素尺寸改变时；
* 元素位置改变时；
* 元素内容改变时；
* 添加或删除可见的 DOM 元素时。

5\.重排优化有如下五种方法

* 将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。
* 如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用）
* 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
* 由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。
* 在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。

[参与互动](https://github.com/yisainan/web-interview/issues/205)

</details>

<b><details><summary>37.发布订阅设计模式</summary></b>

参考答案：

发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。

解析：

#### 发布订阅模式的构成

最常见的发布订阅模式就是咱们DOM事件，仔细回想一下我们要给一个按钮，绑定一个事件，当我点击按钮的时候我要让他的颜色变了，并且页面弹出一个弹出框

我们分析一下这个流程：首先，我们得知道给哪个按钮的时候绑定事件，然后我们得知道触发事件以后需要干什么？

那么在这其中谁是发布者？

是DOM中的按钮，因为是在它身上绑定了事件，当我们点击按钮的时候它便向订阅者发布了这个消息

那么谁是订阅者？

是click事件，当点击按钮时，dom发布了一条消息，而事件订阅了它，所以当它被点击的时候，订阅者会接收到消息

#### 简单例子

上大学的时候甲要打游戏，下午的课不准备去了，然后甲跟乙说，如果下午老师问我去哪了，你就发信息告诉我。然后果然不出所料，下午老师来了，并且问了甲去哪了？然后乙发信息给甲，甲收到信息后干什么乙不知道，乙只是负责如果老师问了就发短信给甲。

[参与互动](https://github.com/yisainan/web-interview/issues/206)

</details>

<b><details><summary>38.jsonp 优缺点？ </summary></b>

参考答案：

### jsonp 优缺点

* 1.优点
  + 1.1 它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略；
  + 1.2 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持
  + 1.3 在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层终于*分 开了。我提供的 jsonp 服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果*有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个 jsonp 服务。
* 2.缺点
  + 2.1 它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求
  + 2.2 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。
  + 2.3 jsonp 在调用失败的时候不会返回各种 HTTP 状态码。
  + 2.4 缺点是安全性。万一假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么结果是什么？所有调用这个 jsonp 的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用 jsonp 的时候必须要保证使用的 jsonp 服务必须是安全可信的

[参与互动](https://github.com/yisainan/web-interview/issues/207)

</details>

<b><details><summary>39.兼容各种浏览器版本的事件绑定</summary></b>

参考答案：

```js
/*
兼容低版本IE，ele为需要绑定事件的元素，
eventName为事件名（保持addEventListener语法，去掉on），fun为事件响应函数
*/

function addEvent(ele, eventName, fun) {
    if (ele.addEventListener) {
        ele.addEventListener(eventName, fun, false);
    } else {
        ele.attachEvent("on" + eventNme, fun);
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/208)

</details>

<b><details><summary>40.typescript 遇到过什么坑</summary></b>

参考答案：

main.ts 报错（ Cannot find module './App.vue'.）

原因： typescript 不能识别.vue 文件

解决办法： 引入 vue 的 typescript declare 库

[参与互动](https://github.com/yisainan/web-interview/issues/209)

</details>

<b><details><summary>41.this 和 apply 的应用</summary></b>

参考答案：比如求数组的最大值 Math.max.apply(this, 数组)

```js
var numbers = [5, 458, 120, -215];
var maxInNumbers = Math.max.apply(this, numbers); //第一个参数也可以填Math或null
console.log(maxInNumbers); // 458
var maxInNumbers = Math.max.call(this, 5, 458, 120, -215);
console.log(maxInNumbers); // 458
```

[参与互动](https://github.com/yisainan/web-interview/issues/210)

</details>

<b><details><summary>42.split() join()的区别</summary></b>

参考答案：

join()：用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串

split()：用于把一个字符串通过指定的分隔符进行分隔成数组

[参与互动](https://github.com/yisainan/web-interview/issues/211)

</details>

<b><details><summary>43.JavaScript 的数据类型</summary></b>

参考答案：JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是基本类型(Primitive Type)。

[参与互动](https://github.com/yisainan/web-interview/issues/212)

</details>

<b><details><summary>44.如何判断一个对象是否属于某个类？</summary></b>

参考答案：instanceof

解析：

```js
if (a instanceof Person) {
    alert("yes");
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/213)

</details>

<b><details><summary>45.new 操作符具体干了什么呢?</summary></b>

参考答案：

样本一

new 共经过了 4 几个阶段

* 1、创建一个空对象
* 2、设置原型链
* 3、让 Func 中的 this 指向 obj，并执行 Func 的函数体
* 4、判断 Func 的返回值类型：

样本二

```

function Test(){}
const test = new Test()
```

1\.创建一个新对象：

```

const obj = {}
```

2\.设置新对象的 constructor 属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的 prototype 对象

```

obj.constructor = Test
obj.__proto__ = Test.prototype
```

3\.使用新对象调用函数，函数中的 this 被指向新实例对象

```

Test.call(obj)
```

4\.将初始化完毕的新对象地址，保存到等号左边的变量中

[参与互动](https://github.com/yisainan/web-interview/issues/214)

</details>

<b><details><summary>46.call() 和 apply() 的含义和区别？</summary></b>

参考答案：

首先说明两个方法的含义：

* call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1, args2); 即 A 对象调用 B 对象的方法。
* apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments); 即 A 对象应用 B 对象的方法。

call 与 apply 的相同点：

* 方法的含义是一样的，即方法功能是一样的；
* 第一个参数的作用是一样的；

call 与 apply 的不同点：两者传入的列表形式不一样

* call 可以传入多个参数；
* apply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入

想一想哪个性能更好一些呢？

[参与互动](https://github.com/yisainan/web-interview/issues/215)

</details>

<b><details><summary>47.sort 排序原理</summary></b>

参考答案：冒泡排序法

解析：

冒泡排序法的原理：

* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

示例：

```js
var arr = [1, 5, 4, 2];
// sort()方法的比较逻辑为：
// 第一轮：1和5比，1和4比，1和2比
// 第二轮：5和4比，5和2比
// 第三轮：4和2比
```

```js
// 一.sort排序规则 return大于0则交换数组相邻2个元素的位置
// 二.arr.sort(function (a,b) {})中
//         a -->代表每一次执行匿名函时候，找到的数组中的当前项；
//         b -->代表当前项的后一项；

// 1.升序
var apple = [45, 42, 10, 147, 7, 65, -74];
// ①默认法,缺点:只根据首位排序
console.log(apple.sort());
// ②指定排序规则法,return可返回任何值
console.log(
    apple.sort(function(a, b) {
        return a - b; //若return返回值大于0(即a＞b),则a,b交换位置
    })
);

//2.降序
var arr = [45, 42, 10, 111, 7, 65, -74];
console.log(
    apple.sort(function(a, b) {
        return b - a; //若return返回值大于零(即b＞a),则a,b交换位置
    })
);
```

[参考 1](https://blog.csdn.net/soraru/article/details/82255616)、[参考 2](https://www.cnblogs.com/huoxiao/p/10239284.html)

[参与互动](https://github.com/yisainan/web-interview/issues/216)

</details>

<b><details><summary>48.Zepto 的点透问题如何解决？</summary></b>

参考答案：

方案一：来得很直接 github 上有个 fastclick 可以完美解决https://github.com/ftlabs/fastclick

引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上

```js
window.addEventListener(
    "load",
    function() {
        FastClick.attach(document.body);
    },
    false
);
```

或者有 zepto 或者 jqm 的 js 里面加上

```js
$(function() {
    FastClick.attach(document.body);
});
```

当然 require 的话就这样：

```js
var FastClick = require("fastclick");
FastClick.attach(document.body, options);
```

方案二：用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault()

```js
$("#cbFinish").on("touchend", function(event) {
    //很多处理比如隐藏什么的
    event.preventDefault();
});
```

方案三：延迟一定的时间(300ms+)来处理事件

```js
$("#cbFinish").on("tap", function(event) {
    setTimeout(function() {
        //很多处理比如隐藏什么的
    }, 320);
});
```

这种方法其实很好，可以和 fadeInIn/fadeOut 等动画结合使用，可以做出过渡效果

理论上上面的方法可以完美的解决 tap 的点透问题，如果真的不行，用 click

解析：

1、“点透”是什么？

你可能碰到过在列表页面上创建一个弹出层，弹出层有个关闭的按钮，你点了这个按钮关闭弹出层后后，这个按钮正下方的内容也会执行点击事件（或打开链接）。这个被定义为这是一个“点透”现象。

2、为什么会出现点透呢？

[参考](https://www.cnblogs.com/axl234/p/5554281.html)

[参与互动](https://github.com/yisainan/web-interview/issues/217)

</details>

<b><details><summary>49.如何判断当前脚本运行在浏览器还是 node 环境中？</summary></b>

参考答案：通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中

[参与互动](https://github.com/yisainan/web-interview/issues/218)

</details>

<b><details><summary>50.移动端最小触控区域是多大？</summary></b>

参考答案：苹果推荐是 44pt x 44pt

解析：[参考](https://developer.apple.com/ios/human-interface-guidelines/visual-design/layout/)

[参与互动](https://github.com/yisainan/web-interview/issues/219)

</details>

<b><details><summary>51.移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</summary></b>

参考答案：

1\.300 毫秒
2\.因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。
3\.推荐 fastclick\.js

[参与互动](https://github.com/yisainan/web-interview/issues/220)

</details>

<b><details><summary>52.解释 JavaScript 中的作用域与变量声明提升？</summary></b>

参考答案：

* 我对作用域的理解是只会对某个范围产生作用，而不会对外产生影响的封闭空间。在这样的一些空间里，外部不能访问内部变量，但内部可以访问外部变量。
* 所有申明都会被提升到作用域的最顶上
* 同一个变量申明只进行一次，并且因此其他申明都会被忽略
* 函数声明的优先级优于变量申明，且函数声明会连带定义一起被提升

[参与互动](https://github.com/yisainan/web-interview/issues/221)

</details>

<b><details><summary>53.Node.js 的适用场景？</summary></b>

参考答案：比如：RESTFUL API、实时聊天、客户端逻辑强大的单页 APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线 APP 等。

解析：[参考](https://www.cnblogs.com/kevin9103/p/5053517.html)

[参与互动](https://github.com/yisainan/web-interview/issues/222)

</details>

<b><details><summary>54.bind、call、apply 的区别</summary></b>

参考答案：

call 和 apply 其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。<br>
call 和 apply 都是在调用时生效，改变调用者的 this 指向。<br>

```

let name = 'Jack'
const obj = {name: 'Tom'}
function sayHi() {console.log('Hi! ' + this.name)}

sayHi() // Hi! Jack
sayHi.call(obj) // Hi! Tom

```

bind 也是改变 this 指向，不过不是在调用时生效，而是返回一个新函数。

```

const newFunc = sayHi.bind(obj)
newFunc() // Hi! Tom
```

[参与互动](https://github.com/yisainan/web-interview/issues/223)

</details>

<b><details><summary>55.使用构造函数的注意点</summary></b>

参考答案：

1\.一般情况下构造函数的首字母需要大写，因为我们在看到一个函数首字母大写的情况，就认定这是一个构造函数，需要跟new关键字进行搭配使用，创建一个新的实例（对象）
2\.构造函数在被调用的时候需要跟new关键字搭配使用。
3\.在构造函数内部通过this\+属性名的形式为实例添加一些属性和方法。
4\.构造函数一般不需要返回值，如果有返回值

    - 4.1 如果返回值是一个基本数据类型，那么调用构造函数，返回值仍旧是那么创建出来的对象。
    - 4.2 如果返回值是一个复杂数据类型，那么调用构造函数的时候，返回值就是这个return之后的那个复杂数据类型。

[参与互动](https://github.com/yisainan/web-interview/issues/224)

</details>

<b><details><summary>56.如何获取浏览器版本信息</summary></b>

参考答案：window.navigator.userAgent

[参与互动](https://github.com/yisainan/web-interview/issues/225)

</details>

<b><details><summary>57.如何实现文件断点续传</summary></b>

参考答案：断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。

首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。

因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。

前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。

当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。
有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。

只要用 slice 方法就可以了

```

var packet = file.slice(start, end);
```

参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块

如

```

file.slice(0,1000);
file.slice(1000,2000);
file.slice(2000,3000);
// ......
```

在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。
如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。

解析：[参考](https://www.cnblogs.com/zhwl/p/3580776.html)

[参与互动](https://github.com/yisainan/web-interview/issues/226)

</details>

<b><details><summary>58.数组的常用方法</summary></b>

参考答案：

1\.Array\.map\(\)

此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组

```js
let arr = [1, 2, 3, 4, 5];
let newArr = arr.map(x => x * 2);
//arr= [1, 2, 3, 4, 5]   原数组保持不变
//newArr = [2, 4, 6, 8, 10] 返回新数组
```

2\.Array\.forEach\(\)

此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和 map 方法区分

```js
let arr = [1, 2, 3, 4, 5];
num.forEach(x => x * 2);
// arr = [2, 4, 6, 8, 10]  数组改变,注意和map区分
```

3\.Array\.filter\(\)

此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回

```js
let arr = [1, 2, 3, 4, 5]
const isBigEnough => value => value >= 3
let newArr = arr.filter(isBigEnough)
//newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组
```

4\.Array\.every\(\)

此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回 true，否则为 false：

```js
let arr = [1, 2, 3, 4, 5]
const isLessThan4 => value => value < 4
const isLessThan6 => value => value < 6
arr.every(isLessThan4) //false
arr.every(isLessThan6) //true
```

5\.Array\.some\(\)

此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回 true，若所有元素都不满足判断条件，则返回 false：

```js
let arr = [1, 2, 3, 4, 5]
const isLessThan4 => value => value < 4
const isLessThan6 => value => value > 6
arr.some(isLessThan4) //true
arr.some(isLessThan6) //false
```

6\.Array\.reduce\(\)

此方法是所有元素调用返回函数，返回值为最后结果, 传入的值必须是函数类型：

```js
let arr = [1, 2, 3, 4, 5];
const add = (a, b) => a + b;
let sum = arr.reduce(add);
//sum = 15  相当于累加的效果
```

与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的

7\.Array\.push\(\)

此方法是在数组的后面添加新加元素，此方法改变了数组的长度：

8\.Array\.pop\(\)

此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：

```js
let arr = [1, 2, 3, 4, 5];
arr.pop();
console.log(arr); //[1, 2, 3, 4]
console.log(arr.length); //4
```

9\.Array\.shift\(\)

此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：

```js
let arr = [1, 2, 3, 4, 5];
arr.shift();
console.log(arr); //[2, 3, 4, 5]
console.log(arr.length); //4
```

10.Array.unshift()

此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：

```js
let arr = [1, 2, 3, 4, 5];
arr.unshift(6, 7);
console.log(arr); //[6, 7, 2, 3, 4, 5]
console.log(arr.length); //7
```

11.Array.isArray()

判断一个对象是不是数组，返回的是布尔值

12.Array.concat()

此方法是一个可以将多个数组拼接成一个数组：

`

```js
let arr1 = [1, 2, 3]
arr2 = [4, 5]
let arr = arr1.concat(arr2)
console.log(arr) //[1, 2, 3, 4, 5]
``
`　　

13.Array.toString()

 此方法将数组转化为字符串：
`
``
js
let arr = [1, 2, 3, 4, 5];
let str = arr.toString()
console.log(str) // 1,2,3,4,5
``
`　

14.Array.join()

  此方法也是将数组转化为字符串：
`
``
js
let arr = [1, 2, 3, 4, 5];
let str1 = arr.toString()
let str2 = arr.toString(',')
let str3 = arr.toString('##')
console.log(str1) // 12345
console.log(str2) // 1,2,3,4,5
console.log(str3) // 1##2##3##4##5

`
```

通过例子可以看出和 toString 的区别，可以设置元素之间的间隔~

15.Array.splice(开始位置， 删除的个数，元素)

万能方法，可以实现增删改：

```js
let arr = [1, 2, 3, 4, 5];
let arr1 = arr.splice(2, 0 'haha')
let arr2 = arr.splice(2, 3)
let arr1 = arr.splice(2, 1 'haha')
console.log(arr1) //[1, 2, 'haha', 3, 4, 5]新增一个元素
console.log(arr2) //[1, 2] 删除三个元素
console.log(arr3) //[1, 2, 'haha', 4, 5] 替换一个元素
```

[参与互动](https://github.com/yisainan/web-interview/issues/227)

</details>

<b><details><summary>59.字符串常用操作</summary></b>

参考答案：

* charAt(index): 返回指定索引处的字符串
* charCodeAt(index): 返回指定索引处的字符的 Unicode 的值
* concat(str1, str2, ...): 连接多个字符串，返回连接后的字符串的副本
* fromCharCode(): 将 Unicode 值转换成实际的字符串
* indexOf(str): 返回 str 在父串中第一次出现的位置，若没有则返回-1
* lastIndexOf(str): 返回 str 在父串中最后一次出现的位置，若没有则返回-1
* match(regex): 搜索字符串，并返回正则表达式的所有匹配
* replace(str1, str2):str1 也可以为正则表达式，用 str2 替换 str1
* search(regex): 基于正则表达式搜索字符串，并返回第一个匹配的位置
* slice(start, end)：返回字符索引在 start 和 end（不含）之间的子串
* split(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量
* substr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串
* substring(from, to)：返回字符索引在 from 和 to（不含）之间的子串
* toLowerCase()：将字符串转换为小写
* toUpperCase()：将字符串转换为大写
* valueOf()：返回原始字符串值

[参与互动](https://github.com/yisainan/web-interview/issues/228)

</details>

<b><details><summary>60.作用域的概念及作用</summary></b>

参考答案：

* 作用域 ： 起作用的一块区域
* 作用域的概念： 对变量起保护作用的一块区域
* 作用： 作用域外部无法获取到作用域内部声明的变量，作用域内部能够获取到作用域外界声明的变量。

[参与互动](https://github.com/yisainan/web-interview/issues/229)

</details>

<b><details><summary>61.作用域的分类</summary></b>

参考答案：块作用域、词法作用域、动态作用域

解析：

1 块作用域 花括号 {}

2 词法作用域（js 属于词法作用域）
作用域只跟在何处被创建有关系，跟在何处被调用没有关系

3 动态作用域
作用域只跟在何处被调用有关系，跟在何处被创建没有关系

[参与互动](https://github.com/yisainan/web-interview/issues/230)

</details>

<b><details><summary>62.js 属于哪种作用域</summary></b>

参考答案：词法作用域（函数作用域）

解析：

```js
// 块作用域
/*{
        var num =123;
    }
    console.log(num);*/
// 如果js属于块作用域，那么在花括号外部就无法访问到花括号内部的声明的num变量。
// 如果js不属于块级作用域，那么花括号外部就能够访问到花括号内部声明的num变量
// 能够输出num变量，也就说明js不属于块级作用。
// 在ES6 之前的版本js是不存在块级作用域的。

//js属于词法作用域还是动态作用域

// js中函数可以帮我们去形成一个作用域

/* function fn(){
        var num =123;
    }
    fn();
    //在函数外界能否访问到num这样一个变量
    console.log(num)*/ //Uncaught ReferenceError: num is not defined
// 如果函数能够生成一个作用域，那么在函数外界就无法访问到函数内部声明的变量。
// js中的函数能够生成一个作用。  函数作用域 。

// 词法作用域：作用的外界只跟作用域在何处创建有关系，跟作用域在何处被调用没有关系

var num = 123;

function f1() {
    console.log(num); //
}

function f2() {
    var num = 456;
    f1(); //f1在f2被调用的时候会被执行 。
}
f2();

//如果js是词法作用域，那么就会输出f1被创建的时候外部的num变量 123
//如果js是动态作用域，那么f1执行的时候就会输出f1被调用时外部环境中的num  456
```

[参与互动](https://github.com/yisainan/web-interview/issues/231)

</details>

<b><details><summary>63.浮点数精度</summary></b>

参考答案：[参考](https://www.css88.com/archives/7340)

[参与互动](https://github.com/yisainan/web-interview/issues/232)

</details>

<b><details><summary>64.自执行函数? 用于什么场景？好处?</summary></b>

参考答案：

自执行函数:
1、声明一个匿名函数
2、马上调用这个匿名函数。<br>
作用：创建一个独立的作用域。<br>

好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理<br>

场景：一般用于框架、插件等场景

[参与互动](https://github.com/yisainan/web-interview/issues/233)

</details>

<b><details><summary>65.多个页面之间如何进行通信</summary></b>

参考答案：有如下几个方式：

* cookie
* web worker
* localeStorage 和 sessionStorage

[参与互动](https://github.com/yisainan/web-interview/issues/234)

</details>

<b><details><summary>66.css 动画和 js 动画的差异</summary></b>

参考答案：

1\.代码复杂度，js 动画代码相对复杂一些
2\.动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css 动画不能添加事件
3\.动画性能看，js 动画多了一个 js 解析的过程，性能不如 css 动画好

解析：[参考](https://zhuanlan.zhihu.com/p/41479807)

[参与互动](https://github.com/yisainan/web-interview/issues/235)

</details>

<b><details><summary>67.如何做到修改 url 参数页面不刷新</summary></b>

参考答案：

HTML5 引入了 `history.pushState()` 和 `history.replaceState()` 方法，它们分别可以添加和修改历史记录条目。

```js
let stateObj = {
    foo: "bar"
};

history.pushState(stateObj, "page 2", "bar.html");
```

假设当前页面为 `foo.html` ，执行上述代码后会变为 `bar.html` ，点击浏览器后退，会变为 `foo.html` ，但浏览器并不会刷新。
`pushState()` 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL.让我们来解释下这三个参数详细内容：

* 状态对象 — 状态对象 `state` 是一个 JavaScript 对象，通过 `pushState ()` 创建新的历史记录条目。无论什么时候用户导航到新的状态， `popstate` 事件就会被触发，且该事件的 `state` 属性包含该历史记录条目状态对象的副本。

  状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有 640k 的大小限制。如果你给 `pushState()` 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 `sessionStorage` 以及 `localStorage` .

* 标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 `state` 传递一个短标题。

* URL — 该参数定义了新的历史 URL 记录。注意，调用 `pushState()` 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前 URL 同源，否则 `pushState()` 会抛出一个异常。该参数是可选的，缺省为当前 URL。

[参与互动](https://github.com/yisainan/web-interview/issues/236)

</details>

<b><details><summary>68.数组方法 pop() push() unshift() shift()</summary></b>

参考答案：

* arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素
* arr.push() 从后面添加元素，返回值为添加完后的数组的长度
* arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度
* arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素

[参与互动](https://github.com/yisainan/web-interview/issues/237)

</details>

<b><details><summary>69.事件绑定与普通事件有什么区别</summary></b>

参考答案：

* 用普通事件添加相同事件，下面会覆盖上面的，而事件绑定不会
* 普通事件是针对非 dom 元素，事件绑定是针对 dom 元素的事件

[参与互动](https://github.com/yisainan/web-interview/issues/238)

</details>

<b><details><summary>70.IE 和 DOM 事件流的区别</summary></b>

参考答案：

1\.事件流的区别

IE 采用冒泡型事件 Netscape 使用捕获型事件 DOM 使用先捕获后冒泡型事件
示例：

复制代码代码如下:

```html
<body>
    <div>
        <button>点击这里</button>
    </div>
</body>
```

冒泡型事件模型： button->div->body (IE 事件流)

捕获型事件模型： body->div->button (Netscape 事件流)

DOM 事件模型： body->div->button->button->div->body (先捕获后冒泡)

2\.事件侦听函数的区别

IE 使用:

```js
[Object].attachEvent("name_of_event_handler", fnHandler); //绑定函数
[Object].detachEvent("name_of_event_handler", fnHandler); //移除绑定
```

DOM 使用：

```js
[Object].addEventListener("name_of_event", fnHandler, bCapture); //绑定函数
[Object].removeEventListener("name_of_event", fnHandler, bCapture); //移除绑定
```

bCapture 参数用于设置事件绑定的阶段，true 为捕获阶段，false 为冒泡阶段。

[参与互动](https://github.com/yisainan/web-interview/issues/239)

</details>

<b><details><summary>71.IE 和标准下有哪些兼容性的写法</summary></b>

参考答案：

```js
var ev = ev || window.event;
document.documentElement.clientWidth || document.body.clientWidth;
var target = ev.srcElement || ev.target;
```

[参与互动](https://github.com/yisainan/web-interview/issues/240)

</details>

<b><details><summary>72.变量提升</summary></b>

参考答案：

### 变量提升

A、js 代码执行的过程

* 1 变量提升
* 2 代码从上到下依次执行

var 关键字和 function 关键字声明的变量会进行变量提升

B、变量提升发生的环境：发生在代码所处的当前作用域。

* 变量提升
* 1 var 关键字进行的变量提升，会把变量提前声明，但是不会提前赋值 。
* 2 function 关键字对变量进行变量提升，既会把变量提前声明，又会把变量提前赋值，也就是把整个函数体提升到代码的顶部
* 3 有一些代码是不会执行的但是仍旧会发生变量提升, 规则适用于 1, 2
* 3.1 return 之后的代码依旧会发生变量提升，规则适用于 1，2
* 3.2 代码报错之后的代码依旧会发生变量提升，规则适用于 1，2
* 3.3 break 之后的代码依旧会发生变量提升，规则适用于 1, 2
* 4 有一些代码是不会执行但是仍旧会发生变量提升，但是规则要发生变化
* 4.1 if 判断语句 if 判断语句中 var 关键字以及 function 关键字声明的变量只会发生提前声明，不会发生提前赋值, 也就是不会吧函数体整体提升到当前作用域顶部。规则跟 1, 2 不适用
* 4.2 switch case 规则跟 1, 2 不适用
* 4.3 do while 规则跟 1, 2 不适用
* 4.4 try catch catch 中声明的变量只会发生提前声明，不会发生提前赋值。
* Ps: 在条件判断语句和 try catch 中的声明的变量不管是否能够执行，都只会发生提前
* 声明，不会发生提前赋值。

解析：

```js
// 如果一个变量声明了但是未赋值，那么输出这个变量就会输出 undefined
var num;
console.log(num);

// 如果一个变量没有声明也没有赋值，那么就会报一个错：
console.log(num); // 输出一个不存在的变量 Uncaught ReferenceError: num is not defined
```

```js
// var 关键字进行的变量提升
console.log(num);
var num = 123;
console.log(num);
var num = 456;
console.log(num);

// 变量提升之后的代码：
var num;
console.log(num);
num = 123;
console.log(num);
num = 456;
console.log(num);
```

```js
// function 关键字的变量提升
console.log(fn);

function fn() {
    console.log(1);
}

// 变量提升之后的代码：
function fn() {
    console.log(1);
}
console.log(fn); // 输出fn的函数体
```

```js
// 3.1 return 之后的代码依旧会发生变量提升  规则适用于1，2
function fn() {
    console.log(num);
    return;
    var num = 123;
}
fn();

// 变量提升之后的代码：
function fn() {
    var num;
    console.log(num);
    return;
    num = 123;
}
fn(); // undefined

function fn() {
    console.log(fo);
    return;

    function fo() {}
}
fn();

// 变量提升之后的代码：
function fn() {
    function fo() {}
    console.log(fo);
    return;
}
fn(); //输出fo的函数体
```

```js
//3.2 代码报错之后的代码依旧会进行变量提升，规则适用于1,2
console.log(num);
xsasfgdsfqdfsdf; //报一个错
var num = 123;
console.log(num);

// 变量提升之后的代码：
var num;
console.log(num); //输出 undefined
dsagdsqghdwfh; // 报一个错误 ，错误之后的代码不会被执行
num = 123;
console.log(num);
```

```js
//function 关键字
console.log(fn);
sasgfdhwhsdqg;

function fn() {}
console.log(fn);

// 变量提升之后的代码：
function fn() {}
console.log(fn); // 输出 fn 的函数体
asdgsdgdfgfdg; // 报一个错误，报错之后的代码不会被执行
console.log(fn);
```

```js
//4 代码不执行，但是会进行变量提升，不过规则不适用于1,2
//4.1 if判断语句
console.log(num);
if (false) {
    var num = 123;
}
console.log(num)

//  变量提升之后的代码：
var num;
console.log(num); //undefined
if (false) {
    num = 123;
}
console.log(num) //undefined

console.log(fn);
if (false) {
    function fn() {}
}
console.log(fn);

// 变量提升之后的代码：
var fn;

function fn;
console.log(fn) //undefined
if (false) {
    function fn() {}
}
console.log(fn) //undefined
/*function fn//Uncaught SyntaxError: Unexpected end of input*/
```

```js
// try catch
try {
    console.log(num);
} catch (e) {
    var num = 123;
}
console.log(num);

var num;
try {
    console.log(num); // undefined
} catch (e) {
    num = 123;
}
console.log(num); // undefined

try {
    console.log(fn);
} catch (e) {
    function fn() {}
}
console.log(fn);

var fn;
try {
    console.log(fn); // undefined
} catch (e) {
    num = 123;
}
console.log(fn); // undefined
```

[对应面试题](../编程题/变量提升.md)

[参与互动](https://github.com/yisainan/web-interview/issues/241)

</details>

<b><details><summary>73.如何阻止冒泡与默认行为</summary></b>

参考答案：

* 阻止冒泡行为：非 IE 浏览器 stopPropagation()，IE 浏览器 window.event.cancelBubble = true
* 阻止默认行为：非 IE 浏览器 preventDefault()，IE 浏览器 window.event.returnValue = false

解析：

当需要阻止冒泡行为时，可以使用

```js
function stopBubble(e) {
    //如果提供了事件对象，则这是一个非IE浏览器
    if (e && e.stopPropagation)
        //因此它支持W3C的stopPropagation()方法
        e.stopPropagation();
    //否则，我们需要使用IE的方式来取消事件冒泡
    else window.event.cancelBubble = true;
}
```

当需要阻止默认行为时，可以使用

```js
//阻止浏览器的默认行为
function stopDefault(e) {
    //阻止默认浏览器动作(W3C)
    if (e && e.preventDefault) e.preventDefault();
    //IE中阻止函数器默认动作的方式
    else window.event.returnValue = false;
    return false;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/242)

</details>

<b><details><summary>74.js 中 this 闭包 作用域</summary></b>

参考答案：

this：指向调用上下文

闭包：定义一个函数就开辟了一个局部作用域，整个 js 执行环境有一个全局作用域

作用域：一个函数可以访问其他函数中的变量（闭包是一个受保护的变量空间）

```js
var f = (function fn() {
        var name = 1;
        return function() {
            name++;
            console.log(name)
        }
    })()

    ==
    >
    undefined 有疑问
```

[参与互动](https://github.com/yisainan/web-interview/issues/243)

</details>

<b><details><summary>75.javascript 的本地对象，内置对象和宿主对象</summary></b>

参考答案：

1\.本地对象

ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象"。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError

2\.内置对象

JS中内置了17个对象，常用的是Array对象、Date对象、正则表达式对象、string对象、Global对象

3\.宿主对象

由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM都是宿主对象。

[参与互动](https://github.com/yisainan/web-interview/issues/244)

</details>

<b><details><summary>76.javascript 的同源策略</summary></b>

参考答案：一段脚本只能读取来自于同一来源的窗口和文档的属性

解析：

同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自 MDN 官方的解释）

简单来说就是：一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合
具体解释：

（1）源包括三个部分：协议、域名、端口（http 协议的默认端口是 80）。如果有任何一个部分不同，则源不同，那就是跨域了。

（2）限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）

Cookie、LocalStorage 和 IndexDB 无法获取。

无法获取和操作 DOM。

不能发送 Ajax 请求。我们要注意，Ajax 只适合同源的通信。

同源策略带来的麻烦：ajax 在不同域名下的请求无法实现，需要进行跨域操作

[参与互动](https://github.com/yisainan/web-interview/issues/245)

</details>

<b><details><summary>77.事件冒泡与事件捕获</summary></b>

参考答案：

事件冒泡：由最具体的元素（目标元素）向外传播到最不具体的元素

事件捕获：由最不确定的元素到目标元素

[参与互动](https://github.com/yisainan/web-interview/issues/246)

</details>

<b><details><summary>78.foo = foo||bar ，这行代码是什么意思？为什么要这样写？</summary></b>

参考答案：

这种写法称为短路表达式

解析：

相当于

```js
var foo;
if (foo) {
    foo = foo;
} else {
    foo = bar;
}
```

常用于函数参数的空判断

[参与互动](https://github.com/yisainan/web-interview/issues/247)

</details>

<b><details><summary>79.复杂数据类型如何转变为字符串</summary></b>

参考答案：

* 首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值
* 如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法
* 如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，
* 如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。

[参与互动](https://github.com/yisainan/web-interview/issues/248)

</details>

<b><details><summary>80.javascript 中 this 的指向问题</summary></b>

参考答案：

* 全局环境、普通函数（非严格模式）指向 window
* 普通函数（严格模式）指向 undefined
* 函数作为对象方法及原型链指向的就是上一级的对象
* 构造函数指向构造的对象
* DOM 事件中指向触发事件的元素
* 箭头函数...

解析：

## 1、全局环境

全局环境下，this 始终指向全局对象（window），无论是否严格模式；

```js
// 在浏览器中，全局对象为 window 对象：
console.log(this === window); // true

this.a = 37;
console.log(window.a); // 37
```

## 2、函数上下文调用

2\.1 普通函数

普通函数内部的 this 分两种情况，严格模式和非严格模式。

（1）非严格模式下，没有被上一级的对象所调用, this 默认指向全局对象 window。

```js
function f1() {
    return this;
}
f1() === window; // true
```

（2）严格模式下，this 指向 undefined。

```js
function f2() {
    "use strict"; // 这里是严格模式
    return this;
}
f2() === undefined; // true
```

2\.2 函数作为对象的方法

（1）函数有被上一级的对象所调用，那么 this 指向的就是上一级的对象。

（2）多层嵌套的对象，内部方法的 this 指向离被调用函数最近的对象（window 也是对象，其内部对象调用方法的 this 指向内部对象， 而非 window）。

```js
//方式1
var o = {
    prop: 37,
    f: function() {
        return this.prop;
    }
};
//当 o.f()被调用时，函数内的this将绑定到o对象。
console.log(o.f()); // logs 37

//方式2
var o = {
    prop: 37
};

function independent() {
    return this.prop;
}
//函数f作为o的成员方法调用
o.f = independent;
console.log(o.f()); // logs 37

//方式3
//this 的绑定只受最靠近的成员引用的影响
o.b = {
    g: independent,
    prop: 42
};
console.log(o.b.g()); // 42
```

特殊例子

```js
// 例子1
var o = {
    a: 10,
    b: {
        // a:12,
        fn: function() {
            console.log(this.a); //undefined
            console.log(this); //{fn: ƒ}
        }
    }
};
o.b.fn();
// 例子2
var o = {
    a: 10,
    b: {
        a: 12,
        fn: function() {
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
};
var j = o.b.fn;
j();
// this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子2中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子1是不一样的，例子1是直接执行了fn
```

2\.3 原型链中的 this

（1）如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样。

```js
var o = {
    f: function() {
        return this.a + this.b;
    }
};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

上述例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。当执行 p.f()时，会查找 p 的原型链，找到 f 函数并执行。因为 f 是作为 p 的方法调用的，所以函数中的 this 指向 p。

（2）相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。

（3）call()和 apply()方法：当函数通过 Function 对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的 this 值可绑定到 call() & apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript 内部会尝试将其转换成对象然后指向它。

```js
function add(c, d) {
    return this.a + this.b + c + d;
}
var o = {
    a: 1,
    b: 3
};

add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34

function tt() {
    console.log(this);
}
// 第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。
tt.call(5); // 内部转成 Number {[[PrimitiveValue]]: 5}
tt.call("asd"); // 内部转成 String {0: "a", 1: "s", 2: "d", length: 3, [[PrimitiveValue]]: "asd"}
```

（4）bind()方法：由 ES5 引入， 在 Function 的原型链上， Function.prototype.bind。通过 bind 方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。

```js
function f() {
    return this.a;
}

var g = f.bind({
    a: "azerty"
});
console.log(g()); // azerty

var o = {
    a: 37,
    f: f,
    g: g
};
console.log(o.f(), o.g()); // 37, azerty
```

2\.4 构造函数中的 this

当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。

构造器返回的默认值是 this 所指的那个对象，也可以手动返回其他的对象。

```js
function C() {
    this.a = 37;
}

var o = new C();
console.log(o.a); // 37
// 为什么this会指向o？首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。

function C2() {
    this.a = 37;
    return {
        a: 38
    }; // 手动设置返回{a:38}对象
}

o = new C2();
console.log(o.a); // 38
```

特殊例子

当 this 碰到 return 时

```js
// 例子1
function fn() {
    this.user = "追梦子";
    return {};
}
var a = new fn();
console.log(a.user); //undefined
// 例子2
function fn() {
    this.user = "追梦子";
    return function() {};
}
var a = new fn();
console.log(a.user); //undefined
// 例子3
function fn() {
    this.user = "追梦子";
    return 1;
}
var a = new fn();
console.log(a.user); //追梦子
// 例子4
function fn() {
    this.user = "追梦子";
    return undefined;
}
var a = new fn();
console.log(a.user); //追梦子
// 例子5
function fn() {
    this.user = "追梦子";
    return undefined;
}
var a = new fn();
console.log(a); //fn {user: "追梦子"}
// 例子6
// 虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊
function fn() {
    this.user = "追梦子";
    return null;
}
var a = new fn();
console.log(a.user); //追梦子

// 总结：如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。
```

2\.5 setTimeout & setInterval

（1）对于延时函数内部的回调函数的 this 指向全局对象 window；

（2）可以通过 bind()方法改变内部函数 this 指向。

```js
//默认情况下代码
function Person() {
    this.age = 0;
    setTimeout(function() {
        console.log(this);
    }, 3000);
}

var p = new Person(); //3秒后返回 window 对象
//通过bind绑定
function Person() {
    this.age = 0;
    setTimeout(
        function() {
            console.log(this);
        }.bind(this),
        3000
    );
}

var p = new Person(); //3秒后返回构造函数新生成的对象 Person{...}
```

## 3、在 DOM 事件中

3\.1 作为一个 DOM 事件处理函数

当函数被用作事件处理函数时，它的 this 指向触发事件的元素（针对 addEventListener 事件）。

```js
// 被调用时，将关联的元素变成蓝色
function bluify(e) {
    //this指向所点击元素
    console.log("this === e.currentTarget", this === e.currentTarget); // 总是 true
    // 当 currentTarget 和 target 是同一个对象时为 true
    console.log("this === e.target", this === e.target);
    this.style.backgroundColor = "#A5D9F3";
}

// 获取文档中的所有元素的列表
var elements = document.getElementsByTagName("*");

// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色
for (var i = 0; i < elements.length; i++) {
    elements[i].addEventListener("click", bluify, false);
}
```

3\.2 作为一个内联事件处理函数

（1）当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素；

（2）当代码被包括在函数内部执行时，其 this 指向等同于 普通函数直接调用的情况，即在非严格模式指向全局对象 window，在严格模式指向 undefined：

```html
<button onclick="console.log(this)">show me</button>
<button onclick="(function () {console.log(this)})()">show inner this</button>
<button onclick="(function () {'use strict'; console.log(this)})()">
    use strict
</button>
```

```

// 控制台打印
<button onclick="console.log(this)">show me</button>
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
undefined
```

## 4、箭头函数

4\.1 全局环境中

在全局代码中，箭头函数被设置为全局对象：

```js
var globalObject = this;
var foo = () => this;
console.log(foo() === globalObject); // true
```

4\.2 this 捕获上下文

箭头函数没有自己的 this，而是使用箭头函数所在的作用域的 this，即指向箭头函数定义时（而不是运行时）所在的作用域。

```js
//1、箭头函数在函数内部，以非方法的方法使用
function Person() {
    this.age = 0;
    setInterval(() => {
        this.age++;
    }, 3000);
}
var p = new Person(); //Person{age: 0}

//普通函数作为内部函数
function Person() {
    this.age = 0;
    setInterval(function() {
        console.log(this);
        this.age++;
    }, 3000);
}
var p = new Person(); //Window{...}
```

4\.2 this 捕获上下文

箭头函数没有自己的 this，而是使用箭头函数所在的作用域的 this，即指向箭头函数定义时（而不是运行时）所在的作用域。

```js
//1、箭头函数在函数内部，以非方法的方法使用
function Person() {
    this.age = 0;
    setInterval(() => {
        console.log(this);
        this.age++;
    }, 3000);
}
var p = new Person(); //Person{age: 0}

//普通函数作为内部函数
function Person() {
    this.age = 0;
    setInterval(function() {
        console.log(this);
        this.age++;
    }, 3000);
}
var p = new Person(); //Window{...}
```

在 setTimeout 中的 this 指向了构造函数新生成的对象，而普通函数指向了全局 window 对象。

4\.3 箭头函数作为对象的方法使用

箭头函数作为对象的方法使用，指向全局 window 对象；而普通函数作为对象的方法使用，则指向调用的对象。

```js
var obj = {
    i: 10,
    b: () => console.log(this.i, this),
    c: function() {
        console.log(this.i, this);
    }
};
obj.b(); // undefined window{...}
obj.c(); // 10 Object {...}
```

4\.4 箭头函数中，call\(\)、apply\(\)、bind\(\)方法无效

```js
var adder = {
    base: 1,
    //对象的方法内部定义箭头函数，this是箭头函数所在的作用域的this，
    //而方法add的this指向adder对象，所以箭头函数的this也指向adder对象。
    add: function(a) {
        var f = v => v + this.base;
        return f(a);
    },
    //普通函数f1的this指向window
    add1: function() {
        var f1 = function() {
            console.log(this);
        };
        return f1();
    },
    addThruCall: function inFun(a) {
        var f = v => v + this.base;
        var b = {
            base: 2
        };

        return f.call(b, a);
    }
};

console.log(adder.add(1)); // 输出 2
adder.add1(); //输出全局对象 window{...}
console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder
```

4\.5 this 指向固定化

箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数

```js
var handler = {
    id: "123456",

    init: function() {
        document.addEventListener(
            "click",
            event => this.doSomething(event.type),
            false
        );
    },

    doSomething: function(type) {
        console.log("Handling " + type + " for " + this.id);
    }
};
```

上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象。如果不使用箭头函数则指向全局 document 对象。

4\.6 箭头函是不适用场景

（1）箭头函数不适合定义对象的方法（方法内有 this），因为此时指向 window；

（2）需要动态 this 的时候，也不应使用箭头函数。

```js
//例1，this指向定义箭头函数所在的作用域，它位于对象cat内，但cat不能构成一个作用域，所以指向全局window，改成普通函数后this指向cat对象。
const cat = {
    lives: 9,
    jumps: () => {
        this.lives--;
    }
};

//例2，此时this也是指向window，不能动态监听button，改成普通函数后this指向按钮对象。
var button = document.getElementById("press");
button.addEventListener("click", () => {
    this.classList.toggle("on");
});
```

[参与互动](https://github.com/yisainan/web-interview/issues/249)

</details>

<b><details><summary>81.call 与 apply 区别</summary></b>

参考答案：第二个参数的类型不同

解析：

call 和 apply 的作用，完全一样，唯一的区别就是在参数上面。

call 接收的参数不固定，第一个参数是函数体内 this 的指向，第二个参数以下是依次传入的参数。

apply 接收两个参数，第一个参数也是函数体内 this 的指向。第二个参数是一个集合对象（数组或者类数组）

[参与互动](https://github.com/yisainan/web-interview/issues/250)

</details>

<b><details><summary>82.正则表达式构造函数 var reg = new RegExp('xxx')与正则表达字面量 var reg = // 有什么不同？</summary></b>

参考答案：使用正则表达字面量的效率更高

解析：下面的示例代码演示了两种可用于创建正则表达式以匹配反斜杠的方法：

```js
//正则表达字面量
var re = /\\/gm;

//正则构造函数
var reg = new RegExp("\\\\", "gm");

var foo = "abc\\123"; // foo的值为"abc\123"
console.log(re.test(foo)); //true
console.log(reg.test(foo)); //true
```

如上面的代码中可以看到，使用正则表达式字面量表示法时式子显得更加简短，而且不用按照类似类（class-like）的构造函数方式思考。

其次，在当使用构造函数的时候，在这里要使用四个反斜杠才能匹配单个反斜杠。这使得正则表达式模式显得更长，更加难以阅读和修改。正确来说，当使用 RegExp()构造函数的时候，不仅需要转义引号（即\"表示"），并且通常还需要双反斜杠（即\\表示一个\）。

使用 new RegExp()的原因之一在于，某些场景中无法事先确定模式，而只能在运行时以字符串方式创建。

[参考](https://www.cnblogs.com/coco1s/p/4008955.html)

[参与互动](https://github.com/yisainan/web-interview/issues/251)

</details>

<b><details><summary>83.js 中 callee 与 caller 的作用</summary></b>

参考答案：

1\.caller 返回一个调用当前函数的引用 如果是由顶层调用的话 则返回 null

（举个栗子哈 caller 给你打电话的人 谁给你打电话了 谁调用了你 很显然是下面 a 函数的执行 只有在打电话的时候你才能知道打电话的人是谁 所以对于函数来说 只有 caller 在函数执行的时候才存在）

```js
var callerTest = function() {
    console.log(callerTest.caller);
};

function a() {
    callerTest();
}
a(); //输出function a() {callerTest();}
callerTest(); //输出null
```

2\.callee 返回一个正在被执行函数的引用 （这里常用来递归匿名函数本身 但是在严格模式下不可行）

   callee 是 arguments 对象的一个成员 表示对函数对象本身的引用 它有个 length 属性（代表形参的长度）

```js
var c = function(x, y) {
    console.log(arguments.length, arguments.callee.length, arguments.callee);
};
c(1, 2, 3); //输出3 2 function(x,y) {console.log(arguments.length,arguments.callee.length,arguments.callee)}
```

[参与互动](https://github.com/yisainan/web-interview/issues/252)

</details>

<b><details><summary>84.异步加载 js 的方法 </summary></b>

参考答案：

方案一： `<script>` 标签的 async="async"属性（详细参见：script 标签的 async 属性）

点评：HTML5 中新增的属性，Chrome、FF、IE9&IE9+均支持（IE6~8 不支持）。此外，这种方法不能保证脚本按顺序执行。

方案二： `<script>` 标签的 defer="defer"属性

点评：兼容所有浏览器。此外，这种方法可以确保所有设置 defer 属性的脚本按顺序执行。

方案三：动态创建 `<script>` 标签

示例：

```html
<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript">
        (function() {
            var s = document.createElement_x("script");
            s.type = "text/javascript";
            s.src = "http://code.jquery.com/jquery-1.7.2.min.js";
            var tmp = document.getElementsByTagName_r("script")[0];
            tmp.parentNode.insertBefore(s, tmp);
        })();
    </script>
</head>

<body>
    <img src="http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg" />
</body>

</html>
```

点评：兼容所有浏览器。

方案四：AJAX eval（使用 AJAX 得到脚本内容，然后通过 eval_r(xmlhttp.responseText)来运行脚本）

点评：兼容所有浏览器。

方案五：iframe 方式（这里可以参照：iframe 异步加载技术及性能 中关于 Meboo 的部分）

点评：兼容所有浏览器。

[参与互动](https://github.com/yisainan/web-interview/issues/253)

</details>

<b><details><summary>85.去除数组重复成员的方法</summary></b>

参考答案：

方法 1 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员

```js
// 去除数组的重复成员
[...new Set([1, 2, 2, 3, 4, 5, 5])];
// [1, 2, 3, 4, 5]
```

方法 2

```js
function dedupe(array) {
    return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3]); // [1, 2, 3]
```

方法 3（ES5）

```js
function unique(arry) {
    const temp = [];
    arry.forEach(e => {
        if (temp.indexOf(e) == -1) {
            temp.push(e);
        }
    });

    return temp;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/254)

</details>

<b><details><summary>86.去除字符串里面的重复字符</summary></b>

参考答案：

最简单的方式

```js
[...new Set("ababbc")].join(""); // "abc"
```

[参与互动](https://github.com/yisainan/web-interview/issues/255)

</details>

<b><details><summary>87.求数组的最大值</summary></b>

参考答案：Math.max.apply(null, 数组)

```js
var a = [1, 2, 3, 5];
alert(Math.max.apply(null, a)); //最大值
alert(Math.min.apply(null, a)); //最小值
```

[参与互动](https://github.com/yisainan/web-interview/issues/256)

</details>

<b><details><summary>88.JS 中 文档碎片的理解和使用</summary></b>

参考答案：

```js
// 1、什么是文档碎片？

document.createDocumentFragment(); // 一个容器，用于暂时存放创建的dom元素

// 2、文档碎片有什么用？

// 将需要添加的大量元素,先添加到文档碎片中，再将文档碎片添加到需要插入的位置，大大 减少dom操作，提高性能（IE和火狐比较明显）
```

解析：

```js
// 普通方式：（操作了100次dom）
for (var i = 100; i > 0; i--) {
    var elem = document.createElement("div");
    document.body.appendChild(elem); //放到body中
}

//  文档碎片：(操作1次dom)
var df = document.createDocumentFragment();
for (var i = 100; i > 0; i--) {
    var elem = document.createElement("div");
    df.appendChild(elem);
}
//最后放入到页面上
document.body.appendChild(df);
```

[参与互动](https://github.com/yisainan/web-interview/issues/257)

</details>

<b><details><summary>89.原型的作用 以及什么是原型</summary></b>

参考答案：作用：实现资源共享

什么是原型: 实例在被创建的那一刻，构造函数的 prototype 属性的值。

[参与互动](https://github.com/yisainan/web-interview/issues/258)

</details>

<b><details><summary>90.javascript 里面的继承怎么实现，如何避免原型链上面的对象共享</summary></b>

参考答案：用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量

[参与互动](https://github.com/yisainan/web-interview/issues/259)

</details>

<b><details><summary>91.简单介绍下 JS 的原型和原型链</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/260)

</details>

<b><details><summary>92.说说你对作用域链的理解</summary></b>

参考答案：作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的。

[参与互动](https://github.com/yisainan/web-interview/issues/261)

</details>

<b><details><summary>93.JavaScript 原型，原型链 ? 有什么特点？</summary></b>

参考答案：

* 原型对象也是普通的对象，是对象一个自带隐式的 `__proto__` 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链。
* 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。
* JavaScript 的数据对象有那些属性值？

  　　 writable：这个属性的值是否可以改。
  　　 configurable：这个属性的配置是否可以删除，修改。
  　　 enumerable：这个属性是否能在 for…in 循环中遍历出来或在 Object.keys 中列举出来。
  　　 value：属性值。

* 当我们需要一个属性的时，Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的 Prototype 对象是否有这个属性。

```js
function clone(proto) {
    function Dummy() {}
    Dummy.prototype = proto;
    Dummy.prototype.constructor = Dummy;
    return new Dummy(); //等价于Object.create(Person);
}

function object(old) {
    function F() {}
    F.prototype = old;
    return new F();
}
var newObj = object(oldObject);
```

[参与互动](https://github.com/yisainan/web-interview/issues/262)

</details>

<b><details><summary>94.请解释什么是事件代理</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/263)

</details>

<b><details><summary>95.offsetWidth/offsetHeight, clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/264)

</details>

<b><details><summary>96.谈谈你对 AMD、CMD 的理解</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/265)

</details>

<b><details><summary>97.web 开发中会话跟踪的方法有哪些</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/266)

</details>

<b><details><summary>98.说几条写 JavaScript 的基本规范？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/267)

</details>

<b><details><summary>99.JavaScript 有几种类型的值？你能画一下他们的内存图吗？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/268)

</details>

<b><details><summary>100.eval 是做什么的？</summary></b>

参考答案：

1\.它的功能是把对应的字符串解析成 JS 代码并运行
2\.应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）

[参与互动](https://github.com/yisainan/web-interview/issues/269)

</details>

<b><details><summary>101.js 延迟加载的方式有哪些？</summary></b>

参考答案：defer 和 async、动态创建 DOM 方式（用得最多）、按需异步载入 js

[参与互动](https://github.com/yisainan/web-interview/issues/270)

</details>

<b><details><summary>102.attribute 和 property 的区别是什么？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/271)

</details>

<b><details><summary>103.什么是面向对象编程及面向过程编程，它们的异同和优缺点</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/272)

</details>

<b><details><summary>104.谈一谈你理解的函数式编程？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/273)

</details>

<b><details><summary>105.对原生 Javascript 了解程度</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/274)

</details>

<b><details><summary>106.Js 动画与 CSS 动画区别及相应实现</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/275)

</details>

<b><details><summary>107.快速的让一个数组乱序</summary></b>

参考答案：

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
console.log(arr.sort(() => 0.5 - Math.random()))

[参与互动](https://github.com/yisainan/web-interview/issues/276)

</details>

<b><details><summary>108.prototype 和__proto__的关系是什么？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/277)

</details>

<b><details><summary>109.UIWebView 和 JavaScript 之间是怎么交互的?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/278)

</details>

<b><details><summary>110.IE 与火狐的事件机制有什么区别？如何阻止冒泡</summary></b>

参考答案：

1\.我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
2\.事件处理机制：IE 是事件冒泡、火狐是 事件捕获；
3\.ev\.stopPropagation\(\); 

[参与互动](https://github.com/yisainan/web-interview/issues/279)

</details>

<b><details><summary>111.在 js 中哪些会被隐式转换为 false</summary></b>

参考答案：Undefined、null、关键字 false、NaN、零、空字符串

[参与互动](https://github.com/yisainan/web-interview/issues/280)

</details>

<b><details><summary>112.列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？</summary></b>

参考答案：

对象：Window，document，location，screen，history，navigator。
方法：Alert()，confirm()，prompt()，open()，close()。

[参与互动](https://github.com/yisainan/web-interview/issues/281)

</details>

<b><details><summary>113.class.forname 的作用? 为什么要用?</summary></b>

参考答案：

```

1、获取Class对象的方式：类名.class、对象.getClass()、Class.forName(“类名”);
2、通过Class对象自审
3、动态调用方法
```

[参与互动](https://github.com/yisainan/web-interview/issues/282)

</details>

<b><details><summary>114.外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</summary></b>

参考答案：会出现乱码，加 charset="GB2312"; 

[参与互动](https://github.com/yisainan/web-interview/issues/283)

</details>

<b><details><summary>115.定时器 setInterval 有一个有名函数 fn1，setInterval（fn1, 500）与 setInterval（fn1(), 500）有什么区别？</summary></b>

参考答案：第一个是重复执行每 500 毫秒执行一次，后面一个只执行一次。

[参与互动](https://github.com/yisainan/web-interview/issues/284)

</details>

<b><details><summary>116.自动分号</summary></b>

参考答案：有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic SemicolonInsertion，ASI）。<br>
因为如果缺失了必要的 ; ，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的。<br>
请注意，ASI 只在换行符处起作用，而不会在代码行的中间插入分号。<br>
如果 JavaScript 解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会这样做。

[参与互动](https://github.com/yisainan/web-interview/issues/285)

</details>

<b><details><summary>117.你用过 require.js吗？它有什么特性？</summary></b>

参考答案：

（1）实现 js 文件的异步加载，避免网页失去响应；
（2）管理模块之间的依赖性，便于代码的编写和维护。

[参与互动](https://github.com/yisainan/web-interview/issues/286)

</details>

<b><details><summary>118.如何阻止事件冒泡和默认事件？</summary></b>

参考答案：

阻止浏览器的默认行为
window.event?window.event.returnValue=false:e.preventDefault(); 

停止事件冒泡
window.event?window.event.cancelBubble=true:e.stopPropagation(); 
原生 JavaScript 中，return false; 只阻止默认行为，不阻止冒泡，jQuery 中的 return false; 既阻止默认行为，又阻止冒泡

[参与互动](https://github.com/yisainan/web-interview/issues/287)

</details>

<b><details><summary>119.分别阐述 split(), slice(), splice(), join()？</summary></b>

参考答案：

* join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于 Array
* split()即把字符串分离开，以数组方式存储。归属于 Stringstring
* slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()
* splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。

[参与互动](https://github.com/yisainan/web-interview/issues/288)

</details>

<b><details><summary>120.事件、IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</summary></b>

参考答案：

1\.我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为
2\.事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件
3\.ev\.stopPropagation\(\); 

   注意旧 ie 的方法：ev.cancelBubble = true; 

[参与互动](https://github.com/yisainan/web-interview/issues/289)

</details>

<b><details><summary>121.内置函数(原生函数)</summary></b>

参考答案：

* String
* Number
* Boolean
* Object
* Function
* Array
* Date
* RegExp
* Error
* Symbol

[参与互动](https://github.com/yisainan/web-interview/issues/290)

</details>

<b><details><summary>122.对象浅拷贝和深拷贝有什么区别</summary></b>

参考答案：在 `JS` 中，除了基本数据类型，还存在对象、数组这种引用类型。
基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。

```

let o1 = {a: 1}
let o2 = o1
```

在这种情况下，如果改变 `o1` 或 `o2` 其中一个值的话，另一个也会变，因为它们都指向同一个地址。

```

o2.a = 3
console.log(o1.a) // 3
```

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。

[参与互动](https://github.com/yisainan/web-interview/issues/291)

</details>

<b><details><summary>123.JS 怎么实现一个类。怎么实例化这个类</summary></b>

参考答案：严格来讲 js 中并没有类的概念，不过 js 中的函数可以作为构造函数来使用，通过 new 来实例化，其实函数本身也是一个对象。

[参与互动](https://github.com/yisainan/web-interview/issues/292)

</details>

<b><details><summary>124.如何编写高性能的 Javascript？</summary></b>

参考答案：

* 使用 DocumentFragment 优化多次 append
* 通过模板元素 clone ，替代 createElement
* 使用一次 innerHTML 赋值代替构建 dom 元素
* 使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素
* 使用 Array 做为 StringBuffer ，代替字符串拼接的操作
* 将循环控制量保存到局部变量
* 顺序无关的遍历时，用 while 替代 for
* 将条件分支，按可能性顺序从高到低排列
* 在同一条件子的多（ >2 ）条件分支时，使用 switch 优于 if
* 使用三目运算符替代条件分支
* 需要不断执行的时候，优先考虑使用 setInterval

[参与互动](https://github.com/yisainan/web-interview/issues/293)

</details>

<b><details><summary>125.数组和对象有哪些原生方法，列举一下？</summary></b>

参考答案：

* Array.concat( ) 连接数组
* Array.join( ) 将数组元素连接起来以构建一个字符串
* Array.length 数组的大小
* Array.pop( ) 删除并返回数组的最后一个元素
* Array.push( ) 给数组添加元素
* Array.reverse( ) 颠倒数组中元素的顺序
* Array.shift( ) 将元素移出数组
* Array.slice( ) 返回数组的一部分
* Array.sort( ) 对数组元素进行排序
* Array.splice( ) 插入、删除或替换数组的元素
* Array.toLocaleString( ) 把数组转换成局部字符串
* Array.toString( ) 将数组转换成一个字符串
* Array.unshift( ) 在数组头部插入一个元素

* Object.hasOwnProperty( ) 检查属性是否被继承
* Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型
* Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性
* Object.toLocaleString( ) 返回对象的本地字符串表示
* Object.toString( ) 定义一个对象的字符串表示
* Object.valueOf( ) 指定对象的原始值

[参与互动](https://github.com/yisainan/web-interview/issues/294)

</details>

<b><details><summary>126.documen.write 和 innerHTML 的区别?</summary></b>

参考答案：

1\.document\.write 是重写整个 document, 写入内容是字符串的 html
2\.innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容

[参与互动](https://github.com/yisainan/web-interview/issues/295)

</details>

<b><details><summary>127.让你自己设计实现一个 requireJS，你会怎么做？</summary></b>

参考答案：核心是实现 js 的加载模块，维护 js 的依赖关系，控制好文件加载的先后顺序

[参与互动](https://github.com/yisainan/web-interview/issues/296)

</details>

<b><details><summary>128.requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</summary></b>

参考答案：核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存

[参与互动](https://github.com/yisainan/web-interview/issues/297)

</details>

<b><details><summary>129.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</summary></b>

参考答案：HasOwnProperty

[参与互动](https://github.com/yisainan/web-interview/issues/298)

</details>

<b><details><summary>130.原型继承</summary></b>

参考答案：所有的 JS 对象都有一个 prototype 属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

[参与互动](https://github.com/yisainan/web-interview/issues/299)

</details>

<b><details><summary>131.用原生 JavaScript 的实现过什么功能吗？</summary></b>

参考答案：轮播图、手风琴、放大镜、3D动画效果等，切记，所答的一定要知道实现原理！，不知道还不如不说！

[参与互动](https://github.com/yisainan/web-interview/issues/300)

</details>

<b><details><summary>132.javascript 代码中的"use strict"; 是什么意思 ? 使用它区别是什么？</summary></b>

参考答案：意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持

[参与互动](https://github.com/yisainan/web-interview/issues/301)

</details>

<b><details><summary>133.简述创建函数的几种方式</summary></b>

参考答案：

```

第一种（函数声明）：
function sum1(num1,num2){
   return num1+num2;
}
第二种（函数表达式）：
var sum2 = function(num1,num2){
   return num1+num2;
}
第三种（函数对象方式）：
var sum3 = new Function("num1","num2","return num1+num2");
```

[参与互动](https://github.com/yisainan/web-interview/issues/302)

</details>

<b><details><summary>134.window.location.search() 返回的是什么？</summary></b>

参考答案：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面, 并使用 javascript 来获得相信应的参数值
返回值：?ver=1.0&id=timlq 也就是问号后面的！

[参与互动](https://github.com/yisainan/web-interview/issues/303)

</details>

<b><details><summary>135.window.location.hash  返回的是什么？</summary></b>

参考答案：锚点 ，  返回值：#love ；

[参与互动](https://github.com/yisainan/web-interview/issues/304)

</details>

<b><details><summary>136.window.location.reload() 作用？</summary></b>

参考答案：刷新当前页面

[参与互动](https://github.com/yisainan/web-interview/issues/305)

</details>

<b><details><summary>137.为什么不能定义 1px 左右的 div 容器？</summary></b>

参考答案：
IE6 下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：
overflow:hidden | zoom:0.08 | line-height:1px

[参与互动](https://github.com/yisainan/web-interview/issues/306)

</details>

<b><details><summary>138.BOM 对象有哪些，列举 window 对象？</summary></b>

参考答案：

```

 1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；
 2、document对象，文档对象；
 3、location对象，浏览器当前URL信息；
 4、navigator对象，浏览器本身信息；
 5、screen对象，客户端屏幕信息；
 6、history对象，浏览器访问历史信息；
```

[参与互动](https://github.com/yisainan/web-interview/issues/307)

</details>

<b><details><summary>139.简述 readonly 与 disabled 的区别</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/308)

</details>

<b><details><summary>140.为什么扩展 javascript 内置对象不是好的做法？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/309)

</details>

<b><details><summary>141.什么是三元表达式？“三元”表示什么意思？</summary></b>

参考答案：三元如名字表示的三元运算符需要三个操作数。

语法是 条件 ? 结果1 : 结果2; .这里你把条件写在问号(?)的前面后面跟着用冒号(:)分隔的结果1和结果2。满足条件时结果1否则结果2。

[参与互动](https://github.com/yisainan/web-interview/issues/310)

</details>

<b><details><summary>142.我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获</summary></b>

参考答案：所有事件的顺序是：其他元素捕获阶段事件 -> 本元素代码顺序事件 -> 其他元素冒泡阶段事件 。

[参考](https://blog.csdn.net/qiqingjin/article/details/51387217)

[参与互动](https://github.com/yisainan/web-interview/issues/311)

</details>

<b><details><summary>144.简述一下 Handlebars 的基本用法？</summary></b>

参考答案：没有用过的话说出它是干什么的即可

[参与互动](https://github.com/yisainan/web-interview/issues/312)

</details>

<b><details><summary>143.简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/313)

</details>

<b><details><summary>145.前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</summary></b>

参考答案：

* Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，
* Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。
* Underscore 封装了常用的 JavaScript 对象操作方法，用于提高开发效率。
* Handlebars 是 JavaScript 一个语义模板库，通过对 view 和 data 的分离来快速构建 Web 模板。

[参与互动](https://github.com/yisainan/web-interview/issues/314)

</details>

<b><details><summary>146.知道什么是 webkit 么? 知道怎么用浏览器的各种工具来调试和 debug 代码么?</summary></b>

参考答案：Webkit 是浏览器引擎，包括 html 渲染和 js 解析功能，手机浏览器的主流内核，与之相对应的引擎有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用）。
对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js 调试工具使用，熟练使用这些工具可以快速提高解决问题的效率

[参与互动](https://github.com/yisainan/web-interview/issues/315)

</details>

<b><details><summary>147.如何测试前端代码? 知道 BDD, TDD, Unit Test 么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</summary></b>

参考答案：了解 BDD 行为驱动开发与 TDD 测试驱动开发已经单元测试相关概念

[参与互动](https://github.com/yisainan/web-interview/issues/316)

</details>

<b><details><summary>148.JavaScript 的循环语句有哪些？</summary></b>

参考答案：while for do while forEach

[参与互动](https://github.com/yisainan/web-interview/issues/317)

</details>

<b><details><summary>149.作用域-编译期执行期以及全局局部作用域问题</summary></b>

参考答案：js 执行主要的两个阶段：预解析和执行期

[参与互动](https://github.com/yisainan/web-interview/issues/318)

</details>

<b><details><summary>150.如何添加 html 元素的事件，有几种方法？请列举</summary></b>

参考答案：直接在标签里添加；在元素上添加、使用事件注册函数添加

[参与互动](https://github.com/yisainan/web-interview/issues/319)

</details>

<b><details><summary>151.列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个</summary></b>

参考答案：

对象：Window document location screen history navigator

方法：Alert() confirm() prompt() open() close()

[参与互动](https://github.com/yisainan/web-interview/issues/320)

</details>

<b><details><summary>152.事件绑定的方式</summary></b>

参考答案：

* 嵌入 dom

```html
<button onclick="func()">按钮</button>
```

* 直接绑定

```js
btn.onclick = function() {};
```

* 事件监听

```js
btn.addEventListener("click", function() {});
```

[参与互动](https://github.com/yisainan/web-interview/issues/321)

</details>

<b><details><summary>153.事件循环</summary></b>

参考答案：事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。

[参与互动](https://github.com/yisainan/web-interview/issues/322)

</details>

<b><details><summary>154.事件模型</summary></b>

参考答案：

* DOM0<br>

  直接绑定

```

<input onclick="sayHi()"/>

btn.onclick = function() {}
btn.onclick = null
```

* DOM2<br>

  DOM2 级事件可以冒泡和捕获
  通过 addEventListener 绑定
  通过 removeEventListener 解绑

```

// 绑定
btn.addEventListener('click', sayHi)
// 解绑
btn.removeEventListener('click', sayHi)
```

* DOM3<br>

  DOM3 具有更多事件类型
  DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下：

```

UI事件，当用户与页面上的元素交互时触发，如：load、scroll
焦点事件，当元素获得或失去焦点时触发，如：blur、focus
鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
文本事件，当在文档中输入文本时触发，如：textInput
键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress
合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart
变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified
```

解析：[参考](https://www.jianshu.com/p/3acdf5f71d5b)

[参与互动](https://github.com/yisainan/web-interview/issues/323)

</details>

<b><details><summary>155.如何自定义事件</summary></b>

参考答案：

1\.原生提供了 3 个方法实现自定义事件
2\.createEvent，设置事件类型，是 html 事件还是 鼠标事件
3\.initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件
4\.dispatchEvent 触发事件

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events)

[参与互动](https://github.com/yisainan/web-interview/issues/324)

</details>

<b><details><summary>156.target 和 currentTarget 区别</summary></b>

参考答案：

* event.target<br>

  返回触发事件的元素

* event.currentTarget<br>

  返回绑定事件的元素

[参与互动](https://github.com/yisainan/web-interview/issues/325)

</details>

<b><details><summary>157.prototype 和__proto__的关系是什么</summary></b>

参考答案：

所有的对象都拥有__proto__属性，它指向对象构造函数的 prototype 属性

```

let obj = {}
obj.__proto__ === Object.prototype // true

function Test(){}
var test = new Test()
test.__proto__ == Test.prototype // true
```

所有的函数都同时拥有__proto__和 protytpe 属性
函数的__proto__指向自己的函数实现 函数的 protytpe 是一个对象 所以函数的 prototype 也有__proto__属性 指向 Object.prototype

```

function func() {}
func.prototype.__proto__ === Object.prototype // true
```

Object.prototype.__proto__指向 null

```

Object.prototype.__proto__ // null
```

[参与互动](https://github.com/yisainan/web-interview/issues/326)

</details>

<b><details><summary>158.什么是原型属性？</summary></b>

参考答案：从构造函数的prototype属性出发找到原型，这时候就把原型称之为构造函数的原型属性

[参与互动](https://github.com/yisainan/web-interview/issues/880)

</details>

<b><details><summary>159.什么是原型对象？</summary></b>

参考答案：从实例的__proto__出发，找到原型，这时候就把原型称之为实例的原型对象。

[参与互动](https://github.com/yisainan/web-interview/issues/881)

</details>

<b><details><summary>160.使用 let、var 和 const 创建变量有什么区别</summary></b>

参考答案：

用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。

```js
function foo() {
    // 所有变量在函数中都可访问
    var bar = "bar";
    let baz = "baz";
    const qux = "qux";

    console.log(bar); // bar
    console.log(baz); // baz
    console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

```js
if (true) {
    var bar = "bar";
    let baz = "baz";
    const qux = "qux";
}

// 用 var 声明的变量在函数作用域上都可访问
console.log(bar); // bar
// let 和 const 定义的变量在它们被定义的语句块之外不可访问
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。

```js
console.log(foo); // undefined

var foo = "foo";

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = "baz";

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = "bar";
```

用 var 重复声明不会报错，但 let 和 const 会。

```js
var foo = "foo";
var foo = "bar";
console.log(foo); // "bar"

let baz = "baz";
let baz = "qux"; // Uncaught SyntaxError: Identifier 'baz' has already been declared
```

let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。

```js
// 这样不会报错。
let foo = "foo";
foo = "bar";

// 这样会报错。
const baz = "baz";
baz = "qux";
```

解析：[参考](https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#%E4%BD%BF%E7%94%A8letvar%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)

[参与互动](https://github.com/yisainan/web-interview/issues/882)

</details>

<b><details><summary>161.JSON 的了解</summary></b>

参考答案：JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于 JavaScript 的一个子集。数据格式简单, 易于读写, 占用带宽小。

[参与互动](https://github.com/yisainan/web-interview/issues/883)

</details>

<b><details><summary>162.事件代理怎么实现？</summary></b>

参考答案：在元素的父节点注册事件，通过事件冒泡，在父节点捕获事件

[参与互动](https://github.com/yisainan/web-interview/issues/884)

</details>

<b><details><summary>163.什么是属性搜索原则？</summary></b>

参考答案：

1\.首先会去查找对象本身上面有没有这个属性，有的话，就返回这个属性
2\.如果对象本身上面没有这个属性，就到它的原型上面去查找，如果有，就返回
3\.就到原型的原型上面去查找有没有这个属性，如果查找到最后一只没有找到，就返回一个undefined

[参与互动](https://github.com/yisainan/web-interview/issues/885)

</details>

<b><details><summary>164.如何避免重绘或者重排？</summary></b>

参考答案：

1\.分离读写操作

```

var curLeft=div.offsetLeft;
var curTop=div.offsetTop;
div.style.left=curLeft+1+'px';
div.style.top=curTop+1+'px';
```

2\.样式集中改变

```

可以添加一个类，样式都在类中改变
```

3\.可以使用absolute脱离文档流。

4\.使用 display:none ，不使用 visibility，也不要改变 它的 z-index

5\.能用css3实现的就用css3实现。

</details>

<b><details><summary>165.说下函数式编程的理解</summary></b>

参考答案：

1\.什么是函数式编程？

函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。

2\.优势特点

代码简洁、开发快速、命令式实现、函数式实现、易于理解，抽象度高、没有副作用，变量无状态

</details>

<b><details><summary>166.forEach，map和filter的区别（哔哩哔哩）</summary></b>

参考答案：

* filter函数，顾名思义，它是一个用来过滤的函数。他可以通过指定的过滤条件，删选出数组中符合条件的元素，并返回。

* map函数，这个函数与filter函数不同之处在于，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。而map则会返回传入函数return的值。

* forEach函数，可以实现对数组的遍历，和map函数与filter函数不同的是它没有返回值。

</details>

<b><details><summary>167.delete 数组的 item，数组的 length 是否会 -1</summary></b>

参考答案：不会

解析：

### delete Array[index]

```js
const arr = ['a', 'b', 'c', 'd', 'e'];
let result = delete arr[1];
console.log(result); // true;
console.log(arr); // ['a', undefined, 'c', 'd', 'e']
console.log(arr.length); // 5
console.log(arr[1]); // undefined
```

使用delete删除元素，返回true和false, true表示删除成功，false表示删除失败。使用delete删除数组元素并不会改变原数组的长度，只是把被删除元素的值变为undefined。

</details>

<b><details><summary>168.给出 ['1', '3', '10'].map(parseInt) 执行结果</summary></b>

参考答案：[1, NaN, 2]

</details>

<b><details><summary>169.执行上下文</summary></b>

参考答案：

执行上下文可以简单理解为一个对象:

它包含三个部分:

* 变量对象(VO)
* 作用域链(词法作用域)
* this指向

它的类型:

* 全局执行上下文
* 函数执行上下文
* eval执行上下文

代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行

</details>

<b><details><summary>170.怎样理解setTimeout 执行误差</summary></b>

参考答案：定时器是属于 宏任务(macrotask) 。如果当前 执行栈 所花费的时间大于 定时器 时间，那么定时器的回调在 宏任务(macrotask) 里，来不及去调用，所有这个时间会有误差。

解析：[参考](https://juejin.im/post/5cfc9d266fb9a07edb3939ea?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)

</details>

<b><details><summary>171.数组降维</summary></b>

参考答案：

1\.数组字符串化

```js
let arr = [
    [222, 333, 444],
    [55, 66, 77], {
        a: 1
    }
]
arr += '';
arr = arr.split(',');

console.log(arr); // ["222", "333", "444", "55", "66", "77", "[object Object]"]
```

这也是比较简单的一种方式，从以上例子中也能看到问题，所有的元素会转换为字符串，且元素为对象类型会被转换为 "[object Object]" ，对于同一种类型数字或字符串还是可以的。

2\.利用apply和concat转换

```js
function reduceDimension(arr) {
    return Array.prototype.concat.apply([], arr);
}

console.log(reduceDimension([
    [123], 4, [7, 8],
    [9, [111]]
])); // [123, 4, 7, 8, 9, Array(1)]
```

3\.递归

```js
function reduceDimension(arr) {
    let ret = [];
    let toArr = function(arr) {
        arr.forEach(function(item) {
            item instanceof Array ? toArr(item) : ret.push(item);
        });
    }
    toArr(arr);
    return ret;
}
```

4\.Array​\.prototype​\.flat\(\)

```js
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity 作为深度，展开任意深度的嵌套数组
arr3.flat(Infinity);
// [1, 2, 3, 4, 5, 6]
```

5\.使用 reduce、concat 和递归无限反嵌套多层嵌套的数组

```js
var arr1 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]];

function flattenDeep(arr1) {
    return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);
}
flattenDeep(arr1);
// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]
```

解析：[參考](https://blog.csdn.net/xufeiayang/article/details/90111775)

</details>

<b><details><summary>172.为什么for循环嵌套顺序会影响性能？</summary></b>

参考答案：把循环次数大的放在内层，执行时间会比较短

```js
var t1 = new Date().getTime()
for (let i = 0; i < 100; i++) {
    for (let j = 0; j < 1000; j++) {
        for (let k = 0; k < 10000; k++) {}
    }
}
var t2 = new Date().getTime()
console.log('first time', t2 - t1)
```

| 变量 | 实例化(次数) | 初始化(次数) | 比较(次数)      | 自增(次数)      |
| ---- | ------------ | ------------ | --------------- | --------------- |
| i    | 1            | 1            | 10              | 10              |
| j    | 10           | 10           | 10 * 100        | 10 * 100        |
| k    | 10 * 100     | 10 * 100     | 10 * 100 * 1000 | 10 * 100 * 1000 |

```js
for (let i = 0; i < 10000; i++) {
    for (let j = 0; j < 1000; j++) {
        for (let k = 0; k < 100; k++) {

        }
    }
}
var t3 = new Date().getTime()
console.log('two time', t3 - t2)
```

| 变量 | 实例化(次数) | 初始化(次数) | 比较(次数)      | 自增(次数)      |
| ---- | ------------ | ------------ | --------------- | --------------- |
| i    | 1            | 1            | 1000            | 1000            |
| j    | 1000         | 1000         | 1000 * 100      | 1000 * 100      |
| k    | 1000 * 100   | 1000 * 100   | 1000 * 100 * 10 | 1000 * 100 * 10 |

解析：[參考](https://blog.csdn.net/weixin_42182143/article/details/98682537)

</details>

<b><details><summary>173.轮播图实现原理</summary></b>

参考答案：

```

1.图片移动实现原理：
利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动。

2.图片移动动画原理：
从a位置移动到b位置，需要先计算两点之间的差值，通过差值和时间间隔，计算出每次移动的步长，通过添加定时器，每次移动相同的步长，实现动画效果。

3.图片定位停止原理：
每一张照片都有相同的宽度，每张照片都有一个绝对的定位数值，通过检测定每次移动后，照片当前位置和需要到达位置之间的距离是否小于步长，如果小于，说明已经移动到位，可以将定时器清除，来停止动画。

4图片切换原理：
在全局设置一个变量，记录当前图片的位置，每次切换或跳转时，只需要将数值修改，并调用图片页数转像素位置函数，再调用像素运动函数即可。

5.自动轮播原理：
设置定时器，一定时间间隔后，将照片标记加1，然后开始切换。

6.左右点击切换原理：
修改当前位置标记，开始切换。这里需要注意与自动轮播之间的冲突。当点击事件触发之后，停止自动轮播计时器，开始切换。当动画结束后再次添加自动轮播计时器。

7.无缝衔接原理：
需要无缝衔接，难度在于最后一页向后翻到第一页，和第一页向前翻到最后一页。由于图片的基本移动原理。要想实现无缝衔接，两张图片就必须紧贴在一起。所以在第一张的前面需要添加最后一张，最后一张的后面需要添加第一张。

7.预防鬼畜原理：
始终保证轮播图的运动动画只有一个，从底层杜绝鬼畜。需要在每次动画开始之前，尝试停止动画定时器，然后开始为新的动画添加定时器。

8.预防暴力点击原理：
如果用户快速点击触发事件，会在短时间内多次调用切换函数，虽然动画函数可以保证，不会发生鬼畜，但在照片从最后一张到第一张的切换过程，不会按照正常的轮播，而是实现了跳转。所以需要通过添加口令的方式来，限制用户的点击。当用户点击完成后，口令销毁，动画结束后恢复口令。

9.小圆点的位置显示原理：
每次触发动画时，通过全局变量标记，获取当前页数，操作清除所有小圆点，然后指定一页添加样式。

10.点击触发跳转的原理：
类似于左右点击触发，只是这是将全局页面标记，直接修改，后执行动画。需要避免与自动轮播定时器的冲突。
```

解析：[参考](https://blog.csdn.net/konghouy/article/details/81407492)

</details>

<b><details><summary>174.如何设计一个轮播图组件</summary></b>

参考答案：

1\.轮播图功能实现
2\.抽出需要传入的变量，如：背景图，文案描述等

</details>

<b><details><summary>175.script 引入方式</summary></b>

参考答案：

* html 静态 `<script>` 引入
* js 动态插入 `<script>`

* `<script defer>` : 延迟加载，元素解析完成后执行
* `<script async>` : 异步加载，但执行时会阻塞元素渲染

</details>

<b><details><summary>176.数组中的forEach和map的区别</summary></b>

参考答案：

#### 相同点

* 都是循环遍历数组中的每一项
* forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项），index（索引值），arr（原数组）
* 匿名函数中的this都是指向window
* 只能遍历数组
* 都不会改变原数组

#### 区别

map方法

```

1.map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。
2.map方法不会对空数组进行检测，map方法不会改变原始数组。
3.浏览器支持：chrome、Safari1.5+、opera都支持，IE9+,
```

```js
array.map(function(item, index, arr) {}, thisValue)

var arr = [0, 2, 4, 6, 8];
var str = arr.map(function(item, index, arr) {
    console.log(this); //window
    console.log("原数组arr:", arr); //注意这里执行5次
    return item / 2;
}, this);
console.log(str); //[0,1,2,3,4]
```

若arr为空数组，则map方法返回的也是一个空数组。

forEach方法

1\.forEach方法用来调用数组的每个元素，将元素传给回调函数
2\.forEach对于空数组是不会调用回调函数的。

```js
Array.forEach(function(item, index, arr) {}, this)
var arr = [0, 2, 4, 6, 8];
var sum = 0;
var str = arr.forEach(function(item, index, arr) {
    sum += item;
    console.log("sum的值为：", sum); //0 2 6 12 20
    console.log(this); //window
}, this)
console.log(sum); //20
console.log(str); //undefined
```

无论arr是不是空数组，forEach返回的都是undefined。这个方法只是将数组中的每一项作为callback的参数执行一次。

</details>

<b><details><summary>177.for in和for of的区别</summary></b>

参考答案：

```

简单总结就是，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。

for-in总是得到对象的key或数组、字符串的下标。

for-of总是得到对象的value或数组、字符串的值，另外还可以用于遍历Map和Set。
```

</details>

<b><details><summary>178.typeof 与 instanceof 区别</summary></b>

参考答案：

```

1、typeof返回结果是该类型的字符串形式表示【6】（number、string、undefined、boolean、function、object）
2、instanceof是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型。 
```

</details>

<b><details><summary>179.微任务和宏任务</summary></b>

参考答案：


宏任务队列（大家称之为macrotask queue，即callback queue）：按HTML标准严格来说，其实没有macrotask queue这种说法，它也就是ES5中的事件队列，该队列存放的是：DOM事件、AJAX事件、setTimeout事件等的回调。可以通过setTimeout(func)即可将func函数添加到宏任务队列中（使用场景：将计算耗时长的任务切分成小块，以便于浏览器有空处理用户事件，以及显示耗时进度）。

微任务队列（microtask queue）：存放的是Promise事件、nextTick事件（Node.js）等。有一个特殊的函数queueMicrotask(func)可以将func函数添加到微任务队列中。

```js
/*
 * 宏任务
 *   分类： setTimeout setInterval requrestAnimationFrame
 *   1.宏任务所处的队列就是宏任务队列
 *   2.第一个宏任务队列中只有一个任务： 执行主线程的js代码
 *   3.宏任务队列可以有多个
 *   4.当宏任务队列的中的任务全部执行完以后会查看是否有微任务队列如果有先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列
 *
 * 微任务
 *   分类： new Promise().then(回调) process.nextTick
 *   1.微任务所处的队列就是微任务队列
 *   2.只有一个微任务队列
 *   3.在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务
 * */

console.log('----------------- start -----------------');

setTimeout(() => {
    console.log('setTimeout');
}, 0)

new Promise((resolve, reject) => {
    for (var i = 0; i < 5; i++) {
        console.log(i);
    }
    resolve(); // 修改promise实例对象的状态为成功的状态
}).then(() => {
    console.log('promise实例成功回调执行');
})

console.log('----------------- end -----------------');
```

</details>

<b><details><summary>180.JavaScript 中 undefined 和 not defined 的区别</summary></b>

参考答案：undefined是没有初始化，not defined是没有声明

</details>

<b><details><summary>181.在JavaScript中创建一个真正的private方法有什么缺点？</summary></b>

参考答案：每一个对象都会创建一个private方法的方法，这样很耗费内存

观察下面代码

```js
var Employee = function(name, company, salary) {
    this.name = name || "";
    this.company = company || "";
    this.salary = salary || 5000;

    // Private method
    var increaseSalary = function() {
        this.salary = this.salary + 1000;
    };

    // Public method
    this.dispalyIncreasedSalary = function() {
        increaseSlary();
        console.log(this.salary);
    };
};

// Create Employee class object
var emp1 = new Employee("John", "Pluto", 3000);
// Create Employee class object
var emp2 = new Employee("Merry", "Pluto", 2000);
// Create Employee class object
var emp3 = new Employee("Ren", "Pluto", 2500);
```

在这里 emp1, emp2, emp3都有一个increaseSalary私有方法的副本。

所以我们除非必要，非常不推荐使用私有方法。

</details>

<b><details><summary>182.JavaScript怎么清空数组？</summary></b>

参考答案：

方法1

arrayList = []; 

直接改变arrayList所指向的对象，原对象并不改变。

方法2

arrayList.length = 0; 

这种方法通过设置length=0 使原数组清除元素。

方法3

arrayList.splice(0, arrayList.length); 

</details>

<b><details><summary>183.怎么判断一个object是否是数组(array)？</summary></b>

参考答案：

方法1

使用 Object.prototype.toString 来判断是否是数组

function isArray(obj){

    return Object.prototype.toString.call( obj ) === '[object Array]';

}

这里使用call来使 toString 中 this 指向 obj。进而完成判断

方法二

使用 原型链 来完成判断

function isArray(obj){

    return obj.__proto__ === Array.prototype;

}

基本思想是利用 实例如果是某个构造函数构造出来的那么 它的 __proto__是指向构造函数的 prototype属性。

方法3

利用JQuery

function isArray(obj){

    return $.isArray(obj)

}

JQuery isArray 的实现其实就是方法1

</details>

<b><details><summary>184.什么是 undefined x 1 ？</summary></b>

在chrome下执行如下代码，我们就可以看到undefined x 1的身影。

参考答案：

```js
var trees = ["redwood", "bay", "cedar", "oak", "maple"];
delete trees[3];
console.log(trees);
```

当我们使用 delete 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是undefined x 1。
注意如果我们使用trees[3] === 'undefined × 1'返回的是 false。因为它仅仅是一种打印表示，并不是值变为undefined x 1。

</details>

<b><details><summary>185.两种函数声明有什么区别？ </summary></b>

```js
var foo = function() {
    // Some code
};

function bar() {
    // Some code
};
```

参考答案：

foo的定义是在运行时。想系统说明这个问题，我们要引入变量提升的这一概念。

我们可以运行下如下代码看看结果。

```js
console.log(foo)
console.log(bar)

var foo = function() {
    // Some code
};

function bar() {
    // Some code
};
```

输出为

```

undefined
function bar(){ 
    // Some code
}; 
```

为什么那？为什么 foo 打印出来是 undefined，而 bar打印出来却是函数？

JavaScript在执行时，会将变量提升。

所以上面代码JavaScript 引擎在实际执行时按这个顺序执行。

```js
// foo bar的定义位置被提升
function bar() {
    // Some code
};
var foo;

console.log(foo)
console.log(bar)

foo = function() {
    // Some code
};
```

</details>

<b><details><summary>186.什么是跨域？跨域请求资源的方法有哪些？</summary></b>

参考答案：

```

(1)、porxy代理
定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。
实现方法：通过nginx代理；
注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。
(2)、CORS 【Cross-Origin Resource Sharing】
定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。
使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：
res.writeHead(200, {
    "Content-Type": "text/html; charset=UTF-8",
    "Access-Control-Allow-Origin":'http://localhost',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'
});
(3)、jsonp
定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。
特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。
实例如下：
<script>
    function testjsonp(data) {
       console.log(data.name); // 获取返回的结果
    }
</script>
<script>
    var _script = document.createElement('script');
    _script.type = "text/javascript";
    _script.src = "http://localhost:8888/jsonp?callback=testjsonp";
    document.head.appendChild(_script);
</script>
缺点：
　　1、这种方式无法发送post请求（这里）
　　2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。
```

</details>

<b><details><summary>187.谈谈垃圾回收机制方式及内存管理 </summary></b>

参考答案：

```

回收机制方式
1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。
2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。
3、实例如下：
function fn1() {
    var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
    var obj = {name:'hanzichi', age: 10};
   return obj;
}
var a = fn1();
var b = fn2();
fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。
 4、垃圾回收策略：标记清除(较为常用)和引用计数。
标记清除：
　　定义和用法：当变量进入环境时，将变量标记"进入环境"，当变量离开环境时，标记为："离开环境"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。
　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。
引用计数：
　　定义和用法：引用计数是跟踪记录每个值被引用的次数。
　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。
```

</details>

<b><details><summary>188.内存管理</summary></b>

参考答案：

```

1、什么时候触发垃圾回收？
垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。
IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。
IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。
2、合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。
3、GC缺陷：(1)、停止响应其他操作；
4、GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC
```

</details>

<b><details><summary>189.开发过程中遇到的内存泄露情况，如何解决的？</summary></b>

参考答案：

```

1、定义和用法：
内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。
2、内存泄露的几种情况:
(1)、当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。
实例如下:
<div id="myDiv">
    <input type="button" value="Click me" id="myBtn">
</div>
<script type="text/javascript">
    var btn = document.getElementById("myBtn");
    btn.onclick = function(){
        document.getElementById("myDiv").innerHTML = "Processing...";
    }
</script>
解决方法如下：
<div id="myDiv">
    <input type="button" value="Click me" id="myBtn">
</div>
<script type="text/javascript">
    var btn = document.getElementById("myBtn");
    btn.onclick = function(){
    btn.onclick = null;
        document.getElementById("myDiv").innerHTML = "Processing...";
    }
</script>
(2)、由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。
实例如下：
function bindEvent(){
    var obj=document.createElement("XXX");
    obj.onclick=function(){
        //Even if it's a empty function
    }
}
解决方法如下：

function bindEvent(){
    var obj=document.createElement("XXX");
    obj.onclick=function(){
         //Even if it's a empty function
    }
    obj=null;
}
```

</details>

<b><details><summary>190.IE与标准浏览器对事件处理的区别？</summary></b>

参考答案：

```

1.监听
标准
element.addEventListener('click',observer, useCapture);
element.removeEventListener('click',observer, useCapture);
IE
element.attachEvent('onclick',observer);
element.detachEvent('onclick',observer);
2.阻止冒泡
标准
event.stopPropagation();
IE
event.cancelBubble = true;
3.阻止默认
标准
event.preventDefault();
IE
event.returnValue = false;
4.event
标准
event
IE8以下
window.event
5.触发当前事件的源对象
event.target  //Firefox,Chrome
event.srcElement   //IE,Chrome
```

</details>

<b><details><summary>191.delete用法</summary></b>

参考答案：

```

用于对象属性的删除
var obj = {
    name: 'Lily'
};
delete obj.name;
obj.name   //undefined
不能删除变量、原型中的变量、函数
```

</details>

<b><details><summary>192.如何删除一个cookie</summary></b>

参考答案：

```

1.将时间设为当前时间往前一点。

var date = newDate();

date.setDate(date.getDate() - 1);//真正的删除

setDate()方法用于设置一个月的某一天。

2.expires的设置

document.cookie= 'user='+ encodeURIComponent('name')  + ';expires = ' + newDate(0)
```

</details>

<b><details><summary>193.用正则把yya yyb yyc变成yya5 yyb6 yyc7？</summary></b>

参考答案：

```js
j = 5;
str.replace(/\w+/g, function(m) {
    return m + j++;
});
// function的第一参数代表匹配正则的字符串，第二个代表第一个子表达式匹配的字符串，第三个代表第二个子表达式匹配的字符串。
```

</details>

<b><details><summary>194.怎么判断两个json对象的内容相等？ </summary></b>

参考答案：

```js
obj = {
    a: 1,
    b: 2
}
obj2 = {
    a: 1,
    b: 2
}
obj3 = {
    a: 1,
    b: 2
}
JSON.stringify(obj) == JSON.stringify(obj2); //true
JSON.stringify(obj) == JSON.stringify(obj3); //false
```

</details>

<b><details><summary>195.获取一个月有多少天</summary></b>

今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据

new Date(year, month, date, hrs, min, sec)，new Date 可以接受这些参数创建一个时间对象 其中当我们把 date 设置为 0 的时候，可以直接通过 getDate() 获取到最后一天的日期然后得到我们要的最后一天

参考答案：

```js
new Date(2019, 12, 0).getDate(); // 31
new Date(2018, 2, 0).getDate(); // 28
// 根据这个我们可以得到一个方法
function getMonthLength(month) {
    const date = new Date(month);
    const year = date.getFullYear();
    // 月份是从 0 开始计算的
    const _month = date.getMonth() + 1;
    return new Date(year, _month, 0).getDate();
}
```

</details>

<b><details><summary>196.关于函数的 length 属性</summary></b>

参考答案：

```js
(() => 1).length === 0; // 输出true
```

解析：

函数是有 length 属性的，函数的 length 属性就是函数参数的个数，函数的参数就是 arguments，而 arguments 也是一个类数组对象所以他是有 length 属性的

</details>

<b><details><summary>197.数组中字符串键值的处理</summary></b>

在 JavaScript 中数组是通过数字进行索引，但是有趣的是他们也是对象，所以也可以包含 字符串 键值和属性，但是这些不会被计算在数组的长度（length）内

如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当做数字索引来处理

参考答案：

```js
const arr = [];
arr[0] = 1;
arr['1'] = '嘿嘿';
arr['cym'] = 'cym';
console.log(arr); // [1, '嘿嘿', cym: 'cym']
console.log(arr.length); // 2
```

</details>

<b><details><summary>198.什么是链表？</summary></b>

答案：链表是一种物理存储单元上非连续、非顺序的存储结构。链表由一系列结点组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

</details>

<b><details><summary>199.链表的基本特征</summary></b>

参考答案：

* 每个元素除了存储数据，需要有额外的内存存储一个引用（地址），来指向下一个元素；
* 每个元素占用的内存空间并不要求是连续的；
* 往往使用链表的第一个节点（根节点）来代表整个链表；
* 长度是可变的，随时可以增加和删除元素；
* 插入和删除元素的效率极高；
* 由于要存储下一个元素的地址，会增加额外的内存开销；
* 通过下标查询链表中的某个节点，效率很低，因此链表的下标遍历效率低。

</details>

<b><details><summary>200.如何查找一篇英文文章中出现频率最高的单词？</summary></b>

参考答案：

```js
function findMostWord(article) {
    // 合法性判断
    if (!article) return;

    // 参数处理
    article = article.trim().toLowerCase();

    let wordList = article.match(/[a-z]+/g),
        visited = [],
        maxNum = 0,
        maxWord = "";

    article = " " + wordList.join("  ") + " ";

    // 遍历判断单词出现次数
    wordList.forEach(function(item) {
        if (visited.indexOf(item) < 0) {

            // 加入 visited 
            visited.push(item);

            let word = new RegExp(" " + item + " ", "g"),
                num = article.match(word).length;

            if (num > maxNum) {
                maxNum = num;
                maxWord = item;
            }
        }
    });

    return maxWord + "  " + maxNum;
}
```

</details>

<b><details><summary>201.介绍 js 的基本数据类型。</summary></b>

参考答案：

```
js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。
Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。
BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
```

</details>

<b><details><summary>202.JavaScript 有几种类型的值？你能画一下他们的内存图吗？</summary></b>

参考答案：

涉及知识点：

* 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
* 堆：引用数据类型（对象、数组和函数）

```
两种类型的区别是：存储位置不同。
原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在
栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实
体。
```

回答：

```
js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。

基本数据类型....（参考1）

复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。

两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中
保存对应的指针来获取堆中的值。
```

详细资料可以参考：
[《JavaScript 有几种类型的值？》](https://blog.csdn.net/lxcao/article/details/52749421)
[《JavaScript 有几种类型的值？能否画一下它们的内存图；》](https://blog.csdn.net/jiangjuanjaun/article/details/80327342)

</details>

<b><details><summary>203.什么是堆？什么是栈？它们之间有什么区别和联系？</summary></b>

参考答案：

```
堆和栈的概念存在于数据结构中和操作系统内存中。

在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全
二叉树是堆的一种实现方式。

在操作系统中，内存被分为栈区和堆区。

栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。
```

详细资料可以参考：
[《什么是堆？什么是栈？他们之间有什么区别和联系？》](https://www.zhihu.com/question/19729973)

</details>

<b><details><summary>204.内部属性 [[Class]] 是什么？</summary></b>

参考答案：

```
所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非
传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：

Object.prototype.toString.call( [1,2,3] );
// "[object Array]"

Object.prototype.toString.call( /regex-literal/i );
// "[object RegExp]"

// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签
// 默认情况类的[[Class]]返回[object Object]
class Class1 {}
Object.prototype.toString.call(new Class1()); // "[object Object]"
// 需要定制[[Class]]
class Class2 {
  get [Symbol.toStringTag]() {
    return "Class2";
  }
}
Object.prototype.toString.call(new Class2()); // "[object Class2]"
```

</details>

<b><details><summary>205.介绍 js 有哪些内置对象？</summary></b>

参考答案：

涉及知识点：

```
全局的对象（ global objects ）或称标准内置对象，不要和 "全局对象（global object）" 混淆。这里说的全局的对象是说在
全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。

标准内置对象的分类

（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。

例如 Infinity、NaN、undefined、null 字面量

（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。

例如 eval()、parseFloat()、parseInt() 等

（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。

例如 Object、Function、Boolean、Symbol、Error 等

（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。

例如 Number、Math、Date

（5）字符串，用来表示和操作字符串的对象。

例如 String、RegExp

（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array

（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。

例如 Map、Set、WeakMap、WeakSet

（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。

例如 SIMD 等

（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。

例如 JSON 等

（10）控制抽象对象

例如 Promise、Generator 等

（11）反射

例如 Reflect、Proxy

（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。

例如 Intl、Intl.Collator 等

（13）WebAssembly

（14）其他

例如 arguments

```

回答：

```
js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函
数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构
造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。
```

详细资料可以参考：
[《标准内置对象的分类》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)
[《JS 所有内置对象属性和方法汇总》](https://segmentfault.com/a/1190000011467723#articleHeader24)

</details>

<b><details><summary>206.undefined 与 undeclared 的区别？</summary></b>

参考答案：

```
已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。

对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ
eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。
```

</details>

<b><details><summary>207.null 和 undefined 的区别？</summary></b>

参考答案：

```
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null
主要用于赋值给一些可能会返回对象的变量，作为初始化。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它
会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等
号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
```

详细资料可以参考：
[《JavaScript 深入理解之 undefined 与 null》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html)

</details>

<b><details><summary>208.如何获取安全的 undefined 值？</summary></b>

参考答案：

```
因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。

表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。

按惯例我们用 void 0 来获得 undefined。
```

</details>

<b><details><summary>209.说几条写 JavaScript 的基本规范？</summary></b>

参考答案：

```
在平常项目开发中，我们遵守一些这样的基本规范，比如说：

（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时
    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。

（2）代码中出现地址、时间等字符串时需要使用常量代替。

（3）在进行比较的时候吧，尽量使用'===', '!=='代替'==', '!='。

（4）不要在内置对象的原型上添加方法，如 Array, Date。

（5）switch 语句必须带有 default 分支。

（6）for 循环必须使用大括号。

（7）if 语句必须使用大括号。
```

</details>

<b><details><summary>210.JavaScript 原型，原型链？ 有什么特点？</summary></b>

参考答案：

```
在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对
象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部
将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们
是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这
个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对
象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又
会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就
是我们新建的对象为什么能够使用 toString() 等方法的原因。

特点：

JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与
之相关的对象也会继承这一改变。
```

详细资料可以参考：
[《JavaScript 深入理解之原型与原型链》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html)

</details>

<b><details><summary>211.js 获取原型的方法？</summary></b>

参考答案：

* p.\_\_proto\_\_
* p.constructor.prototype
* Object.getPrototypeOf(p)

</details>

<b><details><summary>212.在 js 中不同进制数字的表示方式</summary></b>

参考答案：

* 以 0X、0x 开头的表示为十六进制。

* 以 0、0O、0o 开头的表示为八进制。

* 以 0B、0b 开头的表示为二进制格式。

</details>

<b><details><summary>213.js 中整数的安全范围是多少？</summary></b>

参考答案：

```
安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，
即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中
被定义为 Number.MIN_SAFE_INTEGER。

如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次
计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数
来判断。
```

</details>

<b><details><summary>214.typeof NaN 的结果是什么？</summary></b>

参考答案：

```
NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出
数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

typeof NaN; // "number"

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN
为 true。
```

</details>

<b><details><summary>215.isNaN 和 Number.isNaN 函数的区别？</summary></b>

参考答案：

```
函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会
返回 true ，会影响 NaN 的判断。

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为
准确。
```

</details>

<b><details><summary>216.Array 构造函数只有一个参数值时的表现？</summary></b>

参考答案：

```
Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样
创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。

构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。
```

</details>

<b><details><summary>217.其他值到字符串的转换规则？</summary></b>

参考答案：

```
规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。

（1）Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，

（2）Boolean 类型，true 转换为 "true"，false 转换为 "false"。

（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。

（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。

（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）
    来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会
    调用该方法并使用其返回值。
```

</details>

<b><details><summary>218.其他值到数字值的转换规则？</summary></b>

参考答案：

```
有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。

（1）Undefined 类型的值转换为 NaN。

（2）Null 类型的值转换为 0。

（3）Boolean 类型的值，true 转换为 1，false 转换为 0。

（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。

（5）Symbol 类型的值不能转换为数字，会报错。

（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。

如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。
```

</details>

<b><details><summary>219.其他值到布尔类型的值的转换规则？</summary></b>

参考答案：

```
ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。

以下这些是假值：
• undefined
• null
• false
• +0、-0 和 NaN
• ""

假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。
```

</details>

<b><details><summary>220.{} 和 [] 的 valueOf 和 toString 的结果是什么？</summary></b>

参考答案：

```
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

</details>

<b><details><summary>221.什么是假值对象？</summary></b>

参考答案：

```
浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和
普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它
是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。
```

</details>

<b><details><summary>222.~ 操作符的作用？</summary></b>

参考答案：

```
~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。

~x 大致等同于 -(x+1)。
```

</details>

<b><details><summary>223.解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</summary></b>

参考答案：

```
解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu
mber ()）不允许出现非数字字符，否则会失败并返回 NaN。
```

</details>

<b><details><summary>224.`+` 操作符什么时候用于字符串的拼接？</summary></b>

参考答案：

```
根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其
中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以
数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。

简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字
加法。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。
```

</details>

<b><details><summary>225.什么情况下会发生布尔值的隐式强制类型转换？</summary></b>

参考答案：

```
（1） if (..) 语句中的条件判断表达式。
（2） for ( ..; ..; ..) 语句中的条件判断表达式（第二个）。
（3） while (..) 和 do..while(..) 循环中的条件判断表达式。
（4） ? : 中的条件判断表达式。
（5） 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
```

</details>

<b><details><summary>226.|| 和 && 操作符的返回值？</summary></b>

参考答案：

```
|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件
判断。

对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。

&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
```

</details>

<b><details><summary>227.Symbol 值的强制类型转换？</summary></b>

参考答案：

```
ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。

Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果
都是 true ）。
```

</details>

<b><details><summary>228.== 操作符的强制类型转换规则？</summary></b>

参考答案：

```
（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。

（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。

（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。

（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。

（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。

（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
```

详细资料可以参考：
[《JavaScript 字符串间的比较》](https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/)

</details>

<b><details><summary>229.如何将字符串转化为数字，例如 '12.3b'?</summary></b>

参考答案：

```
（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。

（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。

（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。

（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。
```

详细资料可以参考：
[《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》](https://blog.csdn.net/m0_38099607/article/details/72638678)

</details>

<b><details><summary>230.如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12, 000, 000.11』?</summary></b>

参考答案：

```js
// 方法一
function format(number) {
    return number && number.replace(/(?!^)(?=(\d{3})+\.)/g, ",");
}
// 方法二
function format1(number) {
    return Intl.NumberFormat().format(number)
}
// 方法三
function format2(number) {
    return number.toLocaleString('en')
}
```

</details>

<b><details><summary>231.常用正则表达式</summary></b>

参考答案：

```js
// （1）匹配 16 进制颜色值
var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;

// （2）匹配日期，如 yyyy-mm-dd 格式
var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;

// （3）匹配 qq 号
var regex = /^[1-9][0-9]{4,10}$/g;

// （4）手机号码正则
var regex = /^1[34578]\d{9}$/g;

// （5）用户名正则
var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;
```

详细资料可以参考：
[《前端表单验证常用的 15 个 JS 正则表达式》](http://caibaojian.com/form-regexp.html)
[《JS 常用正则汇总》](https://www.jianshu.com/p/1cb5229325a7)

</details>

<b><details><summary>232.生成随机数的各种方法？</summary></b>

参考答案：

[《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》](http://www.hangge.com/blog/cache/detail_1872.html)

</details>

<b><details><summary>233.如何实现数组的随机排序？</summary></b>

参考答案：

```js
// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。

function randomSort(a, b) {
    return Math.random() > 0.5 ? -1 : 1;
}

//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。

// （2）随机从原数组抽取一个元素，加入到新数组

function randomSort(arr) {
    var result = [];

    while (arr.length > 0) {
        var randomIndex = Math.floor(Math.random() * arr.length);
        result.push(arr[randomIndex]);
        arr.splice(randomIndex, 1);
    }

    return result;
}

// （3）随机交换数组内的元素（洗牌算法类似）

function randomSort(arr) {
    var index,
        randomIndex,
        temp,
        len = arr.length;

    for (index = 0; index < len; index++) {
        randomIndex = Math.floor(Math.random() * (len - index)) + index;

        temp = arr[index];
        arr[index] = arr[randomIndex];
        arr[randomIndex] = temp;
    }

    return arr;
}

// es6
function randomSort(array) {
    let length = array.length;

    if (!Array.isArray(array) || length <= 1) return;

    for (let index = 0; index < length - 1; index++) {
        let randomIndex = Math.floor(Math.random() * (length - index)) + index;

        [array[index], array[randomIndex]] = [array[randomIndex], array[index]];
    }

    return array;
}
```

详细资料可以参考：
[《Fisher and Yates 的原始版》](https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top)
[《javascript 实现数组随机排序?》](https://www.zhihu.com/question/32303195)
[《JavaScript 学习笔记：数组随机排序》](https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html)

</details>

<b><details><summary>234.javascript 创建对象的几种方式？</summary></b>

参考答案：

```
我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js
和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象
创建方式，我了解到的方式有这么几种：

（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。

嗯我目前了解到的就是这么几种方式。
```

详细资料可以参考：
[《JavaScript 深入理解之对象创建》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html)

</details>

<b><details><summary>235.JavaScript 继承的几种实现方式？</summary></b>

参考答案：

```
我了解的 js 中实现继承的几种方式有：

（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。
```

详细资料可以参考：
[《JavaScript 深入理解之继承》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html)

</details>

<b><details><summary>236.寄生式组合继承的实现？</summary></b>

参考答案：

```js
function Person(name) {
    this.name = name;
}

Person.prototype.sayName = function() {
    console.log("My name is " + this.name + ".");
};

function Student(name, grade) {
    Person.call(this, name);
    this.grade = grade;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.sayMyGrade = function() {
    console.log("My grade is " + this.grade + ".");
};
```

</details>

<b><details><summary>237.Javascript 的作用域链？</summary></b>

参考答案：

```
作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和
函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前
端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

作用域链的创建过程跟执行上下文的建立有关....
```

详细资料可以参考：
[《JavaScript 深入理解之作用域链》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html)

</details>

<b><details><summary>238.谈谈 This 对象的理解。</summary></b>

参考答案：

```
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模
式来判断。
```

* 1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。

* 2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。

* 3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。

* 4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

```
这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后
是函数调用模式。
```

[《JavaScript 深入理解之 this 详解》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html)

</details>

<b><details><summary>239.eval 是做什么的？</summary></b>

参考答案：

```
它的功能是把对应的字符串解析成 JS 代码并运行。

应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。
```

详细资料可以参考：
[《eval()》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval)

</details>

<b><details><summary>240.什么是 DOM 和 BOM？</summary></b>

参考答案：

```
DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM
的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）
对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati
on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对
象的子对象。
```

详细资料可以参考：
[《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》](https://www.zhihu.com/question/33453164)
[《Window 对象》](http://www.w3school.com.cn/jsref/dom_obj_window.asp)
[《DOM 与 BOM 分别是什么，有何关联？》](https://www.zhihu.com/question/20724662)
[《JavaScript 学习总结（三）BOM 和 DOM 详解》](https://segmentfault.com/a/1190000000654274#articleHeader21)

</details>

<b><details><summary>241.写一个通用的事件侦听器函数。</summary></b>

参考答案：

```js
const EventUtils = {
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 添加事件
    addEvent: function(element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + type, handler);
        } else {
            element["on" + type] = handler;
        }
    },

    // 移除事件
    removeEvent: function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = null;
        }
    },

    // 获取事件目标
    getTarget: function(event) {
        return event.target || event.srcElement;
    },

    // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
    getEvent: function(event) {
        return event || window.event;
    },

    // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
    stopPropagation: function(event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    },

    // 取消事件的默认行为
    preventDefault: function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    }
};
```

详细资料可以参考：
[《JS 事件模型》](https://segmentfault.com/a/1190000006934031#articleHeader6)

</details>

<b><details><summary>242.事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</summary></b>

参考答案：

* 1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。

* 2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。

* 3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true; 

详细资料可以参考：
[《Javascript 事件模型系列（一）事件及事件的三种模型》](https://www.cnblogs.com/lvdabao/p/3265870.html)
[《Javascript 事件模型：事件捕获和事件冒泡》](https://blog.csdn.net/wuseyukui/article/details/13771493)

</details>

<b><details><summary>243.三种事件模型是什么？</summary></b>

参考答案：

```
事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实
现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。

第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。
```

详细资料可以参考：
[《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》](https://blog.csdn.net/u013217071/article/details/77613706)

</details>

<b><details><summary>244.事件委托是什么？</summary></b>

参考答案：

```
事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到
目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。
```

详细资料可以参考：
[《JavaScript 事件委托详解》](https://zhuanlan.zhihu.com/p/26536815)

</details>

<b><details><summary>245.["1", "2", "3"].map(parseInt) 答案是多少？</summary></b>

参考答案：

```
parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。

此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 "1-0", "2-1", "3-2"

因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。
```

详细资料可以参考：
[《为什么 ["1", "2", "3"].map(parseInt) 返回 [1, NaN, NaN]？》](https://blog.csdn.net/justjavac/article/details/19473199)

</details>

<b><details><summary>246.什么是闭包，为什么要用它？</summary></b>

参考答案：

```
闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以
访问到当前函数的局部变量。

闭包有两个常用的用途。

闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外
部访问到函数内部的变量，可以使用这种方法来创建私有变量。

函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以
这个变量对象不会被回收。

其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。
```

详细资料可以参考：
[《JavaScript 深入理解之闭包》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html)

</details>

<b><details><summary>247.javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？</summary></b>

参考答案：

相关知识点：

```
use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。

设立"严格模式"的目的，主要有以下几个：
```

* 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 
* 消除代码运行的一些不安全之处，保证代码运行的安全；
* 提高编译器效率，增加运行速度；
* 为未来新版本的 Javascript 做好铺垫。

区别：

* 1.禁止使用 with 语句。
* 2.禁止 this 关键字指向全局对象。
* 3.对象不能有重名的属性。

回答：

```
use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使
用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一
些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。
我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。
```

详细资料可以参考：
[《Javascript 严格模式详解》](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)

</details>

<b><details><summary>248.如何判断一个对象是否属于某个类？</summary></b>

参考答案：

```
第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。

第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的
[[Class]] 属性来进行判断。
```

详细资料可以参考：
[《js 判断一个对象是否属于某一类》](https://blog.csdn.net/haitunmin/article/details/78418522)

</details>

<b><details><summary>249.instanceof 的作用？</summary></b>

参考答案：

```js
// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
// 实现：

function myInstanceof(left, right) {
    let proto = Object.getPrototypeOf(left), // 获取对象的原型
        prototype = right.prototype; // 获取构造函数的 prototype 对象

    // 判断构造函数的 prototype 对象是否在对象的原型链上
    while (true) {
        if (!proto) return false;
        if (proto === prototype) return true;

        proto = Object.getPrototypeOf(proto);
    }
}
```

详细资料可以参考：
[《instanceof》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)

</details>

<b><details><summary>250.new 操作符具体干了什么呢？如何实现？</summary></b>

参考答案：

```js
// （1）首先创建了一个新的空对象
// （2）设置原型，将对象的原型设置为函数的 prototype 对象。
// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

// 实现:

function objectFactory() {
    let newObject = null,
        constructor = Array.prototype.shift.call(arguments),
        result = null;

    // 参数判断
    if (typeof constructor !== "function") {
        console.error("type error");
        return;
    }

    // 新建一个空对象，对象的原型为构造函数的 prototype 对象
    newObject = Object.create(constructor.prototype);

    // 将 this 指向新建对象，并执行函数
    result = constructor.apply(newObject, arguments);

    // 判断返回对象
    let flag =
        result && (typeof result === "object" || typeof result === "function");

    // 判断返回结果
    return flag ? result : newObject;
}

// 使用方法
// objectFactory(构造函数, 初始化参数);
```

详细资料可以参考：
[《new 操作符具体干了什么？》](https://segmentfault.com/a/1190000008576048)
[《JavaScript 深入之 new 的模拟实现》](https://github.com/mqyqingfeng/Blog/issues/13)

</details>

<b><details><summary>251.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</summary></b>

参考答案：

```
hasOwnProperty

所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和
in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
```

详细资料可以参考：
[《Object.prototype.hasOwnProperty()》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)

</details>

<b><details><summary>252.对于 JSON 的了解？</summary></b>

参考答案：

相关知识点：

```
JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。

JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与
值的映射）。

JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。
```

回答：

```
JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。

另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。
```

详细资料可以参考：
[《深入了解 JavaScript 中的 JSON 》](https://my.oschina.net/u/3284240/blog/874368)

</details>

<b><details><summary>253.`[].forEach.call($$("*"), function(a){a.style.outline="1px solid #"+(~~</summary></b>

参考答案：(Math.random()*(1<<24))).toString(16)})` 能解释一下这段代码的意思吗？

```
（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。

（2）循环遍历 DOM 元素

（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。

（4）生成随机颜色函数。Math.random()*(1<<24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。
```

详细资料可以参考：
[《通过一行代码学 JavaScript》](https://2008winstar.iteye.com/blog/2128290)

</details>

<b><details><summary>254.js 延迟加载的方式有哪些？</summary></b>

参考答案：

相关知识点：

```
js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。
```

一般有以下几种方式：

* defer 属性
* async 属性
* 动态创建 DOM 方式
* 使用 setTimeout 延迟方法
* 让 JS 最后加载

回答：

```
js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。

我了解到的几种方式是：

第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。

第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
```

详细资料可以参考：
[《JS 延迟加载的几种方式》](https://blog.csdn.net/meijory/article/details/76389762)
[《HTML 5 `<script>`  `async` 属性》](http://www.w3school.com.cn/html5/att_script_async.asp)

</details>

<b><details><summary>255.Ajax 是什么? 如何创建一个 Ajax？</summary></b>

参考答案：

相关知识点：

2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的
异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。

具体来说，AJAX 包括以下几个步骤。

* 1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象
* 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息
* 3.设置响应 HTTP 请求状态变化的函数
* 4.发送 HTTP 请求
* 5.获取异步调用返回的数据
* 6.使用 JavaScript 和 DOM 实现局部刷新

一般实现：

```js
const SERVER_URL = "/server";

let xhr = new XMLHttpRequest();

// 创建 Http 请求
xhr.open("GET", SERVER_URL, true);

// 设置状态监听函数
xhr.onreadystatechange = function() {
    if (this.readyState !== 4) return;

    // 当请求成功时
    if (this.status === 200) {
        handle(this.response);
    } else {
        console.error(this.statusText);
    }
};

// 设置请求失败时的监听函数
xhr.onerror = function() {
    console.error(this.statusText);
};

// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");

// 发送 Http 请求
xhr.send(null);

// promise 封装实现：

function getJSON(url) {
    // 创建一个 promise 对象
    let promise = new Promise(function(resolve, reject) {
        let xhr = new XMLHttpRequest();

        // 新建一个 http 请求
        xhr.open("GET", url, true);

        // 设置状态的监听函数
        xhr.onreadystatechange = function() {
            if (this.readyState !== 4) return;

            // 当请求成功或失败时，改变 promise 的状态
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        };

        // 设置错误监听函数
        xhr.onerror = function() {
            reject(new Error(this.statusText));
        };

        // 设置响应的数据类型
        xhr.responseType = "json";

        // 设置请求头信息
        xhr.setRequestHeader("Accept", "application/json");

        // 发送 http 请求
        xhr.send(null);
    });

    return promise;
}
```

回答：

```
我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。

创建一个 ajax 有这样几个步骤

首先是创建一个 XMLHttpRequest 对象。

然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。

在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。

当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。
```

详细资料可以参考：
[《XMLHttpRequest 对象》](https://wangdoc.com/javascript/bom/xmlhttprequest.html)
[《从 ajax 到 fetch、axios》](https://juejin.im/post/5acde23c5188255cb32e7e76)
[《Fetch 入门》](https://juejin.im/post/5c160937f265da61180199b2)
[《传统 Ajax 已死，Fetch 永生》](https://segmentfault.com/a/1190000003810652)

</details>

<b><details><summary>256.谈一谈浏览器的缓存机制？</summary></b>

参考答案：

```
浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。

web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，
它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间
的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires
来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n
o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。
如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。

服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，
这样会造成缓存命中的不准确。

因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。
```

详细资料可以参考：
[《浅谈浏览器缓存》](https://segmentfault.com/a/1190000012573337)
[《前端优化：浏览器缓存技术介绍》](https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3)
[《请求头中的 Cache-Control》](https://www.web-tinker.com/article/21221.html)
[《Cache-Control 字段值详解》](https://juejin.im/post/5c2d6c9ae51d450cf4195a08)

</details>

<b><details><summary>257.Ajax 解决浏览器缓存问题？</summary></b>

参考答案：

* 1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since", "0")。

* 2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control", "no-cache")。

* 3.在 URL 后面加上一个随机数： "fresh=" + Math.random(); 。

* 4.在 URL 后面加上时间戳："nowtime=" + new Date().getTime(); 。

* 5.如果是使用 jQuery，直接这样就可以了\$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。

详细资料可以参考：
[《Ajax 中浏览器的缓存问题解决方法》](https://www.cnblogs.com/cwzqianduan/p/8632009.html)
[《浅谈浏览器缓存》](https://segmentfault.com/a/1190000012573337)

</details>

<b><details><summary>258.同步和异步的区别？</summary></b>

参考答案：

相关知识点：

```
同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  

异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 
```

回答：

```
同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返
回为止再继续向下执行。

异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等
待消息的返回，当消息返回时系统再通知进程进行处理。
```

详细资料可以参考：
[《同步和异步的区别》](https://blog.csdn.net/tennysonsky/article/details/45111623)

</details>

<b><details><summary>259.什么是浏览器的同源政策？</summary></b>

参考答案：

```
我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个
域的协议、域名、端口号必须相同，否则则不属于同一个域。

同源政策主要限制了三个方面

第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。

第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。

第三个是当前域下 ajax 无法发送跨域请求。

同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者
script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。
```

</details>

<b><details><summary>260.如何解决跨域问题？</summary></b>

参考答案：

相关知识点：

* 1.通过 jsonp 跨域
* 2.document.domain + iframe 跨域
* 3.location.hash + iframe
* 4.window.name + iframe 跨域
* 5.postMessage 跨域
* 6.跨域资源共享（CORS)
* 7.nginx 代理跨域
* 8.nodejs 中间件代理跨域
* 9.WebSocket 协议跨域

回答：

```
解决跨域的方法我们可以根据我们想要实现的目的来划分。

首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。

（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。

如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。

（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。

（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。

如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。

（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。

非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

（7）使用 websocket 协议，这个协议没有同源限制。

（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。
```

详细资料可以参考：
[《前端常见跨域解决方案（全）》](https://segmentfault.com/a/1190000011145364)
[《浏览器同源政策及其规避方法》](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)
[《跨域，你需要知道的全在这里》](https://juejin.im/entry/59feae9df265da43094488f6)
[《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》](https://www.zhihu.com/question/31592553)

</details>

<b><details><summary>261.服务器代理转发时，该如何处理 cookie？</summary></b>

参考答案：

详细资料可以参考：
[《深入浅出 Nginx》](https://www.jianshu.com/p/5eab0f83e3b4)

</details>

<b><details><summary>262.简单谈一下 cookie ？</summary></b>

参考答案：

```
我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了9个属性值 name、value、expires、domain、path、secure、HttpOnly、SameSite、Priority。其中 name 和 value 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。

在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。
```

详细资料可以参考：
[《HTTP cookies》 ](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)
[《聊一聊 cookie》 ](https://segmentfault.com/a/1190000004556040)

</details>

<b><details><summary>263.模块化开发怎么做？</summary></b>

参考答案：

```
我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念
，但随着程序越来越复杂，代码的模块化开发变得越来越重要。

由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污
染，并且模块间没有联系。

后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所
有的所有的模块成员，外部代码可以修改内部属性的值。

现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。
```

详细资料可以参考：
[《浅谈模块化开发》](https://juejin.im/post/5ab378c46fb9a028ce7b824f)
[《Javascript 模块化编程（一）：模块的写法》](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)
[《前端模块化：CommonJS，AMD，CMD，ES6》](https://juejin.im/post/5aaa37c8f265da23945f365c)
[《Module 的语法》](http://es6.ruanyifeng.com/#docs/module)

</details>

<b><details><summary>264.js 的几种模块规范？</summary></b>

参考答案：

```
js 中现在比较成熟的有四种模块加载方案。

第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是
服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式
加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定
义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。

第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js
的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60

第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。
```

</details>

<b><details><summary>265.AMD 和 CMD 规范的区别？</summary></b>

参考答案：

它们之间的主要区别有两个方面。

（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇
就近依赖，只有在用到某个模块的时候再去 require。

（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于
模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD
在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句
的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

```js
// CMD
define(function(require, exports, module) {
    var a = require("./a");
    a.doSomething();
    // 此处略去 100 行
    var b = require("./b"); // 依赖可以就近书写
    b.doSomething();
    // ...
});

// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
    // 依赖必须一开始就写好
    a.doSomething();
    // 此处略去 100 行
    b.doSomething();
    // ...
});
```

详细资料可以参考：
[《前端模块化，AMD 与 CMD 的区别》](https://juejin.im/post/5a422b036fb9a045211ef789)

</details>

<b><details><summary>266.ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</summary></b>

参考答案：

* 1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

* 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

</details>

<b><details><summary>267.requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</summary></b>

参考答案：

```
require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。
```

详细资料可以参考：
[《requireJS 的用法和原理分析》](https://github.com/HRFE/blog/issues/10)
[《requireJS 的核心原理是什么？》](https://zhuanlan.zhihu.com/p/55039478)
[《从 RequireJs 源码剖析脚本加载原理》](https://www.cnblogs.com/dong-xu/p/7160919.html)
[《requireJS 原理分析》](https://www.jianshu.com/p/5a39535909e4)

</details>

<b><details><summary>268.JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</summary></b>

参考答案：

详细资料可以参考：
[《JS 模块加载器加载原理是怎么样的？》](https://www.zhihu.com/question/21157540)

</details>

<b><details><summary>269.ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</summary></b>

参考答案：

```
在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。

在 class 中添加的方法，其实是添加在类的原型上的。
```

详细资料可以参考：
[《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》](https://www.zhihu.com/question/29789315)
[《Class 的基本语法》](http://es6.ruanyifeng.com/#docs/class)

</details>

<b><details><summary>270.documen.write 和 innerHTML 的区别？</summary></b>

参考答案：

```
document.write 的内容会代替整个文档内容，会重写整个页面。

innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。
```

详细资料可以参考：
[《简述 document.write 和 innerHTML 的区别。》](https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50)

</details>

<b><details><summary>271.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</summary></b>

参考答案：

（1）创建新节点

```js
createDocumentFragment(node);
createElement(node);
createTextNode(text);
```

（2）添加、移除、替换、插入

```js
appendChild(node)
removeChild(node)
replaceChild(new, old)
insertBefore(new, old)
```

（3）查找

```js
getElementById();
getElementsByName();
getElementsByTagName();
getElementsByClassName();
querySelector();
querySelectorAll();
```

（4）属性操作

```js
getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
```

详细资料可以参考：
[《DOM 概述》](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces)
[《原生 JavaScript 的 DOM 操作汇总》](https://harttle.land/2015/10/01/javascript-dom-api.html)
[《原生 JS 中 DOM 节点相关 API 合集》](https://microzz.com/2017/04/06/jsdom/)

</details>

<b><details><summary>272.innerHTML 与 outerHTML 的区别？</summary></b>

参考答案：

```
对于这样一个 HTML 元素：<div>content<br/></div>。

innerHTML：内部 HTML，content<br/>；
outerHTML：外部 HTML，<div>content<br/></div>；
innerText：内部文本，content ；
outerText：内部文本，content ；
```

</details>

<b><details><summary>273..call() 和 .apply() 的区别？</summary></b>

参考答案：

```
它们的作用一模一样，区别仅在于传入参数的形式的不同。

apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。

call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。
```

详细资料可以参考：
[《apply、call 的区别和用途》](https://juejin.im/entry/58d0a7b22f301e007e5a15ae)

</details>

<b><details><summary>274.JavaScript 类数组对象的定义？</summary></b>

参考答案：

```
一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。

常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length
属性值，代表可接收的参数个数。
```

常见的类数组转换为数组的方法有这样几种：

（1）通过 call 调用数组的 slice 方法来实现转换

```js
Array.prototype.slice.call(arrayLike);
```

（2）通过 call 调用数组的 splice 方法来实现转换

```js
Array.prototype.splice.call(arrayLike, 0);
```

（3）通过 apply 调用数组的 concat 方法来实现转换

```js
Array.prototype.concat.apply([], arrayLike);
```

（4）通过 Array.from 方法来实现转换

```js
Array.from(arrayLike);
```

详细的资料可以参考：
[《JavaScript 深入之类数组对象与 arguments》](https://github.com/mqyqingfeng/Blog/issues/14)
[《javascript 类数组》](https://segmentfault.com/a/1190000000415572)
[《深入理解 JavaScript 类数组》](https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/)

</details>

<b><details><summary>275.数组和对象有哪些原生方法，列举一下？</summary></b>

参考答案：

```
数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。

数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。

数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。

数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。

数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法

数组归并方法 reduce() 和 reduceRight() 方法
```

详细资料可以参考：
[《JavaScript 深入理解之 Array 类型详解》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html)

</details>

<b><details><summary>276.数组的 fill 方法？</summary></b>

参考答案：

```
fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。
```

详细资料可以参考：
[《Array.prototype.fill()》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)

</details>

<b><details><summary>277.[, , , ] 的长度？</summary></b>

参考答案：

```
尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。

JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAS
cript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。

如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数
量。
```

详细资料可以参考：
[《尾后逗号》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas)

</details>

<b><details><summary>278.JavaScript 中的作用域与变量声明提升？</summary></b>

参考答案：

```
变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。

造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。
```

详细资料可以参考：
[《JavaScript 深入理解之变量对象》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html)

</details>

<b><details><summary>279.如何编写高性能的 Javascript ？</summary></b>

参考答案：

* 1.使用位运算代替一些简单的四则运算。
* 2.避免使用过深的嵌套循环。
* 3.不要使用未定义的变量。
* 4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。

详细资料可以参考：
[《如何编写高性能的 Javascript？》](https://zhuanlan.zhihu.com/p/34780474)

</details>

<b><details><summary>280.简单介绍一下 V8 引擎的垃圾回收机制</summary></b>

参考答案：

```
v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
```

详细资料可以参考：
[《深入理解 V8 的垃圾回收原理》](https://www.jianshu.com/p/b8ed21e8a4fb)
[《JavaScript 中的垃圾回收》](https://zhuanlan.zhihu.com/p/23992332)

</details>

<b><details><summary>281.哪些操作会造成内存泄漏？</summary></b>

参考答案：

相关知识点：

* 1.意外的全局变量
* 2.被遗忘的计时器或回调函数
* 3.脱离 DOM 的引用
* 4.闭包

回答：

```
第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留
在内存中，而无法被回收。

第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回
收。

第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。
```

详细资料可以参考：
[《JavaScript 内存泄漏教程》](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)
[《4 类 JavaScript 内存泄漏及如何避免》](https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)
[《杜绝 js 中四种内存泄漏类型的发生》](https://juejin.im/entry/5a64366c6fb9a01c9332c706)
[《javascript 典型内存泄漏及 chrome 的排查方法》](https://segmentfault.com/a/1190000008901861)

</details>

<b><details><summary>282.需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术</summary></b>

参考答案：实现方案？

```
通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history
对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可
以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。

使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问
题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。
```

详细资料可以参考：
[《pushState + ajax 实现浏览器无刷新前进后退》](http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad)
[《Manipulating the browser history》](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)

</details>

<b><details><summary>283.如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</summary></b>

参考答案：

```
typeof window === 'undefined' ? 'node' : 'browser';

通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。
```

</details>

<b><details><summary>284.把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它</summary></b>

参考答案：们？

详细资料可以参考：
[《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》](https://www.zhihu.com/question/20027966)
[《从 Chrome 源码看浏览器如何加载资源》](https://zhuanlan.zhihu.com/p/30558018)

</details>

<b><details><summary>285.移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</summary></b>

参考答案：

```
移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。
```

有三种办法来解决这个问题：

* 1.通过 meta 标签禁用网页的缩放。
* 2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。
* 3.调用一些 js 库，比如 FastClick

```
click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。
```

详细资料可以参考：
[《移动端 300ms 点击延迟和点击穿透》](https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0)

</details>

<b><details><summary>286.什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</summary></b>

参考答案：

```
（1）什么是前端路由？

前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。

（2）什么时候使用前端路由？

在单页面应用，大部分页面结构不变，只改变部分内容的使用

（3）前端路由有什么优点和缺点？

优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户

缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置

前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。
```

详细资料可以参考：
[《什么是“前端路由”》](https://segmentfault.com/q/1010000005336260)
[《浅谈前端路由》 ](https://github.com/kaola-fed/blog/issues/137)
[《前端路由是什么东西？》](https://www.zhihu.com/question/53064386)

</details>

<b><details><summary>287.如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么</summary></b>

参考答案：(mocha, sinon, jasmin, qUnit..)？

详细资料可以参考：
[《浅谈前端单元测试》](https://juejin.im/post/5b2da89cf265da597f1c7cab)

</details>

<b><details><summary>288.检测浏览器版本版本有哪些方式？</summary></b>

参考答案：

```
检测浏览器版本一共有两种方式：

一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。

第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。
```

详细资料可以参考：
[《JavaScript 判断浏览器类型》](https://www.jianshu.com/p/d99f4ca385ac)

</details>

<b><details><summary>289.什么是 Polyfill ？</summary></b>

参考答案：

```
Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。

比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。

一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。
```

详细资料可以参考：
[《Web 开发中的“黑话”》](https://segmentfault.com/a/1190000002593432)
[《Polyfill 为何物》](https://juejin.im/post/5a579bc7f265da3e38496ba1)

</details>

<b><details><summary>290.使用 JS 实现获取文件扩展名？</summary></b>

参考答案：

```js
// String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。

// 对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(>>>) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。

// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。
function getFileExtension(filename) {
    return filename.slice(((filename.lastIndexOf(".") - 1) >>> 0) + 2);
}
```

详细资料可以参考：
[《如何更有效的获取文件扩展名》](https://segmentfault.com/a/1190000004993946)

</details>

<b><details><summary>291.介绍一下 js 的节流与防抖？</summary></b>

参考答案：

相关知识点：

```js
// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。

// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。

// 函数防抖的实现
function debounce(fn, wait) {
    var timer = null;

    return function() {
        var context = this,
            args = arguments;

        // 如果此时存在定时器的话，则取消之前的定时器重新记时
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }

        // 设置定时器，使事件间隔指定事件后执行
        timer = setTimeout(() => {
            fn.apply(context, args);
        }, wait);
    };
}

// 函数节流的实现;
function throttle(fn, delay) {
    var preTime = Date.now();

    return function() {
        var context = this,
            args = arguments,
            nowTime = Date.now();

        // 如果两次时间间隔超过了指定时间，则执行函数。
        if (nowTime - preTime >= delay) {
            preTime = Date.now();
            return fn.apply(context, args);
        }
    };
}
```

回答：

```
函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。

函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。
```

详细资料可以参考：
[《轻松理解 JS 函数节流和函数防抖》](https://juejin.im/post/5a35ed25f265da431d3cc1b1)
[《JavaScript 事件节流和事件防抖》](https://juejin.im/post/5aa60b0e518825556b6c6d1a)
[《JS 的防抖与节流》](https://juejin.im/entry/5b1d2d54f265da6e2545bfa4)

</details>

<b><details><summary>292.Object.is() 与原来的比较操作符 “===”、“==” 的区别？</summary></b>

参考答案：

相关知识点：

```
两等号判等，会在比较时进行类型转换。
三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。

Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.

Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。
```

回答：

```
使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。

使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。

使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。
```

</details>

<b><details><summary>293.escape, encodeURI, encodeURIComponent 有什么区别？</summary></b>

参考答案：

相关知识点：

```
escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。
它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。
```

回答：

```
encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。

encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。

escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。
```

详细资料可以参考：
[《escape, encodeURI, encodeURIComponent 有什么区别?》](https://www.zhihu.com/question/21861899)

</details>

<b><details><summary>294.Unicode 和 UTF-8 之间的关系？</summary></b>

参考答案：

```
Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。

UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。
```

详细资料可以参考：
[《字符编码详解》](https://blog.51cto.com/polaris/377468)
[《字符编码笔记：ASCII，Unicode 和 UTF-8》](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

</details>

<b><details><summary>295.js 的事件循环是什么？</summary></b>

参考答案：

相关知识点：

```
事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。
```

回答：

```
因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
染等。
```

详细资料可以参考：
[《浏览器事件循环机制（event loop）》](https://juejin.im/post/5afbc62151882542af04112d)
[《详解 JavaScript 中的 Event Loop（事件循环）机制》](https://zhuanlan.zhihu.com/p/33058983)
[《什么是 Event Loop？》](http://www.ruanyifeng.com/blog/2013/10/event_loop.html)
[《这一次，彻底弄懂 JavaScript 执行机制》](https://juejin.im/post/59e85eebf265da430d571f89)

</details>

<b><details><summary>296.js 中的深浅拷贝实现？</summary></b>

参考答案：

相关资料：

```js
// 浅拷贝的实现;

function shallowCopy(object) {
    // 只拷贝对象
    if (!object || typeof object !== "object") return;

    // 根据 object 的类型判断是新建一个数组还是对象
    let newObject = Array.isArray(object) ? [] : {};

    // 遍历 object，并且判断是 object 的属性才拷贝
    for (let key in object) {
        if (object.hasOwnProperty(key)) {
            newObject[key] = object[key];
        }
    }

    return newObject;
}

// 深拷贝的实现;

function deepCopy(object) {
    if (!object || typeof object !== "object") return object;

    let newObject = Array.isArray(object) ? [] : {};

    for (let key in object) {
        if (object.hasOwnProperty(key)) {
            newObject[key] = deepCopy(object[key]);
        }
    }

    return newObject;
}
```

回答：

```
浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。

深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。
```

详细资料可以参考：
[《JavaScript 专题之深浅拷贝》](https://github.com/mqyqingfeng/Blog/issues/32)
[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6)

</details>

<b><details><summary>297.手写 call、apply 及 bind 函数</summary></b>

参考答案：

相关资料：

```js
// call函数实现
Function.prototype.myCall = function(context) {
    // 判断调用对象
    if (typeof this !== "function") {
        console.error("type error");
    }

    // 获取参数
    let args = [...arguments].slice(1),
        result = null;

    // 判断 context 是否传入，如果未传入则设置为 window
    context = context || window;

    // 将调用函数设为对象的方法
    context.fn = this;

    // 调用函数
    result = context.fn(...args);

    // 将属性删除
    delete context.fn;

    return result;
};

// apply 函数实现

Function.prototype.myApply = function(context) {
    // 判断调用对象是否为函数
    if (typeof this !== "function") {
        throw new TypeError("Error");
    }

    let result = null;

    // 判断 context 是否存在，如果未传入则为 window
    context = context || window;

    // 将函数设为对象的方法
    context.fn = this;

    // 调用方法
    if (arguments[1]) {
        result = context.fn(...arguments[1]);
    } else {
        result = context.fn();
    }

    // 将属性删除
    delete context.fn;

    return result;
};

// bind 函数实现
Function.prototype.myBind = function(context) {
    // 判断调用对象是否为函数
    if (typeof this !== "function") {
        throw new TypeError("Error");
    }

    // 获取参数
    var args = [...arguments].slice(1),
        fn = this;

    return function Fn() {
        // 根据调用方式，传入不同绑定值
        return fn.apply(
            this instanceof Fn ? this : context,
            args.concat(...arguments)
        );
    };
};
```

回答：

call 函数的实现步骤：

* 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
* 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。
* 3.处理传入的参数，截取第一个参数后的所有参数。
* 4.将函数作为上下文对象的一个属性。
* 5.使用上下文对象来调用这个方法，并保存返回结果。
* 6.删除刚才新增的属性。
* 7.返回结果。

apply 函数的实现步骤：

* 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
* 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。
* 3.将函数作为上下文对象的一个属性。
* 4.判断参数值是否传入
* 4.使用上下文对象来调用这个方法，并保存返回结果。
* 5.删除刚才新增的属性
* 6.返回结果

bind 函数的实现步骤：

* 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
* 2.保存当前函数的引用，获取其余传入参数值。
* 3.创建一个函数返回
* 4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

详细资料可以参考：
[《手写 call、apply 及 bind 函数》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe)
[《JavaScript 深入之 call 和 apply 的模拟实现》](https://github.com/mqyqingfeng/Blog/issues/11)

</details>

<b><details><summary>298.函数柯里化的实现</summary></b>

参考答案：

```js
// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

function curry(fn, args) {
    // 获取函数需要的参数长度
    let length = fn.length;

    args = args || [];

    return function() {
        let subArgs = args.slice(0);

        // 拼接得到现有的所有参数
        for (let i = 0; i < arguments.length; i++) {
            subArgs.push(arguments[i]);
        }

        // 判断参数的长度是否已经满足函数所需参数的长度
        if (subArgs.length >= length) {
            // 如果满足，执行函数
            return fn.apply(this, subArgs);
        } else {
            // 如果不满足，递归返回科里化的函数，等待参数的传入
            return curry.call(this, fn, subArgs);
        }
    };
}

// es6 实现
function curry(fn, ...args) {
    return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
```

详细资料可以参考：
[《JavaScript 专题之函数柯里化》](https://github.com/mqyqingfeng/Blog/issues/42)

</details>

<b><details><summary>299.为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</summary></b>

参考答案：

```
当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。

对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。

我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以
使用 es6 的 Number.EPSILON
```

详细资料可以参考：
[《十进制的 0.1 为什么不能用二进制很好的表示？》](https://blog.csdn.net/Lixuanshengchao/article/details/82049191)
[《十进制浮点数转成二进制》](https://blog.csdn.net/zhengyanan815/article/details/78550073)
[《浮点数的二进制表示》](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)
[《js 浮点数存储精度丢失原理》](https://juejin.im/post/5b372f106fb9a00e6714aa21)
[《浮点数精度之谜》](https://juejin.im/post/594a31d0a0bb9f006b0b2624)
[《JavaScript 浮点数陷阱及解法》](https://github.com/camsong/blog/issues/9)
[《0.1+0.2 !== 0.3？》](https://juejin.im/post/5bd2f10a51882555e072d0c4)
[《JavaScript 中奇特的~运算符》](https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef)

</details>

<b><details><summary>300.原码、反码和补码的介绍</summary></b>

参考答案：

```
原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。

正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。
如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

正数的补码和其原码一样；负数的补码为其反码加1。

例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；
[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001

之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。
```

详细资料可以参考：
[《关于 2 的补码》](http://www.ruanyifeng.com/blog/2009/08/twos_complement.html)

</details>

<b><details><summary>301.toPrecision 和 toFixed 和 Math.round 的区别？</summary></b>

参考答案：

```
toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。
toFixed 是对小数点后指定位数取整，从小数点开始数起。
Math.round 是将一个数字四舍五入到一个整数。
```

</details>

<b><details><summary>302.什么是 XSS 攻击？如何防范 XSS 攻击？</summary></b>

参考答案：

```
XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

XSS 一般分为存储型、反射型和 DOM 型。

存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。

反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。

DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。

XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。

对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。

因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。

还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
```

详细资料可以参考：
[《前端安全系列（一）：如何防止 XSS 攻击？》](https://juejin.im/post/5bad9140e51d450e935c6d64)

</details>

<b><details><summary>303.什么是 CSP？</summary></b>

参考答案：

```
CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。

通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta
http-equiv="Content-Security-Policy">
```

详细资料可以参考：
[《内容安全策略（CSP）》](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)
[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2)

</details>

<b><details><summary>304.什么是 CSRF 攻击？如何防范 CSRF 攻击？</summary></b>

参考答案：

```
CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被
攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

一般的 CSRF 攻击类型有三种：

第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提
交。

第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。

第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

CSRF 可以用下面几种方法来防护：

第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。
```

详细资料可以参考：
[《前端安全系列之二：如何防止 CSRF 攻击？》](https://juejin.im/post/5bc009996fb9a05d0a055192)
[《[ HTTP 趣谈] origin, referer 和 host 区别》](https://www.jianshu.com/p/1f9c71850299)

</details>

<b><details><summary>305.什么是 Samesite Cookie 属性？</summary></b>

参考答案：

```
Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。

将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。

将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。

使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。
```

</details>

<b><details><summary>306.什么是点击劫持？如何防范点击劫持？</summary></b>

参考答案：

```
点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特
定的一些情况才能作为 iframe 来使用。
```

详细资料可以参考：
[《web 安全之--点击劫持攻击与防御技术简介》](https://www.jianshu.com/p/251704d8ff18)

</details>

<b><details><summary>307.SQL 注入攻击？</summary></b>

参考答案：

```
SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构
造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。
```

详细资料可以参考：
[《Web 安全漏洞之 SQL 注入》](https://juejin.im/post/5bd5b820e51d456f72531fa8)
[《如何防范常见的 Web 攻击》](http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB)

</details>

<b><details><summary>308.什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</summary></b>

参考答案：

```
MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。

比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。

MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Co
ntroller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。

MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的
Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。

MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功
能。
```

详细资料可以参考：
[《浅析前端开发中的 MVC/MVP/MVVM 模式》](https://juejin.im/post/593021272f301e0058273468)
[《MVC，MVP 和 MVVM 的图示》](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)
[《MVVM》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf)
[《一篇文章了解架构模式：MVC/MVP/MVVM》](https://segmentfault.com/a/1190000015310674)

</details>

<b><details><summary>309.什么是 requestAnimationFrame ？</summary></b>

参考答案：

详细资料可以参考：
[《你需要知道的 requestAnimationFrame》](https://juejin.im/post/5a82f0626fb9a06358657c9c)
[《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/)

</details>

<b><details><summary>310.谈谈你对 webpack 的看法</summary></b>

参考答案：

```
我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源
数。

我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。

Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。

Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。

Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。

loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。

插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。

使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。
```

详细资料可以参考：
[《不聊 webpack 配置，来说说它的原理》](https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0)
[《前端工程化——构建工具选型：grunt、gulp、webpack》](https://juejin.im/entry/5b5724d05188251aa01647fd)
[《浅入浅出 webpack》](https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0)
[《前端构建工具发展及其比较》](https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e)

</details>

<b><details><summary>311.offsetWidth/offsetHeight, clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</summary></b>

参考答案：

```
clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。
clientTop 返回的是上边框的宽度。
clientLeft 返回的左边框的宽度。

offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。
offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。
offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。

scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。
scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。
scrollLeft 属性返回的是元素滚动条到元素左边的距离。
```

详细资料可以参考：
[《最全的获取元素宽高及位置的方法》](https://juejin.im/post/5bc9366d5188255c4834e75a)
[《用 Javascript 获取页面元素的位置》](http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html)

</details>

<b><details><summary>312.js 语句末尾分号是否可以省略？</summary></b>

参考答案：

```
在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有
利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。
```

</details>

<b><details><summary>313.Object.assign()</summary></b>

参考答案：

```
Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
```

</details>

<b><details><summary>314.Math.ceil 和 Math.floor</summary></b>

参考答案：

```
Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。

Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。
```

</details>

<b><details><summary>315.js for 循环注意点</summary></b>

参考答案：

```js
for (var i = 0, j = 0; i < 5, j < 9; i++, j++) {
    console.log(i, j);
}

// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。
// 当判断语句为空时，循环会一直进行。
```

</details>

<b><details><summary>316.一个列表，假设有 100000 个数据，这个该怎么办？</summary></b>

参考答案：

```
我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？

解决办法：

（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。

（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。

（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。
```

</details>

<b><details><summary>317.谈一谈你理解的函数式编程？</summary></b>

参考答案：

```
简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。

它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"。
```

详细资料可以参考：
[《函数式编程初探》](http://www.ruanyifeng.com/blog/2012/04/functional_programming.html)

</details>

<b><details><summary>318.异步编程的实现方式？</summary></b>

参考答案：

相关资料：

```
回调函数
优点：简单、容易理解
缺点：不利于维护，代码耦合高

事件监听（采用时间驱动模式，取决于某个事件是否发生）：
优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
缺点：事件驱动型，流程不够清晰

发布/订阅（观察者模式）
类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者

Promise 对象
优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；
缺点：编写和理解，相对比较难

Generator 函数
优点：函数体内外的数据交换、错误处理机制
缺点：流程管理不方便

async 函数
优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。
缺点：错误处理机制
```

回答：

```
js 中的异步机制可以分为以下几种：

第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。

第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。

第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。
```

</details>

<b><details><summary>319.Js 动画与 CSS 动画区别及相应实现</summary></b>

参考答案：

```
CSS3 的动画的优点

在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化
代码相对简单

缺点

在动画控制上不够灵活
兼容性不好

JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧
```

</details>

<b><details><summary>320.get 请求传参长度的误区</summary></b>

参考答案：

```
误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。

实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:
```

* 1.HTTP 协议未规定 GET 和 POST 的长度限制
* 2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度
* 3.不同的浏览器和 WEB 服务器，限制的最大长度不一样
* 4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte

</details>

<b><details><summary>321.URL 和 URI 的区别？</summary></b>

参考答案：

```
URI: Uniform Resource Identifier      指的是统一资源标识符
URL: Uniform Resource Location        指的是统一资源定位符
URN: Universal Resource Name          指的是统一资源名称

URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。

URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。
```

详细资料可以参考：
[《HTTP 协议中 URI 和 URL 有什么区别？》](https://www.zhihu.com/question/21950864)
[《你知道 URL、URI 和 URN 三者之间的区别吗？》](http://web.jobbole.com/83452/)
[《URI、URL 和 URN 的区别》](https://segmentfault.com/a/1190000006081973)

</details>

<b><details><summary>322.get 和 post 请求在缓存方面的区别</summary></b>

参考答案：

相关知识点：

```
get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。

post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。
```

回答：

```
缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。
```

详细资料可以参考：
[《HTML 关于 post 和 get 的区别以及缓存问题的理解》](https://blog.csdn.net/qq_27093465/article/details/50479289)

</details>

<b><details><summary>323.图片的懒加载和预加载</summary></b>

参考答案：

相关知识点：

```
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。
```

回答：

```
懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。

预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。

这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。
```

详细资料可以参考：
[《懒加载和预加载》](https://juejin.im/post/5b0c3b53f265da09253cbed0)
[《网页图片加载优化方案》](https://juejin.im/entry/5a73f38cf265da4e99575be3)
[《基于用户行为的图片等资源预加载》](https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/)

</details>

<b><details><summary>324.mouseover 和 mouseenter 的区别？</summary></b>

参考答案：

```
当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。

由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。
```

详细资料可以参考：
[《mouseenter 与 mouseover 为何这般纠缠不清？》](https://github.com/qianlongo/zepto-analysis/issues/1)

</details>

<b><details><summary>325.js 拖拽功能的实现</summary></b>

参考答案：

相关知识点：

```
首先是三个事件，分别是 mousedown，mousemove，mouseup
当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。
clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示
元素的元素的初始坐标，移动的举例应该是：
鼠标移动时候的坐标-鼠标按下去时候的坐标。
也就是说定位信息为：
鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.
```

回答：

```
一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠
标抬起，拖拽过程结束。

这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会
执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状
态。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠
标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。
最后 mouseup 事件触发后，清除状态，结束拖拽事件。
```

详细资料可以参考：
[《原生 js 实现拖拽功能基本思路》](https://blog.csdn.net/LZGS_4/article/details/43523465)

</details>

<b><details><summary>326.为什么使用 setTimeout 实现 setInterval？怎么模拟？</summary></b>

参考答案：

相关知识点：

```js
// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果

function mySetInterval(fn, timeout) {
    // 控制器，控制定时器是否继续执行
    var timer = {
        flag: true
    };

    // 设置递归函数，模拟定时器执行。
    function interval() {
        if (timer.flag) {
            fn();
            setTimeout(interval, timeout);
        }
    }

    // 启动定时器
    setTimeout(interval, timeout);

    // 返回控制器
    return timer;
}
```

回答：

```
setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。

针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。
```

详细资料可以参考：
[《用 setTimeout 实现 setInterval》](https://www.jianshu.com/p/32479bdfd851)
[《setInterval 有什么缺点？》](https://zhuanlan.zhihu.com/p/51995737)

</details>

<b><details><summary>327.let 和 const 的注意点？</summary></b>

参考答案：

* 1.声明的变量只在声明时的代码块内有效
* 2.不存在声明提升
* 3.存在暂时性死区，如果在变量声明前使用，会报错
* 4.不允许重复声明，重复声明会报错

</details>

<b><details><summary>328.什么是 rest 参数？</summary></b>

参考答案：

```
rest 参数（形式为...变量名），用于获取函数的多余参数。
```

</details>

<b><details><summary>329.什么是尾调用，使用尾调用有什么好处？</summary></b>

参考答案：

```
尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。
```

</details>

<b><details><summary>330.Symbol 类型的注意点？</summary></b>

参考答案：

* 1.Symbol 函数前不能使用 new 命令，否则会报错。
* 2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
* 3.Symbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。
* 4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
* 5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
* 6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。

</details>

<b><details><summary>331.Set 和 WeakSet 结构？</summary></b>

参考答案：

* 1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
* 2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，

</details>

<b><details><summary>332.Map 和 WeakMap 结构？</summary></b>

参考答案：

* 1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
* 2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。

</details>

<b><details><summary>333.什么是 Proxy ？</summary></b>

参考答案：

```
Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
```

</details>

<b><details><summary>334.Reflect 对象创建目的？</summary></b>

参考答案：

* 1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。
* 2.修改某些 Object 方法的返回结果，让其变得更合理。
* 3.让 Object 操作都变成函数行为。
* 4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。

</details>

<b><details><summary>335.require 模块引入的查找方式？</summary></b>

参考答案：

```
当 Node 遇到 require(X) 时，按下面的顺序处理。

（1）如果 X 是内置模块（比如 require('http')）
　　a.返回该模块。
　　b.不再继续执行。

（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头
　　a.根据 X 所在的父模块，确定 X 的绝对路径。
　　b.将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    X
    X.js
    X.json
    X.node

　　c.将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    X/package.json（main字段）
    X/index.js
    X/index.json
    X/index.node

（3）如果 X 不带路径
　　a.根据 X 所在的父模块，确定 X 可能的安装目录。
　　b.依次在每个目录中，将 X 当成文件名或目录名加载。

（4）抛出 "not found"
```

详细资料可以参考：
[《require() 源码解读》](http://www.ruanyifeng.com/blog/2015/05/require.html)

</details>

<b><details><summary>336.什么是 Promise 对象，什么是 Promises/A+ 规范？</summary></b>

参考答案：

```
Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。

Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们
可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。
```

详细资料可以参考：
[《Promises/A+ 规范》](http://www.ituring.com.cn/article/66566)
[《Promise》](http://es6.ruanyifeng.com/#docs/promise#Promise-resolve)

</details>

<b><details><summary>337.手写一个 Promise</summary></b>

参考答案：

```js
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";

function MyPromise(fn) {
    // 保存初始化状态
    var self = this;

    // 初始化状态
    this.state = PENDING;

    // 用于保存 resolve 或者 rejected 传入的值
    this.value = null;

    // 用于保存 resolve 的回调函数
    this.resolvedCallbacks = [];

    // 用于保存 reject 的回调函数
    this.rejectedCallbacks = [];

    // 状态转变为 resolved 方法
    function resolve(value) {
        // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变
        if (value instanceof MyPromise) {
            return value.then(resolve, reject);
        }

        // 保证代码的执行顺序为本轮事件循环的末尾
        setTimeout(() => {
            // 只有状态为 pending 时才能转变，
            if (self.state === PENDING) {
                // 修改状态
                self.state = RESOLVED;

                // 设置传入的值
                self.value = value;

                // 执行回调函数
                self.resolvedCallbacks.forEach(callback => {
                    callback(value);
                });
            }
        }, 0);
    }

    // 状态转变为 rejected 方法
    function reject(value) {
        // 保证代码的执行顺序为本轮事件循环的末尾
        setTimeout(() => {
            // 只有状态为 pending 时才能转变
            if (self.state === PENDING) {
                // 修改状态
                self.state = REJECTED;

                // 设置传入的值
                self.value = value;

                // 执行回调函数
                self.rejectedCallbacks.forEach(callback => {
                    callback(value);
                });
            }
        }, 0);
    }

    // 将两个方法传入函数执行
    try {
        fn(resolve, reject);
    } catch (e) {
        // 遇到错误时，捕获错误，执行 reject 函数
        reject(e);
    }
}

MyPromise.prototype.then = function(onResolved, onRejected) {
    // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数
    onResolved =
        typeof onResolved === "function" ?
        onResolved :
        function(value) {
            return value;
        };

    onRejected =
        typeof onRejected === "function" ?
        onRejected :
        function(error) {
            throw error;
        };

    // 如果是等待状态，则将函数加入对应列表中
    if (this.state === PENDING) {
        this.resolvedCallbacks.push(onResolved);
        this.rejectedCallbacks.push(onRejected);
    }

    // 如果状态已经凝固，则直接执行对应状态的函数

    if (this.state === RESOLVED) {
        onResolved(this.value);
    }

    if (this.state === REJECTED) {
        onRejected(this.value);
    }
};
```

</details>

<b><details><summary>338.如何检测浏览器所支持的最小字体大小？</summary></b>

参考答案：

```
用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。
```

</details>

<b><details><summary>339.怎么做 JS 代码 Error 统计？</summary></b>

参考答案：

```
error 统计使用浏览器的 window.error 事件。
```

</details>

<b><details><summary>340.单例模式模式是什么？</summary></b>

参考答案：

```
单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。
```

</details>

<b><details><summary>341.策略模式是什么？</summary></b>

参考答案：

```
策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候
用来将视图层的方法定义和方法调用分离。
```

</details>

<b><details><summary>342.代理模式是什么？</summary></b>

参考答案：

```
 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。
```

</details>

<b><details><summary>343.中介者模式是什么？</summary></b>

参考答案：

```
中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。
```

</details>

<b><details><summary>344.适配器模式是什么？</summary></b>

参考答案：

```
适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种
新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种
自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。
```

更多关于设计模式的资料可以参考：
[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b)
[《JavaScript 设计模式》](https://juejin.im/post/59df4f74f265da430f311909#heading-3)
[《JavaScript 中常见设计模式整理》](https://juejin.im/post/5afe6430518825428630bc4d)

</details>

<b><details><summary>345.观察者模式和发布订阅模式有什么不同？</summary></b>

参考答案：

```
发布订阅模式其实属于广义上的观察者模式

在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。

而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。
```

详细资料可以参考：
[《观察者模式和发布订阅模式有什么不同？》](https://www.zhihu.com/question/23486749)

</details>

<b><details><summary>346.开发中常用的几种 Content-Type ？</summary></b>

参考答案：

```
（1）application/x-www-form-urlencoded

浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL
转码。

（2）multipart/form-data

该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

（3）application/json

告诉服务器消息主体是序列化后的 JSON 字符串。

（4）text/xml

该种方式主要用来提交 XML 格式的数据。
```

详细资料可以参考：
[《常用的几种 Content-Type》](https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/)

</details>

<b><details><summary>347.如何封装一个 javascript 的类型判断函数？</summary></b>

参考答案：

```js
function getType(value) {
    // 判断数据是 null 的情况
    if (value === null) {
        return value + "";
    }

    // 判断数据是引用类型的情况
    if (typeof value === "object") {
        let valueClass = Object.prototype.toString.call(value),
            type = valueClass.split(" ")[1].split("");

        type.pop();

        return type.join("").toLowerCase();
    } else {
        // 判断数据是基本数据类型的情况和函数的情况
        return typeof value;
    }
}
```

详细资料可以参考：
[《JavaScript 专题之类型判断(上)》](https://github.com/mqyqingfeng/Blog/issues/28)

</details>

<b><details><summary>348.如何判断一个对象是否为空对象？</summary></b>

参考答案：

```js
function checkNullObj(obj) {
    return Object.keys(obj).length === 0 && Object.getOwnPropertySymbols(obj).length === 0;
}
```

详细资料可以参考：
[《js 判断一个 object 对象是否为空》](https://blog.csdn.net/FungLeo/article/details/78113661)

</details>

<b><details><summary>349.使用闭包实现每隔一秒打印 1, 2, 3, 4</summary></b>

参考答案：

```js
// 使用闭包实现
for (var i = 0; i < 5; i++) {
    (function(i) {
        setTimeout(function() {
            console.log(i);
        }, i * 1000);
    })(i);
}

// 使用 let 块级作用域

for (let i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, i * 1000);
}
```

</details>

<b><details><summary>350.手写一个 jsonp</summary></b>

参考答案：

```js
function jsonp(url, params, callback) {
    // 判断是否含有参数
    let queryString = url.indexOf("?") === -1 ? "?" : "&";

    // 添加参数
    for (var k in params) {
        if (params.hasOwnProperty(k)) {
            queryString += k + "=" + params[k] + "&";
        }
    }

    // 处理回调函数名
    let random = Math.random()
        .toString()
        .replace(".", ""),
        callbackName = "myJsonp" + random;

    // 添加回调函数
    queryString += "callback=" + callbackName;

    // 构建请求
    let scriptNode = document.createElement("script");
    scriptNode.src = url + queryString;

    window[callbackName] = function() {
        // 调用回调函数
        callback(...arguments);

        // 删除这个引入的脚本
        document.getElementsByTagName("head")[0].removeChild(scriptNode);
    };

    // 发起请求
    document.getElementsByTagName("head")[0].appendChild(scriptNode);
}
```

详细资料可以参考：
[《原生 jsonp 具体实现》](https://www.cnblogs.com/zzc5464/p/jsonp.html)
[《jsonp 的原理与实现》](https://segmentfault.com/a/1190000007665361#articleHeader1)

</details>

<b><details><summary>351.手写一个观察者模式？</summary></b>

参考答案：

```js
var events = (function() {
    var topics = {};

    return {
        // 注册监听函数
        subscribe: function(topic, handler) {
            if (!topics.hasOwnProperty(topic)) {
                topics[topic] = [];
            }
            topics[topic].push(handler);
        },

        // 发布事件，触发观察者回调事件
        publish: function(topic, info) {
            if (topics.hasOwnProperty(topic)) {
                topics[topic].forEach(function(handler) {
                    handler(info);
                });
            }
        },

        // 移除主题的一个观察者的回调事件
        remove: function(topic, handler) {
            if (!topics.hasOwnProperty(topic)) return;

            var handlerIndex = -1;
            topics[topic].forEach(function(item, index) {
                if (item === handler) {
                    handlerIndex = index;
                }
            });

            if (handlerIndex >= 0) {
                topics[topic].splice(handlerIndex, 1);
            }
        },

        // 移除主题的所有观察者的回调事件
        removeAll: function(topic) {
            if (topics.hasOwnProperty(topic)) {
                topics[topic] = [];
            }
        }
    };
})();
```

详细资料可以参考：
[《JS 事件模型》](https://segmentfault.com/a/1190000006934031#articleHeader1)

</details>

<b><details><summary>352.EventEmitter 实现</summary></b>

参考答案：

```js
class EventEmitter {
    constructor() {
        this.events = {};
    }

    on(event, callback) {
        let callbacks = this.events[event] || [];
        callbacks.push(callback);
        this.events[event] = callbacks;

        return this;
    }

    off(event, callback) {
        let callbacks = this.events[event];
        this.events[event] = callbacks && callbacks.filter(fn => fn !== callback);

        return this;
    }

    emit(event, ...args) {
        let callbacks = this.events[event];
        callbacks.forEach(fn => {
            fn(...args);
        });

        return this;
    }

    once(event, callback) {
        let wrapFun = (...args) => {
            callback(...args);

            this.off(event, wrapFun);
        };
        this.on(event, wrapFun);

        return this;
    }
}
```

</details>

<b><details><summary>353.一道常被人轻视的前端 JS 面试题</summary></b>

参考答案：

```js
function Foo() {
    getName = function() {
        alert(1);
    };
    return this;
}
Foo.getName = function() {
    alert(2);
};
Foo.prototype.getName = function() {
    alert(3);
};
var getName = function() {
    alert(4);
};

function getName() {
    alert(5);
}

//请写出以下输出结果：
Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
```

详细资料可以参考：
[《前端程序员经常忽视的一个 JavaScript 面试题》](https://github.com/Wscats/Good-text-Share/issues/85)
[《一道考察运算符优先级的 JavaScript 面试题》](https://segmentfault.com/q/1010000008430170)
[《一道常被人轻视的前端 JS 面试题》](https://www.cnblogs.com/xxcanghai/p/5189353.html)

</details>

<b><details><summary>354.如何确定页面的可用性时间，什么是 Performance API？</summary></b>

参考答案：

```
Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。

使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。

为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒
的千分之一（1秒的百万分之一）。

navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。

loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。
```

根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：

```js
var t = performance.timing;
var pageLoadTime = t.loadEventEnd - t.navigationStart;
```

详细资料可以参考：
[《Performance API》](http://javascript.ruanyifeng.com/bom/performance.html)

</details>

<b><details><summary>355.js 中的命名规则</summary></b>

参考答案：

```
（1）第一个字符必须是字母、下划线（_）或美元符号（$）
（2）余下的字符可以是下划线、美元符号或任何字母或数字字符

一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。
```

详细资料可以参考：
[《ECMAScript 变量》](http://www.w3school.com.cn/js/pro_js_variables.asp)

</details>

<b><details><summary>356.js 中倒计时的纠偏实现？</summary></b>

参考答案：

```
在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。

一般解决倒计时中的误差的有这样两种办法：

（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。

（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。
```

详细资料可以参考：
[《JavaScript 前端倒计时纠偏实现》](https://juejin.im/post/5badf8305188255c8e728adc)

</details>

<b><details><summary>357.进程间通信的方式？</summary></b>

参考答案：

* 1.管道通信
* 2.消息队列通信
* 3.信号量通信
* 4.信号通信
* 5.共享内存通信
* 6.套接字通信

详细资料可以参考：
[《进程间 8 种通信方式详解》](https://blog.csdn.net/violet_echo_0908/article/details/51201278)
[《进程与线程的一个简单解释》](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

</details>

<b><details><summary>358.Js中prototype、[[prototype]]和__proto__的区别和用法</summary></b>

参考答案：

一.显式原型&隐式原型
显式原型：prototype
隐式原型：__proto__

1.1 Important
__proto__是每个对象都具有的属性
prototype是Function独有的属性

1.2 Tips
对象的隐式原型的值为其对应构造函数的显式原型的值
fn.__proto__ === Function.prototype
函数的prototype属性是定义时自动添加的。默认为{}
对象的__proto__属性是创建对象时自动添加的，默认值为其构造函数的prototype
Object.prototype.__proto__ === null

1.3 说了这么多和[[prototype]]有什么关系?
其实[[prototype]]和__proto__意义相同，均表示对象的内部属性，其值指向对象原型。前者在一些书籍、规范中表示一个对象的原型属性，后者则是在浏览器实现中指向对象原型。

二.作用

作用方面来讲当然是实现继承了。其中最经典的共享属性方法的原型链继承。其中必不可少的属性就是__proto__和prototype。

我们举个栗子
```js
function Son(){}
function Father(){}
Son.prototype = new Father();
```
如此即实现了继承
我们可以写代码进行验证
```js
Foo.prototype.__proto__ === Bar.prototype  //true
```
符合上述第三条规则，所以可以通过此方法完成函数的继承。
注意，此为原型链继承，其中的方法与属性为此链上的所有实例所共享

</details>

<b><details><summary>359.说下CommonJS、AMD、CMD三种规范</summary></b>

参考答案：

#### 前言
这三个规范都是为Js模块化加载而生的，使模块能够按需加载，使系统同庞杂的代码得到组织和管理。模块化的管理代码使多人开发得到了更好的合作。

#### 一、CommonJS
是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。

核心思想

一个单独文件就是一个模块，通过require方法来同步加载要依赖的模块，然后通过extports或则module.exports来导出需要暴露的接口。

```js
require("module");
require("../file.js");
exports.doStuff = function() {};
module.exports = someValue;
```

优点：服务器端模块重用，NPM中模块包多，有将近20万个。

缺点：加载模块是同步的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

实现：服务器端的 Node.js；Browserify，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的 文件体积可能很大；modules-webmake，类似Browserify，还不如 Browserify 灵活；wreq，Browserify 的前身；

#### 二、AMD

鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。

其核心接口是：define(id?, dependencies?, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块提前执行，依赖前置。

```js
define("module", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
require(["module", "../file"], function(module, file) { /* ...*/ });
```

优点：在浏览器环境中异步加载模块；并行加载多个模块；

缺点：开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；

实现：RequireJS； curl；

#### 三、CMD

Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。

```js
define(function(require, exports, module) {
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})
```

优点：依赖就近，延迟执行 可以很容易在 Node.js 中运行；
缺点：依赖 SPM 打包，模块的加载逻辑偏重；
实现：Sea.js ；coolie

参考地址：https://zhuanlan.zhihu.com/p/26625636

</details>

<b><details><summary>360.微信的JSSDK都有哪些内容？如何接入？</summary></b>

参考答案：

```
微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。

JSSDK使用步骤
步骤一：绑定域名
步骤二：引入JS文件
步骤三：通过config接口注入权限验证配置
步骤四：通过ready接口处理成功验证
步骤五：通过error接口处理失败验证
```

</details>

<b><details><summary>361.H5页面在微信中如何禁止分享给好友和朋友圈？</summary></b>

参考答案：

```
利用JSBridge实现调用微信提供的一些原生功能，可以通过调用隐藏操作菜单来实现禁用分享。
代码如下：
document.addEventListener('WeixinJSBridgeReady', function onBridgeReady() {
    WeixinJSBridge.call('hideOptionMenu');
});
```

</details>

<b><details><summary>362.什么是本地存储的有效期？</summary></b>

参考答案：

```
本地存储的四种方式：cookie，localStorage, sessionStorage, indexDB
cookie: 通过 expires/max-age 设置过期时间。如不指定，则为 session cookie, 即一次会话有效。
localStorage: 持久存储，需主动清除
sessionStorage: 会话存储，会话结束（浏览器，标签页关闭）自动清除。
indexDB: 持久存储，需主动删除。
```

</details>

<b><details><summary>363.ECMAScript 和 JavaScript 的关系</summary></b>

参考答案：前者是后者的规格，后者是前者的一种实现

解析：

一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？

要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。

该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。

因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。

</details>

<b><details><summary>364.ES6 与 ECMAScript 2015 的关系</summary></b>

参考答案：ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。

解析：

ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？

2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。

但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。

但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。

标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。

ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。

因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。

</details>

<b><details><summary>365.prototype、__proto__与constructor的关系</summary></b>

参考答案：

1. 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。
2. __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
3. prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
4. constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。

原文链接：https://blog.csdn.net/cc18868876837/article/details/81211729

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 为什么用 Nodejs, 它有哪些缺点？</summary></b>

参考答案：

* 事件驱动，通过闭包很容易实现客户端的生命活期。
* 不用担心多线程，锁，并行计算的问题
* V8 引擎速度非常快
* 对于游戏来说，写一遍游戏逻辑代码，前端后端通用

当然 Nodejs 也有一些缺点：

* nodejs 更新很快，可能会出现版本兼容
* nodejs 还不算成熟，还没有大制作
* nodejs 不像其他的服务器，对于不同的链接，不支持进程和线程操作

[参与互动](https://github.com/yisainan/web-interview/issues/371)

</details>

<b><details><summary>2. NodeJS 的工作原理</summary></b>

参考答案：事件循环

[参与互动](https://github.com/yisainan/web-interview/issues/372)

</details>

<b><details><summary>3. Node 的应用场景</summary></b>

参考答案：比如：RESTFUL API、实时聊天、客户端逻辑强大的单页 APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线 APP 等。

* 实时应用：如在线聊天，实时通知推送等等（如 socket.io）
* 分布式应用：通过高效的并行 I/O 使用已有的数据
* 工具类应用：海量的工具，小到前端压缩部署（如 grunt），大到桌面图形界面应用程序
* 游戏类应用：游戏领域对实时和并发有很高的要求（如网易的 pomelo 框架）
* 利用稳定接口提升 Web 渲染能力
* 前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯 Javascript 全栈式 MEAN 架构）

[参与互动](https://github.com/yisainan/web-interview/issues/373)

</details>

<b><details><summary>4. 如何用 NodeJS 搭建中间层？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/374)

</details>

<b><details><summary>5. 什么是 error-first callback ？</summary></b>

参考答案：error-first callback 用来传递错误和数据。第一个参数永远是一个错误对象（error-object），回调函数必须检查它。余下的参数用不过来传递数据。

解析：

```js
fs.readFile(filePath, function(err, data) {
    if (err) {
        //处理出现错误的情况
    }
    //处理数据
});
```

考察面试者对于 Node 异步操作基本知识的见解

[参与互动](https://github.com/yisainan/web-interview/issues/375)

</details>

<b><details><summary>6. 如何避免回调函数嵌套？</summary></b>

参考答案：使用 Promises 将回调写成单独的函数

[参与互动](https://github.com/yisainan/web-interview/issues/376)

</details>

<b><details><summary>7. Node 程序如何监听 80 端口？</summary></b>

参考答案：脑筋急转弯！你不应该直接使用 Node 监听 80 端口（在\*nix 系统中），这样做需要 root 权限，对于运行程序来说这不是一个好主意。

不过，你可以使 Node 监听 1024 以上的端口，然后在 Node 前面部署 nginx 反向代理。

解析：[参考](https://blog.csdn.net/newborn2012/article/details/23860687)

[参与互动](https://github.com/yisainan/web-interview/issues/377)

</details>

<b><details><summary>8. 什么是事件循环（event loop）？</summary></b>

参考答案：至少从开发者的角度来看，Node.js 是单线程运行的。底层使用 libuv 使用多线程。
每一个 I/O 操作都需要一个回调，一旦操作完成会被事件循环执行

解析：[参考](http://blog.csdn.net/yanghua_kobe/article/details/12145537)

[参与互动](https://github.com/yisainan/web-interview/issues/378)

</details>

<b><details><summary>9. 使用什么工具检查代码风格？</summary></b>

参考答案：

* JSLint by Douglas Crockford
* JSHint
* ESLint
* JSCS
  开发团队项目时，强制指定代码风格和使用静态分析，捕捉常见的错误，这些工具都非常有用。

[参与互动](https://github.com/yisainan/web-interview/issues/379)

</details>

<b><details><summary>10. 操作错误和程序错误的区别是什么？</summary></b>

参考答案：操作错误不是 bug，是系统的问题，例如超时或者硬件故障。
另一方面，程序错误（programmer errors）是实际的错误。

[参与互动](https://github.com/yisainan/web-interview/issues/380)

</details>

<b><details><summary>11. 为什么 npmshrinkwarp 非常有用？</summary></b>

参考答案：这个命令在部署 Node.js 应用时是非常有用的——它可以保证所部属的版本就是依赖的版本。

解析：[参考](http://www.tuicool.com/articles/EBVNV37)

[参与互动](https://github.com/yisainan/web-interview/issues/381)

</details>

<b><details><summary>12. 什么是 stub？说出他的用途？举个使用场景？</summary></b>

参考答案：Stubs 是模拟模块或组件行为的程序。
Stubs 提供已知的参考答案来调用函数，另外你还可以断言哪个 stubs 被调用

[参与互动](https://github.com/yisainan/web-interview/issues/382)

</details>

<b><details><summary>13. 什么是测试金字塔？在做 HTTP API 的时候要怎么实现？</summary></b>

参考答案：测试金字塔意思是在写测试时应该编写的底层但愿测试要多于高级的端到端测试。
对于 HTTP APIs，应该归结为：

* 对你的模型多很多单元测试
* 在你的模型与其他交互时更少的集成测试
* 更少的验收测试，在 HTTP 端

[参与互动](https://github.com/yisainan/web-interview/issues/383)

</details>

<b><details><summary>14. 你最熟悉的 Node 框架是什么？为什么？</summary></b>

参考答案：[参考](http://ourjs.com/detail/15%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84node-js%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6)

[参与互动](https://github.com/yisainan/web-interview/issues/384)

</details>

<b><details><summary>15. 你最喜欢的 HTTP 框架，并说明原因？</summary></b>

参考答案：LiteHttp 好多的优点
单线程 灵活的架构 轻量级 多文件上传 自动重定向 禁用一种或多种网络

解析：[参考](http://blog.csdn.net/kymjs/article/details/45716797)

[参与互动](https://github.com/yisainan/web-interview/issues/385)

</details>

<b><details><summary>16. 对 Node 的优点和缺点提出了自己的看法</summary></b>

参考答案：

* （优点）因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
  因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。
  此外，与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，
  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

* （缺点）Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，
  而且缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子。

[参与互动](https://github.com/yisainan/web-interview/issues/386)

</details>

<b><details><summary>17. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</summary></b>

参考答案：至少给出自己的思路（url-hash, 可以使用已有的一些框架 history.js 等）

[参与互动](https://github.com/yisainan/web-interview/issues/387)

</details>

<b><details><summary>18.(如果会用 node)知道 route, middleware, cluster, nodemon, pm2, server-side rendering 么?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/388)

</details>

<b><details><summary>19. 解释一下 Backbone 的 MVC 实现方式？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/389)

</details>

<b><details><summary>20. 什么是“前端路由”? 什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/390)

</details>

<b><details><summary>21. 对 Node 的优点和缺点提出了自己的看法？</summary></b>

参考答案：

优点：

1. 因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。
2. 与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

缺点：

1. Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变。
2. 缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。

[参与互动](https://github.com/yisainan/web-interview/issues/391)

</details>

<b><details><summary>22. 使用过的koa2中间件（阿里）</summary></b>

参考答案：

```
koa-router
koa-bodyparser
koa-views
koa-static
koa-jwt
koa-helmet
koa-convert
```

</details>

<b><details><summary>23.master挂了的话pm2怎么处理（阿里）</summary></b>

参考答案：

```
koa-router
koa-bodyparser
koa-views
koa-static
koa-jwt
koa-helmet
koa-convert
```

</details>

<b><details><summary>24.node文件查找优先级（宝宝树）</summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

> [转载自 50个最新TypeScript面试题合集](http://www.srcmini.com/3507.html)

<b><details><summary>1. 什么是TypeScript?</summary></b>

参考答案：

TypeScript是一种由微软开发和维护的免费开源编程语言。它是一个强类型的JavaScript超集，可编译为纯JavaScript。它是一种用于应用级JavaScript开发的语言。对于熟悉c#、Java和所有强类型语言的开发人员来说，TypeScript非常容易学习和使用。

TypeScript可以在任何浏览器、主机和操作系统上执行。TypeScript不是直接在浏览器上运行的。它需要一个编译器来编译和生成JavaScript文件。TypeScript是带有一些附加特性的ES6 JavaScript版本。

</details>

<b><details><summary>2. TypeScript和JavaScript有什么不同？</summary></b>

TypeScript与JavaScript的区别如下:

参考答案：

| 编号 | JavaScript | TypeScript |
| ----------------------------------------- | ------------------------------------------- | ------------------------------------------- |
| 1 | 	它是由网景公司在1995年开发的。 | 	它是2012年由安德斯·海尔斯伯格(Anders Hejlsberg)开发的。| 
| 2 | 	JavaScript源文件在”.js”扩展。|  	TypeScript源文件是”.ts”扩展名。| 
| 3 | 	JavaScript不支持ES6。 | 	TypeScript 支持ES6。| 
| 4 | 	它不支持强类型或静态类型。|  	它支持强类型或静态类型特性。| 
| 5 | 	它只是一种脚本语言。 | 	它支持面向对象的编程概念，如类、接口、继承、泛型等。| 
| 6 | 	JavaScript没有可选的参数特性。 | 	TypeScript有可选的参数特性。| 
| 7 | 	它是解释语言，这就是为什么它在运行时突出显示错误。 | 	它编译代码并在开发期间突出显示错误。| 
| 8 | 	JavaScript不支持模块。 	| TypeScript支持模块。| 
| 9 | 	在这里，number和string是对象。|  	在这里，number和string是接口。| 
| 10|  	JavaScript不支持泛型。 | 	TypeScript支持泛型。 | 

</details>

<b><details><summary>3. 我们为什么需要TypeScript？</summary></b>

参考答案：

我们需要TypeScript:

*    TypeScript快速、简单，最重要的是，容易学习。
*    TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。
*    TypeScript在编译时提供了错误检查功能。它将编译代码，如果发现任何错误，它将在运行脚本之前突出显示这些错误。
*    TypeScript支持所有JavaScript库，因为它是JavaScript的超集。
*    TypeScript通过使用继承来支持可重用性。
*    TypeScript使应用程序开发尽可能的快速和简单，并且TypeScript的工具支持为我们提供了自动完成、类型检查和源文档。
*    TypeScript支持最新的JavaScript特性，包括ECMAScript 2015。
*    TypeScript提供了ES6的所有优点和更高的生产力。
*    TypeScript支持静态类型、强类型、模块、可选参数等。

</details>

<b><details><summary>4. 列出Typescript的一些特性</summary></b>

参考答案：

![ts_001](../../images/ts_001.png)

</details>

<b><details><summary>5. 列出使用Typescript的一些优点?</summary></b>

参考答案：

### TypeScript 的优点

* TypeScript 增加了代码的可读性和可维护性

  *  类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了
  *  可以在编译阶段就发现大部分错误，这总比在运行时候出错好
  *  增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等

* TypeScript 非常包容

  *  TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可
  *  即使不显式的定义类型，也能够自动做出类型推论
  *  可以定义从简单到复杂的几乎一切类型
  *  即使 TypeScript 编译报错，也可以生成 JavaScript 文件
  *  兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供TypeScript 读取

* TypeScript 拥有活跃的社区

  *  大部分第三方库都有提供给 TypeScript 的类型定义文件
  *  Google 开发的 Angular2 就是使用 TypeScript 编写的
  *  TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范

</details>

<b><details><summary>6. Typescript的缺点是什么?</summary></b>

参考答案：

### TypeScript 的缺点

任何事物都是有两面性的， TypeScript 的弊端在于：

  *  有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念
  *  短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本
  *  集成到构建流程需要一些工作量
  *  可能和一些库结合的不是很完美

</details>

<b><details><summary>7. TypeScript的不同组件是什么?</summary></b>

参考答案：

TypeScript主要有三个组件。这些都是- – 

![ts_002](../../images/ts_002.png)

语言language

该语言由新语法、关键字、类型注释等元素组成，允许我们编写TypeScript。
编译器compiler

TypeScript编译器是开源的、跨平台的，是用TypeScript编写的。它将用TypeScript编写的代码转换为JavaScript代码。它执行从TypeScript代码到JavaScript代码的解析和类型检查。它还可以帮助将不同的文件连接到单个输出文件，并生成源映射。
语言服务language service

语言服务提供信息，帮助编辑器和其他工具提供更好的辅助功能，如自动重构和智能感知。

</details>

<b><details><summary>8. Typescript是谁开发的，目前稳定的Typescript版本是什么？</summary></b>

参考答案：

typescript是由Anders Hejlsberg开发的，他也是c#语言开发团队的核心成员之一。typescript于2012年10月1日发布，被标记为0.8版。它是由Microsoft在Apache 2许可下开发和维护的。它是为开发大型应用程序而设计的。

目前稳定的TypeScript版本是3.2，于2018年9月30日发布。Typescript编译成简单的JavaScript代码，可以在任何支持ECMAScript 2015框架的浏览器上运行。它支持最新的和不断发展的JavaScript特性。

</details>

<b><details><summary>9. 说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？</summary></b>

参考答案：

TypeScript可以通过npm (node .js包管理器)在node的帮助下进行安装和管理。要安装TypeScript，首先要确保npm安装正确，然后运行以下命令在系统上全局安装TypeScript。

```
$ npm install -g typescript  
```
它安装一个命令行代码“tsc”，它将进一步用于编译我们的Typescript代码。确保检查系统上安装的Typescript版本。

安装TypeScript需要以下步骤:

  *  下载并运行节点的.msi安装程序。
  *  输入命令“node -v”检查安装是否成功。
  *  在终端窗口中输入以下命令安装Typescript: $ npm install -g Typescript

</details>

<b><details><summary>10. 列出在Typescript中的内置类型</summary></b>

参考答案：

在Typescript中，内置的数据类型也称为原始数据类型。这些数据如下所示。

![ts_003](../../images/ts_003.png)

数字类型: 用于表示数字类型值。TypeScript中的所有数字都存储为浮点值。

语法: let标识符:number = value;

字符串类型: 它表示存储为Unicode UTF-16代码的字符序列。我们通过将字符串括在单引号或双引号中来在脚本中包含字符串。

语法: let标识符:字符串= ” “;

布尔类型: 用于表示逻辑值。当我们使用布尔类型时，我们只得到真或假的输出。布尔值是一个真值，它指定条件是否为真。

语法: let标识符:bool =布尔值;

Null类型: Null表示值未定义的变量。不能直接引用空类型值本身。空类型没有用处，因为我们只能为它分配一个空值。

语法: let num: number = null;

未定义类型: 它是未定义字面量的类型。未定义的类型表示所有未初始化的变量。它是没有用的，因为我们只能分配一个未定义的值给它。这种内置类型是所有类型的子类型。

语法: let num: number =未定义;

Void类型: Void是不返回任何类型值的函数的返回类型。如果没有可用的数据类型，则使用它。

语法: let unusable:void =未定义;

</details>

<b><details><summary>11. Typescript中的变量是什么？如何在Typescript中创建变量？</summary></b>

参考答案：

变量是存储位置，用于存储要被程序引用和使用的值/信息。它充当程序中值的容器。可以使用var关键字声明它。它应该在使用前声明。在Typescript中声明变量时，应该遵循某些规则-

  *  变量名必须是字母或数字。
  *  变量名不能以数字开头。
  *  变量名不能包含空格和特殊字符，除了下划线(_)和美元($)符号。

我们可以通过以下四种方式之一声明一个变量:

  *  在一条语句中声明类型和值。语法:var [identifier]: [type-annotation] = value;
  *  声明没有值的类型。语法:var [identifier]: [type-annotation];
  *  在没有类型的情况下声明它的值。语法:var [identifier] = value;
  *  声明没有值和类型。语法:var(标识符);

</details>

<b><details><summary>12. 如何编译Typescript文件？</summary></b>

参考答案：

下面是将Typescript文件编译成JavaScript时所遵循的命令。

```
$ tsc <TypeScript File Name>  
```

例如，编译“hello .ts”。

```
$ tsc helloworld.ts  
```

结果是helloworld.js。

</details>

<b><details><summary>13. 是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？</summary></b>

参考答案：

是的，有可能。为此，我们需要添加——outFILE [OutputJSFileName]编译选项。

`$ tsc --outFile comman.js file1.ts file2.ts file3.ts  `

上面的命令将编译所有这三个.ts文件和结果将存储在一个comman.js文件中，在这种情况下，当我们不提供输出文件名像下面的命令。

`$ tsc --outFile file1.ts file2.ts file3.ts  `

然后file2.ts和file3.ts将被编译，并将输出放在file1.ts中，现在是file1.ts包含JavaScript代码。


</details>

<b><details><summary>14. 能否自动编译.ts文件，并实时修改.ts文件？</summary></b>

参考答案：

这是可以的，自动实时根据.ts文件变化自动编译.ts文件是可以的。这可以通过使用——watch compiler选项来实现

`tsc --watch file1.ts  `

上面的命令首先编译file1为file1.js，并注意文件的变化，如果检测到任何更改，它将再次编译文件。这里，我们需要确保在使用——watch选项运行时命令提示符不能关闭。

</details>

<b><details><summary>15. TS的接口是什么意思？参照TS来解释它们。</summary></b>

参考答案：

接口是在我们的应用程序中充当契约的结构。它定义了要遵循的类的语法，这意味着实现接口的类必须实现它的所有成员。它不能被实例化，但是可以被实现它的类对象引用。无论对象是否具有特定的结构，TypeScript编译器都使用接口进行类型检查(也称为“duck typing”鸭子类型或“结构化子类型”)。

语法:

```ts
interface interface_name {    
          // 字段声明
          // 方法声明
}    
```
接口只是声明方法和字段，它不能用来建造任何东西。不需要将接口转换为JavaScript来执行，它们对运行时JavaScript没有任何影响。因此，它们的唯一目的是在开发阶段提供帮助。

</details>

<b><details><summary>16. 你如何理解Typescript中的类？列出类的一些特性。</summary></b>

参考答案：

我们知道，TypeScript是一种面向对象的JavaScript语言，支持OOP编程特性，比如类、接口等。与Java一样，类是用于创建可重用组件的基本实体。它是一组具有公共属性的对象。类是创建对象的模板或蓝图。它是一个逻辑实体。“class”关键字用于在Typescript中声明一个类。

例子:

```ts
class Student {    
    studCode: number;    
    studName: string;    
    constructor(code: number, name: string) {    
            this.studName = name;    
            this.studCode = code;    
    }    
    getGrade() : string {    
        return "A+" ;    
    }    
}    
```

类的特征是-

 * 继承
 * 封装
 * 多态性
 * 抽象

</details>

<b><details><summary>17. 本地Javascript支持模块吗？</summary></b>

参考答案：不。目前，本地JavaScript不支持模块。为了在Javascript中创建和使用模块，我们需要一个像CommonJS这样的外部模块。

</details>

<b><details><summary>18. TypeScript支持哪些面向对象的术语？</summary></b>

参考答案：

TypeScript支持以下面向对象的术语。

  *  模块
  *  类
  *  接口
  *  继承
  *  数据类型
  *  成员函数

</details>

<b><details><summary>19、如何从TypeScript的子类调用基类构造函数？</summary></b>

参考答案：super()函数的作用是: 从子类中调用父类或基类构造函数。

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. </summary></b>

参考答案：

</details>

<b><details><summary>1. js项目如何升级为ts？有何影响？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/)

</details>

<b><details><summary>2. tslint都能配置哪些功能？对开发流程有何影响？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/)

</details>

<b><details><summary>3. ts 基础类型都哪些，他们跟js的区别</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/)

</details>

<b><details><summary>4. ts为什么会流行？与ECMA新规范的关系？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/)

</details>

<b><details><summary>5. 如何理解接口，泛型?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/)

</details>

<b><details><summary>6. ts中type和interface的区别？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/)

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

> [转载自 CavsZhouyou/Front-End-Interview-Notebook](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.md)

# 算法知识总结

本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！

## 目录

- [返回主页](#返回主页)
- [算法知识总结](#算法知识总结)
  - [目录](#目录)
- [常用算法和数据结构总结](#常用算法和数据结构总结)
  - [排序](#排序)
    - [冒泡排序](#冒泡排序)
    - [选择排序](#选择排序)
    - [插入排序](#插入排序)
    - [希尔排序](#希尔排序)
    - [归并排序](#归并排序)
    - [快速排序](#快速排序)
    - [堆排序](#堆排序)
    - [基数排序](#基数排序)
    - [快速排序相对于其他排序效率更高的原因](#快速排序相对于其他排序效率更高的原因)
    - [系统自带排序实现](#系统自带排序实现)
    - [稳定性](#稳定性)
    - [排序面试题目总结](#排序面试题目总结)
  - [树](#树)
    - [二叉树相关性质](#二叉树相关性质)
    - [满二叉树](#满二叉树)
    - [完全二叉树](#完全二叉树)
    - [平衡二叉查找树（AVL）](#平衡二叉查找树avl)
    - [B-树](#b-树)
    - [B+树](#b树)
    - [数据库索引](#数据库索引)
    - [红黑树](#红黑树)
    - [Huffman 树](#huffman-树)
    - [二叉查找树](#二叉查找树)
    - [求解二叉树中两个节点的最近公共祖先节点](#求解二叉树中两个节点的最近公共祖先节点)
  - [链表](#链表)
    - [反转单向链表](#反转单向链表)
  - [动态规划](#动态规划)
    - [爬楼梯问题](#爬楼梯问题)
      - [递归方法分析](#递归方法分析)
      - [备忘录方法](#备忘录方法)
      - [迭代法](#迭代法)
  - [经典笔试题](#经典笔试题)
      - [1. js 实现一个函数，完成超过范围的两个大整数相加功能](#1-js-实现一个函数完成超过范围的两个大整数相加功能)
      - [2. js 如何实现数组扁平化？](#2-js-如何实现数组扁平化)
      - [3. js 如何实现数组去重？](#3-js-如何实现数组去重)
      - [4. 如何求数组的最大值和最小值？](#4-如何求数组的最大值和最小值)
      - [5. 如何求两个数的最大公约数？](#5-如何求两个数的最大公约数)
      - [6. 如何求两个数的最小公倍数？](#6-如何求两个数的最小公倍数)
      - [7. 实现 IndexOf 方法？](#7-实现-indexof-方法)
      - [8. 判断一个字符串是否为回文字符串？](#8-判断一个字符串是否为回文字符串)
      - [9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()](#9-实现一个累加函数的功能比如-sum1232valueof)
      - [10. 使用 reduce 方法实现 forEach、map、filter](#10-使用-reduce-方法实现-foreachmapfilter)
      - [11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 "1", "2", "3"](#11-设计一个简单的任务队列要求分别在-134-秒后打印出-1-2-3)
      - [12. 如何查找一篇英文文章中出现频率最高的单词？](#12-如何查找一篇英文文章中出现频率最高的单词)
- [常见面试智力题总结](#常见面试智力题总结)
      - [1. 时针与分针夹角度数问题？](#1-时针与分针夹角度数问题)
      - [2. 用3升，5升杯子怎么量出4升水？](#2-用3升5升杯子怎么量出4升水)
      - [3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？](#3-四个药罐中有一个浑浊的药罐浑浊的每片药片都比其他三个干净的药罐多一克如何只用一次天平找出浑浊的药罐)
      - [4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？](#4-四张卡片卡片正面是数字反面是字母现在桌上四张卡片状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-我只能翻两张牌我翻哪两张)
      - [5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？](#5-赛马问题25-匹马5-个赛道最少几次能选出最快的三匹马)
      - [6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？](#6-五队夫妇参加聚会每个人不能和自己的配偶握手只能最多和他人握手一次a问了其他人发现每个人的握手次数都不同那么a的配偶握手了几次)
      - [7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？](#7-你只能带行走-60-公里的油只能在起始点加油如何穿过-80-公里的沙漠)
      - [8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？](#8-烧一根不均匀的绳要用一个小时如何用它来判断一个小时十五分钟)
      - [9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？](#9-有7克2克砝码各一个天平一只如何只用这些物品三次将140克的盐分成5090克各一份)
      - [10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？](#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约另一辆火车以第小时20公里的速度从纽约开往洛杉矶如果有一只鸟以外30公里每小时的速度和两辆火车现时启动从洛杉矶出发碰到另辆车后返回依次在两辆火车来回的飞行直道两面辆火车相遇请问这只小鸟飞行了多长距离)
      - [11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？](#11-你有两个罐子50个红色弹球50个蓝色弹球随机选出一个罐子随机选取出一个弹球放入罐子怎么给红色弹球最大的选中机会在你的计划中得到红球的准确几率是多少)
      - [12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？](#12-假设你有8个球其中一个略微重一些但是找出这个球的惟一方法是将两个球放在天平上对比最少要称多少次才能找出这个较重的球)
      - [13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？](#13-在房里有三盏灯房外有三个开关在房外看不见房内的情况你只能进门一次你用什么方法来区分那个开关控制那一盏灯)
      - [14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？](#14-他们都各自买了两对黑袜和两对白袜八对袜子的布质大小完全相同而每对袜子都有一张商标纸连着两位盲人不小心将八对袜子混在一起他们每人怎样才能取回黑袜和白袜各两对呢)
      - [15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。](#15-有三筐水果一筐装的全是苹果第二筐装的全是橘子第三筐是橘子与苹果混在一起筐上的标签都是骗人的就是说筐上的标签都是错的你的任务是拿出其中一筐从里面只拿一只水果然后正确写出三筐水果的标签)
      - [16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？](#16-一个班级60喜欢足球70喜欢篮球80喜欢排球问即三种球都喜欢占比有多少)
      - [17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？](#17-五只鸡五天能下五个蛋一百天下一百个蛋需要多少只鸡)
- [剑指 offer 思路总结](#剑指-offer-思路总结)
  - [题目](#题目)
      - [1. 二维数组中的查找](#1-二维数组中的查找)
      - [2. 替换空格](#2-替换空格)
      - [3. 从尾到头打印链表](#3-从尾到头打印链表)
      - [4. 重建二叉树](#4-重建二叉树)
      - [5. 用两个栈实现队列](#5-用两个栈实现队列)
      - [6. 旋转数组的最小数字](#6-旋转数组的最小数字)
      - [7. 斐波那契数列](#7-斐波那契数列)
      - [8. 跳台阶](#8-跳台阶)
      - [9. 变态跳台阶](#9-变态跳台阶)
      - [10. 矩形覆盖](#10-矩形覆盖)
      - [11. 二进制中1的个数](#11-二进制中1的个数)
      - [12. 数值的整数次方](#12-数值的整数次方)
      - [13. 调整数组顺序使奇数位于偶数前面](#13-调整数组顺序使奇数位于偶数前面)
      - [14. 链表中倒数第 k 个节点](#14-链表中倒数第-k-个节点)
      - [15. 反转链表](#15-反转链表)
      - [16. 合并两个排序的链表](#16-合并两个排序的链表)
      - [17. 树的子结构](#17-树的子结构)
      - [18. 二叉树的镜像](#18-二叉树的镜像)
      - [19. 顺时针打印矩阵](#19-顺时针打印矩阵)
      - [20. 定义一个栈，实现 min 函数](#20-定义一个栈实现-min-函数)
      - [21. 栈的压入弹出](#21-栈的压入弹出)
      - [22. 从上往下打印二叉树](#22-从上往下打印二叉树)
      - [23. 二叉搜索树的后序遍历](#23-二叉搜索树的后序遍历)
      - [24. 二叉树中和为某一值路径](#24-二叉树中和为某一值路径)
      - [25. 复杂链表的复制](#25-复杂链表的复制)
      - [26. 二叉搜索树与双向链表](#26-二叉搜索树与双向链表)
      - [27. 字符串的排列](#27-字符串的排列)
      - [28. 数组中出现次数超过一半的数字](#28-数组中出现次数超过一半的数字)
      - [29. 最小的 K 个数](#29-最小的-k-个数)
      - [30. 连续子数组的最大和](#30-连续子数组的最大和)
      - [31. 整数中1出现的次数（待深入理解）](#31-整数中1出现的次数待深入理解)
      - [32. 把数组排成最小的数](#32-把数组排成最小的数)
      - [33. 丑数（待深入理解）](#33-丑数待深入理解)
      - [34. 第一个只出现一次的字符](#34-第一个只出现一次的字符)
      - [35. 数组中的逆序对](#35-数组中的逆序对)
      - [36. 两个链表的第一个公共结点](#36-两个链表的第一个公共结点)
      - [37. 数字在排序数组中出现的次数](#37-数字在排序数组中出现的次数)
      - [38. 二叉树的深度](#38-二叉树的深度)
      - [39. 平衡二叉树](#39-平衡二叉树)
      - [40. 数组中只出现一次的数字](#40-数组中只出现一次的数字)
      - [41. 和为 S 的连续正数序列](#41-和为-s-的连续正数序列)
      - [42. 和为 S 的两个数字](#42-和为-s-的两个数字)
      - [43. 左旋转字符串](#43-左旋转字符串)
      - [44. 翻转单词顺序列](#44-翻转单词顺序列)
      - [45. 扑克牌的顺子](#45-扑克牌的顺子)
      - [46. 圆圈中最后剩下的数字（约瑟夫环问题）](#46-圆圈中最后剩下的数字约瑟夫环问题)
      - [47. 1+2+3+...+n](#47-123n)
      - [48. 不用加减乘除做加法](#48-不用加减乘除做加法)
      - [49. 把字符串转换成整数。](#49-把字符串转换成整数)
      - [50. 数组中重复的数字](#50-数组中重复的数字)
      - [51. 构建乘积数组](#51-构建乘积数组)
      - [52. 正则表达式的匹配](#52-正则表达式的匹配)
      - [53. 表示数值的字符串](#53-表示数值的字符串)
      - [54. 字符流中第一个不重复的字符](#54-字符流中第一个不重复的字符)
      - [55. 链表中环的入口结点](#55-链表中环的入口结点)
      - [56. 删除链表中重复的结点](#56-删除链表中重复的结点)
      - [57. 二叉树的下一个结点](#57-二叉树的下一个结点)
      - [58. 对称二叉树](#58-对称二叉树)
      - [59. 按之字形顺序打印二叉树（待深入理解）](#59-按之字形顺序打印二叉树待深入理解)
      - [60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。](#60-从上到下按层打印二叉树同一层结点从左至右输出每一层输出一行)
      - [61. 序列化二叉树（待深入理解）](#61-序列化二叉树待深入理解)
      - [62. 二叉搜索树的第 K 个节点](#62-二叉搜索树的第-k-个节点)
      - [63. 数据流中的中位数（待深入理解）](#63-数据流中的中位数待深入理解)
      - [64. 滑动窗口中的最大值（待深入理解）](#64-滑动窗口中的最大值待深入理解)
      - [65. 矩阵中的路径（待深入理解）](#65-矩阵中的路径待深入理解)
      - [66. 机器人的运动范围（待深入理解）](#66-机器人的运动范围待深入理解)
  - [相关算法题](#相关算法题)
      - [1. 明星问题](#1-明星问题)
      - [2. 正负数组求和](#2-正负数组求和)

# 常用算法和数据结构总结

## 排序

### 冒泡排序

冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，
最终达到完全有序。

代码实现：

```js

function bubbleSort(arr) {
    if (!Array.isArray(arr) || arr.length <= 1) return;
    let lastIndex = arr.length - 1;
    while (lastIndex > 0) { // 当最后一个交换的元素为第一个时，说明后面全部排序完毕
        let flag = true, k = lastIndex;
        for (let j = 0; j < k; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = false;
              	lastIndex = j; // 设置最后一次交换元素的位置
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
            }
        }
      	if (flag) break;
    }
}

```
冒泡排序有两种优化方式。

一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。
因此我们不需要再执行之后的外层循环，此时可以直接结束。

一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下
一轮循环中无需再去比较。

优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。

冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。

详细资料可以参考：
[《图解排序算法(一)》](https://www.cnblogs.com/chengxiao/p/6103002.html)
[《常见排序算法 - 鸡尾酒排序 》](http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/)
[《前端笔试&面试爬坑系列---算法》](https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1)
[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41)

### 选择排序

选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。

在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实
我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较
仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。

代码实现：

```js
function selectSort(array) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 
  if (!Array.isArray(array) || length <= 1) return;

  for (let i = 0; i < length - 1; i++) {

    let minIndex = i; // 设置当前循环最小元素索引

    for (let j = i + 1; j < length; j++) {

      // 如果当前元素比最小元素索引，则更新最小元素索引
      if (array[minIndex] > array[j]) {
        minIndex = j;
      }
    }

    // 交换最小元素到当前位置
    // [array[i], array[minIndex]] = [array[minIndex], array[i]];
    swap(array, i, minIndex);
  }

  return array;
}

// 交换数组中两个元素的位置
function swap(array, left, right) {
  var temp = array[left];
  array[left] = array[right];
  array[right] = temp;
}
```

选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。

选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。

详细资料可以参考：
[《图解排序算法(一)》](https://www.cnblogs.com/chengxiao/p/6103002.html)


### 插入排序

直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。

插入排序核心--扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，
继续接，可能是中间数，就插在中间....依次

代码实现：

```js
function insertSort(array) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 
  if (!Array.isArray(array) || length <= 1) return;

  // 循环从 1 开始，0 位置为默认的已排序的序列
  for (let i = 1; i < length; i++) {
    let temp = array[i]; // 保存当前需要排序的元素
    let j = i;

    // 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置
    while (j -1 >= 0 && array[j - 1] > temp) {
      array[j] = array[j - 1];
      j--;
    }

    // 将找到的位置插入元素
    array[j] = temp;
  }

  return array;
}
```

当排序序列为已排序序列时，为最好的时间复杂度 O(n)。

插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。

详细资料可以参考：
[《图解排序算法(一)》](https://www.cnblogs.com/chengxiao/p/6103002.html)

### 希尔排序

希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元
素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。

代码实现：

```js
function hillSort(array) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 
  if (!Array.isArray(array) || length <= 1) return;


  // 第一层确定增量的大小，每次增量的大小减半
  for (let gap = parseInt(length >> 1); gap >= 1; gap = parseInt(gap >> 1)) {

    // 对每个分组使用插入排序，相当于将插入排序的1换成了 n
    for (let i = gap; i < length; i++) {
      let temp = array[i];
      let j = i;

      while (j - gap >= 0 && array[j - gap] > temp) {
        array[j] = array[j - gap];
        j -= gap;
      }
      array[j] = temp;
    }
  }

  return array;
}
```

希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行
基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一
次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。

简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，
所以排序速度也很快。

希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。

插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，
所以希尔排序是一个不稳定的排序。

希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。

详细资料可以参考：
[《图解排序算法(二)之希尔排序》](https://www.cnblogs.com/chengxiao/p/6104371.html)
[《数据结构基础 希尔排序 之 算法复杂度浅析》](https://blog.csdn.net/u013630349/article/details/48250109)

### 归并排序

归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后
将数组排序合并，最终合并为排序好的数组。

代码实现：

```js
function mergeSort(array) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于0，直接返回，不需要排序 
  if (!Array.isArray(array) || length === 0) return;

  if (length === 1) {
    return array;
  }

  let mid = parseInt(length >> 1), // 找到中间索引值
    left = array.slice(0, mid), // 截取左半部分
    right = array.slice(mid, length); // 截取右半部分

  return merge(mergeSort(left), mergeSort(right)); // 递归分解后，进行排序合并
}


function merge(leftArray, rightArray) {

  let result = [],
    leftLength = leftArray.length,
    rightLength = rightArray.length,
    il = 0,
    ir = 0;

  // 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止
  while (il < leftLength && ir < rightLength) {
    if (leftArray[il] < rightArray[ir]) {
      result.push(leftArray[il++]);
    } else {
      result.push(rightArray[ir++]);
    }
  }

  // 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。
  while (il < leftLength) {
    result.push(leftArray[il++]);
  }

  // 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。
  while (ir < rightLength) {
    result.push(rightArray[ir++]);
  }

  return result;
}
```
归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每
一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。

归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归
并排序的空间复杂度为 O(n)。

归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。

详细资料可以参考：
[《图解排序算法(四)之归并排序》](https://www.cnblogs.com/chengxiao/p/6194356.html)
[《归并排序的空间复杂度？》](https://www.zhihu.com/question/27274006)


### 快速排序

快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据
都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

代码实现：

```js
function quickSort(array, start, end) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 
  if (!Array.isArray(array) || length <= 1 || start >= end) return;

  let index = partition(array, start, end); // 将数组划分为两部分，并返回右部分的第一个元素的索引值

  quickSort(array, start, index - 1); // 递归排序左半部分
  quickSort(array, index + 1, end); // 递归排序右半部分
}


function partition(array, start, end) {

  let pivot = array[start]; // 取第一个值为枢纽值，获取枢纽值的大小


  // 当 start 等于 end 指针时结束循环
  while (start < end) {

    // 当 end 指针指向的值大等于枢纽值时，end 指针向前移动
    while (array[end] >= pivot && start < end) {
      end--;
    }

    // 将比枢纽值小的值交换到 start 位置
    array[start] = array[end];

    // 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动
    while (array[start] < pivot && start < end) {
      start++;
    }

    // 将比枢纽值大的值交换到 end 位置，进入下一次循环
    array[end] = array[start];
  }

  // 将枢纽值交换到中间点
  array[start] = pivot;

  // 返回中间索引值
  return start;
}
```

这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值
等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者
start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的
值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递
归左右两边的的序列。

当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂
度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。

当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏
的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。

快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。

快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。

详细资料可以参考：
[《图解排序算法(五)之快速排序——三数取中法》](https://www.cnblogs.com/chengxiao/p/6262208.html)
[《关于快速排序的四种写法》](https://segmentfault.com/a/1190000004410119#articleHeader2)
[《快速排序的时间和空间复杂度》](https://harttle.land/2015/09/27/quick-sort.html)
[《快速排序最好，最坏，平均复杂度分析》](https://blog.csdn.net/weshjiness/article/details/8660583)
[《快速排序算法的递归深度》](https://blog.csdn.net/qq_33758761/article/details/76782610)

### 堆排序

堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行
交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，
便能得到一个有序序列了。

```js
function heapSort(array) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 
  if (!Array.isArray(array) || length <= 1) return;

  buildMaxHeap(array); // 将传入的数组建立为大顶堆

  // 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆
  for (let i = length - 1; i > 0; i--) {
    swap(array, 0, i);
    adjustMaxHeap(array, 0, i); // 将剩下的元素重新构建为大顶堆
  }

  return array;
}


function adjustMaxHeap(array, index, heapSize) {
  let iMax,
    iLeft,
    iRight;

  while (true) {
    iMax = index; // 保存最大值的索引
    iLeft = 2 * index + 1; // 获取左子元素的索引
    iRight = 2 * index + 2; // 获取右子元素的索引

    // 如果左子元素存在，且左子元素大于最大值，则更新最大值索引
    if (iLeft < heapSize && array[iMax] < array[iLeft]) {
      iMax = iLeft;
    }

    // 如果右子元素存在，且右子元素大于最大值，则更新最大值索引
    if (iRight < heapSize && array[iMax] < array[iRight]) {
      iMax = iRight;
    }

    // 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树
    if (iMax !== index) {
      swap(array, index, iMax);
      index = iMax;
    } else {

      // 如果未被更新，说明该子树满足大顶堆的要求，退出循环
      break;
    }
  }
}

// 构建大顶堆
function buildMaxHeap(array) {
  let length = array.length,
    iParent = parseInt(length >> 1) - 1; // 获取最后一个非叶子点的元素

  for (let i = iParent; i >= 0; i--) {
    adjustMaxHeap(array, i, length); // 循环调整每一个子树，使其满足大顶堆的要求
  }
}

// 交换数组中两个元素的位置
function swap(array, i, j) {
  let temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
```

建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在
不管什么情况下都是 O(nlogn)。

堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。

详细资料可以参考：
[《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)
[《常见排序算法 - 堆排序 (Heap Sort)》](http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/)
[《堆排序中建堆过程时间复杂度O(n)怎么来的？》](https://www.zhihu.com/question/20729324)
[《排序算法之 堆排序 及其时间复杂度和空间复杂度》](https://blog.csdn.net/YuZhiHui_No1/article/details/44258297)
[《最小堆 构建、插入、删除的过程图解》](https://blog.csdn.net/hrn1216/article/details/51465270)


### 基数排序 

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将
所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样
从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

代码实现：

```js
function radixSort(array) {

  let length = array.length;

  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 
  if (!Array.isArray(array) || length <= 1) return;

  let bucket = [],
    max = array[0],
    loop;

  // 确定排序数组中的最大值
  for (let i = 1; i < length; i++) {
    if (array[i] > max) {
      max = array[i];
    }
  }

  // 确定最大值的位数
  loop = (max + '').length;


  // 初始化桶
  for (let i = 0; i < 10; i++) {
    bucket[i] = [];
  }

  for (let i = 0; i < loop; i++) {
    for (let j = 0; j < length; j++) {
      let str = array[j] + '';

      if (str.length >= i + 1) {
        let k = parseInt(str[str.length - 1 - i]); // 获取当前位的值，作为插入的索引
        bucket[k].push(array[j]);
      } else {
        // 处理位数不够的情况，高位默认为 0
        bucket[0].push(array[j]);
      }
    }

    array.splice(0, length); // 清空旧的数组

    // 使用桶重新初始化数组
    for (let i = 0; i < 10; i++) {
      let t = bucket[i].length;

      for (let j = 0; j < t; j++) {
        array.push(bucket[i][j]);
      }

      bucket[i] = [];
    }
  }

  return array;

}
```
基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定
排序。

详细资料可以参考：
[《常见排序算法 - 基数排序》](http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/)
[《排序算法之 基数排序 及其时间复杂度和空间复杂度》](https://blog.csdn.net/YuZhiHui_No1/article/details/44594415)


算法总结可以参考：
[《算法的时间复杂度和空间复杂度-总结》](https://blog.csdn.net/zolalad/article/details/11848739)
[《十大经典排序算法（动图演示）》](https://www.cnblogs.com/onepixel/p/7674659.html)
[《各类排序算法的对比及实现》](https://blog.csdn.net/wangiijing/article/details/51485119)

### 快速排序相对于其他排序效率更高的原因

上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同
数据量的情况下，它的运算效率最高，并且它额外所需空间最小。

我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看
的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最
坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？

首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因
此归并排序首先就被排除掉了。

接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。

第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在
枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我
们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互
换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较
是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。

第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机
中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原
理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当
前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理
来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于
空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行
数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显
提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来
说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更
高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可
以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其
他的因素。

相关资料可以参考：
[《为什么在平均情况下快速排序比堆排序要优秀？》](https://www.zhihu.com/question/23873747)
[《为什么说快速排序是性能最好的排序算法？》](https://blog.csdn.net/qq_36770641/article/details/82669788)

### 系统自带排序实现

每个语言的排序内部实现都是不同的。

对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据
量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。


### 稳定性

稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，
而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。

稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个`<ul>`列表进行渲染，
当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。

### 排序面试题目总结

1. 快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。

2. 初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。

3. 合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。

4. 外部排序常用的算法是归并排序。

5. 数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。

6. 如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。

7. 插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。

8. 对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。
   
9. 下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。
   因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。

10. 拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。

11. 任何一个基于"比较"的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k > n!，
    时间下界为 O(nlogn)

12. m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3

13. 对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。

14. 在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)


## 树

### 二叉树相关性质

1. 节点的度：一个节点含有的子树的个数称为该节点的度；

2. 叶节点或终端节点：度为零的节点； 

3. 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 

4. 树的高度或深度：树中节点的最大层次。

5. 在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i>=1。 

6. 深度为 h 的二叉树最多有 2^h-1个结点(h>=1)，最少有 h 个结点。

7. 对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1； 
   
8. 给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。

9. 二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 

10. 二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 

11. 二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。

12. 二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。

13. 一个带权的无向连通图的最小生成树的权值之和是唯一的。
    
14. 只有一个结点的二叉树的度为 0 。
    
15. 二叉树的度是以节点的最大的度数定义的。

16. 树的后序遍历序列等同于该树对应的二叉树的中序序列。

17. 树的先序遍历序列等同于该树对应的二叉树的先序序列。 

18. 线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列： 
    debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。

19. 递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，
    也就是深度d！=logn，有可能d>>logn。所以栈大小应该是O（d）

20. 一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，
    即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。

21. 引入二叉线索树的目的是加快查找结点的前驱或后继的速度。

22. 二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。

23. 不管是几叉树，节点数等于=分叉数+1

24. 任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。


详细资料可以参考：
[《n 个节点的二叉树有多少种形态》](https://blog.csdn.net/adminabcd/article/details/46672759)
[《数据结构二叉树知识点总结》](https://www.cnblogs.com/guoyaohua/p/8595289.html)
[《还原二叉树--已知先序中序或者后序中序》](https://www.jianshu.com/p/2943a21d2a99)
[《树、森林与二叉树的转换》](https://blog.csdn.net/linraise/article/details/11745559)

### 满二叉树

对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满
二叉树。


### 完全二叉树

对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满
二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。

性质：

1. 具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数) 

2. 有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则
   如果 I>1，则其父结点的编号为 I/2；

3. 完全二叉树，如果 2 * I <= N，则其左儿子（即左子树的根结点）的编号为2 * I；若2 * I > N，则无左儿子；如
   果 2 * I + 1 <= N，则其右儿子的结点编号为 2 * I + 1；若 2 * I + 1 > N，则无右儿子。

### 平衡二叉查找树（AVL）

平衡二叉查找树具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。

平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有
一点帮帮助，反而增加了维护的成本。

平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树
的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。

详细资料可以参考：
[《平衡二叉树，AVL树之图解篇》](https://www.cnblogs.com/suimeng/p/4560056.html)

### B-树

B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O 
次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，
我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少
索引树的高度是提高索引效率的关键。

B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每
个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页
只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树
的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查
找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。

详细资料可以参考：
[《漫画：什么是 B- 树？》](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561220&idx=1&sn=2a6d8a0290f967027b1d54456f586405&chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&scene=21#wechat_redirect)

### B+树

B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。
B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点
中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够
包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含
了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。

详细资料可以参考：
[《漫画：什么是 B+ 树？》](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561244&idx=1&sn=df3abafd3aa2f5a3abfe507bfc26982f&chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&scene=21#wechat_redirect)


### 数据库索引

数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建
立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是
由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。

相关资料可以参考：
[《深入浅出数据库索引原理》](https://zhuanlan.zhihu.com/p/23624390)
[《数据库的最简单实现》](http://www.ruanyifeng.com/blog/2014/07/database_implementation.html)

### 红黑树

红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子
节点的最长路径不会超过最短路径的两倍。

红黑树的有具体的规则：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。

详细资料可以参考：
[《漫画：什么是红黑树？》](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561574&idx=1&sn=edab54460a85c9686e0ec0f5d178907c&chksm=f1feeaa5c68963b3689d23db68ab14a9c50a33dd5e9244a74d7765321b42af7ec14abfadf9ac&scene=21#wechat_redirect)
[《漫画算法等精选文章目录》](https://cloud.tencent.com/developer/article/1101517)


### Huffman 树

给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉
树，也称为 Huffman 树。

利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码
不是另一个字符编码的前缀。

性质：

1. 对应一组权重构造出来的 Huffman 树一般不是唯一的

2. Huffman 树具有最小的带权路径长度

3. Huffman 树中没有度为1的结点

4. 哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近

5. Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和

详细资料可以参考：

[《数据结构和算法—— Huffman 树和 Huffman 编码》](https://blog.csdn.net/google19890102/article/details/54848262) 
[《详细图解哈夫曼 Huffman 编码树》](https://blog.csdn.net/fx677588/article/details/70767446)


### 二叉查找树

二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，
对于数值型和非数值型数据，比如字母和字符串，都是如此。

实现树节点类：

```js
// 节点类，树的节点
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }

  show() {
    console.log(this.value);
  }
}
```

实现二叉查找树类：

```js
class BinarySearchTree {

  constructor() {
    this.root = null
  }

}
```

实现树的节点插入方法

节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，
否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。
循环这个过程直到找到合适的插入位置。

```js

  insert(value) {

    let newNode = new Node(value);

    // 判断根节点是否为空，如果不为空则递归插入到树中
    if (this.root === null) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }

  insertNode(node, newNode) {

    // 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。
    if (newNode.value < node.value) {
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }

  }
```

通过递归实现树的先序、中序、后序遍历

```js
 // 先序遍历通过递归实现
 // 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。
  preOrderTraverse() {
    this.preOrderTraverseNode(this.root);
  }

  preOrderTraverseNode(node) {
    if (node !== null) {
      node.show();
      this.preOrderTraverseNode(node.left);
      this.preOrderTraverseNode(node.right);
    }
  }

  // 中序遍历通过递归实现
  // 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。
  inOrderTraverse() {
    this.inOrderTraverseNode(this.root);
  }

  inOrderTraverseNode(node) {
    if (node !== null) {
      this.inOrderTraverseNode(node.left);
      node.show();
      this.inOrderTraverseNode(node.right);
    }
  }

  // 后序遍历通过递归实现
  // 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。
  postOrderTraverse() {
    this.postOrderTraverseNode(this.root);
  }

  postOrderTraverseNode(node) {
    if (node !== null) {
      this.postOrderTraverseNode(node.left);
      this.postOrderTraverseNode(node.right);
      node.show();
    }
  }
```

通过循环实现树的先序、中序、后序遍历

```js
  // 先序遍历通过循环实现
  // 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将
  // 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。
  preOrderTraverseByStack() {
    let stack = [];

    // 现将根节点入栈，开始遍历
    stack.push(this.root);

    while (stack.length > 0) {

      // 从栈中获取当前节点
      let node = stack.pop();

      // 执行节点操作
      node.show();

      // 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根
      // 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的
      if (node.right) {
        stack.push(node.right);
      }

      if (node.left) {
        stack.push(node.left);
      }
    }
  }

  // 中序遍历通过循环实现
  // 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有
  // 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。
  inOrderTraverseByStack() {
    let stack = [],
      node = this.root;

    // 中序遍历是先左再根最后右
    // 所以首先应该先把最左边节点遍历到底依次 push 进栈
    // 当左边没有节点时，就打印栈顶元素，然后寻找右节点
    while (stack.length > 0 || node) {
      if (node) {
        stack.push(node);
        node = node.left;
      } else {
        node = stack.pop();
        node.show();
        node = node.right;
      }
    }
  }

  // 后序遍历通过循环来实现
  // 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次
  // 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。
  postOrderTraverseByStack() {
    let stack1 = [],
      stack2 = [],
      node = null;

    // 后序遍历是先左再右最后根
    // 所以对于一个栈来说，应该先 push 根节点
    // 然后 push 右节点，最后 push 左节点

    stack1.push(this.root);

    while (stack1.length > 0) {
      node = stack1.pop();

      stack2.push(node);  
      
      if (node.left) {
        stack1.push(node.left);
      }
      
      if (node.right) {
        stack1.push(node.right);
      }

    }

    while (stack2.length > 0) {
      node = stack2.pop();
      node.show();
    }
  }
```

实现寻找最大最小节点值

```js
 // 寻找最小值，在最左边的叶子节点上
  findMinNode(root) {
    let node = root;

    while (node && node.left) {
      node = node.left;
    }

    return node;
  }

  // 寻找最大值，在最右边的叶子节点上

  findMaxNode(root) {
    let node = root;

    while (node && node.right) {
      node = node.right;
    }

    return node;
  }
```

实现寻找特定大小节点值

```js
  // 寻找特定值
  find(value) {
    return this.findNode(this.root, value);
  }

  findNode(node, value) {

    if (node === null) {
      return node;
    }
    if (value < node.value) {
      return this.findNode(node.left, value);
    } else if (value > node.value) {
      return this.findNode(node.right, value);
    } else {
      return node;
    }
  }
```

实现移除节点值

移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如
果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。

```js

  // 移除指定值节点
  remove(value) {
    this.removeNode(this.root, value);
  }
  removeNode(node, value) {

    if (node === null) {
      return node;
    }

    // 寻找指定节点
    if (value < node.value) {
      node.left = this.removeNode(node.left, value);
      return node;
    } else if (value > node.value) {
      node.right = this.removeNode(node.right, value);
      return node;
    } else { // 找到节点

      // 第一种情况——没有叶节点
      if (node.left === null && node.right === null) {
        node = null;
        return node;
      }

      // 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点
      if (node.left === null) {
        node = node.right;
        return node;
      } else if (node.right === null) {
        node = node.left;
      }

      // 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点
      // 的值，保持树的特性，然后将替换的节点去掉
      let aux = this.findMinNode(node.right);
      node.value = aux.value;
      node.right = this.removeNode(node.right, aux);
      return node;
    }
  }
```

### 求解二叉树中两个节点的最近公共祖先节点

```
求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑

（1）该二叉树为搜索二叉树 

    解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于
    根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个
    节点的值小时，该节点则为两个节点的最近公共祖先节点。

（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。

    通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点
    的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。

（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。

    这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同
    的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。
```
详细资料可以参考：
[《二叉树中两个节点的最近公共祖先节点》](https://blog.csdn.net/xyzbaihaiping/article/details/52122885)

## 链表

### 反转单向链表

需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是
一道面试常考题。

思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。

```js
var reverseList = function(head) {
    // 判断下变量边界问题
    if (!head || !head.next) return head;
    // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null
    let pre = null;
    let current = head;
    let next;
    // 判断当前节点是否为空
    // 不为空就先获取当前节点的下一节点
    // 然后把当前节点的 next 设为上一个节点
    // 然后把 current 设为下一个节点，pre 设为当前节点
    while(current) {
        next = current.next;
        current.next = pre;
        pre = current;
        current = next;
    }
    return pre;
};
```

## 动态规划

### 爬楼梯问题

有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？

#### 递归方法分析

由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，
因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上
从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到
2级阶梯的走法数量。

代码实现
```js
function getClimbingWays(n) {

  if (n < 1) {
    return 0;
  }

  if (n === 1) {
    return 1;
  }

  if (n === 2) {
    return 2;
  }

  return getClimbingWays(n - 1) + getClimbingWays(n - 2);
}
```

使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度
为递归的深度 O(logn)。

#### 备忘录方法

分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给
保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。

代码实现
```js
let map = new Map();

function getClimbingWays(n) {

  if (n < 1) {
    return 0;
  }

  if (n === 1) {
    return 1;
  }

  if (n === 2) {
    return 2;
  }

  if (map.has(n)) {
    return map.get(n);
  } else {
    let value = getClimbingWays(n - 1) + getClimbingWays(n - 2);
    map.set(n, value);
    return value;
  }
}
```

通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)

#### 迭代法

通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。

代码实现
```js
function getClimbingWays(n) {

  if (n < 1) {
    return 0;
  }

  if (n === 1) {
    return 1;
  }

  if (n === 2) {
    return 2;
  }

  let a = 1,
    b = 2,
    temp = 0;

  for (let i = 3; i <= n; i++) {
    temp = a + b;
    a = b;
    b = temp;
  }

  return temp;
}
```

通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。

详细资料可以参考：
[《漫画：什么是动态规划？（整合版）》](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561168&idx=1&sn=9d1c6f7ba6d651c75399c4aa5254a7d8&chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&scene=21#wechat_redirect)


## 经典笔试题

#### 1. js 实现一个函数，完成超过范围的两个大整数相加功能
   ```js
   主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。

   function bigNumberAdd(number1, number2) {

     let result = "", // 保存最后结果
       carry = false; // 保留进位结果

     // 将字符串转换为数组
     number1 = number1.split("");
     number2 = number2.split("");

     // 当数组的长度都变为0，并且最终不再进位时，结束循环
     while (number1.length || number2.length || carry) {

       // 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0
       carry += ~~number1.pop() + ~~number2.pop();

       // 取加法结果的个位加入最终结果
       result = carry % 10 + result;

       // 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0
       carry = carry > 9;
     }

     // 返回最终结果
     return result;
   }
   ```
   详细资料可以参考：
   [《JavaScript实现超范围的数相加》](https://blog.csdn.net/fe_dev/article/details/80079372)
   [《js 实现大整数加法》](https://blog.csdn.net/q1059081877q/article/details/80689194)


#### 2. js 如何实现数组扁平化？
   ```js
   // 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好
   function flattenArray(array) {

     if (!Array.isArray(array)) return;

     let result = [];

     result = array.reduce(function (pre, item) {
       // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中
       return pre.concat(Array.isArray(item) ? flattenArray(item) : item);
     }, []);

     return result;
   }

   // 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况
   function flattenArray(array) {
     return array.toString().split(",").map(function (item) {
       return +item;
     })
   }
   ```
   详细资料可以参考：
   [《JavaScript专题之数组扁平化》](https://github.com/mqyqingfeng/Blog/issues/36)


#### 3. js 如何实现数组去重？
   ```js
   function unique(array) {
     if (!Array.isArray(array) || array.length <= 1) return;

     var result = [];

     array.forEach(function (item) {
       if (result.indexOf(item) === -1) {
         result.push(item);
       }
     })

     return result;
   }


   function unique(array) {
     if (!Array.isArray(array) || array.length <= 1) return;

     return [...new Set(array)];
   }
   ```
   详细资料可以参考：
   [《JavaScript专题之数组去重》](https://github.com/mqyqingfeng/Blog/issues/27)
  
#### 4. 如何求数组的最大值和最小值？
   ```js
   var arr = [6, 4, 1, 8, 2, 11, 23];
   console.log(Math.max.apply(null, arr))
   ```
   详细资料可以参考：
   [《JavaScript专题之如何求数组的最大值和最小值》](https://github.com/mqyqingfeng/Blog/issues/35)

#### 5. 如何求两个数的最大公约数？
   ```js
   基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，
   直到余数为0时，最后的被除数就是两个数的最大公约数。

   function getMaxCommonDivisor(a, b) {
     if (b === 0) return a;

     return getMaxCommonDivisor(b, a % b);
   }
   ```

#### 6. 如何求两个数的最小公倍数？
   ```js
   基本思想是采用将两个数相乘，然后除以它们的最大公约数

   function getMinCommonMultiple(a, b){
     return a * b / getMaxCommonDivisor(a, b);
   }
   ```
   详细资料可以参考：
   [《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》](https://www.cnblogs.com/cssfirefly/archive/2012/10/23/2734936.html)

#### 7. 实现 IndexOf 方法？
   ```js
   function indexFun(array, val) {
     if (!Array.isArray(array)) return;

     let length = array.length;

     for (let i = 0; i < length; i++) {
       if (array[i] === val) {
         return i;
       }
     }

     return -1;
   }   
   ```

#### 8. 判断一个字符串是否为回文字符串？
   ```js
   function isPalindrome(str) {
     let reg = /[\W_]/g, // 匹配所有非单词的字符以及下划线
       newStr = str.replace(reg, "").toLowerCase(), // 替换为空字符并将大写字母转换为小写
       reverseStr = newStr.split("").reverse().join(""); // 将字符串反转

     return reverseStr === newStr;
   }
   ```

#### 9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()
   ```js
   function sum(...args) {

   let result = 0;

   result = args.reduce(function (pre, item) {
     return pre + item;
   }, 0);

   let add = function (...args) {

     result = args.reduce(function (pre, item) {
       return pre + item;
     }, result);

     return add;
   };

   add.valueOf = function () {
     console.log(result);
   }

   return add;
   }
   ```

#### 10. 使用 reduce 方法实现 forEach、map、filter 
   ```js

    // forEach
    function forEachUseReduce(array, handler) {
      array.reduce(function (pre, item, index) {
        handler(item, index);
      }, null);
    }
    
    // map
    function mapUseReduce(array, handler) {
      let result = [];

      array.reduce(function (pre, item, index) {
        let mapItem = handler(item, index);
        result.push(mapItem);
      }, null);

      return result;
    }
    
    // filter
    function filterUseReduce(array, handler) {
      let result = [];

      array.reduce(function (pre, item, index) {
        if (handler(item, index)) {
          result.push(item);
        }
      }, null);

      return result;
    }
   ```

#### 11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 "1", "2", "3"
   ```js
    class Queue {

      constructor() {
        this.queue = [];
        this.time = 0;
      }

      addTask(task, t) {
        this.time += t;
        this.queue.push([task, this.time]);
        return this;
      }

      start() {
        this.queue.forEach(item => {
          setTimeout(() => {
            item[0]();
          }, item[1]);
        })
      }
    }
   ```
#### 12. 如何查找一篇英文文章中出现频率最高的单词？
   ```js
    function findMostWord(article) {

    // 合法性判断
    if (!article) return;

    // 参数处理
    article = article.trim().toLowerCase();

    let wordList = article.match(/[a-z]+/g),
     visited = [],
     maxNum = 0,
     maxWord = "";

    article = " " + wordList.join("  ") + " ";

    // 遍历判断单词出现次数
    wordList.forEach(function (item) {
     if (visited.indexOf(item) < 0) {
       let word = new RegExp(" " + item + " ", "g"),
         num = article.match(word).length;

       if (num > maxNum) {
         maxNum = num;
         maxWord = item;
       }
     }
    });

    return maxWord + "  " + maxNum;

    }
   ```


# 常见面试智力题总结

#### 1. 时针与分针夹角度数问题？
   
   分析：
   ```
   当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？

   我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。

   时针每走一格为 30 度。

   因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。

   因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;
   ```

   答案：
   ```
   因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; 
   ```
  
   详细资料参考：
   [《面试智力题 — 时针与分针夹角度数问题》](https://blog.csdn.net/prstaxy/article/details/22210829)

#### 2. 用3升，5升杯子怎么量出4升水？
   ```
   （1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。

   （2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。

   （3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。
   ```

#### 3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？
   ```
   由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。

   （1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。

   （2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4
       片药片。

   （3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。
   ```

#### 4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？
   ```
   我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。
   ```

#### 5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？
   ```
   我认为一共至少需要 7 次才能选出最快的三匹马。

   （1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直
       接淘汰掉，那么我们现在还剩下了 15 匹马。

   （2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余
       马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，
       它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，
       它们都有竞争最快第二第三的机会。

   （3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。
   ```

#### 6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？
   ```
   （1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。

   （2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因
       此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。

   （3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有
       他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。

   （4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手
       ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数
       为 1 的人是配偶。

   （5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。

   （6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。

   （7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。
   ```

#### 7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？
   ```
   （1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。

   （2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路
       程。
   ```

#### 8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？
   ```
   一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。
  
   （1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。

   （2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。

   （3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。

   （4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。
   ```

#### 9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？
   ```
   （1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。

   （2） 第二次再用第一次称取的盐和砝码称取 16 克盐。

   （3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。
   ```

#### 10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？ 
   ```
    由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此
    两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。
   ```

#### 11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？
   ```
    第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法
   ```

#### 12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？
   ```
    最少两次可以称出。

    首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。

    第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如
    果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。
   ```

#### 13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？
   ```
    （1）首先打开一盏灯 10 分钟，然后打开第二盏。
    （2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开
        的。
   ```

#### 14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？
   ```
    将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。
   ```

#### 15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。
   ```
    从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。

    对应水果标签的筐的标签改为另一种水果。

    另一种水果标签的框改为混合。
   ``` 

#### 16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？
   ```
    （1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。

    （2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多
        90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。

    因此三种球都喜欢的人占比为 10%-60%
   ```

#### 17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？
   ```
    五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。
   ```
    
   更多的智力题可以参考：
   [《经典面试智力题200+题和解答》](https://blog.csdn.net/hilyoo/article/details/4445858)


# 剑指 offer 思路总结

本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！

## 题目

#### 1. 二维数组中的查找
   ```
   题目：
   在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的
   一个二维数组和一个整数，判断数组中是否含有该整数。


   思路：

   （1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。

   （2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动
       ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。
   ```

#### 2. 替换空格
   ```
   题目：

   请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20
   Are%20Happy


   思路：

   使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”

   str.replace(/\s/g,"%20")
   ```

#### 3. 从尾到头打印链表
   ```
   题目：

   输入一个链表，从尾到头打印链表每个节点的值。


   思路：

   利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的
   实现可以利用 Array 的 push 和 pop 方法来模拟。
   ```

#### 4. 重建二叉树
   ```
   题目：

   输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输
   入前序遍历序列 {1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6}，则重建二叉树并返回。


   思路：

   利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左
   边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的
   时间复杂度为 O(n)，空间复杂度为 O(logn)。
   ```

#### 5. 用两个栈实现队列
   ```
   题目：

   用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。


   思路：

   队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接
   将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中
   的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。

   扩展：

   当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。
   ```

#### 6. 旋转数组的最小数字
   ```
   题目：

   把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的
   最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大
   小为0，请返回0。


   思路：

   （1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相
       邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。

   （2）二分法
   ```
   相关资料可以参考：
   [《旋转数组的最小数字》](https://www.cnblogs.com/edisonchou/p/4746561.html)

#### 7. 斐波那契数列
   ```
   题目：

   大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n<=39


   思路：

   斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠
   加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。
   ```

#### 8. 跳台阶
   ```
   题目：

   一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

   思路：

   跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一
   种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。

   和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。
   ```

#### 9. 变态跳台阶
   ```
   题目：

   一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

   思路：

   变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。
   
   f(1) = 1
   f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。
   f(3) = f(3-1) + f(3-2) + f(3-3) 
   ...
   f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 
   
   再次总结可得

                 | 1       ,(n=0 ) 
   f(n) =        | 1       ,(n=1 )
                 | 2*f(n-1),(n>=2)
   ```

#### 10. 矩形覆盖
   ```
    题目：

    我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共
    有多少种方法？


    思路：

    依旧是斐波那契数列的应用
   ```

#### 11. 二进制中1的个数
   ```
    题目：

    输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。


    思路：

    一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后
    面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判
    断这个数可以经历多少次这样的过程。

    如：1100&1011=1000 
   ```

#### 12. 数值的整数次方
   ```
    题目：

    给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。


    思路：

    首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 
   ```

#### 13. 调整数组顺序使奇数位于偶数前面
   ```
    题目：

    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半
    部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。


    思路：

    由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到
    奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间
    复杂度为 O(n)。
   ```

#### 14. 链表中倒数第 k 个节点
   ```
    题目：

    输入一个链表，输出该链表中倒数第 k 个结点。


    思路：

    使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后
    移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。
   ```

#### 15. 反转链表
   ```
    题目：

    输入一个链表，反转链表后，输出链表的所有元素。


    思路：

    通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当
    前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne
    xt 节点，实现下一次循环。
   ```

#### 16. 合并两个排序的链表
   ```
    题目：

    输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

    思路：

    通过递归的方式，依次将两个链表的元素递归进行对比。
   ```

#### 17. 树的子结构
   ```
    题目：

    输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）

    思路：

    通过递归的思想来解决

    第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。
    第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。
   ```

#### 18. 二叉树的镜像
   ```
    题目：

    操作给定的二叉树，将其变换为源二叉树的镜像。 

    思路：

    从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。
   ```

#### 19. 顺时针打印矩阵
   ```
    题目：

    输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
    例如，如果输入如下矩阵： 1 2 3 4
    										 5 6 7 8 
    										 9 10 11 12 
    										 13 14 15 16 
    则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10


    思路：

    （1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一
        次需要打印的数据范围。

    （2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。
   ```

#### 20. 定义一个栈，实现 min 函数
   ```
    题目：

    定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。


    思路：
    
    使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小
    的值。
   ```

#### 21. 栈的压入弹出
   ```
    题目：

    输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如
    序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序
    列的弹出序列。（注意：这两个序列的长度是相等的）


    思路：

    我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出
    栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中
    的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。
   ```

#### 22. 从上往下打印二叉树
   ```
    题目：

    从上往下打印出二叉树的每个节点，同层节点从左至右打印。


    思路：

    本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子
    节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。
   ```

#### 23. 二叉搜索树的后序遍历
   ```
    题目：

    输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两
    个数字都互不相同。


    思路：

    对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，
    所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我
    们可以利用这些特点来递归判断。
   ```

#### 24. 二叉树中和为某一值路径
   ```
    题目：

    输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经
    过的结点形成一条路径。


    思路：

    通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。
   ```

#### 25. 复杂链表的复制
   ```
    题目：

    输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为
    复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）


    思路：

    （1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra
        ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。

    （2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复
        制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此
        不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。

    （3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行
        random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点
        。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。
   ```

#### 26. 二叉搜索树与双向链表
   ```
    题目：

    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。


    思路：

    需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序
    序列。

    基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并
    将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点
    的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。
   ```

#### 27. 字符串的排列
   ```
    题目：

    输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有
    字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。

    思路：

    我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可
    以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一
    个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。
   ```
   详细资料可以参考：
   [《字符串的排列》](https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html)


#### 28. 数组中出现次数超过一半的数字
   ```
    题目：

    数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数
    字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

    思路：

    （1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为
        O(nlogn)。

    （2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中
        位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随
        机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字
        便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之
        在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。

    （3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数
        字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果
        次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，
        则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。
   ```
   详细资料可以参考：
   [《出现次数超过一半的数字》](https://blog.csdn.net/ns_code/article/details/26957383)


#### 29. 最小的 K 个数
   ```
    题目：

    输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。


    思路：

    （1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂
        度，最好的情况下为 O(nlogn)。

    （2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part
        ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢
        纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢
        纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划
        分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平
        均时间复杂度为 O(n)。

    （3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这
        就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最
        大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一
        种方法的平均时间复杂度为 O(nlogk)。
   ```
   详细资料可以参考：
   [《寻找最小的 k 个数》](https://www.kancloud.cn/kancloud/the-art-of-programming/41579)


#### 30. 连续子数组的最大和
   ```
    题目：

    HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计
    算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的
    正数会弥补它呢？例如：{6,-3,-2,7,-15,1,2,2}，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠
    住？（子向量的长度至少是1）


    思路：

    （1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首
        往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。

    （2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。
        因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负
        数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。
        使用这一种方法的时间复杂度为 O(n)。
   ```
   详细资料可以参考：
   [《连续子数组的最大和》](http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html)

#### 31. 整数中1出现的次数（待深入理解）
   ```
    题目：

    求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、
    12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整
    数区间中1出现的次数。

    思路：

    （1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。

    （2）第二种思路是求出1出现在每位上的次数，然后进行叠加。
   ```
   详细资料可以参考：
   [《从1到n整数中1出现的次数：O(logn)算法》](https://blog.csdn.net/yi_Afly/article/details/52012593)


#### 32. 把数组排成最小的数
   ```
    题目：

    输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321
    }，则打印出这三个数字能排成的最小数字为321323。


    思路：

    （1）求出数组的全排列，然后对每个排列结果进行比较。

    （2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的
        结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。
   ```
   详细资料可以参考：
   [《把数组排成最小的数》](http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html)

#### 33. 丑数（待深入理解）
   ```
    题目：

    把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求
    按从小到大的顺序的第 N 个丑数。


    思路：

    （1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以
        5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。

    （2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。
   ```

#### 34. 第一个只出现一次的字符
   ```
    题目：

    在一个字符串（1<=字符串长度<=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。


    思路：

    （1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这
        一种方法的时间复杂度为 O(n^2)。

    （2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时
        ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。
   ```

#### 35. 数组中的逆序对
   ```
    题目：

    在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对
    的总数 P。


    思路：

    （1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果
        后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比
        较，因此这个算法的时间复杂度是 O(n^2)。

    （2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂
        度为 O(nlogn)。
   ```
   详细资料可以参考：
   [《数组中的逆序对》](http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html)

#### 36. 两个链表的第一个公共结点
   ```
    题目：

    输入两个链表，找出它们的第一个公共结点。

    思路：

    （1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二
        个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一
        个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。

    （2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈
        ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这
        一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。

    （3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个
        指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，
        判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。
   ```
   详细资料可以参考：
   [《两个链表的第一个公共结点》](http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html)

#### 37. 数字在排序数组中出现的次数
   ```
    题目：

    统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出
    现了 4 次，因此输出 4 。


    思路：

    （1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。

    （2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要
        去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束
        位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如
        果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值
        是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们
        下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结
        束位置。这一种方法的平均时间复杂度为 O(logn)。
   ```

#### 38. 二叉树的深度
   ```
    题目：

    输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深
    度。


    思路：

    根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。
   ```

#### 39. 平衡二叉树
   ```
    题目：

    输入一棵二叉树，判断该二叉树是否是平衡二叉树。


    思路：

    （1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它
        就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。

    （2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深
        度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。
   ```

#### 40. 数组中只出现一次的数字
   ```
    题目：

    一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。


    思路：

    （1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。

    （2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中
        的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下
        的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和
        B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会
        被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。
   ``` 

#### 41. 和为 S 的连续正数序列
   ```
    题目：

    小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究
    竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。
    现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序
    列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。


    思路：

    维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后
    判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续
    往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连
    续序列，直到数组遍历完成终止。
   ```
   详细资料可以参考：
   [《和为 s 的连续正数序列》](http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html)


#### 42. 和为 S 的两个数字
   ```
    题目：

    输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数
    的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。


    思路：

    首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和
    为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素
    。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和
    比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。
   ```
   详细资料可以参考：
   [《和为 S 的字符串》](https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html)


#### 43. 左旋转字符串
   ```
    题目：

    汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的
    字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “X
    YZdefabc”。是不是很简单？OK，搞定它！


    思路：

    字符串裁剪后拼接
   ```

#### 44. 翻转单词顺序列
   ```
    题目：

    牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有
    一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了
    ，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？


    思路：

    通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。
   ```

#### 45. 扑克牌的顺子
   ```
    题目：

    LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出
    了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王
    ，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作1，J 为11，
    Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。
    现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。


    思路：

    首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数
    组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空
    缺，这个数组实际上还是连续的。

    于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如
    果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0
    数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。
   ```
   详细资料可以参考：
   [《扑克牌的顺子》](http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html)

#### 46. 圆圈中最后剩下的数字（约瑟夫环问题）
   ```
    题目：

    0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数
    字。


    思路：

    （1）使用环形链表进行模拟。

    （2）根据规律得出（待深入理解）
   ```
   详细资料可以参考：
   [《圆圈中最后剩下的数字》](http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html)


#### 47. 1+2+3+...+n
   ```
    题目：

    求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。


    思路：

    由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 && 操作符的短路特
    性来实现。
   ```

#### 48. 不用加减乘除做加法
   ```
    题目：

    写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。


    思路：

    通过位运算，递归来实现。
   ```

#### 49. 把字符串转换成整数。
   ```
    题目：

    将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描
    述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。


    思路：

    首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。
   ```

#### 50. 数组中重复的数字
   ```
    题目：

    在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知
    道每个数字重复了几次。请找出数组中任意一个重复的数字。


    思路：

    （1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。

    （2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O
        (n)，空间复杂度为 O(n)。

    （3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值
        交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要
        额外的内存空间。
   ```
    
#### 51. 构建乘积数组
   ```
    题目：

    给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A
    [i+1]*...*A[n-1]。不能使用除法。


    思路：
    
    （1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1] 

          D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1] 

          B[i]=C[i]×D[i]

          将乘积分为前后两个部分，分别循环求出后，再进行相乘。

    （2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）
   ``` 
   详细资料可以参考：
   [《构建乘积数组》](https://zhuanlan.zhihu.com/p/34804711)


#### 52. 正则表达式的匹配
   ```
    题目：

    请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任
    意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，
    但是与"aa.a"和"ab*a"均不匹配。


    思路：

    （1）状态机思路（待深入理解）
   ```
   详细资料可以参考：
   [《正则表达式匹配》](http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html)


#### 53. 表示数值的字符串
   ```
    题目：

    请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-
    16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。、


    思路：

    利用正则表达式实现
   ```

#### 54. 字符流中第一个不重复的字符
   ```
    题目：

    请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次
    的字符是 "g" 。当从该字符流中读出前六个字符 "google" 时，第一个只出现一次的字符是 "l"。 输出描述：如果当前字符流
    没有存在出现一次的字符，返回#字符。


    思路：

    同第 34 题
   ```

#### 55. 链表中环的入口结点
   ```
    题目：

    一个链表中包含环，如何找出环的入口结点？


    思路：

    首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我
    们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此
    通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。

    然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇
    点就是环的入口节点。
   ```
   详细资料可以参考：
   [《链表中环的入口结点》](http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html)
   [《《剑指offer》——链表中环的入口结点》](https://blog.csdn.net/shansusu/article/details/50285735)


#### 56. 删除链表中重复的结点
   ```
    题目：

    在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1->2->3-
    >3->4->4->5 处理后为 1->2->5


    思路：

    解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头
    结点也可能被删除，所以在链表头额外添加一个结点。

    接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除
    之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev
    要始终与下一个没有重复的结点连接在一起。
   ```

#### 57. 二叉树的下一个结点
   ```
    题目：

    给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，
    还有一个指向父节点的指针。


    思路：

    这个问题我们可以分为三种情况来讨论。

    第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点
    出发，一直沿着左子节点的指针，就能找到下一个节点。

    第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节
    点。

    第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到
    一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。
   ```

#### 58. 对称二叉树
   ```
    题目：

    请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。


    思路：

    我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式
    ，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉
    树。
   ```

#### 59. 按之字形顺序打印二叉树（待深入理解）
   ```
    题目：

    请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照
    从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。


    思路：

    按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层
    ，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每
    一个栈遍历完成后进入下一层循环。
   ```
   详细资料可以参考：
   [《按之字形顺序打印二叉树》](https://www.cnblogs.com/wuguanglin/p/Print.html)


#### 60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
   ```
    题目：

    从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。


    思路：

    用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还
    没有打印的结点数，另一个变量表示下一次结点的数目。
   ```

#### 61. 序列化二叉树（待深入理解）
   ```
    题目：

    请实现两个函数，分别用来序列化和反序列化二叉树。


    思路：

    数组模拟
   ```

#### 62. 二叉搜索树的第 K 个节点
   ```
    题目：

    给定一颗二叉搜索树，请找出其中的第 k 小的结点。


    思路：

    对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。
   ```

#### 63. 数据流中的中位数（待深入理解）
   ```
    题目：

    如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据
    流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

   ```

#### 64. 滑动窗口中的最大值（待深入理解）
   ```
    题目：

    给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的
    大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下
    6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2
    ,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。


    思路：

    使用队列的方式模拟
   ```

#### 65. 矩阵中的路径（待深入理解）
   ```
    题目：

    请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每
    一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子
    。例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的
    第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
   ```

#### 66. 机器人的运动范围（待深入理解）
   ```
    题目：

    地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能
    进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是
    ，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
   ```


剑指 offer 相关资料可以参考：
[《剑指 offer 题目练习及思路分析》](https://blog.csdn.net/zzl819954692/article/details/79648054)
[《JS 版剑指 offer》](https://www.cnblogs.com/wuguanglin/p/code-interview.html)
[《剑指 Offer 学习心得》](https://wiki.jikexueyuan.com/project/for-offer/)



## 相关算法题 


#### 1. 明星问题
   ```
   题目：

   有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个
   函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。


   思路：

   （1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。
       这一种方法的时间复杂度为 O(n^2)。

   （2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明
       A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移
       除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩
       一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。
   ```
   详细资料可以参考：
   [《一个明星和 n-1 个群众》](https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f)

#### 2. 正负数组求和
   ```
   题目：

   有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和
   最接近零。


   思路：

   （1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分
       别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动
       一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。
   ```
> [转载自 haizlin/fe-interview](https://github.com/haizlin/fe-interview/blob/master/lib/React.md)

# React面试题
> 鼓励PR，持续更新（React v16.6.0）

## 历史题目(最新：2019.07.18)
[React](#React) | [ReactNative](#ReactNative) | [React-Router](#React-Router) | [Redux/Mobx](#Redux/Mobx) | [Flux](#Flux)

### React
- [什么时候使用状态管理器？](https://github.com/haizlin/fe-interview/issues/953)
- [render函数中return如果没有使用()会有什么问题？](https://github.com/haizlin/fe-interview/issues/952)
- [componentWillUpdate可以直接修改state的值吗？](https://github.com/haizlin/fe-interview/issues/951)
- [说说你对React的渲染原理的理解](https://github.com/haizlin/fe-interview/issues/950)
- [什么渲染劫持？](https://github.com/haizlin/fe-interview/issues/949)
- [React Intl是什么原理？](https://github.com/haizlin/fe-interview/issues/948)
- [你有使用过React Intl吗？](https://github.com/haizlin/fe-interview/issues/947)
- [怎么实现React组件的国际化呢？](https://github.com/haizlin/fe-interview/issues/946)
- [说说Context有哪些属性？](https://github.com/haizlin/fe-interview/issues/945)
- [怎么使用Context开发组件？](https://github.com/haizlin/fe-interview/issues/944)
- [为什么React并不推荐我们优先考虑使用Context？](https://github.com/haizlin/fe-interview/issues/943)
- [除了实例的属性可以获取Context外哪些地方还能直接获取Context呢？](https://github.com/haizlin/fe-interview/issues/942)
- [childContextTypes是什么？它有什么用？](https://github.com/haizlin/fe-interview/issues/941)
- [contextType是什么？它有什么用？](https://github.com/haizlin/fe-interview/issues/940)
- [Consumer向上找不到Provider的时候怎么办？](https://github.com/haizlin/fe-interview/issues/939)
- [有使用过Consumer吗？](https://github.com/haizlin/fe-interview/issues/938)
- [在React怎么使用Context？](https://github.com/haizlin/fe-interview/issues/937)
- [React15和16别支持IE几以上？](https://github.com/haizlin/fe-interview/issues/936)
- [说说你对windowing的了解](https://github.com/haizlin/fe-interview/issues/935)
- [举例说明React的插槽有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/934)
- [你有用过React的插槽(Portals)吗？怎么用？](https://github.com/haizlin/fe-interview/issues/933)
- [React的严格模式有什么用处？](https://github.com/haizlin/fe-interview/issues/932)
- [React如何进行代码拆分？拆分的原则是什么？](https://github.com/haizlin/fe-interview/issues/931)
- [React组件的构造函数有什么作用？](https://github.com/haizlin/fe-interview/issues/930)
- [React组件的构造函数是必须的吗？](https://github.com/haizlin/fe-interview/issues/929)
- [React中在哪捕获错误？](https://github.com/haizlin/fe-interview/issues/928)
- [React怎样引入svg的文件？](https://github.com/haizlin/fe-interview/issues/927)
- [说说你对Relay的理解](https://github.com/haizlin/fe-interview/issues/926)
- [在React中你有经常使用常量吗？](https://github.com/haizlin/fe-interview/issues/925)
- [为什么说React中的props是只读的？](https://github.com/haizlin/fe-interview/issues/924)
- [你有使用过formik库吗？说说它的优缺点](https://github.com/haizlin/fe-interview/issues/923)
- [你有用过哪些React的表单库吗？说说它们的优缺点](https://github.com/haizlin/fe-interview/issues/901)
- [如果组件的属性没有传值，那么它的默认值是什么？](https://github.com/haizlin/fe-interview/issues/900)
- [可以使用TypeScript写React应用吗？怎么操作？](https://github.com/haizlin/fe-interview/issues/899)
- [`super()`和`super(props)`有什么区别？](https://github.com/haizlin/fe-interview/issues/898)
- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)
- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)
- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)
- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)
- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)
- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)
- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)
- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)
- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)
- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)
- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)
- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)
- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)
- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)
- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)
- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)
- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)
- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)
- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)
- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)
- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)
- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)
- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)
- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)
- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)
- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)
- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)
- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)
- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)
- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)
- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)
- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)
- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)
- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)
- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)
- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)
- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)
- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)
- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)
- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)
- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)
- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)
- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)
- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)
- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)
- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)
- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)
- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)
- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)
- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)
- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)
- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)
- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)
- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)
- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)
- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)
- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)
- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)
- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)
- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)
- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)
- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)
- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)
- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)
- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)
- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)
- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)
- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)
- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)
- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)
- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)
- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)
- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)
- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)
- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)
- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)
- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)
- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)
- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)
- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)
- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)
- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)
- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)
- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)
- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)
- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)
- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)
- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)
- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)
- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)
- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)
- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)
- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)
- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)
- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)
- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)
- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)
- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)
- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)
- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)
- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)
- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)
- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)
- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)
- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)
- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)
- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)
- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)
- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)
- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)
- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)
- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)
- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)
- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)
- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)
- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)
- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)
- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)
- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)
- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)
- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)
- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)
- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)
- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)
- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)
- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)
- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)
- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)
- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)
- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)
- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)
- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)
- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)
- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)
- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)
- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)
- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)
- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)
- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)
- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)
- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)
- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)
- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)
- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)
- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)
- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)
- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)
- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)
- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)
- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)
- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)
- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)
- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)
- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)
- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)
- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)
- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)
- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)
- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)
- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)
- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)
- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)
- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)
- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)
- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)
- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)
- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)
- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)
- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)
- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)
- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)
- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)
- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)
- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)
- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)
- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)
- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)
- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)
- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)
- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)
- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)
- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)
- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)
- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)
- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)
- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)
- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)
- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)
- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)
- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)
- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)
- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)
- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)
- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)
- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)
- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)
- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)
- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)
- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)
- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)
- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)
- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)
- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)
- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)
- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)
- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)
- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)
- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)
- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)
- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)
- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)
- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)
- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)
- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)
- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)
- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)
- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)
- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)
- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)
- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)
- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)
- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)
- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)
- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)
- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)
- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)
- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)
- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)
- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)
- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)
- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)
- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)
- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)
- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)
- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)
- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)

### ReactNative
- [如何在React Native中设置环境变量？]()
- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)
- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)
- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)
- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)
- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)
- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)

### React-Router
- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)
- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)
- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)
- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)
- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)
- [React-Router 3和React-Router 4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)
- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)
- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)
- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)
- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)
- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)
- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)
- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)
- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)

### Redux/Mobx
- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)
- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)
- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)
- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)
- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)
- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)
- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)
- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)
- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)
- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)
- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)
- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)
- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)
- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)
- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)
- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)
- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)
- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)
- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)
- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)
- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)
- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)
- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)
- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)
- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)
- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)
- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)
- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)
- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)
- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)
- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)
- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)

### Flux
- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)
- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)
- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 当你调用 setState 的时候，发生了什么事？</summary></b>

参考答案：将传递给 setState 的对象合并到组件的当前状态，这将启动一个和解的过程，构建一个新的 react 元素树，与上一个元素树进行对比（ diff ），从而进行最小化的重渲染。

[参与互动](https://github.com/yisainan/web-interview/issues/496)

</details>

<b><details><summary>2. React 项目用过什么脚手架（本题是开放性题目）</summary></b>

参考答案：create-react-app 是最常用 的脚手架，一定要说出来！

* Create React App：如果你是在学习 React 或创建一个新的单页应用

Create React App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用。

* Next. js：如果你是在用 Node. js 构建服务端渲染的网站

Next. js 为您提供生产环境所需的所有功能以及最佳的开发体验：包括静态及服务器端融合渲染、 支持 TypeScript、智能化打包、 路由预取等功能 无需任何配置。

* Gatsby：如果你是在构建面向内容的静态网站

Gatsby. js 是基于 React 构建的、速度非常快的、现代化网站生成器。超越静态网站: 用 Gatsby 可以构建博客、电子商务网站、成熟的应用程序等。

* nwb：用于React应用程序、库和其他web npm模块的工具包

* razzle：创建没有配置的服务器呈现的通用JavaScript应用程序

Razzle是类似于next. js的简单服务端框架, 用于在服务端渲染 React 应用程序。

* Neutrino：创建和构建零初始配置的现代JavaScript应用程序

* Yeoman：

Yeoman提供generator系统，一个generator是一个插件，在我们在一个完整的项目上使用‘yo’命令时，会运行该generator。通过这些官方的Generators，推出了Yeoman工作流，工作流是一个健壮、有自己特色的客户端堆栈，包含能快速构建漂亮的网络应用的工具和框架。Yeoman提供了负责开始项目开发的一切，没有任何让人头痛的手动配置。

采用模块化结构，Yeoman利用从几个开源社区网站学习到的成功和教训，以确保栈开发人员越来越智能的进行开发。基于良好的文档基础以及深思熟虑的项目构建过程，Yeoman提供测试和其他更多技术 ，因此开发人员可以更专注于解决方案而不用去担心其他小事。

Yeoman主要提供了三个工具：脚手架（yo），构建工具（grunt），包管理器（bower）。这三个工具是分别独立开发的，但是需要配合使用，来实现我们更高效的工作流模式。

* umi. js：

umi，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。你可以将它简单的理解为一个专注性能的类 next. js 前端框架，并通过约定、自动生成和解析代码等方式来辅助开发，减少我们开发者的代码量。

* react-cli脚手架

* Rekit脚手架

[参与互动](https://github.com/yisainan/web-interview/issues/497)

</details>

<b><details><summary>3. 功能组件( Functional Component )与类组件( Class Component )如何选择？</summary></b>

参考答案：如果您的组件具有状态( state ) 或 生命周期方法，请使用 Class 组件。否则，使用功能组件

解析：

React中有两种组件：函数组件（Functional Components) 和类组件（Class Components）。据我观察，大部分同学都习惯于用类组件，而很少会主动写函数组件，包括我自己也是这样。但实际上，在使用场景和功能实现上，这两类组件是有很大区别的。

来看一个函数组件的例子：

``` 
function Welcome = (props) => {
  const sayHi = () => {
    alert( `Hi ${props.name}` );
  }
  return (
    <div>
      <h1>Hello, {props.name}</h1>
      <button onClick ={sayHi}>Say Hi</button>
    </div>
  )
}
```

把上面的函数组件改写成类组件：

``` 
import React from 'react'

class Welcome extends React.Component {
  constructor(props) {
    super(props);
    this.sayHi = this.sayHi.bind(this);
  }
  sayHi() {
    alert( `Hi ${this.props.name}` );
  }
  render() {
    return (
      <div>
        <h1>Hello, {this.props.name}</h1>
        <button onClick ={this.sayHi}>Say Hi</button>
      </div>
    )
  }
}
```

下面让我们来分析一下两种实现的区别：

1. 第一眼直观的区别是，函数组件的代码量比类组件要少一些，所以函数组件比类组件更加简洁。千万不要小看这一点，对于我们追求极致的程序员来说，这依然是不可忽视的。

2. 函数组件看似只是一个返回值是DOM结构的函数，其实它的背后是无状态组件（Stateless Components）的思想。函数组件中，你无法使用State，也无法使用组件的生命周期方法，这就决定了函数组件都是展示性组件（Presentational Components），接收Props，渲染DOM，而不关注其他逻辑。

3. 函数组件中没有this。所以你再也不需要考虑this带来的烦恼。而在类组件中，你依然要记得绑定this这个琐碎的事情。如示例中的sayHi。

4. 函数组件更容易理解。当你看到一个函数组件时，你就知道它的功能只是接收属性，渲染页面，它不执行与UI无关的逻辑处理，它只是一个纯函数。而不用在意它返回的DOM结构有多复杂。

5. 性能。目前React还是会把函数组件在内部转换成类组件，所以使用函数组件和使用类组件在性能上并无大的差异。但是，React官方已承诺，未来将会优化函数组件的性能，因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间。

6. 函数组件迫使你思考最佳实践。这是最重要的一点。组件的主要职责是UI渲染，理想情况下，所有的组件都是展示性组件，每个页面都是由这些展示性组件组合而成。如果一个组件是函数组件，那么它当然满足这个要求。所以牢记函数组件的概念，可以让你在写组件时，先思考这个组件应不应该是展示性组件。更多的展示性组件意味着更多的组件有更简洁的结构，更多的组件能被更好的复用。

所以，当你下次在动手写组件时，一定不要忽略了函数组件，应该尽可能多地使用函数组件。

[参与互动](https://github.com/yisainan/web-interview/issues/498)

</details>

<b><details><summary>4. React 中 keys 的作用是什么？</summary></b>

参考答案：Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

``` 
render () {
  return (
    <ul>
      {this.state.todoItems.map(({item, key}) => {
        return <li key={key}>{item}</li>
      })}
    </ul>
  )
}
```

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。

[参与互动](https://github.com/yisainan/web-interview/issues/499)

</details>

<b><details><summary>5. React 优势</summary></b>

参考答案：

1、React 速度很快：它并不直接对 DOM 进行操作，引入了一个叫做虚拟 DOM 的概念，安插在 javascript 逻辑和实际的 DOM 之间，性能好。

2、跨浏览器兼容：虚拟 DOM 帮助我们解决了跨浏览器问题，它为我们提供了标准化的 API，甚至在 IE8 中都是没问题的。

3、一切都是 component：代码更加模块化，重用代码更容易，可维护性高。

4、单向数据流：Flux 是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着 React 视图库的开发而被 Facebook 概念化。

5、同构、纯粹的 javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是 JavaScript 的执行，预渲染你的应用有助于搜索引擎优化。

6、兼容性好：比如使用 RequireJS 来加载和打包，而 Browserify 和 Webpack 适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

[参与互动](https://github.com/yisainan/web-interview/issues/500)

</details>

<b><details><summary>6. React 很多个 setState 为什么是执行完再 render</summary></b>

参考答案：react为了提高整体的渲染性能，会将一次渲染周期中的state进行合并，在这个渲染周期中对所有setState的所有调用都会被合并起来之后，再一次性的渲染，这样可以避免频繁的调用setState导致频繁的操作dom，提高渲染性能。

具体的实现方面，可以简单的理解为react中存在一个状态变量isBatchingUpdates，当处于渲染周期开始时，这个变量会被设置成true，渲染周期结束时，会被设置成false，react会根据这个状态变量，当出在渲染周期中时，仅仅只是将当前的改变缓存起来，等到渲染周期结束时，再一次性的全部render。

[参与互动](https://github.com/yisainan/web-interview/issues/501)

</details>

<b><details><summary>7. react diff 原理（常考，大厂必考）</summary></b>

参考答案：

1. 把树形结构按照层级分解，只比较同级元素。
2. 给列表结构的每个单元添加唯一的 key 属性，方便比较。
3. React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）
4. 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 
5. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

[参与互动](https://github.com/yisainan/web-interview/issues/502)

</details>

<b><details><summary>8. react 生命周期函数</summary></b>

参考答案：

#### react15生命周期

1. 初始化阶段：

getDefaultProps: 获取实例的默认属性
getInitialState: 获取实例的初始化状态
componentWillMount：组件即将被装载、渲染到页面上
render: 组件在这里生成虚拟的 DOM 节点
componentDidMount: 组件真正在被装载之后

2. 运行中阶段：

componentWillReceiveProps: 组件将要接收到属性的时候调用
shouldComponentUpdate: 组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）
componentWillUpdate: 组件即将更新不能修改属性和状态
render: 组件重新描绘
componentDidUpdate: 组件已经更新

3. 销毁阶段：

componentWillUnmount: 组件即将销毁

#### react16生命周期

React 在v16. 3版本中将 componentWillMount, componentWillReceiveProps 以及componentWillUpdate 加上了UNSAFE_前缀，这些钩子将在React 17. 0废除

新引入的两个生命周期函数 

* getDerivedStateFromProps: 是一个静态方法, 是一个和组件自身"不相关"的角色. 在这个静态方法中, 除了两个默认的位置参数 nextProps 和 currentState 以外, 你无法访问任何组件上的数据. 
* getSnapshotBeforeUpdate: 获取render之前的dom状态

[参与互动](https://github.com/yisainan/web-interview/issues/503)

</details>

<b><details><summary>9. shouldComponentUpdate 是做什么的？（react 性能优化是哪个周期函数？）</summary></b>

参考答案：

1. shouldComponentUpdate询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。
2. 这个方法用来判断是否需要调用 render 方法重新描绘 dom。
3. 因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。

[参与互动](https://github.com/yisainan/web-interview/issues/504)

</details>

<b><details><summary>10. 为什么虚拟 dom 会提高性能?(必考)</summary></b>

参考答案：

虚拟dom(virtual dom) 其实就是一个JavaScript对象，通过这个JavaScript对象来描述真实dom。

真实dom：以前没有虚拟dom，如果需要比较两个页面的差异，我们需要通过对真实dom进行比对。真实dom节点是非常复杂的，它里面会绑定的事件，它会有属性，背后会有各种方法，会频繁触发重排与重绘，所以两个真实dom比对，非常耗性能。

总损耗 = 真实DOM完全增删改 + （可能较多的节点）重排与重绘

虚拟dom：相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提髙性能。

总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）重排与重绘 

具体实现步骤如下： 

1. 用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中;
2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异;
3. 把步骤2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。

[参与互动](https://github.com/yisainan/web-interview/issues/505)

</details>

<b><details><summary>11. React 中 refs 的作用是什么？</summary></b>

参考答案：

refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：

``` jsx
class CustomForm extends Component {
  handleSubmit = () => {
    console.log("Input Value: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} />
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
```

上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：

``` 
function CustomForm ({handleSubmit}) {
  let inputElement
  return (
    <form onSubmit={() => handleSubmit(inputElement.value)}>
      <input
        type='text'
        ref={(input) => inputElement = input} />
      <button type='submit'>Submit</button>
    </form>
  )
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/506)

</details>

<b><details><summary>12. setState 和 replaceState 的区别</summary></b>

参考答案：

1. setState 是修改其中的部分状态，相当于 Object. assign，只是覆盖，不会减少原来的状态；
2. replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。

[参与互动](https://github.com/yisainan/web-interview/issues/507)

</details>

<b><details><summary>13. redux 有什么缺点</summary></b>

参考答案：

* 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。
* 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。

[参与互动](https://github.com/yisainan/web-interview/issues/508)

</details>

<b><details><summary>14. 简述 flux 思想</summary></b>

参考答案：Flux 的最大特点，就是数据的"单向流动"。

1. 用户访问 View
2. View 发出用户的 Action
3. Dispatcher 收到 Action，要求 Store 进行相应的更新
4. Store 更新后，发出一个"change"事件
5. View 收到"change"事件后，更新页面

[参考](http://www.ruanyifeng.com/blog/2016/01/flux.html)

[参与互动](https://github.com/yisainan/web-interview/issues/509)

</details>

<b><details><summary>15. 了解 redux 么，说一下 redux 吧</summary></b>

参考答案：

1、为什么要用redux

在React中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过props）, 所以，两个非父子组件之间通信就相对麻烦，redux的出现就是为了解决state里面的数据问题

2、Redux设计理念

Redux是将整个应用状态存储到一个地方上称为store, 里面保存着一个状态树store tree, 组件可以派发(dispatch)行为(action)给store, 而不是直接通知其他组件，组件内部通过订阅store中的状态state来刷新自己的视图。

![redux工作流](../../images/react_001.png)

3、Redux三大原则

1. 唯一数据源

整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中

2. 保持只读状态

state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象

3. 数据改变只能通过纯函数来执行

使用纯函数来执行修改，为了描述action如何改变state的，你需要编写reducers

4、Redux概念解析

1. Store
* store就是保存数据的地方，你可以把它看成一个数据，整个应用只能有一个store
* Redux提供createStore这个函数，用来生成Store

``` js
import {
    createStore
} from 'redux'
const store = createStore(fn);
```

2. State

state就是store里面存储的数据，store里面可以拥有多个state，Redux规定一个state对应一个View, 只要state相同，view就是一样的，反过来也是一样的，可以通过store. getState( )获取

``` js
import {
    createStore
} from 'redux'
const store = createStore(fn);
const state = store.getState()
```

3. Action

state的改变会导致View的变化，但是在redux中不能直接操作state也就是说不能使用this. setState来操作，用户只能接触到View。在Redux中提供了一个对象来告诉Store需要改变state。Action是一个对象其中type属性是必须的，表示Action的名称，其他的可以根据需求自由设置。

``` js
const action = {
    type: 'ADD_TODO',
    payload: 'redux原理'
}
```

在上面代码中，Action的名称是ADD_TODO，携带的数据是字符串‘redux原理’，Action描述当前发生的事情，这是改变state的唯一的方式

4. store. dispatch( )

store. dispatch( )是view发出Action的唯一办法

``` js
store.dispatch({
    type: 'ADD_TODO',
    payload: 'redux原理'
})
```

store. dispatch接收一个Action作为参数，将它发送给store通知store来改变state。

5. Reducer

Store收到Action以后，必须给出一个新的state，这样view才会发生变化。这种state的计算过程就叫做Reducer。
Reducer是一个纯函数，他接收Action和当前state作为参数，返回一个新的state

> 注意：Reducer必须是一个纯函数，也就是说函数返回的结果必须由参数state和action决定，而且不产生任何副作用也不能修改state和action对象

``` js
const reducer = (state, action) => {
    switch (action.type) {
        case ADD_TODO:
            return newstate;
        default
        return state
    }
}
```

5、Redux源码

``` js
let createStore = (reducer) => {
    let state;
    //获取状态对象
    //存放所有的监听函数
    let listeners = [];
    let getState = () => state;
    //提供一个方法供外部调用派发action
    let dispath = (action) => {
        //调用管理员reducer得到新的state
        state = reducer(state, action);
        //执行所有的监听函数
        listeners.forEach((l) => l())
    }
    //订阅状态变化事件，当状态改变发生之后执行监听函数
    let subscribe = (listener) => {
        listeners.push(listener);
    }
    dispath();
    return {
        getState,
        dispath,
        subscribe
    }
}
let combineReducers = (renducers) => {
    //传入一个renducers管理组，返回的是一个renducer
    return function(state = {}, action = {}) {
        let newState = {};
        for (var attr in renducers) {
            newState[attr] = renducers[attr](state[attr], action)

        }
        return newState;
    }
}
export {
    createStore,
    combineReducers
};
```

6、Redux使用案例

html代码

``` html
<div id="counter"></div>
<button id="addBtn">+</button>
<button id="minusBtn">-</button>
```

js代码

``` js
function createStore(reducer) {
    var state;
    var listeners = [];
    var getState = () => state;
    var dispatch = (action) => {
        state = reducer(state, action);
        listeners.forEach(l => l());
    }
    var subscribe = (listener) => {
        listeners.push(listener);
        return () => {
            listeners = listeners.filter((l) => l != listener)
        }
    }
    dispatch();
    return {
        getState,
        dispatch,
        subscribe
    }
}
var reducer = (state = 0, action) => {
    if (!action) return state;
    console.log(action);
    switch (action.type) {
        case 'INCREMENT':
            return state + 1;
        case 'DECREMENT':
            return state - 1;
        default:
            return state;
    }
}
var store = createStore(reducer);
store.subscribe(function() {
    document.querySelector('#counter').innerHTML = store.getState();
});

document.querySelector('#addBtn').addEventListener('click', function() {
    store.dispatch({
        type: 'INCREMENT'
    });
});
document.querySelector('#minusBtn').addEventListener('click', function() {
    store.dispatch({
        type: 'DECREMENT'
    });
});
```

[参考](https://www.jianshu.com/p/e984206553c2)
[参与互动](https://github.com/yisainan/web-interview/issues/510)

</details>

<b><details><summary>16. React 中有三种构建组件的方式</summary></b>

参考答案：React. createClass()、ES6 class 和无状态函数。

[参与互动](https://github.com/yisainan/web-interview/issues/511)

</details>

<b><details><summary>17. react 组件的划分业务组件技术组件？</summary></b>

参考答案：

* 根据组件的职责通常把组件分为 UI 组件和容器组件。
* UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。
* 两者通过 React-Redux 提供 connect 方法联系起来。

[参与互动](https://github.com/yisainan/web-interview/issues/512)

</details>

<b><details><summary>18. 描述事件在 React 中的处理方式</summary></b>

参考答案：

为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。

这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。

[参与互动](https://github.com/yisainan/web-interview/issues/513)

</details>

<b><details><summary>19. 应该在 React 组件的何处发起 Ajax 请求</summary></b>

参考答案：

在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。

[参与互动](https://github.com/yisainan/web-interview/issues/514)

</details>

<b><details><summary>20. (在构造函数中)调用 super(props) 的目的是什么</summary></b>

参考答案：

在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this. props。

[参与互动](https://github.com/yisainan/web-interview/issues/515)

</details>

<b><details><summary>21. 除了在构造函数中绑定 this，还有其它方式吗</summary></b>

参考答案：

你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。

[参与互动](https://github.com/yisainan/web-interview/issues/516)

</details>

<b><details><summary>22. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</summary></b>

参考答案：

因为 this. props 和 this. state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。

[参与互动](https://github.com/yisainan/web-interview/issues/517)

</details>

<b><details><summary>23. 何为高阶组件(higher order component)</summary></b>

参考答案：

高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。

[参与互动](https://github.com/yisainan/web-interview/issues/518)

</details>

<b><details><summary>24. 何为受控组件(controlled component)</summary></b>

参考答案：

在 HTML 中，类似 `<input>` , `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为"受控元素"。

[参与互动](https://github.com/yisainan/web-interview/issues/519)

</details>

<b><details><summary>25. 在 React 当中 Element 和 Component 有何区别？</summary></b>

参考答案：

React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。

React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element

[参与互动](https://github.com/yisainan/web-interview/issues/520)

</details>

<b><details><summary>26. (组件的)状态(state)和属性(props)之间有何区别</summary></b>

参考答案：

* State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。
* Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。

[参与互动](https://github.com/yisainan/web-interview/issues/521)

</details>

<b><details><summary>27. 展示组件(Presentational component)和容器组件(Container component)之间有何区别？</summary></b>

参考答案：

* 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。
* 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。

[参与互动](https://github.com/yisainan/web-interview/issues/522)

</details>

<b><details><summary>28. 类组件(Class component)和 函数式组件(Functional component)之间有何区别？</summary></b>

参考答案：

1. 函数式组件比类组件操作简单，只是简单的调取和返回 JSX；而类组件可以使用生命周期函数来操作业务

2. 函数式组件可以理解为静态组件（组件中的内容调取的时候已经固定了，很难再修改），而类组件，可以基于组件内部的状态来动态更新渲染的内容

* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态
* 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件

[参与互动](https://github.com/yisainan/web-interview/issues/523)

</details>

<b><details><summary>29. createElement 和 cloneElement 有什么区别？</summary></b>

参考答案：传入的第一个参数不同

React. createElement(): JSX 语法就是用 React. createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。

``` 
React.createElement(type, [props], [...children]);
```

React. cloneElement()与 React. createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。将保留原始元素的键和引用。

``` 
React.cloneElement(element, [props], [...children]);
```

[参与互动](https://github.com/yisainan/web-interview/issues/524)

</details>

<b><details><summary>30. React实现一个防抖的模糊查询输入框</summary></b>

参考答案：[參考](https://blog.csdn.net/cc18868876837/article/details/96303296)

</details>

<b><details><summary>31. React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？</summary></b>

参考答案：

</details>

<b><details><summary>32. React 中 setState 什么时候是同步的，什么时候是异步的？</summary></b>

参考答案：

</details>

<b><details><summary>33. react-router里的 `<Link>` 标签和 `<a>` 标签有什么区别（滴滴）</summary></b>

参考答案：

</details>

<b><details><summary>34. react-router怎么实现路由切换（滴滴）</summary></b>

参考答案：

</details>

<b><details><summary>35. React组件事件代理的原理（网易）</summary></b>

参考答案：

</details>

<b><details><summary>36. RN的原理，为什么可以同时在安卓和IOS端运行（寺库）</summary></b>

参考答案：

</details>

<b><details><summary>37. 比较一下React与Vue</summary></b>

参考答案：

``` 
相同点
1)	都有组件化开发和Virtual DOM
2)	都支持props进行父子组件间数据通信
3)	都支持数据驱动视图, 不直接操作真实DOM, 更新状态数据界面就自动更新
4)	都支持服务器端渲染
5)	都有支持native的方案,React的React Native,Vue的Weex

不同点
1)	数据绑定: vue实现了数据的双向绑定,react数据流动是单向的
2)	组件写法不一样, React推荐的做法是 JSX , 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,js写在同一个文件
3)	state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理
4)	virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制
5)	React严格上只针对MVC的view层,Vue则是MVVM模式
```

</details>

<b><details><summary>38. 受控组件与非受控组件</summary></b>

参考答案：

* 受控: 表单元素状态由使用者维护
* 非受控: 表单元素状态DOM 自身维护

1. 受控组件

在HTML中，标签`<input>、<textarea>、<select>`的值的改变通常是根据用户输入进行更新。在React中，可变状态通常保存在组件的状态属性中，并且只能使用 setState() 更新，而呈现表单的React组件也控制着在后续用户输入时该表单中发生的情况，以这种由React控制的输入表单元素而改变其值的方式，称为：“受控组件”。

2. 不受控组件

表单数据由DOM本身处理。即不受setState()的控制，与传统的HTML表单输入相似，input输入值即显示最新值（使用 ref 从DOM获取表单值）

</details>

<b><details><summary>39. reactjs主要方法</summary></b>

参考答案：

``` 
render()
getInitialState() //组件挂载之前调用一次
getDefaultProps() //在组件类创建的时候调用一次
propTypes() //对象允许验证传入到组件的props
生命周期方法
componentWillMount() //服务器端和客户端都只调用一次，在初始化渲染执行之前立刻调用
componentDidMount() //在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）
componentWillReceiveProps(object nextProps) //在组件接收到新的 props 的时候调用
shouldComponentUpdate(object nextProps,object nextState) //在接收到新的props或者state，将要渲染之前调用。返回true或者false
componentWillUpdate(object nextProps,object nextState) //在接收到新的props或者state之前立刻调用。
componentDidUpdate(object prevProps,object prevState) //在组件的更新已经同步到DOM中之后立刻被调用
componentWillUnmount() //在组件从DOM中移除的时候立刻被调用
```

</details>

<b><details><summary>40. React. cloneElement()解析</summary></b>

参考答案：

``` js
React.cloneElement(
    element,
    [props],
    [...children]
)
```

说明： 该方法以 element 作为起点，克隆并返回一个新的 React 元素。所产生的元素将具有原始元素的props ，新的 props 为浅层合并。 新的子元素将取代现有的子元素， key 和 ref 将被保留。

该方法接收三个参数，注意参数的数据类型：

* 第一个参数为必选参数：TYPE（ReactElement），用于克隆的母体React元素。
* 第二个参数为可选参数：[PROPS（object）]，为克隆后生成的React元素添加新的props或覆盖从母体中克隆而来的部分或全部props。
* 第三个参数为可选参数：[CHILDREN（ReactElement）]，为新生成的React元素添加新的children，取代从母体中克隆而来的children。

</details>

<b><details><summary>41. JSX 的本质是什么，它和 JS 之间到底是什么关系？</summary></b>

参考答案：JSX 的本质其实是React.createElement这个 JavaScript 调用的语法糖。

这个描述的意思是使用JSX语法可以扩展JavaScript 的功能：在JavaScript 中可以像写HTML一样来构建UI（原生JS是不具备这种能力的），但编译后最终其实还是纯JS代码。JSX 的定位是 JavaScript 的“扩展”，而非 JavaScript 的“某个版本”，所以浏览器并不会像天然支持 JavaScript 一样地支持 JSX。要使JSX在JavaScript中生效，我们需要借助Babel（Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。类似的，Babel 也具备将 JSX 语法转换为 JavaScript 代码的能力。）进行编译：JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。


如下一个Babel编译的例子：

可以看到，所有的 JSX 标签都被转化成了 React.createElement 调用，这也就意味着，我们写的 JSX 其实写的就是 React.createElement。

![Babel编译的例子](../../images/react_003.png)

这里我们可以得出结论：JSX 的本质其实是React.createElement这个 JavaScript 调用的语法糖。

解析：[参考地址](https://chen-cong.blog.csdn.net/article/details/111920385)

</details>

<b><details><summary>42. 为什么要用 JSX？不用会有什么后果？</summary></b>

参考答案：JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML 标签语法来创建虚拟 DOM，在降低学习成本的同时，也提升了研发效率与研发体验。

</details>

<b><details><summary>43. JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？</summary></b>

参考答案：JSX 背后的功能模块是React.createElement，该函数并没有做很多复杂的事情，基本上是在进行格式化数据的操作，执行到最后会 return 一个针对 ReactElement 的调用。

解析：[参考地址](https://chen-cong.blog.csdn.net/article/details/111920385)

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>
---
name: 内容错误或改进意见
about: 这是一个方便用户提出内容错误或改进意见的模板
title: "[bug] "
labels: Bug
assignees: ''

---

**内容错误**



**改进意见**
> [转载自 semlinker/reactjs-interview-questions](https://github.com/semlinker/reactjs-interview-questions)

# React 面试题 & 回答

> 本项目的面试题来源于 [sudheerj/reactjs-interview-questions](https://github.com/sudheerj/reactjs-interview-questions) 这个项目。一时兴起就动起了翻译的念头，由于本人的 React 功力尚浅，翻译的内容难免有误或不妥的地方，望请各位见谅。如果你喜欢这个项目，请 Star，更感谢你的 Pull Request。

### 目录

<!-- TOC -->
| 序号. | 问题 |
| --- | --------- |
| | [Core React](#core-react) |
|1 | [什么是 React?](#什么是-react) |
|2 | [React 的主要特点是什么?](#react-的主要特点是什么) |
|3 | [什么是 JSX?](#什么是-jsx) |
|4 | [元素和组件有什么区别?](#元素和组件有什么区别) |
|5 | [如何在 React 中创建组件?](#如何在-react-中创建组件) |
|6 | [何时使用类组件和函数组件?](#何时使用类组件和函数组件) |
|7 | [什么是 Pure Components?](#什么是-pure-components) |
|8 | [React 的状态是什么?](#react-的状态是什么) |
|9 | [React 中的 props 是什么?](#react-中的-props-是什么) |
|10 | [状态和属性有什么区别?](#状态和属性有什么区别) |
|11 | [我们为什么不能直接更新状态?](#我们为什么不能直接更新状态) |
|12 | [回调函数作为 `setState()` 参数的目的是什么?](#回调函数作为-setstate-参数的目的是什么) |
|13 | [HTML 和 React 事件处理有什么区别?](#html-和-react-事件处理有什么区别) |
|14 | [如何在 JSX 回调中绑定方法或事件处理程序?](#如何在-jsx-回调中绑定方法或事件处理程序) |
|15 | [如何将参数传递给事件处理程序或回调函数?](#如何将参数传递给事件处理程序或回调函数) |
|16 | [React 中的合成事件是什么?](#react-中的合成事件是什么) |
|17 | [什么是内联条件表达式?](#什么是内联条件表达式) |
|18 | [什么是 "key" 属性，在元素数组中使用它们有什么好处?](#什么是-key-属性在元素数组中使用它们有什么好处) |
|19 | [refs 有什么用?](#refs-有什么用) |
|20 | [如何创建 refs?](#如何创建-refs) |
|21 | [什么是 forward refs?](#什么是-forward-refs) |
|22 | [callback refs 和 findDOMNode() 哪一个是首选选项?](#callback-refs-和-finddomnode-哪一个是首选选项) |
|23 | [为什么 String Refs 被弃用?](#为什么-string-refs-被弃用) |
|24 | [什么是 Virtual DOM?](#什么是-virtual-dom) |
|25 | [Virtual DOM 如何工作?](#virtual-dom-如何工作) |
|26 | [Shadow DOM 和 Virtual DOM 之间有什么区别?](#shadow-dom-和-virtual-dom-之间有什么区别) |
|27 | [什么是 React Fiber?](#什么是-react-fiber) |
|28 | [React Fiber 的主要目标是什么?](#react-fiber-的主要目标是什么) |
|29 | [什么是受控组件?](#什么是受控组件) |
|30 | [什么是非受控组件?](#什么是非受控组件) |
|31 | [createElement 和 cloneElement 有什么区别?](#createelement-和-cloneelement-有什么区别) |
|32 | [在 React 中的提升状态是什么?](#在-react-中的提升状态是什么) |
|33 | [组件生命周期的不同阶段是什么?](#组件生命周期的不同阶段是什么) |
|34 | [React 生命周期方法有哪些?](#react-生命周期方法有哪些) |
|35 | [什么是高阶组件（HOC）?](#什么是高阶组件hoc) |
|36 | [如何为高阶组件创建属性代理?](#如何为高阶组件创建属性代理) |
|37 | [什么是上下文（Context）?](#什么是上下文context) |
|38 | [children 属性是什么?](#children-属性是什么) |
|39 | [怎样在 React 中写注释?](#怎样在-react-中写注释) |
|40 | [构造函数使用带 props 参数的目的是什么?](#构造函数使用带-props-参数的目的是什么) |
|41 | [什么是调解?](#什么是调解) |
|42 | [如何使用动态属性名设置 state ?](#如何使用动态属性名设置-state-) |
|43 | [每次组件渲染时调用函数的常见错误是什么?](#每次组件渲染时调用函数的常见错误是什么) |
|44 | [为什么有组件名称要首字母大写?](#为什么有组件名称要首字母大写) |
|45 | [为什么 React 使用 `className` 而不是 `class` 属性?](#为什么-react-使用-classname-而不是-class-属性) |
|46 | [什么是 Fragments ?](#什么是-fragments-) |
|47 | [为什么使用 Fragments 比使用容器 div 更好?](#为什么使用-fragments-比使用容器-div-更好) |
|48 | [在 React 中什么是 Portal ?](#在-react-中什么是-portal-) |
|49 | [什么是无状态组件?](#什么是无状态组件) |
|50 | [什么是有状态组件?](#什么是有状态组件) |
|51 | [在 React 中如何校验 props 属性?](#在-react-中如何校验-props-属性) |
|52 | [React 的优点是什么?](#react-的优点是什么) |
|53 | [React 的局限性是什么?](#react-的局限性是什么) |
|54 | [在 React v16 中的错误边界是什么?](#在-react-v16-中的错误边界是什么) |
|55 | [在 React v15 中如何处理错误边界?](#在-react-v15-中如何处理错误边界) |
|56 | [静态类型检查推荐的方法是什么?](#静态类型检查推荐的方法是什么) |
|57 | [`react-dom` 包的用途是什么?](#react-dom-包的用途是什么) |
|58 | [`react-dom` 中 render 方法的目的是什么?](#react-dom-中-render-方法的目的是什么) |
|59 | [ReactDOMServer 是什么?](#reactdomserver-是什么) |
|60 | [在 React 中如何使用 innerHTML?](#在-react-中如何使用-innerhtml) |
|61 | [如何在 React 中使用样式?](#如何在-react-中使用样式) |
|62 | [在 React 中事件有何不同?](#在-react-中事件有何不同) |
|63 | [如果在构造函数中使用 `setState()` 会发生什么?](#如果在构造函数中使用-setstate-会发生什么) |
|64 | [索引作为键的影响是什么?](#索引作为键的影响是什么) |
|65 | [在 `componentWillMount()` 方法中使用 `setState()` 好吗?](#在-componentwillmount-方法中使用-setstate-好吗) |
|66 | [如果在初始状态中使用 props 属性会发生什么?](#如果在初始状态中使用-props-属性会发生什么) |
|67 | [如何有条件地渲染组件?](#如何有条件地渲染组件) |
|68 | [为什么在 DOM 元素上展开 props 需要小心?](#为什么在-dom-元素上展开-props-需要小心) |
|69 | [在 React 中如何使用装饰器?](#在-react-中如何使用装饰器) |
|70 | [如何 memoize（记忆）组件?](#如何-memoize记忆组件) |
|71 | [如何实现 Server Side Rendering 或 SSR?](#如何实现-server-side-rendering-或-ssr) |
|72 | [如何在 React 中启用生产模式?](#如何在-react-中启用生产模式) |
|73 | [什么是 CRA 及其好处?](#什么是-cra-及其好处) |
|74 | [在 mounting 阶段生命周期方法的执行顺序是什么?](#在-mounting-阶段生命周期方法的执行顺序是什么) |
|75 | [在 React v16 中，哪些生命周期方法将被弃用?](#在-react-v16-中哪些生命周期方法将被弃用) |
|76 | [生命周期方法 `getDerivedStateFromProps()` 的目的是什么?](#生命周期方法-getderivedstatefromprops-的目的是什么) |
|77 | [生命周期方法 `getSnapshotBeforeUpdate()` 的目的是什么?](#生命周期方法-getsnapshotbeforeupdate-的目的是什么) |
|78 | [createElement() 和 cloneElement() 方法有什么区别?](#createelement-和-cloneelement-方法有什么区别) |
|79 | [推荐的组件命名方法是什么?](#推荐的组件命名方法是什么) |
|80 | [在组件类中方法的推荐顺序是什么?](#在组件类中方法的推荐顺序是什么) |
|81 | [什么是 switching 组件?](#什么是-switching-组件) |
|82 | [为什么我们需要将函数传递给 setState() 方法?](#为什么我们需要将函数传递给-setstate-方法) |
|83 | [在 React 中什么是严格模式?](#在-react-中什么是严格模式) |
|84 | [React Mixins 是什么?](#react-mixins-是什么) |
|85 | [为什么 `isMounted()` 是一个反模式，而正确的解决方案是什么?](#为什么-ismounted-是一个反模式而正确的解决方案是什么) |
|86 | [React 中支持哪些指针事件?](#react-中支持哪些指针事件) |
|87 | [为什么组件名称应该以大写字母开头?](#为什么组件名称应该以大写字母开头) |
|88 | [在 React v16 中是否支持自定义 DOM 属性?](#在-react-v16-中是否支持自定义-dom-属性) |
|89 | [constructor 和 getInitialState 有什么区别?](#constructor-和-getinitialstate-有什么区别) |
|90 | [是否可以在不调用 setState 方法的情况下，强制组件重新渲染?](#是否可以在不调用-setstate-方法的情况下强制组件重新渲染) |
|91 | [在使用 ES6 类的 React 中 `super()` 和 `super(props)` 有什么区别?](#在使用-es6-类的-react-中-super-和-superprops-有什么区别) |
|92 | [在 JSX 中如何进行循环?](#在-jsx-中如何进行循环) |
|93 | [如何在 attribute 引号中访问 props 属性?](#如何在-attribute-引号中访问-props-属性) |
|94 | [什么是 React proptype 数组?](#什么是-react-proptype-数组) |
|95 | [如何有条件地应用样式类?](#如何有条件地应用样式类) |
|96 | [React 和 ReactDOM 之间有什么区别?](#react-和-reactdom-之间有什么区别) |
|97 | [为什么 ReactDOM 从 React 分离出来?](#为什么-reactdom-从-react-分离出来) |
|98 | [如何使用 React label 元素?](#如何使用-react-label-元素) |
|99 | [如何合并多个内联的样式对象?](#如何合并多个内联的样式对象) |
|100 | [如何在调整浏览器大小时重新渲染视图?](#如何在调整浏览器大小时重新渲染视图) |
|101 | [`setState()` 和 `replaceState()` 方法之间有什么区别?](#setstate-和-replacestate-方法之间有什么区别) |
|102 | [如何监听状态变化?](#如何监听状态变化) |
|103 | [在 React 状态中删除数组元素的推荐方法是什么?](#在-react-状态中删除数组元素的推荐方法是什么) |
|104 | [在 React 中是否可以不在页面上渲染 HTML 内容?](#在-react-中是否可以不在页面上渲染-html-内容) |
|105 | [如何用 React 漂亮地显示 JSON?](#如何用-react-漂亮地显示-json) |
|106 | [为什么你不能更新 React 中的 props?](#为什么你不能更新-react-中的-props) |
|107 | [如何在页面加载时聚焦一个输入元素?](#如何在页面加载时聚焦一个输入元素) |
|108 | [更新状态中的对象有哪些可能的方法?](#更新状态中的对象有哪些可能的方法) |
|109 | [为什么函数比对象更适合于 `setState()`?](#为什么函数比对象更适合于-setstate) |
|110 | [我们如何在浏览器中找到当前正在运行的 React 版本?](#我们如何在浏览器中找到当前正在运行的-react-版本) |
|111 | [在 `create-react-app` 项目中导入 polyfills 的方法有哪些?](#在-create-react-app-项目中导入-polyfills-的方法有哪些) |
|112 | [如何在 create-react-app 中使用 https 而不是 http?](#如何在-create-react-app-中使用-https-而不是-http) |
|113 | [如何避免在 create-react-app 中使用相对路径导入?](#如何避免在-create-react-app-中使用相对路径导入) |
|114 | [如何为 React Router 添加 Google Analytics?](#如何为-react-router-添加-google-analytics) |
|115 | [如何每秒更新一个组件?](#如何每秒更新一个组件) |
|116 | [如何将 vendor prefixes 应用于 React 中的内联样式?](#如何将-vendor-prefixes-应用于-react-中的内联样式) |
|117 | [如何使用 React 和 ES6 导入和导出组件?](#如何使用-react-和-es6-导入和导出组件) |
|118 | [为什么 React 组件名称必须以大写字母开头?](#为什么-react-组件名称必须以大写字母开头) |
|119 | [为什么组件的构造函数只被调用一次?](#为什么组件的构造函数只被调用一次) |
|120 | [在 React 中如何定义常量?](#在-react-中如何定义常量) |
|121 | [在 React 中如何以编程方式触发点击事件?](#在-react-中如何以编程方式触发点击事件) |
|122 | [在 React 中是否可以使用 async/await?](#在-react-中是否可以使用-async/await) |
|123 | [React 项目常见的文件结构是什么?](#react-项目常见的文件结构是什么) |
|124 | [最流行的动画软件包是什么?](#最流行的动画软件包是什么) |
|125 | [模块化样式文件有什么好处?](#模块化样式文件有什么好处) |
|126 | [什么是 React 流行的特定 linters?](#什么是-react-流行的特定-linters) |
|127 | [如何发起 AJAX 调用以及应该在哪些组件生命周期方法中进行 AJAX 调用?](#如何发起-ajax-调用以及应该在哪些组件生命周期方法中进行-ajax-调用) |
|128 | [什么是渲染属性?](#什么是渲染属性) |
| | [React Router](#react-router) |
|129 | [什么是 React Router?](#什么是-react-router) |
|130 | [React Router 与 history 库的区别?](#react-router-与-history-库的区别) |
|131 | [在 React Router v4 中的`<Router>`组件是什么?](#在-react-router-v4-中的router组件是什么) |
|132 | [`history` 中的 `push()` 和 `replace()` 方法的目的是什么?](#history-中的-push-和-replace-方法的目的是什么) |
|133 | [如何使用在 React Router v4 中以编程的方式进行导航?](#如何使用在-react-router-v4-中以编程的方式进行导航) |
|134 | [如何在 React Router v4 中获取查询字符串参数?](#如何在-react-router-v4-中获取查询字符串参数) |
|135 | [为什么你会得到 "Router may have only one child element" 警告?](#为什么你会得到-"router-may-have-only-one-child-element"-警告) |
|136 | [如何在 React Router v4 中将 params 传递给 `history.push` 方法?](#如何在-react-router-v4-中将-params-传递给-history.push-方法) |
|137 | [如何实现默认页面或 404 页面?](#如何实现默认页面或-404-页面) |
|138 | [如何在 React Router v4 上获取历史对象?](#如何在-react-router-v4-上获取历史对象) |
|139 | [登录后如何执行自动重定向?](#登录后如何执行自动重定向) |
| | [React Internationalization](#react-internationalization) |
|140 | [什么是 React Intl?](#什么是-react-intl) |
|141 | [React Intl 的主要特性是什么?](#react-intl-的主要特性是什么) |
|142 | [在 React Intl 中有哪两种格式化方式?](#在-react-intl-中有哪两种格式化方式) |
|143 | [在 React Intl 中如何使用`<FormattedMessage>`作为占位符使用?](#在-react-intl-中如何使用formattedmessage作为占位符使用) |
|144 | [如何使用 React Intl 访问当前语言环境?](#如何使用-react-intl-访问当前语言环境) |
|145 | [如何使用 React Intl 格式化日期?](#如何使用-react-intl-格式化日期) |
| | [React Testing](#react-testing) |
|146 | [在 React 测试中什么是浅层渲染（Shallow Renderer）?](#在-react-测试中什么是浅层渲染shallow-renderer) |
|147 | [在 React 中 `TestRenderer` 包是什么?](#在-react-中-testrenderer-包是什么) |
|148 | [ReactTestUtils 包的目的是什么?](#reacttestutils-包的目的是什么) |
|149 | [什么是 Jest?](#什么是-jest) |
|150 | [Jest 对比 Jasmine 有什么优势?](#jest-对比-jasmine-有什么优势) |
|151 | [举一个简单的 Jest 测试用例](#举一个简单的-jest-测试用例) |
| | [React Redux](#react-redux) |
|152 | [什么是 Flux?](#什么是-flux) |
|153 | [什么是 Redux?](#什么是-redux) |
|154 | [Redux 的核心原则是什么？?](#redux-的核心原则是什么) |
|155 | [与 Flux 相比，Redux 的缺点是什么?](#与-flux-相比redux-的缺点是什么) |
|156 | [`mapStateToProps()` 和 `mapDispatchToProps()` 之间有什么区别?](#mapstatetoprops-和-mapdispatchtoprops-之间有什么区别) |
|157 | [我可以在 reducer 中触发一个 Action 吗?](#我可以在-reducer-中触发一个-action-吗) |
|158 | [如何在组件外部访问 Redux 存储的对象?](#如何在组件外部访问-redux-存储的对象) |
|159 | [MVW 模式的缺点是什么?](#mvw-模式的缺点是什么) |
|160 | [Redux 和 RxJS 之间是否有任何相似之处?](#redux-和-rxjs-之间是否有任何相似之处) |
|161 | [如何在加载时触发 Action?](#如何在加载时触发-action) |
|162 | [在 React 中如何使用 Redux 的 `connect()` ?](#在-react-中如何使用-redux-的-connect-) |
|163 | [如何在 Redux 中重置状态?](#如何在-redux-中重置状态) |
|164 | [Redux 中连接装饰器的 `at` 符号的目的是什么?](#redux-中连接装饰器的-at-符号的目的是什么) |
|165 | [React 上下文和 React Redux 之间有什么区别?](#react-上下文和-react-redux-之间有什么区别) |
|166 | [为什么 Redux 状态函数称为 reducers ?](#为什么-redux-状态函数称为-reducers-) |
|167 | [如何在 Redux 中发起 AJAX 请求?](#如何在-redux-中发起-ajax-请求) |
|168 | [我应该在 Redux Store 中保留所有组件的状态吗?](#我应该在-redux-store-中保留所有组件的状态吗) |
|169 | [访问 Redux Store 的正确方法是什么?](#访问-redux-store-的正确方法是什么) |
|170 | [React Redux 中展示组件和容器组件之间的区别是什么?](#react-redux-中展示组件和容器组件之间的区别是什么) |
|171 | [Redux 中常量的用途是什么?](#redux-中常量的用途是什么) |
|172 | [编写 `mapDispatchToProps()` 有哪些不同的方法?](#编写-mapdispatchtoprops-有哪些不同的方法) |
|173 | [在 `mapStateToProps()` 和 `mapDispatchToProps()` 中使用 `ownProps` 参数有什么用?](#在-mapstatetoprops-和-mapdispatchtoprops-中使用-ownprops-参数有什么用) |
|174 | [如何构建 Redux 项目目录?](#如何构建-redux-项目目录) |
|175 | [什么是 redux-saga?](#什么是-redux-saga) |
|176 | [redux-saga 的模型概念是什么?](#redux-saga-的模型概念是什么) |
|177 | [在 redux-saga 中 `call()` 和 `put()` 之间有什么区别?](#在-redux-saga-中-call-和-put-之间有什么区别) |
|178 | [什么是 Redux Thunk?](#什么是-redux-thunk) |
|179 | [`redux-saga` 和 `redux-thunk` 之间有什么区别?](#redux-saga-和-redux-thunk-之间有什么区别) |
|180 | [什么是 Redux DevTools?](#什么是-redux-devtools) |
|181 | [Redux DevTools 的功能有哪些?](#redux-devtools-的功能有哪些) |
|182 | [什么是 Redux 选择器以及使用它们的原因?](#什么是-redux-选择器以及使用它们的原因) |
|183 | [什么是 Redux Form?](#什么是-redux-form) |
|184 | [Redux Form 的主要功能有哪些?](#redux-form-的主要功能有哪些) |
|185 | [如何向 Redux 添加多个中间件?](#如何向-redux-添加多个中间件) |
|186 | [如何在 Redux 中设置初始状态?](#如何在-redux-中设置初始状态) |
|187 | [Relay 与 Redux 有何不同?](#relay-与-redux-有何不同) |
| | [React Native](#react-native) |
|188 | [React Native 和 React 有什么区别?](#react-native-和-react-有什么区别) |
|189 | [如何测试 React Native 应用程序?](#如何测试-react-native-应用程序) |
|190 | [如何在 React Native 查看日志?](#如何在-react-native-查看日志) |
|191 | [怎么调试 React Native 应用?](#怎么调试-react-native-应用) |
| | [React supported libraries & Integration](#react-supported-libraries-&-integration) |
|192 | [什么是 Reselect 以及它是如何工作的?](#什么是-reselect-以及它是如何工作的) |
|193 | [什么是 Flow?](#什么是-flow) |
|194 | [Flow 和 PropTypes 有什么区别?](#flow-和-proptypes-有什么区别) |
|195 | [在 React 中如何使用 Font Awesome 图标?](#在-react-中如何使用-font-awesome-图标) |
|196 | [什么 是 React 开发者工具?](#什么-是-react-开发者工具) |
|197 | [在 Chrome 中为什么 DevTools 没有加载本地文件?](#在-chrome-中为什么-devtools-没有加载本地文件) |
|198 | [如何在 React 中使用 Polymer?](#如何在-react-中使用-polymer) |
|199 | [与 Vue.js 相比，React 有哪些优势?](#与-vue.js-相比react-有哪些优势) |
|200 | [React 和 Angular 有什么区别?](#react-和-angular-有什么区别) |
|201 | [为什么 React 选项卡不会显示在 DevTools 中?](#为什么-react-选项卡不会显示在-devtools-中) |
|202 | [什么是 Styled Components?](#什么是-styled-components) |
|203 | [举一个 Styled Components 的例子?](#举一个-styled-components-的例子) |
|204 | [什么是 Relay?](#什么是-relay) |
|205 | [如何在 `create-react-app` 中使用 TypeScript?](#如何在-create-react-app-中使用-typescript) |
| | [Miscellaneous](#miscellaneous) |
|206 | [Reselect 库的主要功能有哪些?](#reselect-库的主要功能有哪些) |
|207 | [举一个 Reselect 用法的例子?](#举一个-reselect-用法的例子) |
|208 | [Redux 中的 Action 是什么?](#redux-中的-action-是什么) |
|209 | [在 React 中 statics 对象是否能与 ES6 类一起使用?](#在-react-中-statics-对象是否能与-es6-类一起使用) |
|210 | [Redux 只能与 React 一起使用么?](#redux-只能与-react-一起使用么) |
|211 | [您是否需要使用特定的构建工具来使用 Redux ?](#您是否需要使用特定的构建工具来使用-redux-) |
|212 | [Redux Form 的 `initialValues` 如何从状态更新?](#redux-form-的-initialvalues-如何从状态更新) |
|213 | [React 是如何为一个属性声明不同的类型?](#react-是如何为一个属性声明不同的类型) |
|214 | [我可以导入一个 SVG 文件作为 React 组件么?](#我可以导入一个-svg-文件作为-react-组件么) |
|215 | [为什么不建议使用内联引用回调或函数?](#为什么不建议使用内联引用回调或函数) |
|216 | [在 React 中什么是渲染劫持?](#在-react-中什么是渲染劫持) |
|217 | [什么是 HOC 工厂实现?](#什么是-hoc-工厂实现) |
|218 | [如何传递数字给 React 组件?](#如何传递数字给-react-组件) |
|219 | [我需要将所有状态保存到 Redux 中吗？我应该使用 react 的内部状态吗?](#我需要将所有状态保存到-redux-中吗我应该使用-react-的内部状态吗) |
|220 | [在 React 中 registerServiceWorker 的用途是什么?](#在-react-中-registerserviceworker-的用途是什么) |
|221 | [React memo 函数是什么?](#react-memo-函数是什么) |
|222 | [React lazy 函数是什么?](#react-lazy-函数是什么) |
|223 | [如何使用 setState 防止不必要的更新?](#如何使用-setstate-防止不必要的更新) |
|224 | [如何在 React 16 版本中渲染数组、字符串和数值? ](#如何在-react-16-版本中渲染数组、字符串和数值-) |
|225 | [如何在 React 类中使用类字段声明语法?](#如何在-react-类中使用类字段声明语法) |
|226 | [什么是 hooks?](#什么是-hooks) |
|227 | [Hooks 需要遵循什么规则?](#hooks-需要遵循什么规则) |
|228 | [如何确保钩子遵循正确的使用规则?](#如何确保钩子遵循正确的使用规则) |
|229 | [Flux 和 Redux 之间有什么区别?](#flux-和-redux-之间有什么区别) |
|230 | [React Router V4 有什么好处?](#react-router-v4-有什么好处) |
|231 | [您能描述一下 componentDidCatch 生命周期方法签名吗?](#您能描述一下-componentdidcatch-生命周期方法签名吗) |
|232 | [在哪些情况下，错误边界不会捕获错误?](#在哪些情况下错误边界不会捕获错误) |
|233 | [为什么事件处理器不需要错误边界?](#为什么事件处理器不需要错误边界) |
|234 | [try catch 与错误边界有什么区别?](#try-catch-与错误边界有什么区别) |
|235 | [React 16 中未捕获的错误的行为是什么?](#react-16-中未捕获的错误的行为是什么) |
|236 | [放置错误边界的正确位置是什么?](#放置错误边界的正确位置是什么) |
|237 | [从错误边界跟踪组件堆栈有什么好处?](#从错误边界跟踪组件堆栈有什么好处) |
|238 | [在定义类组件时，什么是必须的方法?](#在定义类组件时什么是必须的方法) |
|239 | [render 方法可能返回的类型是什么?](#render-方法可能返回的类型是什么) |
|240 | [构造函数的主要目的是什么?](#构造函数的主要目的是什么) |
|241 | [是否必须为 React 组件定义构造函数?](#是否必须为-react-组件定义构造函数) |
|242 | [什么是默认属性?](#什么是默认属性) |
|243 | [为什么不能在 componentWillUnmount 中调用 setState() 方法?](#为什么不能在-componentwillunmount-中调用-setstate-方法) |
|244 | [getDerivedStateFromError 的目的是什么?](#getderivedstatefromerror-的目的是什么) |
|245 | [当组件重新渲染时顺序执行的方法有哪些?](#当组件重新渲染时顺序执行的方法有哪些) |
|246 | [错误处理期间调用哪些方法?](#错误处理期间调用哪些方法) |
|247 | [displayName 类属性的用途是什么?](#displayname-类属性的用途是什么) |
|248 | [支持 React 应用程序的浏览器有哪一些?](#支持-react-应用程序的浏览器有哪一些) |
|249 | [unmountComponentAtNode 方法的目的是什么?](#unmountcomponentatnode-方法的目的是什么) |
|250 | [什么是代码拆分?](#什么是代码拆分) |
|251 | [严格模式有什么好处?](#严格模式有什么好处) |
|252 | [什么是 Keyed Fragments ?](#什么是-keyed-fragments-) |
|253 | [React 支持所有的 HTML 属性么?](#react-支持所有的-html-属性么) |
|254 | [HOC 有哪些限制?](#hoc-有哪些限制) |
|255 | [如何在 DevTools 中调试 forwardRefs?](#如何在-devtools-中调试-forwardrefs) |
|256 | [什么时候组件的 props 属性默认为 true?](#什么时候组件的-props-属性默认为-true) |
|257 | [什么是 NextJS 及其主要特征?](#什么是-nextjs-及其主要特征) |
|258 | [如何将事件处理程序传递给组件?](#如何将事件处理程序传递给组件) |
|259 | [在渲染方法中使用箭头函数好么?](#在渲染方法中使用箭头函数好么) |
|260 | [如何防止函数被多次调用?](#如何防止函数被多次调用) |
|261 | [JSX 如何防止注入攻击?](#jsx-如何防止注入攻击) |
|262 | [如何更新已渲染的元素?](#如何更新已渲染的元素) |
|263 | [你怎么说 props 是只读的?](#你怎么说-props-是只读的) |
|264 | [你认为状态更新是如何合并的?](#你认为状态更新是如何合并的) |
|265 | [如何将参数传递给事件处理程序?](#如何将参数传递给事件处理程序) |
|266 | [如何防止组件渲染?](#如何防止组件渲染) |
|267 | [安全地使用索引作为键的条件是什么?](#安全地使用索引作为键的条件是什么) |
|268 | [keys 是否需要全局唯一?](#keys-是否需要全局唯一) |
|269 | [用于表单处理的流行选择是什么?](#用于表单处理的流行选择是什么) |
|270 | [formik 相对于其他 redux 表单库有什么优势?](#formik-相对于其他-redux-表单库有什么优势) |
|271 | [为什么不需要使用继承?](#为什么不需要使用继承) |
|272 | [我可以在 React 应用程序中可以使用 web components 么?](#我可以在-react-应用程序中可以使用-web-components-么) |
|273 | [什么是动态导入?](#什么是动态导入) |
|274 | [什么是 loadable 组件?](#什么是-loadable-组件) |
|275 | [什么是 suspense 组件?](#什么是-suspense-组件) |
|276 | [什么是基于路由的代码拆分?](#什么是基于路由的代码拆分) |
|277 | [举例说明如何使用 context?](#举例说明如何使用-context) |
|278 | [在 context 中默认值的目的是什么?](#在-context-中默认值的目的是什么) |
|279 | [你是怎么使用 contextType?](#你是怎么使用-contexttype) |
|280 | [什么是 consumer?](#什么是-consumer) |
|281 | [在使用 context 时，如何解决性能方面的问题?](#在使用-context-时如何解决性能方面的问题) |
|282 | [在 HOCs 中 forward ref 的目的是什么?](#在-hocs-中-forward-ref-的目的是什么) |
|283 | [ref 参数对于所有函数或类组件是否可用?](#ref-参数对于所有函数或类组件是否可用) |
|284 | [在组件库中当使用 forward refs 时，你需要额外的注意?](#在组件库中当使用-forward-refs-时你需要额外的注意) |
|285 | [如何在没有 ES6 的情况下创建 React 类组件](#如何在没有-es6-的情况下创建-react-类组件) |
|286 | [是否可以在没有 JSX 的情况下使用 React?](#是否可以在没有-jsx-的情况下使用-react) |
|287 | [什么是差异算法?](#什么是差异算法) |
|288 | [差异算法涵盖了哪些规则?](#差异算法涵盖了哪些规则) |
|289 | [你什么时候需要使用 refs?](#你什么时候需要使用-refs) |
|290 | [对于渲染属性来说是否必须将 prop 属性命名为 render?](#对于渲染属性来说是否必须将-prop-属性命名为-render) |
|291 | [在 Pure Component 中使用渲染属性会有什么问题?](#在-pure-component-中使用渲染属性会有什么问题) |
|292 | [如何使用渲染属性创建 HOC?](#如何使用渲染属性创建-hoc) |
|293 | [什么是 windowing 技术?](#什么是-windowing-技术) |
|294 | [你如何在 JSX 中打印 falsy 值?](#你如何在-jsx-中打印-falsy-值) |
|295 | [portals 的典型使用场景是什么?](#portals-的典型使用场景是什么) |
|296 | [如何设置非受控组件的默认值?](#如何设置非受控组件的默认值) |
|297 | [你最喜欢的 React 技术栈是什么?](#你最喜欢的-react-技术栈是什么) |
|298 | [Real DOM 和 Virtual DOM 有什么区别?](#real-dom-和-virtual-dom-有什么区别) |
|299 | [如何为 React 应用程序添加 bootstrap?](#如何为-react-应用程序添加-bootstrap) |
|300 | [你能否列出使用 React 作为前端框架的顶级网站或应用程序?](#你能否列出使用-react-作为前端框架的顶级网站或应用程序) |
|301 | [是否建议在 React 中使用 CSS In JS 技术?](#是否建议在-react-中使用-css-in-js-技术) |
|302 | [我需要用 hooks 重写所有类组件吗?](#我需要用-hooks-重写所有类组件吗) |
|303 | [如何使用 React Hooks 获取数据?](#如何使用-react-hooks-获取数据) |
|304 | [Hooks 是否涵盖了类的所有用例?](#hooks-是否涵盖了类的所有用例) |
<!-- /TOC -->

## Core React

1. ### 什么是 React?

    [React](https://reactjs.org/) 是一个**开源前端 JavaScript 库**，用于构建用户界面，尤其是单页应用程序。它用于处理网页和移动应用程序的视图层。React 是由 Facebook 的软件工程师 Jordan Walke 创建的。在 2011 年 React 应用首次被部署到 Facebook 的信息流中，之后于 2012 年被应用到 Instagram 上。

    阅读资源：

    1. [React 中文文档](https://react.docschina.org/docs/hello-world.html)
    2. [掘金 - 图解 React](https://juejin.im/post/5b481f6b51882519ad6175c2)
    2. [掘金 - 200行代码实现简版react](https://juejin.im/post/5c0c7304f265da613e22106c)

    **[⬆ 返回顶部](#目录)**

2. ### React 的主要特点是什么?

    React 的主要特性有：

    * 考虑到真实的 DOM 操作成本很高，它使用 VirtualDOM 而不是真实的 DOM。
    * 支持服务端渲染。
    * 遵循单向数据流或数据绑定。
    * 使用可复用/可组合的 UI 组件开发视图。

    **[⬆ 返回顶部](#目录)**

3. ### 什么是 JSX?

    JSX 是 ECMAScript 一个类似 XML 的语法扩展。基本上，它只是为 `React.createElement()` 函数提供语法糖，从而让在我们在 JavaScript 中，使用类 HTML 模板的语法，进行页面描述。

    在下面的示例中，`<h1>` 内的文本标签会作为 JavaScript 函数返回给渲染函数。

    ```jsx
    class App extends React.Component {
      render() {
        return(
          <div>
            <h1>{'Welcome to React world!'}</h1>
          </div>
        )
      }
    }
    ```

    以上示例 render 方法中的 JSX 将会被转换为以下内容：

    ```javascript
    React.createElement("div", null, React.createElement(
      "h1", null, 'Welcome to React world!'));
    ```

    这里你可以访问 [Babeljs](https://babeljs.io/repl) 在线体验一下。

    阅读资源：

    1. [从零开始实现一个React（一）：JSX和虚拟DOM ](https://github.com/hujiulong/blog/issues/4)

    **[⬆ 返回顶部](#目录)**

4. ### 元素和组件有什么区别?

    一个 *Element* 是一个简单的对象，它描述了你希望在屏幕上以 DOM 节点或其他组件的形式呈现的内容。*Elements* 在它们的属性中可以包含其他 *Elements*。创建一个 React 元素是很轻量的。一旦元素被创建后，它将不会被修改。

    React Element 的对象表示如下：

    ```javascript
    const element = React.createElement(
      'div',
      {id: 'login-btn'},
      'Login'
    )
    ```

    上面的 `React.createElement()` 函数会返回一个对象。

    ```
    {
      type: 'div',
      props: {
        children: 'Login',
        id: 'login-btn'
      }
    }
    ```

    最后使用 `ReactDOM.render()` 方法渲染到 DOM：

    ```html
    <div id='login-btn'>Login</div>
    ```

    而一个组件可以用多种不同方式声明。它可以是一个含有 `render()` 方法的类。或者，在简单的情况中，它可以定义为函数。无论哪种情况，它都将 props 作为输入，并返回一个 JSX 树作为输出：

    ```jsx
    const Button = ({ onLogin }) =>
      <div id={'login-btn'} onClick={onLogin} />
    ```

    然后 JSX 被转换成 `React.createElement()` 函数：

    ```javascript
    const Button = ({ onLogin }) => React.createElement(
      'div',
      { id: 'login-btn', onClick: onLogin },
      'Login'
    )
    ```

    阅读资源：

    1. [为什么React元素有一个$$typeof属性?](https://overreacted.io/zh-hans/why-do-react-elements-have-typeof-property/)

    **[⬆ 返回顶部](#目录)**

5. ### 如何在 React 中创建组件?

    有两种可行的方法来创建一个组件：

    1. **Function Components:** 这是创建组件最简单的方式。这些是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素：

        ```jsx 
        function Greeting({ message }) {
          return <h1>{`Hello, ${message}`}</h1>
        }
        ```

    2. **Class Components:** 你还可以使用 ES6 类来定义组件。上面的函数组件若使用 ES6 的类可改写为：

        ```jsx 
        class Greeting extends React.Component {
          render() {
            return <h1>{`Hello, ${this.props.message}`}</h1>
          }
        }
        ```

    通过以上任意方式创建的组件，可以这样使用：

    ```jsx 
      <Greeting message="semlinker"/>
    ```

    在 React 内部对函数组件和类组件的处理方式是不一样的，如：

    ```javascript
      // 如果 Greeting 是一个函数
      const result = Greeting(props); // <p>Hello</p>

      // 如果 Greeting 是一个类
      const instance = new Greeting(props); // Greeting {}
      const result = instance.render(); // <p>Hello</p>
    ```

    阅读资源：

    1. [React 如何区分 Class 和 Function?](https://overreacted.io/zh-hans/how-does-react-tell-a-class-from-a-function/)

    **[⬆ 返回顶部](#目录)**

6. ### 何时使用类组件和函数组件?

    如果组件需要使用**状态或生命周期方法**，那么使用类组件，否则使用函数组件。

    **[⬆ 返回顶部](#目录)**

7. ### 什么是 Pure Components?

    `React.PureComponent` 与 `React.Component` 完全相同，只是它为你处理了 `shouldComponentUpdate()` 方法。当属性或状态发生变化时，PureComponent 将对属性和状态进行**浅比较**。另一方面，一般的组件不会将当前的属性和状态与新的属性和状态进行比较。因此，在默认情况下，每当调用 `shouldComponentUpdate` 时，默认返回 true，所以组件都将重新渲染。

    **[⬆ 返回顶部](#目录)**

8. ### React 的状态是什么?

    组件的状态是一个对象，它包含某些信息，这些信息可能在组件的生命周期中发生更改。我们应该尽量使状态尽可能简单，并尽量减少有状态组件的数量。让我们创建一个包含消息状态的 User 组件：

    ```javascript
    class User extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          message: 'Welcome to React world'
        }
      }
    
      render() {
        return (
          <div>
            <h1>{this.state.message}</h1>
          </div>
        )
      }
    }
    ```

    ![state](images/state.jpg)

    状态（State）与属性（Props）类似，但它是私有的，完全由组件控制。也就是说，除了它所属的组件外，任何组件都无法访问它。

    **[⬆ 返回顶部](#目录)**

9. ### React 中的 props 是什么?

    Props 是组件的输入。它们是单个值或包含一组值的对象，这些值在创建时使用类似于 HTML 标记属性的命名约定传递给组件。它们是从父组件传递到子组件的数据。

    Props 的主要目的是提供以下组件功能：

    1. 将自定义数据传递到组件。
    2. 触发状态更改。
    3. 在组件的 `render()` 方法中通过 `this.props.reactProp` 使用。

    例如，让我们使用 `reactProp` 属性创建一个元素：

    ```jsx
    <Element reactProp={'1'} />
    ```

    然后，`reactProp` 将成为附加到 React props 对象的属性，该对象最初已存在于使用 React 库创建的所有组件上。

    ```
    props.reactProp
    ```

    **[⬆ 返回顶部](#目录)**

10. ### 状态和属性有什么区别?

    state 和 props 都是普通的 JavaScript 对象。虽然它们都保存着影响渲染输出的信息，但它们在组件方面的功能不同。Props 以类似于函数参数的方式传递给组件，而状态则类似于在函数内声明变量并对它进行管理。

    States vs Props

    | Conditions           | States | Props |
    | -------------------- | ------ | ----- |
    | 可从父组件接收初始值 | 是     | 是    |
    | 可在父组件中改变其值 | 否     | 是    |
    | 在组件内设置默认值   | 是     | 是    |
    | 在组件内可改变       | 是     | 否    |
    | 可作为子组件的初始值 | 是     | 是    |

    **[⬆ 返回顶部](#目录)**

11. ### 我们为什么不能直接更新状态?

    如果你尝试直接改变状态，那么组件将不会重新渲染。

    ```javascript
    //Wrong
    this.state.message = 'Hello world'
    ```

    正确方法应该是使用 `setState()` 方法。它调度组件状态对象的更新。当状态更改时，组件通将会重新渲染。

    ```javascript
    //Correct
    this.setState({ message: 'Hello World' })
    ```

    **注意：** 你可以在 *constructor* 中或使用最新的 JavaScript 类属性声明语法直接设置状态对象。

    另在React文档中，提到永远不要直接更改this.state，而是使用this.setState进行状态更新，这样做的两个主要原因如下：
    
    1. setState分批工作：这意味着不能期望setState立即进行状态更新，这是一个异步操作，因此状态更改可能在以后的时间点发生，这意味着手动更改状态可能会被setState覆盖。
    2. 性能：当使用纯组件或shouldComponentUpdate时，它们将使用===运算符进行浅表比较，但是如果更改状态，则对象引用将仍然相同，因此比较将失败。

    **注意：** 为了避免避免数组/对象突变，可使用以下方法：

    1）使用slice
    2）使用Object.assign
    3）在ES6中使用Spread operator
    4）嵌套对象

    **[⬆ 返回顶部](#目录)**

12. ### 回调函数作为 `setState()` 参数的目的是什么?

    当 setState 完成和组件渲染后，回调函数将会被调用。由于 `setState()` 是异步的，回调函数用于任何后续的操作。

    **注意：** 建议使用生命周期方法而不是此回调函数。

    ```javascript
    setState({ name: 'John' }, () => console.log('The name has updated and component re-rendered'))
    ```

    阅读资源：

    1. [掘金 - 揭密React setState](https://juejin.im/post/5b87d14e6fb9a01a18268caf)
    2. [setState 如何知道该做什么?](https://overreacted.io/zh-hans/how-does-setstate-know-what-to-do/)

    **[⬆ 返回顶部](#目录)**

13. ### HTML 和 React 事件处理有什么区别?

    1. 在 HTML 中事件名必须小写：

    ```html
    <button onclick='activateLasers()'>
    ```

    而在 React 中它遵循 *camelCase* (驼峰) 惯例：

    ```jsx
    <button onClick={activateLasers}>
    ```

    2. 在 HTML 中你可以返回 `false` 以阻止默认的行为：

    ```html
    <a href='#' onclick='console.log("The link was clicked."); return false;' />
    ```

    而在 React 中你必须地明确地调用 `preventDefault()` ：

    ```javascript
    function handleClick(event) {
      event.preventDefault()
      console.log('The link was clicked.')
    }
    ```

    **[⬆ 返回顶部](#目录)**

14. ### 如何在 JSX 回调中绑定方法或事件处理程序?

    实现这一点有三种可能的方法：

    1.	**Binding in Constructor:** 在 JavaScript 类中，方法默认不被绑定。这也适用于定义为类方法的 React 事件处理程序。通常我们在构造函数中绑定它们。

    ```javascript
    class Component extends React.Componenet {
      constructor(props) {
        super(props)
        this.handleClick = this.handleClick.bind(this)
      }
    
      handleClick() {
        // ...
      }
    }
    ```

    2. **Public class fields syntax:** 如果你不喜欢 bind 方案，则可以使用 *public class fields syntax* 正确绑定回调。

    ```jsx 
    handleClick = () => {
      console.log('this is:', this)
    }
    ```

    ```jsx 
    <button onClick={this.handleClick}>
      {'Click me'}
    </button>
    ```

    3. **Arrow functions in callbacks:** 你可以在回调函数中直接使用 *arrow functions*。

    ```jsx
    <button onClick={(event) => this.handleClick(event)}>
      {'Click me'}
    </button>
    ```

    **注意：** 如果回调函数作为属性传给子组件，那么这些组件可能触发一个额外的重新渲染。在这些情况下，考虑到性能，最好使用 `.bind()` 或 *public class fields syntax* 方案。

    **[⬆ 返回顶部](#目录)**

15. ### 如何将参数传递给事件处理程序或回调函数?

    你可以使用箭头函数来包装事件处理器并传递参数：

    ```jsx 
    <button onClick={() => this.handleClick(id)} />
    ```

    这相当于调用 `.bind`:

    ```jsx 
    <button onClick={this.handleClick.bind(this, id)} />
    ```

    **[⬆ 返回顶部](#目录)**

16. ### React 中的合成事件是什么?

    `SyntheticEvent` 是对浏览器原生事件的跨浏览器包装。它的 API 与浏览器的原生事件相同，包括 `stopPropagation()` 和 `preventDefault()`，除了事件在所有浏览器中的工作方式相同。

    **[⬆ 返回顶部](#目录)**

17. ### 什么是内联条件表达式?

    在 JS 中你可以使用 if 语句或三元表达式，来实现条件判断。除了这些方法之外，你还可以在 JSX 中嵌入任何表达式，方法是将它们用大括号括起来，然后再加上 JS 逻辑运算符 `&&`。

    ```jsx 
    <h1>Hello!</h1>
    {
        messages.length > 0 && !isLogin ?
          <h2>
              You have {messages.length} unread messages.
          </h2>
          :
          <h2>
              You don't have unread messages.
          </h2>
    }
    ```
    
    当然如果只是想判断 if，可以如下直接判断：
    
    ```
    {
        isLogin && <span>Your have been login!</span>
    }
    ```
    
    在上面的代码中，不需要使用`isLogin ? <span>Your have been login!</span> : null`这样的形式。

    **[⬆ 返回顶部](#目录)**

18. ### 什么是 "key" 属性，在元素数组中使用它们有什么好处?

    `key` 是一个特殊的字符串属性，你在创建元素数组时需要包含它。*Keys* 帮助 React 识别哪些项已更改、添加或删除。

    我们通常使用数据中的 IDs 作为 *keys*:

    ```jsx
    const todoItems = todos.map((todo) =>
      <li key={todo.id}>
        {todo.text}
      </li>
    )
    ```

    在渲染列表项时，如果你没有稳定的 IDs，你可能会使用 *index* 作为 *key*：

    ```jsx
    const todoItems = todos.map((todo, index) =>
      <li key={index}>
        {todo.text}
      </li>
    )
    ```

    **注意：**

    1. 由于列表项的顺序可能发生改变，因此并不推荐使用 *indexes* 作为 *keys*。这可能会对性能产生负面影响，并可能导致组件状态出现问题。
    2. 如果将列表项提取为单独的组件，则在列表组件上应用 *keys* 而不是 `li` 标签。
    3. 如果在列表项中没有设置 `key` 属性，在控制台会显示警告消息。

    **[⬆ 返回顶部](#目录)**

19. ### refs 有什么用?

    *ref* 用于返回对元素的引用。但在大多数情况下，应该避免使用它们。当你需要直接访问 DOM 元素或组件的实例时，它们可能非常有用。

20. ### 如何创建 refs?

    这里有两种方案
    1. 这是最近增加的一种方案。*Refs* 是使用 `React.createRef()` 方法创建的，并通过 `ref` 属性添加到 React 元素上。为了在整个组件中使用*refs*，只需将 *ref* 分配给构造函数中的实例属性。

    ```jsx 
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
        this.myRef = React.createRef()
      }
      render() {
        return <div ref={this.myRef} />
      }
    }
    ```

    2. 你也可以使用 ref 回调函数的方案，而不用考虑 React 版本。例如，访问搜索栏组件中的 `input` 元素如下：

    ```jsx 
    class SearchBar extends Component {
       constructor(props) {
          super(props);
          this.txtSearch = null;
          this.state = { term: '' };
          this.setInputSearchRef = e => {
             this.txtSearch = e;
          }
       }
    
       onInputChange(event) {
          this.setState({ term: this.txtSearch.value });
       }
    
       render() {
          return (
             <input
                value={this.state.term}
                onChange={this.onInputChange.bind(this)}
                ref={this.setInputSearchRef} />
          );
       }
    }
    ```

    你也可以在使用 **closures** 的函数组件中使用 *refs*。

    **注意：** 你也可以使用内联引用回调，尽管这不是推荐的方法。

    **[⬆ 返回顶部](#目录)**

21. ### 什么是 forward refs?

    *Ref forwarding* 是一个特性，它允许一些组件获取接收到 *ref* 对象并将它进一步传递给子组件。

    ```jsx 
    const ButtonElement = React.forwardRef((props, ref) => (
      <button ref={ref} className="CustomButton">
        {props.children}
      </button>
    ));
    
    // Create ref to the DOM button:
    const ref = React.createRef();
    <ButtonElement ref={ref}>{'Forward Ref'}</ButtonElement>
    ```

    **[⬆ 返回顶部](#目录)**

22. ### callback refs 和 findDOMNode() 哪一个是首选选项?

    最好是使用 *callback refs* 而不是 `findDOMNode()` API。因为 `findDOMNode()` 阻碍了将来对 React 的某些改进。

    使用 `findDOMNode` 已弃用的方案：

    ```javascript
    class MyComponent extends Component {
      componentDidMount() {
        findDOMNode(this).scrollIntoView()
      }
    
      render() {
        return <div />
      }
    }
    ```

    推荐的方案是：

    ```javascript
    class MyComponent extends Component {
      componentDidMount() {
        this.node.scrollIntoView()
      }
    
      render() {
        return <div ref={node => this.node = node} />
      }
    }
    ```

    **[⬆ 返回顶部](#目录)**

23. ### 为什么 String Refs 被弃用?

    如果你以前使用过 React，你可能会熟悉旧的 API，其中的 `ref` 属性是字符串，如 `ref={'textInput'}`，并且 DOM 节点的访问方式为`this.refs.textInput`。我们建议不要这样做，因为字符串引用有以下问题，并且被认为是遗留问题。字符串 refs 在 React v16 版本中被移除。

    1. 它们强制 React 跟踪当前执行的组件。这是有问题的，因为它使 React 模块有状态，这会导致在 bundle 中复制 React 模块时会导致奇怪的错误。
    2. 它们是不可组合的 - 如果一个库把一个 ref 传给子元素，则用户无法对其设置另一个引用。
    3. 它们不能与静态分析工具一起使用，如 Flow。Flow 无法猜测出 `this.refs` 上的字符串引用的作用及其类型。Callback refs 对静态分析更友好。
    4. 使用 "render callback" 模式（比如： <DataGrid renderRow={this.renderRow} />），它无法像大多数人预期的那样工作。

       ```jsx 
       class MyComponent extends Component {
         renderRow = (index) => {
           // This won't work. Ref will get attached to DataTable rather than MyComponent:
           return <input ref={'input-' + index} />;

           // This would work though! Callback refs are awesome.
           return <input ref={input => this['input-' + index] = input} />;
         }

         render() {
           return <DataTable data={this.props.data} renderRow={this.renderRow} />
         }
       }
       ```

    **[⬆ 返回顶部](#目录)**

24. ### 什么是 Virtual DOM?

    *Virtual DOM* (VDOM) 是 *Real DOM* 的内存表示形式。UI 的展示形式被保存在内存中并与真实的 DOM 同步。这是在调用的渲染函数和在屏幕上显示元素之间发生的一个步骤。整个过程被称为 *reconciliation*。

    Real DOM vs Virtual DOM

    |           Real DOM           |       Virtual DOM        |
    | :--------------------------: | :----------------------: |
    |           更新较慢           |         更新较快         |
    |      可以直接更新 HTML       |    无法直接更新 HTML     |
    | 如果元素更新，则创建新的 DOM | 如果元素更新，则更新 JSX |
    |       DOM 操作非常昂贵       |     DOM 操作非常简单     |
    |        较多的内存浪费        |       没有内存浪费       |

    阅读资源：

    1. [知乎 - 如何理解虚拟DOM?](https://www.zhihu.com/question/29504639)
    2. [edureka - react-interview-questions](https://www.edureka.co/blog/interview-questions/react-interview-questions/)

    **[⬆ 返回顶部](#目录)**

25. ### Virtual DOM 如何工作?

    *Virtual DOM* 分为三个简单的步骤。

    1. 每当任何底层数据发生更改时，整个 UI 都将以 Virtual DOM 的形式重新渲染。
        ![vdom](images/vdom1.png)

    2. 然后计算先前 Virtual DOM 对象和新的 Virtual DOM 对象之间的差异。
        ![vdom2](images/vdom2.png)

    3. 一旦计算完成，真实的 DOM 将只更新实际更改的内容。
        ![vdom3](images/vdom3.png)

    **[⬆ 返回顶部](#目录)**

26. ### Shadow DOM 和 Virtual DOM 之间有什么区别?

    [Shadow DOM](https://developers.google.com/web/fundamentals/web-components/shadowdom?hl=zh-cn) 是一种浏览器技术，它解决了构建网络应用的脆弱性问题。Shadow DOM 修复了 CSS 和 DOM。它在网络平台中引入作用域样式。 无需工具或命名约定，你即可使用原生 JavaScript 捆绑 CSS 和标记、隐藏实现详情以及编写独立的组件。*Virtual DOM* 是一个由 JavaScript 库在浏览器 API 之上实现的概念。

    **[⬆ 返回顶部](#目录)**

27. ### 什么是 React Fiber?

    Fiber 是 React v16 中新的 *reconciliation* 引擎，或核心算法的重新实现。React Fiber 的目标是提高对动画，布局，手势，暂停，中止或者重用任务的能力及为不同类型的更新分配优先级，及新的并发原语等领域的适用性。

    **[⬆ 返回顶部](#目录)**

28. ### React Fiber 的主要目标是什么?

    *React Fiber* 的目标是提高其在动画、布局和手势等领域的适用性。它的主要特性是 **incremental rendering**: 将渲染任务拆分为小的任务块并将任务分配到多个帧上的能力。

    **[⬆ 返回顶部](#目录)**

29. ### 什么是受控组件?

    在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，即每个状态更改都有一个相关联的处理程序。

    例如，我们使用下面的 handleChange 函数将输入框的值转换成大写：

    ```javascript
    handleChange(event) {
      this.setState({value: event.target.value.toUpperCase()})
    }
    ```

    **[⬆ 返回顶部](#目录)**

30. ### 什么是非受控组件?

    非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。

    在下面的 UserProfile 组件中，我们通过 ref 引用 `name` 输入框：

    ```jsx 
    class UserProfile extends React.Component {
      constructor(props) {
        super(props)
        this.handleSubmit = this.handleSubmit.bind(this)
        this.input = React.createRef()
      }
    
      handleSubmit(event) {
        alert('A name was submitted: ' + this.input.current.value)
        event.preventDefault()
      }
    
      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              {'Name:'}
              <input type="text" ref={this.input} />
            </label>
            <input type="submit" value="Submit" />
          </form>
        );
      }
    }
    ```

    在大多数情况下，建议使用受控组件来实现表单。

    **[⬆ 返回顶部](#目录)**

31. ### createElement 和 cloneElement 有什么区别?

    JSX 元素将被转换为 `React.createElement()` 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 `cloneElement` 用于克隆元素并传递新的属性。

    **[⬆ 返回顶部](#目录)**

32. ### 在 React 中的提升状态是什么?

    当多个组件需要共享相同的更改数据时，建议将共享状态提升到最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移动到父组件，而不是在两个子组件中维护局部状态。

    **[⬆ 返回顶部](#目录)**

33. ### 组件生命周期的不同阶段是什么?

    组件生命周期有三个不同的生命周期阶段：

    1. **Mounting:** 组件已准备好挂载到浏览器的 DOM 中. 此阶段包含来自 `constructor()`, `getDerivedStateFromProps()`, `render()`, 和 `componentDidMount()` 生命周期方法中的初始化过程。

    2. **Updating:** 在此阶段，组件以两种方式更新，发送新的属性并使用 `setState()` 或 `forceUpdate()` 方法更新状态. 此阶段包含 `getDerivedStateFromProps()`, `shouldComponentUpdate()`, `render()`, `getSnapshotBeforeUpdate()` 和 `componentDidUpdate()` 生命周期方法。

    3. **Unmounting:** 在这个最后阶段，不需要组件，它将从浏览器 DOM 中卸载。这个阶段包含 `componentWillUnmount()` 生命周期方法。

    值得一提的是，在将更改应用到 DOM 时，React 内部也有阶段概念。它们按如下方式分隔开：

    1. **Render** 组件将会进行无副作用渲染。这适用于纯组件（Pure Component），在此阶段，React 可以暂停，中止或重新渲染。

    2. **Pre-commit** 在组件实际将更改应用于 DOM 之前，有一个时刻允许 React 通过`getSnapshotBeforeUpdate()`捕获一些 DOM 信息（例如滚动位置）。

    3. **Commit** React 操作 DOM 并分别执行最后的生命周期： `componentDidMount()` 在 DOM 渲染完成后调用, `componentDidUpdate()` 在组件更新时调用,  `componentWillUnmount()` 在组件卸载时调用。
    React 16.3+ 阶段 (也可以看[交互式版本](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/))

    ![phases 16.3+](images/phases16.3.jpg)

    React 16.3 之前

    ![phases 16.2](images/phases.png)

    **[⬆ 返回顶部](#目录)**


34. ### React 生命周期方法有哪些?

    React 16.3+

    - **getDerivedStateFromProps:** 在调用`render()`之前调用，并在 *每次* 渲染时调用。 需要使用派生状态的情况是很罕见得。值得阅读 [如果你需要派生状态](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html).
    - **componentDidMount:** 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。
    - **shouldComponentUpdate:** 确定组件是否应该更新。 默认情况下，它返回`true`。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回`false`值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。
    - **getSnapshotBeforeUpdate:** 在最新的渲染输出提交给 DOM 前将会立即调用，这对于从 DOM 捕获信息（比如：滚动位置）很有用。
    - **componentDidUpdate:** 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果`shouldComponentUpdate()`返回`false`，则不会触发。
    - **componentWillUnmount** 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。

    Before 16.3

    - **componentWillMount:** 在组件`render()`前执行，用于根组件中的应用程序级别配置。应该避免在该方法中引入任何的副作用或订阅。
    - **componentDidMount:** 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。
    - **componentWillReceiveProps:** 在组件接收到新属性前调用，若你需要更新状态响应属性改变（例如，重置它），你可能需对比`this.props`和`nextProps`并在该方法中使用`this.setState()`处理状态改变。
    - **shouldComponentUpdate:** 确定组件是否应该更新。 默认情况下，它返回`true`。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回`false`值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。
    - **componentWillUpdate:** 当`shouldComponentUpdate`返回`true`后重新渲染组件之前执行，注意你不能在这调用`this.setState()`
    - **componentDidUpdate:** 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果`shouldComponentUpdate()`返回`false`，则不会触发。
    - **componentWillUnmount:** 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。

    **[⬆ 返回顶部](#目录)**

35. ### 什么是高阶组件（HOC）?

    *高阶组件*(*HOC*) 就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种模式，这种模式是由`react`自身的组合性质必然产生的。

    我们将它们称为**纯组件**，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。

    ```javascript
    const EnhancedComponent = higherOrderComponent(WrappedComponent)
    ```

    HOC 有很多用例：

    1. 代码复用，逻辑抽象化
    2. 渲染劫持
    3. 抽象化和操作状态（`state`）
    4. 操作属性（`props`）
    
    > 译注：更详细用法请参考[高阶组件的使用](https://react.docschina.org/docs/higher-order-components.html)

    **[⬆ 返回顶部](#目录)**

36. ### 如何为高阶组件创建属性代理?

    你可以使用*属性代理*模式向输入组件增加或编辑属性（props）：

    ```jsx
    function HOC(WrappedComponent) {
      return class Test extends Component {
        render() {
          const newProps = {
            title: 'New Header',
            footer: false,
            showFeatureX: false,
            showFeatureY: true
          };

          return <WrappedComponent {...this.props} {...newProps} />
        }
      }
    }
    ```

    **[⬆ 返回顶部](#目录)**

37. ### 什么是上下文（Context）?

    *Context* 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递`props`。比如，需要在应用中许多组件需要访问登录用户信息、地区偏好、UI主题等。

    ```jsx
    // 创建一个 theme Context,  默认 theme 的值为 light
    const ThemeContext = React.createContext('light');
    
    function ThemedButton(props) {
      // ThemedButton 组件从 context 接收 theme
      return (
        <ThemeContext.Consumer>
          {theme => <Button {...props} theme={theme} />}
        </ThemeContext.Consumer>
      );
    }
    
    // 中间组件
    function Toolbar(props) {
      return (
        <div>
          <ThemedButton />
        </div>
      );
    }
    
    class App extends React.Component {
      render() {
        return (
          <ThemeContext.Provider value="dark">
            <Toolbar />
          </ThemeContext.Provider>
        );
      }
    }
    ```

    **[⬆ 返回顶部](#目录)**

38. ### children 属性是什么?

    *Children* 是一个属性（`this.props.chldren`），它允许你将组件作为数据传递给其他组件，就像你使用的任何其他组件一样。在组件的开始和结束标记之间放置的组件树将作为`children`属性传递给该组件。

    React API 中有许多方法中提供了这个不透明数据结构的方法，包括：`React.Children.map`、`React.Children.forEach`、`React.Children.count`、`React.Children.only`、`React.Children.toArray`。

    ```jsx
    const MyDiv = React.createClass({
      render: function() {
        return <div>{this.props.children}</div>
      }
    })

    ReactDOM.render(
      <MyDiv>
        <span>{'Hello'}</span>
        <span>{'World'}</span>
      </MyDiv>,
      node
    )
    ```

    **[⬆ 返回顶部](#目录)**

39. ### 怎样在 React 中写注释?

    React/JSX 中的注释类似于 JavaScript 的多行注释，但是是用大括号括起来。

    **单行注释：**

    ```jsx 
    <div>
      {/* 单行注释（在原生 JavaScript 中，单行注释用双斜杠（//）表示） */}
      {`Welcome ${user}, let's play React`}
    </div>
    ```

    **多行注释：**

    ```jsx
    <div>
      {/* 多行注释超过
       一行 */}
      {`Welcome ${user}, let's play React`}
    </div>
    ```

    **[⬆ 返回顶部](#目录)**

40. ### 构造函数使用带 props 参数的目的是什么?

    在调用`super()`方法之前，子类构造函数不能使用`this`引用。这同样适用于ES6子类。将`props`参数传递给`super()`的主要原因是为了在子构造函数中访问`this.props`。

    **带 props 参数:**

    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        console.log(this.props) // prints { name: 'John', age: 42 }
      }
    }
    ```

    **不带 props 参数:**

    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super()

        console.log(this.props) // prints undefined

        // but props parameter is still available
        console.log(props) // prints { name: 'John', age: 42 }
      }

      render() {
        // no difference outside constructor
        console.log(this.props) // prints { name: 'John', age: 42 }
      }
    }
    ```

    上面的代码片段显示`this.props`仅在构造函数中有所不同。 它在构造函数之外是相同的。

    **[⬆ 返回顶部](#目录)**

41. ### 什么是调解?

    当组件的`props`或`state`发生更改时，React 通过将新返回的元素与先前呈现的元素进行比较来确定是否需要实际的 DOM 更新。当它们不相等时，React 将更新 DOM 。此过程称为*reconciliation*。

    **[⬆ 返回顶部](#目录)**

42. ### 如何使用动态属性名设置 state ?

    如果你使用 ES6 或 Babel 转换器来转换你的 JSX 代码，那么你可以使用*计算属性名称*来完成此操作。

    ```javascript
    handleInputChange(event) {
      this.setState({ [event.target.id]: event.target.value })
    }
    ```

    **[⬆ 返回顶部](#目录)**

43. ### 每次组件渲染时调用函数的常见错误是什么?

    你需要确保在将函数作为参数传递时未调用该函数。

    ```jsx
    render() {
      // Wrong: handleClick is called instead of passed as a reference!
      return <button onClick={this.handleClick()}>{'Click Me'}</button>
    }
    ```

    相反地，传递函数本身应该没有括号：

    ```jsx
    render() {
      // Correct: handleClick is passed as a reference!
      return <button onClick={this.handleClick}>{'Click Me'}</button>
    }
    ```

    **[⬆ 返回顶部](#目录)**

44. ### 为什么有组件名称要首字母大写?

    这是必要的，因为组件不是 DOM 元素，它们是构造函数。 此外，在 JSX 中，小写标记名称是指 HTML 元素，而不是组件。

    **[⬆ 返回顶部](#目录)**

45. ### 为什么 React 使用 `className` 而不是 `class` 属性?

    `class` 是 JavaScript 中的关键字，而 JSX 是 JavaScript 的扩展。这就是为什么 React 使用 `className` 而不是 `class` 的主要原因。传递一个字符串作为 `className` 属性。

    ```jsx
    render() {
      return <span className={'menu navigation-menu'}>{'Menu'}</span>
    }
    ```
    
    在实际项目中，我们经常使用[classnames](https://github.com/JedWatson/classnames)来方便我们操作`className`。

    **[⬆ 返回顶部](#目录)**

46. ### 什么是 Fragments ?

    它是 React 中的常见模式，用于组件返回多个元素。*Fragments* 可以让你聚合一个子元素列表，而无需向 DOM 添加额外节点。

    ```jsx 
    render() {
      return (
        <React.Fragment>
          <ChildA />
          <ChildB />
          <ChildC />
        </React.Fragment>
      )
    }
    ```

    以下是简洁语法，但是在一些工具中还不支持：

    ```jsx 
    render() {
      return (
        <>
          <ChildA />
          <ChildB />
          <ChildC />
        </>
      )
    }
    ```
    
    > 译注：`React 16` 以前，`render` 函数的返回必须有一个根节点，否则报错。

    **[⬆ 返回顶部](#目录)**

47. ### 为什么使用 Fragments 比使用容器 div 更好?

    1. 通过不创建额外的 DOM 节点，Fragments 更快并且使用更少的内存。这在非常大而深的节点树时很有好处。
    2. 一些 CSS 机制如*Flexbox*和*CSS Grid*具有特殊的父子关系，如果在中间添加 div 将使得很难保持所需的结构。
    3. 在 DOM 审查器中不会那么的杂乱。

    **[⬆ 返回顶部](#目录)**

48. ### 在 React 中什么是 Portal ?

    *Portal* 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。

    ```javascript
    ReactDOM.createPortal(child, container)
    ```

    第一个参数是任何可渲染的 React 子节点，例如元素，字符串或片段。第二个参数是 DOM 元素。

    **[⬆ 返回顶部](#目录)**

49. ### 什么是无状态组件?

    如果行为独立于其状态，则它可以是无状态组件。你可以使用函数或类来创建无状态组件。但除非你需要在组件中使用生命周期钩子，否则你应该选择函数组件。无状态组件有很多好处： 它们易于编写，理解和测试，速度更快，而且你可以完全避免使用`this`关键字。

    **[⬆ 返回顶部](#目录)**

50. ### 什么是有状态组件?

    如果组件的行为依赖于组件的*state*，那么它可以被称为有状态组件。这些*有状态组件*总是*类组件*，并且具有在`constructor`中初始化的状态。

    ```javascript
    class App extends Component {
      constructor(props) {
        super(props)
        this.state = { count: 0 }
      }

      render() {
        // ...
      }
    }
    ```

    **[⬆ 返回顶部](#目录)**

51. ### 在 React 中如何校验 props 属性?

    当应用程序以开发模式运行的时，React 将会自动检查我们在组件上设置的所有属性，以确保它们具有正确的类型。如果类型不正确，React 将在控制台中生成警告信息。由于性能影响，它在生产模式下被禁用。使用 `isRequired` 定义必填属性。

    预定义的 prop 类型：

    1. `PropTypes.number`
    2. `PropTypes.string`
    3. `PropTypes.array`
    4. `PropTypes.object`
    5. `PropTypes.func`
    6. `PropTypes.node`
    7. `PropTypes.element`
    8. `PropTypes.bool`
    9. `PropTypes.symbol`
    10. `PropTypes.any`

    我们可以为 `User` 组件定义 `propTypes`，如下所示：

    ```jsx 
    import React from 'react'
    import PropTypes from 'prop-types'

    class User extends React.Component {
      static propTypes = {
        name: PropTypes.string.isRequired,
        age: PropTypes.number.isRequired
      }

      render() {
        return (
          <>
            <h1>{`Welcome, ${this.props.name}`}</h1>
            <h2>{`Age, ${this.props.age}`}</h2>
          </>
        )
      }
    }
    ```

    **注意:** 在 React v15.5 中，*PropTypes* 从 `React.PropTypes` 被移动到 `prop-types` 库中。

    **[⬆ 返回顶部](#目录)**

52. ### React 的优点是什么?

    1. 使用 *Virtual DOM* 提高应用程序的性能。
    2. JSX 使代码易于读写。
    3. 它支持在客户端和服务端渲染。
    4. 易于与框架（Angular，Backbone）集成，因为它只是一个视图库。
    5. 使用 Jest 等工具轻松编写单元与集成测试。

    **[⬆ 返回顶部](#目录)**

53. ### React 的局限性是什么?

    1. React 只是一个视图库，而不是一个完整的框架。
    2. 对于 Web 开发初学者来说，有一个学习曲线。
    3. 将 React 集成到传统的 MVC 框架中需要一些额外的配置。
    4. 代码复杂性随着内联模板和 JSX 的增加而增加。
    5. 如果有太多的小组件可能增加项目的庞大和复杂。

    **[⬆ 返回顶部](#目录)**

54. ### 在 React v16 中的错误边界是什么?

    错误边界是在其子组件树中的任何位置捕获 JavaScript 错误、记录这些错误并显示回退 UI 而不是崩溃的组件树的组件。

    如果一个类组件定义了一个名为 `componentDidCatch(error, info)` 或 `static getDerivedStateFromError() ` 新的生命周期方法，则该类组件将成为错误边界：

    ```jsx 
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props)
        this.state = { hasError: false }
      }

      componentDidCatch(error, info) {
        // You can also log the error to an error reporting service
        logErrorToMyService(error, info)
      }

      static getDerivedStateFromError(error) {
         // Update state so the next render will show the fallback UI.
         return { hasError: true };
       }

      render() {
        if (this.state.hasError) {
          // You can render any custom fallback UI
          return <h1>{'Something went wrong.'}</h1>
        }
        return this.props.children
      }
    }
    ```

    之后，将其作为常规组件使用：

    ```jsx 
    <ErrorBoundary>
      <MyWidget />
    </ErrorBoundary>
    ```

    **[⬆ 返回顶部](#目录)**

55. ### 在 React v15 中如何处理错误边界?

    React v15 使用 `unstable_handleError` 方法为错误边界提供了非常基础的支持。已在 React v16 中，将其重命名为`componentDidCatch`。 

    **[⬆ 返回顶部](#目录)**

56. ### 静态类型检查推荐的方法是什么?

    通常，我们使用 PropTypes 库（在 React v15.5 之后 `React.PropTypes` 被移动到了 `prop-types` 包中），在 React 应用程序中执行类型检查。对于大型项目，建议使用静态类型检查器，比如 Flow 或 TypeScript，它们在编译时执行类型检查并提供 auto-completion 功能。

    **[⬆ 返回顶部](#目录)**

57. ### `react-dom` 包的用途是什么?

    `react-dom` 包提供了特定的 DOM 方法，可以在应用程序的顶层使用。大多数的组件不需要使用此模块。该模块中提供的一些方法如下：

    1. `render()`
    2. `hydrate()`
    3. `unmountComponentAtNode()`
    4. `findDOMNode()`
    5. `createPortal()`

    **[⬆ 返回顶部](#目录)**

58. ### `react-dom` 中 render 方法的目的是什么?

    此方法用于将 React 元素渲染到所提供容器中的 DOM 结构中，并返回对组件的引用。如果 React 元素之前已被渲染到容器中，它将对其执行更新，并且只在需要时改变 DOM 以反映最新的更改。

    ```
    ReactDOM.render(element, container[, callback])
    ```

    如果提供了可选的回调函数，该函数将在组件被渲染或更新后执行。

    **[⬆ 返回顶部](#目录)**

59. ### ReactDOMServer 是什么?

    `ReactDOMServer` 对象使你能够将组件渲染为静态标记（通常用于 Node 服务器中），此对象主要用于服务端渲染（SSR）。以下方法可用于服务器和浏览器环境：

    1. `renderToString()`
    2. `renderToStaticMarkup()`

    例如，你通常运行基于 Node 的 Web 服务器，如 Express，Hapi 或 Koa，然后你调用 `renderToString` 将根组件渲染为字符串，然后作为响应进行发送。

    ```javascript
    // using Express
    import { renderToString } from 'react-dom/server'
    import MyPage from './MyPage'

    app.get('/', (req, res) => {
      res.write('<!DOCTYPE html><html><head><title>My Page</title></head><body>')
      res.write('<div id="content">')
      res.write(renderToString(<MyPage/>))
      res.write('</div></body></html>')
      res.end()
    })
    ```

    **[⬆ 返回顶部](#目录)**

60. ### 在 React 中如何使用 innerHTML?

    `dangerouslySetInnerHTML` 属性是 React 用来替代在浏览器 DOM 中使用 `innerHTML`。与 `innerHTML` 一样，考虑到跨站脚本攻击（XSS），使用此属性也是有风险的。使用时，你只需传递以 `__html` 作为键，而 HTML 文本作为对应值的对象。

    在本示例中 MyComponent 组件使用 `dangerouslySetInnerHTML` 属性来设置 HTML 标记：

    ```jsx 
    function createMarkup() {
      return { __html: 'First &middot; Second' }
    }

    function MyComponent() {
      return <div dangerouslySetInnerHTML={createMarkup()} />
    }
    ```

    **[⬆ 返回顶部](#目录)**

61. ### 如何在 React 中使用样式?

    `style` 属性接受含有 camelCased（驼峰）属性的 JavaScript 对象，而不是 CSS 字符串。这与 DOM 样式中的 JavaScript 属性一致，效率更高，并且可以防止 XSS 安全漏洞。

    ```jsx 
    const divStyle = {
      color: 'blue',
      backgroundImage: 'url(' + imgUrl + ')'
    };

    function HelloWorldComponent() {
      return <div style={divStyle}>Hello World!</div>
    }
    ```

    为了与在 JavaScript 中访问 DOM 节点上的属性保持一致，样式键采用了 camelcased（例如`node.style.backgroundImage`）。

    **[⬆ 返回顶部](#目录)**


62. ### 在 React 中事件有何不同?

    处理 React 元素中的事件有一些语法差异：

    1. React 事件处理程序是采用驼峰而不是小写来命名的。 
    2. 使用 JSX，你将传递一个函数作为事件处理程序，而不是字符串。

    **[⬆ 返回顶部](#目录)**

63. ### 如果在构造函数中使用 `setState()` 会发生什么?

    当你使用 `setState()` 时，除了设置状态对象之外，React 还会重新渲染组件及其所有的子组件。你会得到这样的错误：*Can only update a mounted or mounting component.*。因此我们需要在构造函数中使用 `this.state` 初始化状态。

    **[⬆ 返回顶部](#目录)**

64. ### 索引作为键的影响是什么?

    Keys 应该是稳定的，可预测的和唯一的，这样 React 就能够跟踪元素。

    在下面的代码片段中，每个元素的键将基于列表项的顺序，而不是绑定到即将展示的数据上。这将限制 React 能够实现的优化。

    ```jsx 
    {todos.map((todo, index) =>
      <Todo
        {...todo}
        key={index}
      />
    )}
    ```

    假设 `todo.id` 对此列表是唯一且稳定的，如果将此数据作为唯一键，那么 React 将能够对元素进行重新排序，而无需重新创建它们。 

    ```jsx 
    {todos.map((todo) =>
      <Todo {...todo}
        key={todo.id} />
    )}
    ```

    **[⬆ 返回顶部](#目录)**

65. ### 在 `componentWillMount()` 方法中使用 `setState()` 好吗?

    建议避免在 `componentWillMount()` 生命周期方法中执行异步初始化。在 mounting 发生之前会立即调用 `componentWillMount()`，且它在 `render()` 之前被调用，因此在此方法中更新状态将不会触发重新渲染。应避免在此方法中引入任何副作用或订阅操作。我们需要确保对组件初始化的异步调用发生在 `componentDidMount()` 中，而不是在 `componentWillMount()` 中。

    ```jsx 
    componentDidMount() {
      axios.get(`api/todos`)
        .then((result) => {
          this.setState({
            messages: [...result.data]
          })
        })
    }
    ```
  
    **[⬆ 返回顶部](#目录)**

66. ### 如果在初始状态中使用 props 属性会发生什么?

    如果在不刷新组件的情况下更改组件上的属性，则不会显示新的属性值，因为构造函数函数永远不会更新组件的当前状态。只有在首次创建组件时才会用 props 属性初始化状态。

    以下组件将不显示更新的输入值：

    ```jsx 
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        this.state = {
          records: [],
          inputValue: this.props.inputValue
        };
      }

      render() {
        return <div>{this.state.inputValue}</div>
      }
    }
    ```

    在 render 方法使用使用 props 将会显示更新的值：


    ```jsx 
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
    
        this.state = {
          record: []
        }
      }
    
      render() {
        return <div>{this.props.inputValue}</div>
      }
    }
    ```
    
    **[⬆ 返回顶部](#目录)**

67. ### 如何有条件地渲染组件?

    在某些情况下，你希望根据某些状态渲染不同的组件。 JSX 不会渲染 `false` 或 `undefined`，因此你可以使用 `&&` 运算符，在某个条件为 true 时，渲染组件中指定的内容。

    ```jsx 
    const MyComponent = ({ name, address }) => (
      <div>
        <h2>{name}</h2>
        {address &&
          <p>{address}</p>
        }
      </div>
    )
    ```

    如果你需要一个 `if-else` 条件，那么使用三元运算符：

    ```jsx 
    const MyComponent = ({ name, address }) => (
      <div>
        <h2>{name}</h2>
        {address
          ? <p>{address}</p>
          : <p>{'Address is not available'}</p>
        }
      </div>
    )
    ```

    阅读资源：

    1. [掘金 - 精读《React 八种条件渲染》](https://juejin.im/post/5b285c0d5188257494641d0b)

    **[⬆ 返回顶部](#目录)**

68. ### 为什么在 DOM 元素上展开 props 需要小心?

    当我们展开属性时，我们会遇到添加未知 HTML 属性的风险，这是一种不好的做法。相反，我们可以使用属性解构和`...rest` 运算符，因此它只添加所需的 props 属性。例如，

    ```jsx 
    const ComponentA = () =>
      <ComponentB isDisplay={true} className={'componentStyle'} />

    const ComponentB = ({ isDisplay, ...domProps }) =>
      <div {...domProps}>{'ComponentB'}</div>
    ```

    **[⬆ 返回顶部](#目录)**

69. ### 在 React 中如何使用装饰器?

    你可以装饰你的类组件，这与将组件传递到函数中是一样的。 装饰器是修改组件功能灵活且易读的方式。

    ```jsx 
    @setTitle('Profile')
    class Profile extends React.Component {
        //....
    }

    /*
      title is a string that will be set as a document title
      WrappedComponent is what our decorator will receive when
      put directly above a component class as seen in the example above
    */
    const setTitle = (title) => (WrappedComponent) => {
      return class extends React.Component {
        componentDidMount() {
          document.title = title
        }

        render() {
          return <WrappedComponent {...this.props} />
        }
      }
    }
    ```

    **[⬆ 返回顶部](#目录)**

70. ### 如何 memoize（记忆）组件?

    有可用于函数组件的 memoize 库。例如 `moize` 库可以将组件存储在另一个组件中。

    ```jsx 
    import moize from 'moize'
    import Component from './components/Component' // this module exports a non-memoized component

    const MemoizedFoo = moize.react(Component)

    const Consumer = () => {
      <div>
        {'I will memoize the following entry:'}
        <MemoizedFoo/>
      </div>
    }
    ```

    **[⬆ 返回顶部](#目录)**

71. ### 如何实现 Server Side Rendering 或 SSR?

    React 已经配备了用于处理 Node 服务器上页面渲染的功能。你可以使用特殊版本的 DOM 渲染器，它遵循与客户端相同的模式。

    ```jsx 
    import ReactDOMServer from 'react-dom/server'
    import App from './App'

    ReactDOMServer.renderToString(<App />)
    ```

    此方法将以字符串形式输出常规 HTML，然后将其作为服务器响应的一部分放在页面正文中。在客户端，React 检测预渲染的内容并无缝地衔接。

    **[⬆ 返回顶部](#目录)**

72. ### 如何在 React 中启用生产模式?

    你应该使用 Webpack 的 `DefinePlugin` 方法将 `NODE_ENV` 设置为 `production`，通过它你可以去除 propType 验证和额外警告等内容。除此之外，如果你压缩代码，如使用 Uglify 的死代码消除，以去掉用于开发的代码和注释，它将大大减少包的大小。

    **[⬆ 返回顶部](#目录)**

73. ### 什么是 CRA 及其好处?

    `create-react-app` CLI 工具允许你无需配置步骤，快速创建和运行 React 应用。

    让我们使用 *CRA* 来创建 Todo 应用：

    ```shell
    # Installation
    $ npm install -g create-react-app

    # Create new project
    $ create-react-app todo-app
    $ cd todo-app

    # Build, test and run
    $ npm run build
    $ npm run test
    $ npm start
    ```

    它包含了构建 React 应用程序所需的一切：

    1. React, JSX, ES6, 和 Flow 语法支持。
    2. ES6 之外的语言附加功能，比如对象扩展运算符。
    3. Autoprefixed CSS，因此你不在需要 -webkit- 或其他前缀。
    4. 一个快速的交互式单元测试运行程序，内置了对覆盖率报告的支持。
    5. 一个实时开发服务器，用于警告常见错误。
    6. 一个构建脚本，用于打包用于生产中包含 hashes 和 sourcemaps 的 JS、CSS 和 Images 文件。

    **[⬆ 返回顶部](#目录)**

74. ### 在 mounting 阶段生命周期方法的执行顺序是什么?

    在创建组件的实例并将其插入到 DOM 中时，将按以下顺序调用生命周期方法。

    1. `constructor()`
    2. `static getDerivedStateFromProps()`
    3. `render()`
    4. `componentDidMount()`

    **[⬆ 返回顶部](#目录)**

75. ### 在 React v16 中，哪些生命周期方法将被弃用?

    以下生命周期方法将成为不安全的编码实践，并且在异步渲染方面会更有问题。

    1. `componentWillMount()`
    2. `componentWillReceiveProps()`
    3. `componentWillUpdate()`

    从 React v16.3 开始，这些方法使用 `UNSAFE_` 前缀作为别名，未加前缀的版本将在 React v17 中被移除。

    **[⬆ 返回顶部](#目录)**

76. ### 生命周期方法 `getDerivedStateFromProps()` 的目的是什么?

    新的静态 `getDerivedStateFromProps()` 生命周期方法在实例化组件之后以及重新渲染组件之前调用。它可以返回一个对象用于更新状态，或者返回 `null` 指示新的属性不需要任何状态更新。

    ```javascript
    class MyComponent extends React.Component {
      static getDerivedStateFromProps(props, state) {
        // ...
      }
    }
    ```

    此生命周期方法与 `componentDidUpdate()` 一起涵盖了 `componentWillReceiveProps()` 的所有用例。

    **[⬆ 返回顶部](#目录)**

77. ### 生命周期方法 `getSnapshotBeforeUpdate()` 的目的是什么?

    新的 `getSnapshotBeforeUpdate()` 生命周期方法在 DOM 更新之前被调用。此方法的返回值将作为第三个参数传递给`componentDidUpdate()`。

    ```javascript
    class MyComponent extends React.Component {
      getSnapshotBeforeUpdate(prevProps, prevState) {
        // ...
      }
    }
    ```

    此生命周期方法与 `componentDidUpdate()` 一起涵盖了 `componentWillUpdate()` 的所有用例。

    **[⬆ 返回顶部](#目录)**

78. ### createElement() 和 cloneElement() 方法有什么区别?

    JSX 元素将被转换为 `React.createElement()` 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 `cloneElement` 用于克隆元素并传递新的属性。

    **[⬆ 返回顶部](#目录)**

79. ### 推荐的组件命名方法是什么?

    建议通过引用命名组件，而不是使用 `displayName`。

    使用 `displayName` 命名组件:

    ```javascript
    export default React.createClass({
      displayName: 'TodoApp',
      // ...
    })
    ```

    推荐的方式：

    ```javascript
    export default class TodoApp extends React.Component {
      // ...
    }
    ```

    **[⬆ 返回顶部](#目录)**

80. ### 在组件类中方法的推荐顺序是什么?

    从 *mounting* 到 *render stage* 阶段推荐的方法顺序：

    1. `static` 方法
    2. `constructor()`
    3. `getChildContext()`
    4. `componentWillMount()`
    5. `componentDidMount()`
    6. `componentWillReceiveProps()`
    7. `shouldComponentUpdate()`
    8. `componentWillUpdate()`
    9. `componentDidUpdate()`
    10. `componentWillUnmount()`
    11. 点击处理程序或事件处理程序，如 `onClickSubmit()` 或 `onChangeDescription()`
    12. 用于渲染的getter方法，如 `getSelectReason()` 或 `getFooterContent()`
    13. 可选的渲染方法，如 `renderNavigation()` 或 `renderProfilePicture()`
    14. `render()`

    **[⬆ 返回顶部](#目录)**

81. ### 什么是 switching 组件?

    switching 组件是渲染多个组件之一的组件。我们需要使用对象将 prop 映射到组件中。

    例如，以下的 switching 组件将基于 `page` 属性显示不同的页面：

    ```jsx 
    import HomePage from './HomePage'
    import AboutPage from './AboutPage'
    import ServicesPage from './ServicesPage'
    import ContactPage from './ContactPage'

    const PAGES = {
      home: HomePage,
      about: AboutPage,
      services: ServicesPage,
      contact: ContactPage
    }

    const Page = (props) => {
      const Handler = PAGES[props.page] || ContactPage

      return <Handler {...props} />
    }

    // The keys of the PAGES object can be used in the prop types to catch dev-time errors.
    Page.propTypes = {
      page: PropTypes.oneOf(Object.keys(PAGES)).isRequired
    }
    ```

    **[⬆ 返回顶部](#目录)**

82. ### 为什么我们需要将函数传递给 setState() 方法?

    这背后的原因是 `setState()` 是一个异步操作。出于性能原因，React 会对状态更改进行批处理，因此在调用 `setState()` 方法之后，状态可能不会立即更改。这意味着当你调用 `setState()` 方法时，你不应该依赖当前状态，因为你不能确定当前状态应该是什么。这个问题的解决方案是将一个函数传递给 `setState()`，该函数会以上一个状态作为参数。通过这样做，你可以避免由于 `setState()` 的异步性质而导致用户在访问时获取旧状态值的问题。

    假设初始计数值为零。在连续三次增加操作之后，该值将只增加一个。

    ```javascript
    // assuming this.state.count === 0
    this.setState({ count: this.state.count + 1 })
    this.setState({ count: this.state.count + 1 })
    this.setState({ count: this.state.count + 1 })
    // this.state.count === 1, not 3
    ```

    如果将函数传递给 `setState()`，则 count 将正确递增。

    ```javascript
    this.setState((prevState, props) => ({
      count: prevState.count + props.increment
    }))
    // this.state.count === 3 as expected
    ```

    **[⬆ 返回顶部](#目录)**

83. ### 在 React 中什么是严格模式?

    `React.StrictMode` 是一个有用的组件，用于突出显示应用程序中的潜在问题。就像 `<Fragment>`，`<StrictMode>` 一样，它们不会渲染任何额外的 DOM 元素。它为其后代激活额外的检查和警告。这些检查仅适用于开发模式。

    ```jsx 
    import React from 'react'

    function ExampleApplication() {
      return (
        <div>
          <Header />
          <React.StrictMode>
            <div>
              <ComponentOne />
              <ComponentTwo />
            </div>
          </React.StrictMode>
          <Footer />
        </div>
      )
    }
    ```

    在上面的示例中，*strict mode* 检查仅应用于 `<ComponentOne>` 和 `<ComponentTwo>` 组件。

    **[⬆ 返回顶部](#目录)**

84. ### React Mixins 是什么?

    *Mixins* 是一种完全分离组件通用功能的方法。 Mixins 不应该被继续使用，可以用高阶组件或装饰器来替换。

    最常用的 mixins 是 `PureRenderMixin`。当 props 和状态与之前的 props 和状态相等时，你可能在某些组件中使用它来防止不必要的重新渲染：

    ```javascript
    const PureRenderMixin = require('react-addons-pure-render-mixin')

    const Button = React.createClass({
      mixins: [PureRenderMixin],
      // ...
    })
    ````
    <!-- TODO: mixins are deprecated -->

    **[⬆ 返回顶部](#目录)**

85. ### 为什么 `isMounted()` 是一个反模式，而正确的解决方案是什么?

    `isMounted()` 的主要场景是避免在组件卸载后调用 `setState()`，因为它会发出警告。

    ```javascript
    if (this.isMounted()) {
      this.setState({...})
    }
    ```

    在调用 `setState()` 之前检查 `isMounted()` 会消除警告，但也会破坏警告的目的。使用 `isMounted()` 有一种代码味道，因为你要检查的唯一原因是你认为在卸载组件后可能持有引用。

    最佳解决方案是找到在组件卸载后调用 `setState()` 的位置，并修复它们。这种情况最常发生在回调中，即组件正在等待某些数据并在数据到达之前卸载。理想情况下，在卸载之前，应在 `componentWillUnmount()` 中取消任何回调。

    **[⬆ 返回顶部](#目录)**

86. ### React 中支持哪些指针事件?

    *Pointer Events* 提供了处理所有输入事件的统一方法。在过去，我们有一个鼠标和相应的事件监听器来处理它们，但现在我们有许多与鼠标无关的设备，比如带触摸屏的手机或笔。我们需要记住，这些事件只能在支持 *Pointer Events* 规范的浏览器中工作。

    目前以下事件类型在 *React DOM* 中是可用的：

    1. `onPointerDown`
    2. `onPointerMove`
    3. `onPointerUp`
    4. `onPointerCancel`
    5. `onGotPointerCapture`
    6. `onLostPointerCaptur`
    7. `onPointerEnter`
    8. `onPointerLeave`
    9. `onPointerOver`
    10. `onPointerOut`

    **[⬆ 返回顶部](#目录)**

87. ### 为什么组件名称应该以大写字母开头?

    如果使用 JSX 渲染组件，则该组件的名称必须以大写字母开头，否则 React 将会抛出无法识别标签的错误。这种约定是因为只有 HTML 元素和 SVG 标签可以以小写字母开头。

    定义组件类的时候，你可以以小写字母开头，但在导入时应该使用大写字母。

    ```jsx 
    class myComponent extends Component {
      render() {
        return <div />
      }
    }

    export default myComponent
    ```

    当在另一个文件导入时，应该以大写字母开头：

    ```jsx 
    import MyComponent from './MyComponent'
    ```

    **[⬆ 返回顶部](#目录)**

88. ### 在 React v16 中是否支持自定义 DOM 属性?

    是的，在过去 React 会忽略未知的 DOM 属性。如果你编写的 JSX 属性 React 无法识别，那么 React 将跳过它。例如：

    ```jsx 
    <div mycustomattribute={'something'} />
    ```

    在 React 15 中将在 DOM 中渲染一个空的 div：

    ```html
    <div />
    ```

    在 React 16 中，任何未知的属性都将会在 DOM 显示：

    ```html
    <div mycustomattribute='something' />
    ```

    这对于应用特定于浏览器的非标准属性，尝试新的 DOM APIs 与集成第三方库来说非常有用。

    **[⬆ 返回顶部](#目录)**

89. ### constructor 和 getInitialState 有什么区别?

    当使用 ES6 类时，你应该在构造函数中初始化状态，而当你使用 `React.createClass()` 时，就需要使用 `getInitialState()` 方法。

    使用 ES6 类:

    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
        this.state = { /* initial state */ }
      }
    }
    ```

    使用 `React.createClass()`:

    ```javascript
    const MyComponent = React.createClass({
      getInitialState() {
        return { /* initial state */ }
      }
    })
    ```

    **注意：** 在 React v16 中 `React.createClass()` 已被弃用和删除，请改用普通的 JavaScript 类。

    **[⬆ 返回顶部](#目录)**

90. ### 是否可以在不调用 setState 方法的情况下，强制组件重新渲染?

    默认情况下，当组件的状态或属性改变时，组件将重新渲染。如果你的 `render()` 方法依赖于其他数据，你可以通过调用 `forceUpdate()` 来告诉 React，当前组件需要重新渲染。

    ```javascript
    component.forceUpdate(callback)
    ```

    建议避免使用 `forceUpdate()`，并且只在 `render()` 方法中读取 `this.props` 和 `this.state`。

    **[⬆ 返回顶部](#目录)**

91. ### 在使用 ES6 类的 React 中 `super()` 和 `super(props)` 有什么区别?

    当你想要在 `constructor()` 函数中访问 `this.props`，你需要将 props 传递给 `super()` 方法。

    使用 `super(props)`:

    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
        console.log(this.props) // { name: 'John', ... }
      }
    }
    ```

    使用 `super()`:

    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super()
        console.log(this.props) // undefined
      }
    }
    ```

    在 `constructor()` 函数之外，访问 `this.props` 属性会显示相同的值。

    阅读资源：

    1. [为什么我们要写 super(props)？](https://overreacted.io/zh-hans/why-do-we-write-super-props/)

    **[⬆ 返回顶部](#目录)**

92. ### 在 JSX 中如何进行循环?

    你只需使用带有 ES6 箭头函数语法的 `Array.prototype.map` 即可。例如，`items` 对象数组将会被映射成一个组件数组：

    ```jsx 
    <tbody>
      {items.map(item => <SomeComponent key={item.id} name={item.name} />)}
    </tbody>
    ```

    你不能使用 `for` 循环进行迭代：

    ```jsx 
    <tbody>
      for (let i = 0; i < items.length; i++) {
        <SomeComponent key={items[i].id} name={items[i].name} />
      }
    </tbody>
    ```

    这是因为 JSX 标签会被转换成函数调用，并且你不能在表达式中使用语句。但这可能会由于 `do` 表达式而改变，它们是第一阶段提案。

    **[⬆ 返回顶部](#目录)**

93. ### 如何在 attribute 引号中访问 props 属性?

    React (或 JSX) 不支持属性值内的变量插值。下面的形式将不起作用：

    ```jsx
    <img className='image' src='images/{this.props.image}' />
    ```

    但你可以将 JS 表达式作为属性值放在大括号内。所以下面的表达式是有效的：

    ```jsx
    <img className='image' src={'images/' + this.props.image} />
    ```

    使用模板字符串也是可以的：

    ```jsx
    <img className='image' src={`images/${this.props.image}`} />
    ```

    **[⬆ 返回顶部](#目录)**

94. ### 什么是 React proptype 数组?

    如果你要规范具有特定对象格式的数组的属性，请使用 `React.PropTypes.shape()` 作为 `React.PropTypes.arrayOf()` 的参数。

    ```javascript
    ReactComponent.propTypes = {
      arrayWithShape: React.PropTypes.arrayOf(React.PropTypes.shape({
        color: React.PropTypes.string.isRequired,
        fontSize: React.PropTypes.number.isRequired
      })).isRequired
    }
    ```

    **[⬆ 返回顶部](#目录)**

95. ### 如何有条件地应用样式类?

    你不应该在引号内使用大括号，因为它将被计算为字符串。

    ```jsx 
    <div className="btn-panel {this.props.visible ? 'show' : 'hidden'}">
    ```

    相反，你需要将大括号移到外部（不要忘记在类名之间添加空格）：

    ```jsx 
    <div className={'btn-panel ' + (this.props.visible ? 'show' : 'hidden')}>
    ```

    模板字符串也可以工作：

    ```jsx 
    <div className={`btn-panel ${this.props.visible ? 'show' : 'hidden'}`}>
    ```

    **[⬆ 返回顶部](#目录)**

96. ### React 和 ReactDOM 之间有什么区别?

    `react` 包中包含 `React.createElement()`, `React.Component`, `React.Children`，以及与元素和组件类相关的其他帮助程序。你可以将这些视为构建组件所需的同构或通用帮助程序。`react-dom` 包中包含了 `ReactDOM.render()`，在 `react-dom/server` 包中有支持服务端渲染的 `ReactDOMServer.renderToString()` 和 `ReactDOMServer.renderToStaticMarkup()` 方法。

    **[⬆ 返回顶部](#目录)**

97. ### 为什么 ReactDOM 从 React 分离出来?

    React 团队致力于将所有的与 DOM 相关的特性抽取到一个名为 ReactDOM 的独立库中。React v0.14 是第一个拆分后的版本。通过查看一些软件包，`react-native`，`react-art`，`react-canvas`，和 `react-three`，很明显，React 的优雅和本质与浏览器或 DOM 无关。为了构建更多 React 能应用的环境，React 团队计划将主要的 React 包拆分成两个：`react` 和 `react-dom`。这为编写可以在 React 和 React Native 的 Web 版本之间共享的组件铺平了道路。

    **[⬆ 返回顶部](#目录)**

98. ### 如何使用 React label 元素?

    如果你尝试使用标准的 `for` 属性将 `<label>` 元素绑定到文本输入框，那么在控制台将会打印缺少 HTML 属性的警告消息。

    ```jsx 
    <label for={'user'}>{'User'}</label>
    <input type={'text'} id={'user'} />
    ```

    因为 `for` 是 JavaScript 的保留字，请使用 `htmlFor` 来替代。

    ```jsx 
    <label htmlFor={'user'}>{'User'}</label>
    <input type={'text'} id={'user'} />
    ```

    **[⬆ 返回顶部](#目录)**

99. ### 如何合并多个内联的样式对象?

    在 React 中，你可以使用扩展运算符:

    ```jsx 
     <button style=`{{...styles.panel.button, ...styles.panel.submitButton}}`>{'Submit'}</button>
    ```

    如果你使用的是 React Native，则可以使用数组表示法：

    ```jsx 
    <button style={[styles.panel.button, styles.panel.submitButton]}>{'Submit'}</button>
    ```

    **[⬆ 返回顶部](#目录)**

100. ### 如何在调整浏览器大小时重新渲染视图?

     你可以在 `componentDidMount()` 中监听 `resize` 事件，然后更新尺寸（`width` 和 `height`）。你应该在 `componentWillUnmount()` 方法中移除监听。

     ```javascript
     class WindowDimensions extends React.Component {
       componentWillMount() {
         this.updateDimensions()
       }

       componentDidMount() {
         window.addEventListener('resize', this.updateDimensions)
       }

       componentWillUnmount() {
         window.removeEventListener('resize', this.updateDimensions)
       }

       updateDimensions() {
         this.setState({width: $(window).width(), height: $(window).height()})
       }

       render() {
         return <span>{this.state.width} x {this.state.height}</span>
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

101. ### `setState()` 和 `replaceState()` 方法之间有什么区别?

     当你使用 `setState()` 时，当前和先前的状态将被合并。`replaceState()` 会抛出当前状态，并仅用你提供的内容替换它。通常使用 `setState()`，除非你出于某种原因确实需要删除所有以前的键。你还可以在 `setState()` 中将状态设置为 `false`/`null`，而不是使用 `replaceState()`。

     **[⬆ 返回顶部](#目录)**

102. ### 如何监听状态变化?

     当状态更改时将调用以下生命周期方法。你可以将提供的状态和属性值与当前状态和属性值进行比较，以确定是否发生了有意义的改变。

     ```
     componentWillUpdate(object nextProps, object nextState)
     componentDidUpdate(object prevProps, object prevState)
     ```

     **[⬆ 返回顶部](#目录)**


103. ### 在 React 状态中删除数组元素的推荐方法是什么?

     更好的方法是使用 `Array.prototype.filter()` 方法。

     例如，让我们创建用于更新状态的 `removeItem()` 方法。

     ```javascript
     removeItem(index) {
       this.setState({
         data: this.state.data.filter((item, i) => i !== index)
       })
     }
     ```

     **[⬆ 返回顶部](#目录)**

104. ### 在 React 中是否可以不在页面上渲染 HTML 内容?

     可以使用最新的版本 (>=16.2)，以下是可能的选项：

     ```jsx 
     render() {
       return false
     }
     ```

     ```jsx 
     render() {
       return null
     }
     ```

     ```jsx 
     render() {
       return []
     }
     ```

     ```jsx 
     render() {
       return <React.Fragment></React.Fragment>
     }
     ```

     ```jsx 
     render() {
       return <></>
     }
     ```

     返回 `undefined` 是无效的。

     **[⬆ 返回顶部](#目录)**

105. ### 如何用 React 漂亮地显示 JSON?

     我们可以使用 `<pre>` 标签，以便保留 `JSON.stringify()` 的格式：


     ```jsx 
     const data = { name: 'John', age: 42 }
    
     class User extends React.Component {
       render() {
         return (
           <pre>
             {JSON.stringify(data, null, 2)}
           </pre>
         )
       }
     }
    
     React.render(<User />, document.getElementById('container'))
     ```
    
     **[⬆ 返回顶部](#目录)**

106. ### 为什么你不能更新 React 中的 props?

     React 的哲学是 props 应该是 *immutable* 和 *top-down*。这意味着父级可以向子级发送任何属性值，但子级不能修改接收到的属性。

     **[⬆ 返回顶部](#目录)**

107. ### 如何在页面加载时聚焦一个输入元素?

     你可以为 `input` 元素创建一个 `ref`，然后在 `componentDidMount()` 方法中使用它：

     ```jsx 
     class App extends React.Component{
       componentDidMount() {
         this.nameInput.focus()
       }

       render() {
         return (
           <div>
             <input
               defaultValue={'Won\'t focus'}
             />
             <input
               ref={(input) => this.nameInput = input}
               defaultValue={'Will focus'}
             />
           </div>
         )
       }
     }

     ReactDOM.render(<App />, document.getElementById('app'))
     ```

     **[⬆ 返回顶部](#目录)**

108. ### 更新状态中的对象有哪些可能的方法?

     1. 用一个对象调用 `setState()` 来与状态合并：

         * 使用 `Object.assign()` 创建对象的副本：

             ```javascript
             const user = Object.assign({}, this.state.user, { age: 42 })
             this.setState({ user })
             ```

         * 使用扩展运算符：

             ```javascript
             const user = { ...this.state.user, age: 42 }
             this.setState({ user })
             ```

     2. 使用一个函数调用 `setState()`：

         ```javascript
         this.setState(prevState => ({
           user: {
             ...prevState.user,
             age: 42
           }
         }))
         ```

      **[⬆ 返回顶部](#目录)**

109. ### 为什么函数比对象更适合于 `setState()`?

     出于性能考虑，React 可能将多个 `setState()` 调用合并成单个更新。这是因为我们可以异步更新 `this.props` 和 `this.state`，所以不应该依赖它们的值来计算下一个状态。

     以下的 counter 示例将无法按预期更新：

     ```javascript
     // Wrong
     this.setState({
       counter: this.state.counter + this.props.increment,
     })
     ```

     首选方法是使用函数而不是对象调用 `setState()`。该函数将前一个状态作为第一个参数，当前时刻的 props 作为第二个参数。

     ```javascript
     // Correct
     this.setState((prevState, props) => ({
       counter: prevState.counter + props.increment
     }))
     ```

     **[⬆ 返回顶部](#目录)**

110. ### 我们如何在浏览器中找到当前正在运行的 React 版本?

     你可以使用 `React.version` 来获取版本：

     ```jsx 
     const REACT_VERSION = React.version

     ReactDOM.render(
       <div>{`React version: ${REACT_VERSION}`}</div>,
       document.getElementById('app')
     )
     ```

     **[⬆ 返回顶部](#目录)**

111. ### 在 `create-react-app` 项目中导入 polyfills 的方法有哪些?

     1. **从 `core-js` 中手动导入:**

         创建一个名为 `polyfills.js` 文件，并在根目录下的 `index.js` 文件中导入它。运行 `npm install core-js` 或 `yarn add core-js` 并导入你所需的功能特性：

         ```javascript
         import 'core-js/fn/array/find'
         import 'core-js/fn/array/includes'
         import 'core-js/fn/number/is-nan'
         ```

     2. **使用 Polyfill 服务:**

         通过将以下内容添加到 `index.html` 中来获取自定义的特定于浏览器的 polyfill：

         ```html
         <script src='https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'></script>
         ```

         在上面的脚本中，我们必须显式地请求 `Array.prototype.includes` 特性，因为它没有被包含在默认的特性集中。

     **[⬆ 返回顶部](#目录)**

112. ### 如何在 create-react-app 中使用 https 而不是 http?

     你只需要使用 `HTTPS=true` 配置。你可以编辑 `package.json` 中的 scripts 部分：

     ```json
     "scripts": {
       "start": "set HTTPS=true && react-scripts start"
     }
     ```

     或直接运行 `set HTTPS=true && npm start`

     **[⬆ 返回顶部](#目录)**

113. ### 如何避免在 create-react-app 中使用相对路径导入?

     在项目的根目录中创建一个名为 `.env` 的文件，并写入导入路径：

     ```
     NODE_PATH=src/app
     ```

     然后重新启动开发服务器。现在，你应该能够在没有相对路径的情况下导入 `src/app` 内的任何内容。

     **[⬆ 返回顶部](#目录)**

114. ### 如何为 React Router 添加 Google Analytics?

     在 `history` 对象上添加一个监听器以记录每个页面的访问：

     ```javascript
     history.listen(function (location) {
       window.ga('set', 'page', location.pathname + location.search)
       window.ga('send', 'pageview', location.pathname + location.search)
     })
     ```

     **[⬆ 返回顶部](#目录)**

115. ### 如何每秒更新一个组件?

     你需要使用 `setInterval()` 来触发更改，但也需要在组件卸载时清除计时器，以防止错误和内存泄漏。

     ```javascript
     componentDidMount() {
       this.interval = setInterval(() => this.setState({ time: Date.now() }), 1000)
     }

     componentWillUnmount() {
       clearInterval(this.interval)
     }
     ```

     **[⬆ 返回顶部](#目录)**

116. ### 如何将 vendor prefixes 应用于 React 中的内联样式?

     React不会自动应用 *vendor prefixes*，你需要手动添加 *vendor prefixes*。

     ```jsx 
     <div style=`{{
       transform: 'rotate(90deg)',
       WebkitTransform: 'rotate(90deg)', // note the capital 'W' here
       msTransform: 'rotate(90deg)' // 'ms' is the only lowercase vendor prefix
     }} `/>
     ```

     **[⬆ 返回顶部](#目录)**

117. ### 如何使用 React 和 ES6 导入和导出组件?

     导出组件时，你应该使用默认导出：

     ```jsx 
     import React from 'react'
     import User from 'user'

     export default class MyProfile extends React.Component {
       render(){
         return (
           <User type="customer">
             //...
           </User>
         )
       }
     }
     ```

     使用 export 说明符，MyProfile 将成为成员并导出到此模块，此外在其他组件中你无需指定名称就可以导入相同的内容。

     **[⬆ 返回顶部](#目录)**

118. ### 为什么 React 组件名称必须以大写字母开头?

     在 JSX 中，小写标签被认为是 HTML 标签。但是，含有 `.` 的大写和小写标签名却不是。

     1. `<component />` 将被转换为 `React.createElement('component')` (i.e, HTML 标签)
     2. `<obj.component />` 将被转换为 `React.createElement(obj.component)`
     3. `<Component />` 将被转换为 `React.createElement(Component)`

     **[⬆ 返回顶部](#目录)**

119. ### 为什么组件的构造函数只被调用一次?

     React 协调算法假设如果自定义组件出现在后续渲染的相同位置，则它与之前的组件相同，因此重用前一个实例而不是创建新实例。

     **[⬆ 返回顶部](#目录)**

120. ### 在 React 中如何定义常量?

     你可以使用 ES7 的 `static` 来定义常量。

     ```javascript
     class MyComponent extends React.Component {
       static DEFAULT_PAGINATION = 10
     }
     ```

     **[⬆ 返回顶部](#目录)**

121. ### 在 React 中如何以编程方式触发点击事件?

     你可以使用 ref 属性通过回调函数获取对底层的 `HTMLinputeElement` 对象的引用，并将该引用存储为类属性，之后你就可以利用该引用在事件回调函数中， 使用 `HTMLElement.click` 方法触发一个点击事件。这可以分为两个步骤：

     1. 在 render 方法创建一个 ref：

         ```jsx 
         <input ref={input => this.inputElement = input} />
         ```

     2. 在事件处理器中触发点击事件

         ```javascript
         this.inputElement.click()
         ```

     **[⬆ 返回顶部](#目录)**

122. ### 在 React 中是否可以使用 async/await?

     如果要在 React 中使用 `async`/`await`，则需要 *Babel* 和 [transform-async-to-generator](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator) 插件。

     **[⬆ 返回顶部](#目录)**

123. ### React 项目常见的文件结构是什么?

     React 项目文件结构有两种常见的实践。

     1. **按功能或路由分组:**

         构建项目的一种常见方法是将 CSS，JS 和测试用例放在一起，按功能或路由分组。

         ```
         common/
         ├─ Avatar.js
         ├─ Avatar.css
         ├─ APIUtils.js
         └─ APIUtils.test.js
         feed/
         ├─ index.js
         ├─ Feed.js
         ├─ Feed.css
         ├─ FeedStory.js
         ├─ FeedStory.test.js
         └─ FeedAPI.js
         profile/
         ├─ index.js
         ├─ Profile.js
         ├─ ProfileHeader.js
         ├─ ProfileHeader.css
         └─ ProfileAPI.js
         ```

     2. **按文件类型分组:**

         另一种流行的项目结构组织方法是将类似的文件组合在一起。

         ```
         api/
         ├─ APIUtils.js
         ├─ APIUtils.test.js
         ├─ ProfileAPI.js
         └─ UserAPI.js
         components/
         ├─ Avatar.js
         ├─ Avatar.css
         ├─ Feed.js
         ├─ Feed.css
         ├─ FeedStory.js
         ├─ FeedStory.test.js
         ├─ Profile.js
         ├─ ProfileHeader.js
         └─ ProfileHeader.css
         ```

     **[⬆ 返回顶部](#目录)**

124. ### 最流行的动画软件包是什么?

     *React Transition Group* 和 *React Motion* 是React生态系统中流行的动画包。

     **[⬆ 返回顶部](#目录)**

125. ### 模块化样式文件有什么好处?

     建议避免在组件中对样式值进行硬编码。任何可能在不同的 UI 组件之间使用的值都应该提取到它们自己的模块中。

     例如，可以将这些样式提取到单独的组件中：

     ```javascript
     export const colors = {
       white,
       black,
       blue
     }

     export const space = [
       0,
       8,
       16,
       32,
       64
     ]
     ```

     然后在其他组件中单独导入：

     ```javascript
     import { space, colors } from './styles'
     ```

     **[⬆ 返回顶部](#目录)**


126. ### 什么是 React 流行的特定 linters?

     ESLint 是一个流行的 JavaScript linter。有一些插件可以分析特定的代码样式。在 React 中最常见的一个是名为 `eslint-plugin-react` npm 包。默认情况下，它将使用规则检查许多最佳实践，检查内容从迭代器中的键到一组完整的 prop 类型。另一个流行的插件是 `eslint-plugin-jsx-a11y`，它将帮助修复可访问性的常见问题。由于 JSX 提供的语法与常规 HTML 略有不同，因此常规插件无法获取 `alt` 文本和 `tabindex` 的问题。

     **[⬆ 返回顶部](#目录)**

127. ### 如何发起 AJAX 调用以及应该在哪些组件生命周期方法中进行 AJAX 调用?

     你可以使用 AJAX 库，如 Axios，jQuery AJAX 和浏览器内置的 `fetch` API。你应该在 `componentDidMount()` 生命周期方法中获取数据。这样当获取到数据的时候，你就可以使用 `setState()` 方法来更新你的组件。

     例如，从 API 中获取员工列表并设置本地状态：

     ```jsx 
     class MyComponent extends React.Component {
       constructor(props) {
         super(props)
         this.state = {
           employees: [],
           error: null
         }
       }

       componentDidMount() {
         fetch('https://api.example.com/items')
           .then(res => res.json())
           .then(
             (result) => {
               this.setState({
                 employees: result.employees
               })
             },
             (error) => {
               this.setState({ error })
             }
           )
       }

       render() {
         const { error, employees } = this.state
         if (error) {
           return <div>Error: {error.message}</div>;
         } else {
           return (
             <ul>
               {employees.map(item => (
                 <li key={employee.name}>
                   {employee.name}-{employees.experience}
                 </li>
               ))}
             </ul>
           )
         }
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

128. ### 什么是渲染属性?

     **Render Props** 是一种简单的技术，用于使用值为函数的 prop 属性在组件之间共享代码。下面的组件使用返回 React 元素的 render 属性：

     ```jsx 
     <DataProvider render={data => (
       <h1>{`Hello ${data.target}`}</h1>
     )}/>
     ```

     像 React Router 和 DownShift 这样的库使用了这种模式。

     **[⬆ 返回顶部](#目录)**

## React Router

129. ### 什么是 React Router?

     React Router 是一个基于 React 之上的强大路由库，可以帮助您快速地向应用添加视图和数据流，同时保持 UI 与 URL 同步。

     **[⬆ 返回顶部](#目录)**

130. ### React Router 与 history 库的区别?

     React Router 是`history`库的包装器，它处理浏览器的`window.history`与浏览器和哈希历史的交互。它还提供了内存历史记录，这对于没有全局历史记录的环境非常有用，例如移动应用程序开发（React Native）和使用 Node 进行单元测试。

     **[⬆ 返回顶部](#目录)**

131. ### 在 React Router v4 中的`<Router>`组件是什么?

     React Router v4 提供了以下三种类型的 `<Router>` 组件:

     1. `<BrowserRouter>`
     2. `<HashRouter>`
     3. `<MemoryRouter>`

     以上组件将创建*browser*，*hash*和*memory*的 history 实例。React Router v4 通过`router`对象中的上下文使与您的路由器关联的`history`实例的属性和方法可用。

     **[⬆ 返回顶部](#目录)**

132. ### `history` 中的 `push()` 和 `replace()` 方法的目的是什么?

     一个 history 实例有两种导航方法：

     1. `push()`
     2. `replace()`

     如果您将 history 视为一个访问位置的数组，则`push()`将向数组添加一个新位置，`replace()`将用新的位置替换数组中的当前位置。

     **[⬆ 返回顶部](#目录)**

133. ### 如何使用在 React Router v4 中以编程的方式进行导航?

     在组件中实现操作路由/导航有三种不同的方法。

     1. **使用`withRouter()`高阶函数：**

         `withRouter()`高阶函数将注入 history 对象作为组件的 prop。该对象提供了`push()`和`replace()`方法，以避免使用上下文。

         ```jsx 
         import { withRouter } from 'react-router-dom' // this also works with 'react-router-native'

         const Button = withRouter(({ history }) => (
           <button
             type='button'
             onClick=`{() => { history.push('/new-location') }}`
           >
             {'Click Me!'}
           </button>
         ))
         ```

     2. **使用`<Route>`组件和渲染属性模式：**

         `<Route>`组件传递与`withRouter()`相同的属性，因此您将能够通过 history 属性访问到操作历史记录的方法。

         ```jsx 
         import { Route } from 'react-router-dom'

         const Button = () => (
           <Route render={({ history }) => (
             <button
               type='button'
               onClick={() => { history.push('/new-location') }}
             >
               {'Click Me!'}
             </button>
           )} />
         )
         ```

     3. **使用上下文:**

         建议不要使用此选项，并将其视为不稳定的API。

         ```jsx 
         const Button = (props, context) => (
           <button
             type='button'
             onClick={() => {
               context.history.push('/new-location')
             }}
           >
             {'Click Me!'}
           </button>
         )

         Button.contextTypes = {
           history: React.PropTypes.shape({
             push: React.PropTypes.func.isRequired
           })
         }
         ```

     **[⬆ 返回顶部](#目录)**

134. ### 如何在 React Router v4 中获取查询字符串参数?

     在 React Router v4 中并没有内置解析查询字符串的能力，因为多年来一直有用户希望支持不同的实现。因此，使用者可以选择他们喜欢的实现方式。建议的方法是使用 [query-string](https://www.npmjs.com/package/query-string) 库。

     ```javascript
     const queryString = require('query-string');
     const parsed = queryString.parse(props.location.search);
     ```

     如果你想要使用原生 API 的话，你也可以使用 `URLSearchParams` ：

     ```javascript
     const params = new URLSearchParams(props.location.search)
     const foo = params.get('name')
     ```

     如果使用 `URLSearchParams` 的话您应该为 IE11 使用*polyfill*。

     **[⬆ 返回顶部](#目录)**

135. ### 为什么你会得到 "Router may have only one child element" 警告?

     此警告的意思是`Router`组件下仅能包含一个子节点。

     你必须将你的 Route 包装在`<Switch>`块中，因为`<Switch>`是唯一的，它只提供一个路由。

     首先，您需要在导入中添加`Switch`：

     ```javascript
     import { Switch, Router, Route } from 'react-router'
     ```

     然后在`<Switch>`块中定义路由：

     ```jsx 
     <Router>
       <Switch>
         <Route {/* ... */} />
         <Route {/* ... */} />
       </Switch>
     </Router>
     ```

     **[⬆ 返回顶部](#目录)**

136. ### 如何在 React Router v4 中将 params 传递给 `history.push` 方法?

     在导航时，您可以将 props 传递给`history`对象：

     ```javascript
     this.props.history.push({
       pathname: '/template',
       search: '?name=sudheer',
       state: { detail: response.data }
     })
     ```

     `search`属性用于在`push()`方法中传递查询参数。

     **[⬆ 返回顶部](#目录)**

137. ### 如何实现默认页面或 404 页面?

     `<Switch>`呈现匹配的第一个孩子`<Route>`。 没有路径的`<Route>`总是匹配。所以你只需要简单地删除 path 属性，如下所示：

     ```jsx 
     <Switch>
       <Route exact path="/" component={Home}/>
       <Route path="/user" component={User}/>
       <Route component={NotFound} />
     </Switch>
     ```

     **[⬆ 返回顶部](#目录)**

138. ### 如何在 React Router v4 上获取历史对象?

     1. 创建一个导出`history`对象的模块，并在整个项目中导入该模块。

         例如， 创建`history.js`文件:

         ```javascript
         import { createBrowserHistory } from 'history'

         export default createBrowserHistory({
           /* pass a configuration object here if needed */
         })
         ```

     2. 您应该使用`<Router>`组件而不是内置路由器。在`index.js`文件中导入上面的`history.js`：

         ```jsx 
         import { Router } from 'react-router-dom'
         import history from './history'
         import App from './App'

         ReactDOM.render((
           <Router history={history}>
             <App />
           </Router>
         ), holder)
         ```

     3. 您还可以使用类似于内置历史对象的`history`对象的push方法：

         ```javascript
         // some-other-file.js
         import history from './history'

         history.push('/go-here')
         ```

     **[⬆ 返回顶部](#目录)**

139. ### 登录后如何执行自动重定向?

     `react-router`包在 React Router 中提供了`<Redirect>`组件。渲染`<Redirect>`将导航到新位置。与服务器端重定向一样，新位置将覆盖历史堆栈中的当前位置。

     ```javascript
     import React, { Component } from 'react'
     import { Redirect } from 'react-router'

     export default class LoginComponent extends Component {
       render() {
         if (this.state.isLoggedIn === true) {
           return <Redirect to="/your/redirect/page" />
         } else {
           return <div>{'Login Please'}</div>
         }
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

## React Internationalization

140. ### 什么是 React Intl?

     [React Intl](https://github.com/yahoo/react-intl)库使 React 中的内部化变得简单，使用现成的组件和 API ，可以处理从格式化字符串，日期和数字到复数的所有功能。React Intl 是[FormatJS](http://formatjs.io/)的一部分，它通过其组件和 API 提供与 React 的绑定。

     **[⬆ 返回顶部](#目录)**

141. ### React Intl 的主要特性是什么?

     1. 用分隔符显示数字
     2. 正确显示日期和时间
     3. 显示相对于“现在”的日期
     4. 将标签转换为字符串
     5. 支持 150 多种语言
     6. 支持在浏览器和 Node 中运行
     7. 建立在标准之上

     **[⬆ 返回顶部](#目录)**

142. ### 在 React Intl 中有哪两种格式化方式?

     该库提供了两种格式化字符串，数字和日期的方法：React 组件或 API。

     ```jsx
     <FormattedMessage
       id={'account'}
       defaultMessage={'The amount is less than minimum balance.'}
     />
     ```

     ```javascript
     const messages = defineMessages({
       accountMessage: {
         id: 'account',
         defaultMessage: 'The amount is less than minimum balance.',
       }
     })

     formatMessage(messages.accountMessage)
     ```

     **[⬆ 返回顶部](#目录)**

143. ### 在 React Intl 中如何使用`<FormattedMessage>`作为占位符使用?

     `react-intl`的`<Formatted ... />`组件返回元素，而不是纯文本，因此它们不能用于占位符，替代文本等。在这种情况下，您应该使用较低级别的 API `formatMessage()`。您可以使用`injectIntl()`高阶函数将`intl`对象注入到组件中，然后使用该对象上使用`formatMessage()`格式化消息。

     ```jsx
     import React from 'react'
     import { injectIntl, intlShape } from 'react-intl'

     const MyComponent = ({ intl }) => {
       const placeholder = intl.formatMessage({id: 'messageId'})
       return <input placeholder={placeholder} />
     }

     MyComponent.propTypes = {
       intl: intlShape.isRequired
     }

     export default injectIntl(MyComponent)
     ```

     **[⬆ 返回顶部](#目录)**

144. ### 如何使用 React Intl 访问当前语言环境?

     您可以在应用的任何组件中使用`injectIntl()`获取的当前语言环境：

     ```jsx 
     import { injectIntl, intlShape } from 'react-intl'

     const MyComponent = ({ intl }) => (
       <div>{`The current locale is ${intl.locale}`}</div>
     )

     MyComponent.propTypes = {
       intl: intlShape.isRequired
     }

     export default injectIntl(MyComponent)
     ```

     **[⬆ 返回顶部](#目录)**

145. ### 如何使用 React Intl 格式化日期?

     `injectIntl()`高阶组件将允许您通过组件中的 props 访问`formatDate()`方法。 该方法由`FormattedDate`实例在内部使用，它返回格式化日期的字符串表示。

     ```jsx 
     import { injectIntl, intlShape } from 'react-intl'

     const stringDate = this.props.intl.formatDate(date, {
       year: 'numeric',
       month: 'numeric',
       day: 'numeric'
     })

     const MyComponent = ({intl}) => (
       <div>{`The formatted date is ${stringDate}`}</div>
     )

     MyComponent.propTypes = {
       intl: intlShape.isRequired
     }

     export default injectIntl(MyComponent)
     ```

     **[⬆ 返回顶部](#目录)**

## React Testing

146. ### 在 React 测试中什么是浅层渲染（Shallow Renderer）?

     *浅层渲染*对于在 React 中编写单元测试用例很有用。它允许您渲染一个*一级深的组件*并断言其渲染方法返回的内容，而不必担心子组件未实例化或渲染。

     例如，如果您有以下组件：

     ```javascript
     function MyComponent() {
       return (
         <div>
           <span className={'heading'}>{'Title'}</span>
           <span className={'description'}>{'Description'}</span>
         </div>
       )
     }
     ```

     然后你可以如下断言：

     ```jsx 
     import ShallowRenderer from 'react-test-renderer/shallow'

     // in your test
     const renderer = new ShallowRenderer()
     renderer.render(<MyComponent />)

     const result = renderer.getRenderOutput()

     expect(result.type).toBe('div')
     expect(result.props.children).toEqual([
       <span className={'heading'}>{'Title'}</span>,
       <span className={'description'}>{'Description'}</span>
     ])
     ```

     **[⬆ 返回顶部](#目录)**

147. ### 在 React 中 `TestRenderer` 包是什么?

     此包提供了一个渲染器，可用于将组件渲染为纯 JavaScript 对象，而不依赖于 DOM 或原生移动环境。该包可以轻松获取由 ReactDOM 或 React Native 平台所渲染的视图层次结构（类似于DOM树）的快照，而无需使用浏览器或`jsdom`。

     ```jsx 
     import TestRenderer from 'react-test-renderer'

     const Link = ({page, children}) => <a href={page}>{children}</a>

     const testRenderer = TestRenderer.create(
       <Link page={'https://www.facebook.com/'}>{'Facebook'}</Link>
     )

     console.log(testRenderer.toJSON())
     // {
     //   type: 'a',
     //   props: { href: 'https://www.facebook.com/' },
     //   children: [ 'Facebook' ]
     // }
     ```

     **[⬆ 返回顶部](#目录)**

148. ### ReactTestUtils 包的目的是什么?

     *ReactTestUtils*由`with-addons`包提供，允许您对模拟 DOM 执行操作以进行单元测试。

     **[⬆ 返回顶部](#目录)**

149. ### 什么是 Jest?

     *Jest*是一个由 Facebook 基于 Jasmine 创建的 JavaScript 单元测试框架，提供自动模拟创建和`jsdom`环境。它通常用于测试组件。

     **[⬆ 返回顶部](#目录)**

150. ### Jest 对比 Jasmine 有什么优势?

     与 Jasmine 相比，有几个优点： 

     - 自动查找在源代码中要执行测试。
     - 在运行测试时自动模拟依赖项。
     - 允许您同步测试异步代码。
     - 使用假的 DOM 实现（通过`jsdom`）运行测试，以便可以在命令行上运行测试。
     - 在并行流程中运行测试，以便更快完成。

     **[⬆ 返回顶部](#目录)**

151. ### 举一个简单的 Jest 测试用例

     让我们为`sum.js`文件中添加两个数字的函数编写一个测试：

     ```javascript
     const sum = (a, b) => a + b

     export default sum
     ```

     创建一个名为`sum.test.js`的文件，其中包含实际测试：

     ```javascript
     import sum from './sum'

     test('adds 1 + 2 to equal 3', () => {
       expect(sum(1, 2)).toBe(3)
     })
     ```

     然后将以下部分添加到`package.json`：

     ```json
     {
       "scripts": {
         "test": "jest"
       }
     }
     ```

     最后，运行`yarn test`或`npm test`，Jest 将打印结果：

     ```console
     $ yarn test
     PASS ./sum.test.js
     ✓ adds 1 + 2 to equal 3 (2ms)
     ```

     **[⬆ 返回顶部](#目录)**

## React Redux

152. ### 什么是 Flux?

     *Flux* 是*应用程序设计范例*，用于替代更传统的 MVC 模式。它不是一个框架或库，而是一种新的体系结构，它补充了 React 和单向数据流的概念。在使用 React 时，Facebook 会在内部使用此模式。

     在 dispatcher，stores 和视图组件具有如下不同的输入和输出：

     ![flux](images/flux.png)

     **[⬆ 返回顶部](#目录)**

153. ### 什么是 Redux?

     *Redux* 是基于 *Flux设计模式* 的 JavaScript 应用程序的可预测状态容器。Redux 可以与 React 一起使用，也可以与任何其他视图库一起使用。它很小（约2kB）并且没有依赖性。

     **[⬆ 返回顶部](#目录)**

154. ### Redux 的核心原则是什么？?

     Redux 遵循三个基本原则：

     1. **单一数据来源：** 整个应用程序的状态存储在单个对象树中。单状态树可以更容易地跟踪随时间的变化并调试或检查应用程序。
     2. **状态是只读的：** 改变状态的唯一方法是发出一个动作，一个描述发生的事情的对象。这可以确保视图和网络请求都不会直接写入状态。
     3. **使用纯函数进行更改：** 要指定状态树如何通过操作进行转换，您可以编写reducers。Reducers 只是纯函数，它将先前的状态和操作作为参数，并返回下一个状态。

     **[⬆ 返回顶部](#目录)**

155. ### 与 Flux 相比，Redux 的缺点是什么?

     我们应该说使用 Redux 而不是 Flux 几乎没有任何缺点。这些如下：

     1. **您将需要学会避免突变：** Flux 对变异数据毫不吝啬，但 Redux 不喜欢突变，许多与 Redux 互补的包假设您从不改变状态。您可以使用 dev-only 软件包强制执行此操作，例如`redux-immutable-state-invariant`，Immutable.js，或指示您的团队编写非变异代码。
     2. **您将不得不仔细选择您的软件包：** 虽然 Flux 明确没有尝试解决诸如撤消/重做，持久性或表单之类的问题，但 Redux 有扩展点，例如中间件和存储增强器，以及它催生了丰富的生态系统。
     3. **还没有很好的 Flow 集成：** Flux 目前可以让你做一些非常令人印象深刻的静态类型检查，Redux 还不支持。

     **[⬆ 返回顶部](#目录)**

156. ### `mapStateToProps()` 和 `mapDispatchToProps()` 之间有什么区别?

     `mapStateToProps()`是一个实用方法，它可以帮助您的组件获得最新的状态（由其他一些组件更新）：

     ```javascript
     const mapStateToProps = (state) => {
       return {
         todos: getVisibleTodos(state.todos, state.visibilityFilter)
       }
     }
     ```

     `mapDispatchToProps()`是一个实用方法，它可以帮助你的组件触发一个动作事件（可能导致应用程序状态改变的调度动作）：

     ```javascript
     const mapDispatchToProps = (dispatch) => {
       return {
         onTodoClick: (id) => {
           dispatch(toggleTodo(id))
         }
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

157. ### 我可以在 reducer 中触发一个 Action 吗?

     在 reducer 中触发 Action 是**反模式**。您的 reducer 应该*没有副作用*，只是接收 Action 并返回一个新的状态对象。在 reducer 中添加侦听器和调度操作可能会导致链接的 Action 和其他副作用。

     **[⬆ 返回顶部](#目录)**

158. ### 如何在组件外部访问 Redux 存储的对象?

     是的，您只需要使用`createStore()`从它创建的模块中导出存储。此外，它不应污染全局窗口对象。

     ```javascript
     store = createStore(myReducer)

     export default store
     ```

     **[⬆ 返回顶部](#目录)**

159. ### MVW 模式的缺点是什么?

     1. DOM 操作非常昂贵，导致应用程序行为缓慢且效率低下。
     3. 由于循环依赖性，围绕模型和视图创建了复杂的模型。
     3. 协作型应用程序（如Google Docs）会发生大量数据更改。
     4. 无需添加太多额外代码就无法轻松撤消（及时回退）。

     **[⬆ 返回顶部](#目录)**

160. ### Redux 和 RxJS 之间是否有任何相似之处?

     这些库的目的是不同的，但是存在一些模糊的相似之处。

     Redux 是一个在整个应用程序中管理状态的工具。它通常用作 UI 的体系结构。可以将其视为（一半）Angular 的替代品。 RxJS 是一个反应式编程库。它通常用作在 JavaScript 中完成异步任务的工具。把它想象成 Promise 的替代品。 Redux 使用 Reactive 范例，因为Store是被动的。Store 检测到 Action，并自行改变。RxJS也使用 Reactive 范例，但它不是一个体系结构，它为您提供了基本构建块 Observables 来完成这种模式。

     **[⬆ 返回顶部](#目录)**

161. ### 如何在加载时触发 Action?

     您可以在`componentDidMount()`方法中触发 Action，然后在`render()`方法中可以验证数据。

     ```javascript
     class App extends Component {
       componentDidMount() {
         this.props.fetchData()
       }

       render() {
         return this.props.isLoaded
           ? <div>{'Loaded'}</div>
           : <div>{'Not Loaded'}</div>
       }
     }

     const mapStateToProps = (state) => ({
       isLoaded: state.isLoaded
     })

     const mapDispatchToProps = { fetchData }

     export default connect(mapStateToProps, mapDispatchToProps)(App)
     ```

     **[⬆ 返回顶部](#目录)**

162. ### 在 React 中如何使用 Redux 的 `connect()` ?

     您需要按照两个步骤在容器中使用您的 Store：

     1. **使用`mapStateToProps()`：** 它将 Store 中的状态变量映射到您指定的属性。
     2. **将上述属性连接到容器：** `mapStateToProps`函数返回的对象连接到容器。你可以从`react-redux`导入`connect()`。

         ```jsx 
         import React from 'react'
         import { connect } from 'react-redux'

         class App extends React.Component {
           render() {
             return <div>{this.props.containerData}</div>
           }
         }

         function mapStateToProps(state) {
           return { containerData: state.data }
         }

         export default connect(mapStateToProps)(App)
         ```

     **[⬆ 返回顶部](#目录)**

163. ### 如何在 Redux 中重置状态?

     你需要在你的应用程序中编写一个*root reducer*，它将处理动作委托给`combineReducers()`生成的 reducer。

     例如，让我们在`USER_LOGOUT`动作之后让`rootReducer()`返回初始状态。我们知道，无论 Action 怎么样，当使用`undefined`作为第一个参数调用它们时，reducers 应该返回初始状态。

     ```javascript
     const appReducer = combineReducers({
       /* your app's top-level reducers */
     })

     const rootReducer = (state, action) => {
       if (action.type === 'USER_LOGOUT') {
         state = undefined
       }

       return appReducer(state, action)
     }
     ```

     如果使用`redux-persist`，您可能还需要清理存储空间。`redux-persist`在 storage 引擎中保存您的状态副本。首先，您需要导入适当的 storage 引擎，然后在将其设置为`undefined`之前解析状态并清理每个存储状态键。

     ```javascript
     const appReducer = combineReducers({
       /* your app's top-level reducers */
     })

     const rootReducer = (state, action) => {
       if (action.type === 'USER_LOGOUT') {
         Object.keys(state).forEach(key => {
           storage.removeItem(`persist:${key}`)
         })

         state = undefined
       }

       return appReducer(state, action)
     }
     ```

     **[⬆ 返回顶部](#目录)**

164. ### Redux 中连接装饰器的 `at` 符号的目的是什么?

     **@** 符号实际上是用于表示装饰器的 JavaScript 表达式。*装饰器*可以在设计时注释和修改类和属性。

     让我们举个例子，在没有装饰器的情况下设置 Redux 。

     * **未使用装饰器:**

         ```javascript
         import React from 'react'
         import * as actionCreators from './actionCreators'
         import { bindActionCreators } from 'redux'
         import { connect } from 'react-redux'

         function mapStateToProps(state) {
           return { todos: state.todos }
         }

         function mapDispatchToProps(dispatch) {
           return { actions: bindActionCreators(actionCreators, dispatch) }
         }

         class MyApp extends React.Component {
           // ...define your main app here
         }

         export default connect(mapStateToProps, mapDispatchToProps)(MyApp)
         ```

     * **使用装饰器:**

         ```javascript
         import React from 'react'
         import * as actionCreators from './actionCreators'
         import { bindActionCreators } from 'redux'
         import { connect } from 'react-redux'

         function mapStateToProps(state) {
           return { todos: state.todos }
         }

         function mapDispatchToProps(dispatch) {
           return { actions: bindActionCreators(actionCreators, dispatch) }
         }

         @connect(mapStateToProps, mapDispatchToProps)
         export default class MyApp extends React.Component {
           // ...define your main app here
         }
         ```

     除了装饰器的使用外，上面的例子几乎相似。装饰器语法尚未构建到任何 JavaScript 运行时中，并且仍然是实验性的并且可能会发生变化。您可以使用`babel`来获得装饰器支持。

     **[⬆ 返回顶部](#目录)**

165. ### React 上下文和 React Redux 之间有什么区别?

     您可以直接在应用程序中使用**Context**，这对于将数据传递给深度嵌套的组件非常有用。而**Redux**功能更强大，它还提供了 Context API 无法提供的大量功能。此外，React Redux 在内部使用上下文，但它不会在公共 API 中有所体现。

     **[⬆ 返回顶部](#目录)**

166. ### 为什么 Redux 状态函数称为 reducers ?

     Reducers 总是返回状态的累积（基于所有先前状态和当前 Action）。因此，它们充当了状态的 Reducer。每次调用 Redux reducer 时，状态和 Action 都将作为参数传递。然后基于该 Action 减少（或累积）该状态，然后返回下一状态。您可以*reduce*一组操作和一个初始状态（Store），在该状态下执行这些操作以获得最终的最终状态。

     **[⬆ 返回顶部](#目录)**

167. ### 如何在 Redux 中发起 AJAX 请求?

     您可以使用`redux-thunk`中间件，它允许您定义异步操作。

     让我们举个例子，使用*fetch API*将特定帐户作为 AJAX 调用获取：

     ```javascript
     export function fetchAccount(id) {
       return dispatch => {
         dispatch(setLoadingAccountState()) // Show a loading spinner
         fetch(`/account/${id}`, (response) => {
           dispatch(doneFetchingAccount()) // Hide loading spinner
           if (response.status === 200) {
             dispatch(setAccount(response.json)) // Use a normal function to set the received state
           } else {
             dispatch(someError)
           }
         })
       }
     }

     function setAccount(data) {
      return { type: 'SET_Account', data: data }
     }
     ```

     **[⬆ 返回顶部](#目录)**

168. ### 我应该在 Redux Store 中保留所有组件的状态吗?

      将数据保存在 Redux 存储中，并在组件内部保持 UI 相关状态。

      **[⬆ 返回顶部](#目录)**

169. ### 访问 Redux Store 的正确方法是什么?

     在组件中访问 Store 的最佳方法是使用`connect()`函数，该函数创建一个包裹现有组件的新组件。此模式称为*高阶组件*，通常是在 React 中扩展组件功能的首选方式。这允许您将状态和 Action 创建者映射到组件，并在 Store 更新时自动传递它们。

     我们来看一个使用 connect 的`<FilterLink>`组件的例子：

     ```javascript
     import { connect } from 'react-redux'
     import { setVisibilityFilter } from '../actions'
     import Link from '../components/Link'

     const mapStateToProps = (state, ownProps) => ({
       active: ownProps.filter === state.visibilityFilter
     })

     const mapDispatchToProps = (dispatch, ownProps) => ({
       onClick: () => dispatch(setVisibilityFilter(ownProps.filter))
     })

     const FilterLink = connect(
       mapStateToProps,
       mapDispatchToProps
     )(Link)

     export default FilterLink
     ```

     由于它具有相当多的性能优化并且通常不太可能导致错误，因此 Redux 开发人员几乎总是建议使用`connect()`直接访问 Store（使用上下文API）。

     ```javascript
     class MyComponent {
       someMethod() {
         doSomethingWith(this.context.store)
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

170. ### React Redux 中展示组件和容器组件之间的区别是什么?

     **展示组件**是一个类或功能组件，用于描述应用程序的展示部分。

     **容器组件**是连接到 Redux Store的组件的非正式术语。容器组件*订阅* Redux 状态更新和*dispatch*操作，它们通常不呈现 DOM 元素；他们将渲染委托给展示性的子组件。

     **[⬆ 返回顶部](#目录)**

171. ### Redux 中常量的用途是什么?

     常量允许您在使用 IDE 时轻松查找项目中该特定功能的所有用法。它还可以防止你拼写错误，在这种情况下，你会立即得到一个`ReferenceError`。

     通常我们会将它们保存在一个文件中（`constants.js`或`actionTypes.js`）。

     ```javascript
     export const ADD_TODO = 'ADD_TODO'
     export const DELETE_TODO = 'DELETE_TODO'
     export const EDIT_TODO = 'EDIT_TODO'
     export const COMPLETE_TODO = 'COMPLETE_TODO'
     export const COMPLETE_ALL = 'COMPLETE_ALL'
     export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
     ```

     在 Redux 中，您可以在两个地方使用它们：

     1. **在 Action 创建时:**

         让我们看看 `actions.js`:

         ```javascript
         import { ADD_TODO } from './actionTypes';

         export function addTodo(text) {
           return { type: ADD_TODO, text }
         }
         ```

     2. **在 reducers 里:**

         让我们创建 `reducer.js` 文件:

         ```javascript
         import { ADD_TODO } from './actionTypes'

         export default (state = [], action) => {
           switch (action.type) {
             case ADD_TODO:
               return [
                 ...state,
                 {
                   text: action.text,
                   completed: false
                 }
               ];
             default:
               return state
           }
         }
         ```

     **[⬆ 返回顶部](#目录)**

172. ### 编写 `mapDispatchToProps()` 有哪些不同的方法?

     有一些方法可以将*action creators*绑定到`mapDispatchToProps()`中的`dispatch()`。以下是可能的写法：

     ```javascript
     const mapDispatchToProps = (dispatch) => ({
      action: () => dispatch(action())
     })
     ```

     ```javascript
     const mapDispatchToProps = (dispatch) => ({
      action: bindActionCreators(action, dispatch)
     })
     ```

     ```javascript
     const mapDispatchToProps = { action }
     ```

     第三种写法只是第一种写法的简写。

     **[⬆ 返回顶部](#目录)**

173. ### 在 `mapStateToProps()` 和 `mapDispatchToProps()` 中使用 `ownProps` 参数有什么用?

     如果指定了`ownProps`参数，React Redux 会将传递给该组件的 props 传递给你的*connect*函数。因此，如果您使用连接组件：

     ```jsx 
     import ConnectedComponent from './containers/ConnectedComponent';

     <ConnectedComponent user={'john'} />
     ```

     你的`mapStateToProps()`和`mapDispatchToProps()`函数里面的`ownProps`将是一个对象：

     ```javascript
     { user: 'john' }
     ```

     您可以使用此对象来决定从这些函数返回的内容。

     **[⬆ 返回顶部](#目录)**

174. ### 如何构建 Redux 项目目录?

     大多数项目都有几个顶级目录，如下所示：

     1. **Components**: 用于*dumb*组件，Redux 不必关心的组件。
     2. **Containers**: 用于连接到 Redux 的*smart*组件。
     3. **Actions**: 用于所有 Action 创建器，其中文件名对应于应用程序的一部分。
     4. **Reducers**: 用于所有 reducer，其中文件名对应于state key。
     5. **Store**: 用于 Store 初始化。

     这种结构适用于中小型项目。

     **[⬆ 返回顶部](#目录)**

175. ### 什么是 redux-saga?

     `redux-saga`是一个库，旨在使 React/Redux 项目中的副作用（数据获取等异步操作和访问浏览器缓存等可能产生副作用的动作）更容易，更好。

     这个包在 NPM 上有发布:

     ```console
     $ npm install --save redux-saga
     ```

     **[⬆ 返回顶部](#目录)**

176. ### redux-saga 的模型概念是什么?

     *Saga*就像你的项目中的一个单独的线程，它独自负责副作用。`redux-saga` 是一个 redux *中间件*，这意味着它可以在项目启动中使用正常的 Redux 操作，暂停和取消该线程，它可以访问完整的 Redux 应用程序状态，并且它也可以调度 Redux 操作。

     **[⬆ 返回顶部](#目录)**

177. ### 在 redux-saga 中 `call()` 和 `put()` 之间有什么区别?

     `call()`和`put()`都是 Effect 创建函数。 `call()`函数用于创建 Effect 描述，指示中间件调用 promise。`put()`函数创建一个 Effect，指示中间件将一个 Action 分派给 Store。

     让我们举例说明这些 Effect 如何用于获取特定用户数据。

     ```javascript
     function* fetchUserSaga(action) {
       // `call` function accepts rest arguments, which will be passed to `api.fetchUser` function.
       // Instructing middleware to call promise, it resolved value will be assigned to `userData` variable
       const userData = yield call(api.fetchUser, action.userId)

       // Instructing middleware to dispatch corresponding action.
       yield put({
         type: 'FETCH_USER_SUCCESS',
         userData
       })
     }
     ```

     **[⬆ 返回顶部](#目录)**

178. ### 什么是 Redux Thunk?

     *Redux Thunk*中间件允许您编写返回函数而不是 Action 的创建者。 thunk 可用于延迟 Action 的发送，或仅在满足某个条件时发送。内部函数接收 Store 的方法`dispatch()`和`getState()`作为参数。

     **[⬆ 返回顶部](#目录)**

179. ### `redux-saga` 和 `redux-thunk` 之间有什么区别?

     *Redux Thunk*和*Redux Saga*都负责处理副作用。在大多数场景中，Thunk 使用*Promises*来处理它们，而 Saga 使用*Generators*。Thunk 易于使用，因为许多开发人员都熟悉 Promise，Sagas/Generators 功能更强大，但您需要学习它们。但是这两个中间件可以共存，所以你可以从 Thunks 开始，并在需要时引入 Sagas。

     **[⬆ 返回顶部](#目录)**

180. ### 什么是 Redux DevTools?

     *Redux DevTools*是 Redux 的实时编辑的时间旅行环境，具有热重新加载，Action 重放和可自定义的 UI。如果您不想安装 Redux DevTools 并将其集成到项目中，请考虑使用 Chrome 和 Firefox 的扩展插件。

     **[⬆ 返回顶部](#目录)**

181. ### Redux DevTools 的功能有哪些?

     1. 允许您检查每个状态和 action 负载。
     2. 让你可以通过*撤销*回到过去。
     3. 如果更改 reducer 代码，将重新评估每个*已暂存*的 Action。
     4. 如果 Reducers 抛出错误，你会看到这发生了什么 Action，以及错误是什么。
     5. 使用`persistState()`存储增强器，您可以在页面重新加载期间保持调试会话。

     **[⬆ 返回顶部](#目录)**

182. ### 什么是 Redux 选择器以及使用它们的原因?

     *选择器*是将 Redux 状态作为参数并返回一些数据以传递给组件的函数。

     例如，要从 state 中获取用户详细信息：

     ```javascript
     const getUserData = state => state.user.data
     ```

     **[⬆ 返回顶部](#目录)**

183. ### 什么是 Redux Form?

     *Redux Form*与 React 和 Redux 一起使用，以使 React 中的表单能够使用 Redux 来存储其所有状态。Redux Form 可以与原始 HTML5 输入一起使用，但它也适用于常见的 UI 框架，如 Material UI，React Widgets和React Bootstrap。

     **[⬆ 返回顶部](#目录)**

184. ### Redux Form 的主要功能有哪些?

       1. 字段值通过 Redux 存储持久化。
       2. 验证（同步/异步）和提交。
       3. 字段值的格式化，解析和规范化。

     **[⬆ 返回顶部](#目录)**

185. ### 如何向 Redux 添加多个中间件?

     你可以使用`applyMiddleware()`。

     例如，你可以添加`redux-thunk`和`logger`作为参数传递给`applyMiddleware()`：

     ```javascript
     import { createStore, applyMiddleware } from 'redux'
     const createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(createStore)
     ```

     **[⬆ 返回顶部](#目录)**

186. ### 如何在 Redux 中设置初始状态?

     您需要将初始状态作为第二个参数传递给 createStore ：

     ```javascript
     const rootReducer = combineReducers({
       todos: todos,
       visibilityFilter: visibilityFilter
     })

     const initialState = {
       todos: [{ id: 123, name: 'example', completed: false }]
     }

     const store = createStore(
       rootReducer,
       initialState
     )
     ```

     **[⬆ 返回顶部](#目录)**

187. ### Relay 与 Redux 有何不同?

     Relay 与 Redux 类似，因为它们都使用单个 Store。主要区别在于 relay 仅管理源自服务器的状态，并且通过*GraphQL*查询（用于读取数据）和突变（用于更改数据）来使用对状态的所有访问。Relay 通过仅提取已更改的数据而为您缓存数据并优化数据提取。

     **[⬆ 返回顶部](#目录)**

## React Native

188. ### React Native 和 React 有什么区别?

     **React**是一个 JavaScript 库，支持前端 Web 和在服务器上运行，用于构建用户界面和 Web 应用程序。

     **React Native**是一个移动端框架，可编译为本机应用程序组件，允许您使用 JavaScript 构建本机移动应用程序（iOS，Android和Windows），允许您使用 React 构建组件。

     **[⬆ 返回顶部](#目录)**

189. ### 如何测试 React Native 应用程序?

     React Native 只能在 iOS 和 Android 等移动模拟器中进行测试。您可以使用 expo app（[https://expo.io](https://expo.io)）在移动设备上运行该应用程序。如果使用 QR 代码进行同步，则您的移动设备和计算机应位于同一个无线网络中。

     **[⬆ 返回顶部](#目录)**

190. ### 如何在 React Native 查看日志?

     您可以使用`console.log`，`console.warn`等。从 React Native v0.29 开始，您只需运行以下命令即可在控制台中查看日志：

     ```
     $ react-native log-ios
     $ react-native log-android
     ```

     **[⬆ 返回顶部](#目录)**

191. ### 怎么调试 React Native 应用?

     按照以下步骤调试 React Native 应用程序：

     1. 在 iOS 模拟器中运行您的应用程序。
     2. 按`Command + D`，然后在网页中打开`http://localhost:8081/debugger-ui`。
     3. 启用*Pause On Caught Exceptions*以获得更好的调试体验。
     4. 按`Command + Option + I`打开 Chrome Developer 工具，或通过`View` ->`Developer` ->`Developer Tools`打开它。
     5. 您现在应该能够像平常那样进行调试。

     **[⬆ 返回顶部](#目录)**

## React supported libraries & Integration

192. ### 什么是 Reselect 以及它是如何工作的?

     *Reselect*是一个**选择器库**（用于 Redux ），它使用*memoization*概念。它最初编写用于计算类似 Redux 的应用程序状态的派生数据，但它不能绑定到任何体系结构或库。

     Reselect 保留最后一次调用的最后输入/输出的副本，并仅在其中一个输入发生更改时重新计算结果。如果连续两次提供相同的输入，则 Reselect 将返回缓存的输出。它的 memoization 和缓存是完全可定制的。

     **[⬆ 返回顶部](#目录)**

193. ### 什么是 Flow?

     *Flow* 是一个静态类型检查器，旨在查找 JavaScript 中的类型错误。与传统类型系统相比，Flow 类型可以表达更细粒度的区别。例如，与大多数类型系统不同，Flow 能帮助你捕获涉及 `null` 的错误。

     **[⬆ 返回顶部](#目录)**

194. ### Flow 和 PropTypes 有什么区别?

     Flow 是一个静态分析工具（静态检查器），它使用该语言的超集，允许你在所有代码中添加类型注释，并在编译时捕获整个类的错误。PropTypes 是一个基本类型检查器（运行时检查器），已经被添加到 React 中。除了检查传递给给定组件的属性类型外，它不能检查其他任何内容。如果你希望对整个项目进行更灵活的类型检查，那么 Flow/TypeScript 是更合适的选择。

     **[⬆ 返回顶部](#目录)**

195. ### 在 React 中如何使用 Font Awesome 图标?

     接下来的步骤将在 React 中引入 Font Awesome：

     1. 安装 `font-awesome`:

     ```shell
     $ npm install --save font-awesome
     ```

     2. 在 `index.js` 文件中导入 `font-awesome`:

     ```javascript
     import 'font-awesome/css/font-awesome.min.css'
     ```

     3. 在 `className` 中添加 Font Awesome 类:

     ```javascript
     render() {
       return <div><i className={'fa fa-spinner'} /></div>
     }
     ```

     **[⬆ 返回顶部](#目录)**

196. ### 什么 是 React 开发者工具?

     *React Developer Tools* 允许您检查组件层次结构，包括组件属性和状态。它既可以作为浏览器扩展（用于 Chrome 和 Firefox ），也可以作为独立的应用程序（用于其他环境，包括 Safari、IE 和 React Native）。

     可用于不同浏览器或环境的官方扩展。
     1. **Chrome插件**
     2. **Firefox插件**
     3. **独立应用** （ Safari，React Native 等）

     **[⬆ 返回顶部](#目录)**

197. ### 在 Chrome 中为什么 DevTools 没有加载本地文件?

     如果您在浏览器中打开了本地 HTML 文件（`file://...`），则必须先打开*Chrome Extensions*并选中“允许访问文件URL”。

     **[⬆ 返回顶部](#目录)**

198. ### 如何在 React 中使用 Polymer?

     1. 创建 Polymer 元素：

         ```jsx 
         <link rel='import' href='../../bower_components/polymer/polymer.html' />
         Polymer({
           is: 'calender-element',
           ready: function() {
             this.textContent = 'I am a calender'
           }
         })
         ```

     2. 通过在 HTML 文档中导入 Polymer 组件，来创建该组件对应的标签。例如，在 React 应用程序的 `index.html` 文件中导入。

         ```html
         <link rel='import' href='./src/polymer-components/calender-element.html'>
         ```

     3. 在 JSX 文件中使用该元素：

         ```javascript
         import React from 'react'

         class MyComponent extends React.Component {
           render() {
             return (
               <calender-element />
             )
           }
         }

         export default MyComponent
         ```

     **[⬆ 返回顶部](#目录)**

199. ### 与 Vue.js 相比，React 有哪些优势?

     与 Vue.js 相比，React 具有以下优势：

     1. 在大型应用程序开发中提供更大的灵活性。
     2. 更容易测试。
     3. 更适合创建移动端应用程序。
     4. 提供更多的信息和解决方案。

     **[⬆ 返回顶部](#目录)**

200. ### React 和 Angular 有什么区别?

     | React | Angular |
     | ----- | ------- |
     | React 是一个库，只有View层 | Angular是一个框架，具有完整的 MVC 功能 |
     | React 可以处理服务器端的渲染 | AngularJS 仅在客户端呈现，但 Angular 2 及更高版本可以在服务器端渲染 |
     | React 在 JS 中使用看起来像 HTML 的 JSX，这可能令人困惑 | Angular 遵循 HTML 的模板方法，这使得代码更短且易于理解 |
     | React Native 是一种 React 类型，它用于构建移动应用程序，它更快，更稳定 | Ionic，Angular 的移动 app 相对原生 app 来说不太稳定和慢 |
     | 在 Reac t中，数据只以单一方向传递，因此调试很容易 | 在 Angular 中，数据以两种方式传递，即它在子节点和父节点之间具有双向数据绑定，因此调试通常很困难 |

     **[⬆ 返回顶部](#目录)**

201. ### 为什么 React 选项卡不会显示在 DevTools 中?

     当页面加载时，*React DevTools*设置一个名为`__REACT_DEVTOOLS_GLOBAL_HOOK__`的全局变量，然后 React 在初始化期间与该钩子通信。如果网站没有使用 React，或者如果 React 无法与 DevTools 通信，那么它将不会显示该选项卡。

     **[⬆ 返回顶部](#目录)**

202. ### 什么是 Styled Components?

     styled-components 是一个用于样式化 React 应用程序的 JavaScript 库。 它删除了样式和组件之间的映射，并允许您在 js 中编写 CSS。

     **[⬆ 返回顶部](#目录)**

203. ### 举一个 Styled Components 的例子?

     让我们创建具有特定样式的`<Title>`和`<Wrapper>`组件。

     ```javascript
     import React from 'react'
     import styled from 'styled-components'

     // Create a <Title> component that renders an <h1> which is centered, red and sized at 1.5em
     const Title = styled.h1`
       font-size: 1.5em;
       text-align: center;
       color: palevioletred;
     `

     // Create a <Wrapper> component that renders a <section> with some padding and a papayawhip background
     const Wrapper = styled.section`
       padding: 4em;
       background: papayawhip;
     `
     ```

     `Title`和`Wrapper`变量现在是可以像任何其他 react 组件一样渲染。

     ```jsx 
     <Wrapper>
       <Title>{'Lets start first styled component!'}</Title>
     </Wrapper>
     ```

     **[⬆ 返回顶部](#目录)**

204. ### 什么是 Relay?

     Relay 是一个 JavaScript 框架，用于使用 React 视图层为 Web 应用程序提供数据层和客户端与服务器之间的通信。

     **[⬆ 返回顶部](#目录)**

205. ### 如何在 `create-react-app` 中使用 TypeScript?

     当您创建一个新项目带有`--scripts-version`选项值为`react-scripts-ts`时便可将 TypeScript 引入。

     生成的项目结构如下所示：

     ```
     my-app/
     ├─ .gitignore
     ├─ images.d.ts
     ├─ node_modules/
     ├─ public/
     ├─ src/
     │  └─ ...
     ├─ package.json
     ├─ tsconfig.json
     ├─ tsconfig.prod.json
     ├─ tsconfig.test.json
     └─ tslint.json
     ```

     **[⬆ 返回顶部](#目录)**

## Miscellaneous

206. ### Reselect 库的主要功能有哪些?

       1. 选择器可以计算派生数据，允许 Redux 存储最小可能状态。
       2. 选择器是有效的。除非其参数之一发生更改，否则不会重新计算选择器。
       3. 选择器是可组合的。它们可以用作其他选择器的输入。

     **[⬆ 返回顶部](#目录)**

207. ### 举一个 Reselect 用法的例子?

     让我们通过使用 Reselect 来简化计算不同数量的装运订单：

     ```javascript
     import { createSelector } from 'reselect'

     const shopItemsSelector = state => state.shop.items
     const taxPercentSelector = state => state.shop.taxPercent

     const subtotalSelector = createSelector(
       shopItemsSelector,
       items => items.reduce((acc, item) => acc + item.value, 0)
     )

     const taxSelector = createSelector(
       subtotalSelector,
       taxPercentSelector,
       (subtotal, taxPercent) => subtotal * (taxPercent / 100)
     )

     export const totalSelector = createSelector(
       subtotalSelector,
       taxSelector,
       (subtotal, tax) => ({ total: subtotal + tax })
     )

     let exampleState = {
       shop: {
         taxPercent: 8,
         items: [
           { name: 'apple', value: 1.20 },
           { name: 'orange', value: 0.95 },
         ]
       }
     }

     console.log(subtotalSelector(exampleState)) // 2.15
     console.log(taxSelector(exampleState))      // 0.172
     console.log(totalSelector(exampleState))    // { total: 2.322 }
     ```

     **[⬆ 返回顶部](#目录)**

208. ### Redux 中的 Action 是什么?

     *Actions*是纯 JavaScript 对象或信息的有效负载，可将数据从您的应用程序发送到您的 Store。 它们是 Store 唯一的数据来源。 Action 必须具有指示正在执行的操作类型的 type 属性。

     例如，表示添加新待办事项的示例操作：

     ```
     {
       type: ADD_TODO,
       text: 'Add todo item'
     }
     ```

     **[⬆ 返回顶部](#目录)**

209. ### 在 React 中 statics 对象是否能与 ES6 类一起使用?

     不行，`statics` 仅适用于 `React.createClass()`：

     ```javascript
     someComponent= React.createClass({
       statics: {
         someMethod: function() {
           // ..
         }
       }
     })
     ```

     但是你可以在 ES6+ 的类中编写静态代码，如下所示：

     ```javascript
     class Component extends React.Component {
       static propTypes = {
         // ...
       }

       static someMethod() {
         // ...
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

210. ### Redux 只能与 React 一起使用么?

     Redux 可以用做任何 UI 层的数据存储。最常见的应用场景是 React 和 React Native，但也有一些 bindings 可用于 AngularJS，Angular 2，Vue，Mithril 等项目。Redux 只提供了一种订阅机制，任何其他代码都可以使用它。

     **[⬆ 返回顶部](#目录)**

211. ### 您是否需要使用特定的构建工具来使用 Redux ?

     Redux 最初是用 ES6 编写的，用 Webpack 和 Babel 编译成 ES5。 无论您的 JavaScript 构建过程如何，您都应该能够使用它。Redux 还提供了一个 UMD 版本，可以直接使用而无需任何构建过程。

     **[⬆ 返回顶部](#目录)**

212. ### Redux Form 的 `initialValues` 如何从状态更新?

     你需要添加`enableReinitialize：true`设置。

     ```javascript
     const InitializeFromStateForm = reduxForm({
       form: 'initializeFromState',
       enableReinitialize : true
     })(UserEdit)
     ```

     如果你的`initialValues`属性得到更新，你的表单也会更新。

     **[⬆ 返回顶部](#目录)**

213. ### React 是如何为一个属性声明不同的类型?

     你可以使用 `PropTypes` 中的 `oneOfType()` 方法。

     例如，如下所示 size 的属性值可以是 `string` 或 `number` 类型。

     ```javascript
     Component.PropTypes = {
       size: PropTypes.oneOfType([
         PropTypes.string,
         PropTypes.number
       ])
     }
     ```

     **[⬆ 返回顶部](#目录)**

214. ### 我可以导入一个 SVG 文件作为 React 组件么?

     你可以直接将 SVG 作为组件导入，而不是将其作为文件加载。此功能仅在 `react-scripts@2.0.0` 及更高版本中可用。


     ```jsx 
     import { ReactComponent as Logo } from './logo.svg'
    
     const App = () => (
       <div>
         {/* Logo is an actual react component */}
         <Logo />
       </div>
     )
     ```
      
     **[⬆ 返回顶部](#目录)**

215. ### 为什么不建议使用内联引用回调或函数?

     如果将 ref 回调定义为内联函数，则在更新期间它将会被调用两次。首先使用 null 值，然后再使用 DOM 元素。这是因为每次渲染的时候都会创建一个新的函数实例，因此 React 必须清除旧的 ref 并设置新的 ref。

     ```jsx
     class UserForm extends Component {
       handleSubmit = () => {
         console.log("Input Value is: ", this.input.value)
       }
     
       render () {
        return (
          <form onSubmit={this.handleSubmit}>
            <input
              type='text'
              ref={(input) => this.input = input} /> // Access DOM input in handle submit
            <button type='submit'>Submit</button>
          </form>
        )
      }
     }
     ```

     但我们期望的是当组件挂载时，ref 回调只会被调用一次。一个快速修复的方法是使用 ES7 类属性语法定义函数。
         
     ```jsx
     class UserForm extends Component {
      handleSubmit = () => {
        console.log("Input Value is: ", this.input.value)
      }
         
      setSearchInput = (input) => {
        this.input = input
      }
         
      render () {
        return (
          <form onSubmit={this.handleSubmit}>
            <input
              type='text'
              ref={this.setSearchInput} /> // Access DOM input in handle submit
            <button type='submit'>Submit</button>
          </form>
        )
      }
     }
     ```

     **[⬆ 返回顶部](#目录)**

216. ### 在 React 中什么是渲染劫持?

     渲染劫持的概念是控制一个组件将从另一个组件输出什么的能力。实际上，这意味着你可以通过将组件包装成高阶组件来装饰组件。通过包装，你可以注入额外的属性或产生其他变化，这可能会导致渲染逻辑的更改。实际上它不支持劫持，但通过使用 HOC，你可以使组件以不同的方式工作。

     **[⬆ 返回顶部](#目录)**

217. ### 什么是 HOC 工厂实现?

     在 React 中实现 HOC 有两种主要方式。 1.属性代理（PP）和 2.继承倒置（II）。他们遵循不同的方法来操纵*WrappedComponent*。

     **属性代理**
     在这种方法中，HOC 的 render 方法返回 WrappedComponent 类型的 React 元素。我们通过 HOC 收到 props，因此定义为**属性代理**。

     ```jsx
     
     function ppHOC(WrappedComponent) {
      return class PP extends React.Component {
        render() {
          return <WrappedComponent {...this.props}/>
        }
      }
     }
     ```

     **继承倒置**
     在这种方法中，返回的 HOC 类（Enhancer）扩展了 WrappedComponent 。它被称为继承反转，因为它不是扩展一些 Enhancer 类的 WrappedComponent，而是由 Enhancer 被动扩展。 通过这种方式，它们之间的关系似乎是**逆的**。

     ```jsx
     function iiHOC(WrappedComponent) {
      return class Enhancer extends WrappedComponent {
        render() {
          return super.render()
        }
      }
     }
     ```

     **[⬆ 返回顶部](#目录)**

218. ### 如何传递数字给 React 组件?

     传递数字时你应该使用 `{}`，而传递字符串时还需要使用引号：

     ```jsx
        React.render(<User age={30} department={"IT"} />, document.getElementById('container'));
     ```

     **[⬆ 返回顶部](#目录)**

219. ### 我需要将所有状态保存到 Redux 中吗？我应该使用 react 的内部状态吗?

     这取决于开发者的决定。即开发人员的工作是确定应用程序的哪种状态，以及每个状态应该存在的位置，有些用户喜欢将每一个数据保存在 Redux 中，以维护其应用程序的完全可序列化和受控。其他人更喜欢在组件的内部状态内保持非关键或UI状态，例如“此下拉列表当前是否打开”。

     以下是确定应将哪种数据放入Redux的主要规则：

     1. 应用程序的其他部分是否关心此数据？
     2. 您是否需要能够基于此原始数据创建更多派生数据？
     3. 是否使用相同的数据来驱动多个组件？
     4. 能够将此状态恢复到给定时间点（即时间旅行调试）是否对您有价值？
     5. 您是否要缓存数据（即，如果已经存在，则使用处于状态的状态而不是重新请求它）？

220. ### 在 React 中 registerServiceWorker 的用途是什么?

     默认情况下，React 会为你创建一个没有任何配置的 service worker。Service worker 是一个 Web API，它帮助你缓存资源和其他文件，以便当用户离线或在弱网络时，他/她仍然可以在屏幕上看到结果，因此，它可以帮助你建立更好的用户体验，这是你目前应该了解的关于 Service worker 的内容。

     ```jsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import App from './App';
        import registerServiceWorker from './registerServiceWorker';
     
        ReactDOM.render(<App />, document.getElementById('root'));
        registerServiceWorker();
     ```

     **[⬆ 返回顶部](#目录)**

221. ### React memo 函数是什么?

     当类组件的输入属性相同时，可以使用 **pureComponent** 或 **shouldComponentUpdate** 来避免组件的渲染。现在，你可以通过把函数组件包装在 **React.memo** 中来实现相同的功能。

     ```jsx
     const MyComponent = React.memo(function MyComponent(props) {
      /* only rerenders if props change */
     });
     ```

     **[⬆ 返回顶部](#目录)**

222. ### React lazy 函数是什么?

     使用 React.lazy 函数允许你将动态导入的组件作为常规组件进行渲染。当组件开始渲染时，它会自动加载包含 OtherComponent 的包。它必须返回一个 Promise，该 Promise 解析后为一个带有默认导出 React 组件的模块。

     ```jsx
     const OtherComponent = React.lazy(() => import('./OtherComponent'));
     
     function MyComponent() {
      return (
        <div>
          <OtherComponent />
        </div>
      );
     }
     ```

     **注意：** React.lazy 和 Suspense 还不能用于服务端渲染。如果要在服务端渲染的应用程序中进行代码拆分，我们仍然建议使用 React Loadable。

     **[⬆ 返回顶部](#目录)**

223. ### 如何使用 setState 防止不必要的更新?

     你可以把状态的当前值与已有的值进行比较，并决定是否重新渲染页面。如果没有更改，你需要返回 `null` 以阻止渲染，否则返回最新的状态值。例如，用户配置信息组件将按以下方式实现条件渲染：

     ```jsx
     getUserProfile = user => {
       const latestAddress = user.address;
       this.setState(state => {
         if (state.address === latestAddress) {
           return null;
         } else {
           return { title: latestAddress };
         }
       });
     };
     ```

     **[⬆ 返回顶部](#目录)**

224. ### 如何在 React 16 版本中渲染数组、字符串和数值? 

     **Arrays**: 与旧版本不同的是，在 React 16 中你不需要确保 **render** 方法必须返回单个元素。通过返回数组，你可以返回多个没有包装元素的同级元素。例如，让我们看看下面的开发人员列表：

     ```jsx
     const ReactJSDevs = () => {
       return [
         <li key="1">John</li>,
         <li key="2">Jackie</li>,
         <li key="3">Jordan</li>
       ];
     }
     ```

     你还可以将此数组项合并到另一个数组组件中：

     ```jsx
     const JSDevs = () => {
       return (
         <ul>
           <li>Brad</li>
           <li>Brodge</li>
           <ReactJSDevs/>
           <li>Brandon</li>
         </ul>
       );
     }
     ```

     **Strings and Numbers:** 在 render 方法中，你也可以返回字符串和数值类型：

     ```jsx
     // String
     render() {
      return 'Welcome to ReactJS questions';
     }
     // Number
     render() {
      return 2018;
     }
     ```

     **[⬆ 返回顶部](#目录)**

225. ### 如何在 React 类中使用类字段声明语法?

     使用类字段声明可以使 React 类组件更加简洁。你可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定。让我们以一个 counter 示例来演示类字段声明，即不使用构造函数初始化状态且不进行方法绑定：

     ```jsx
     class Counter extends Component {
       state = { value: 0 };
     
       handleIncrement = () => {
         this.setState(prevState => ({
           value: prevState.value + 1
         }));
       };
     
       handleDecrement = () => {
         this.setState(prevState => ({
           value: prevState.value - 1
         }));
       };
     
       render() {
         return (
           <div>
             {this.state.value}
     
             <button onClick={this.handleIncrement}>+</button>
             <button onClick={this.handleDecrement}>-</button>
           </div>
         )
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

226. ### 什么是 hooks?

     Hooks 是一个新的草案，它允许你在不编写类的情况下使用状态和其他 React 特性。让我们来看一个 useState 钩子示例：

     ```jsx
     import { useState } from 'react';
     
     function Example() {
       // Declare a new state variable, which we'll call "count"
       const [count, setCount] = useState(0);
     
       return (
         <div>
           <p>You clicked {count} times</p>
           <button onClick={() => setCount(count + 1)}>
             Click me
           </button>
         </div>
       );
     }
     ```

      阅读资源：

      1. [掘金 - 30分钟精通React Hooks](https://juejin.im/post/5be3ea136fb9a049f9121014)

      **[⬆ 返回顶部](#目录)**

227. ### Hooks 需要遵循什么规则?

     为了使用 hooks，你需要遵守两个规则：

     1. 仅在顶层的 React 函数调用 hooks。也就是说，你不能在循环、条件或内嵌函数中调用 hooks。这将确保每次组件渲染时都以相同的顺序调用 hooks，并且它会在多个 useState 和 useEffect 调用之间保留 hooks 的状态。
     2. 仅在 React 函数中调用 hooks。例如，你不能在常规的 JavaScript 函数中调用 hooks。

     **[⬆ 返回顶部](#目录)**

228. ### 如何确保钩子遵循正确的使用规则?

     React 团队发布了一个名为**eslint-plugin-react-hooks**的 ESLint 插件，它实施了这两个规则。您可以使用以下命令将此插件添加到项目中，

     ```shell
     npm install eslint-plugin-react-hooks@next
     ```

     并在您的 ESLint 配置文件中应用以下配置：
     ```javascript
     // Your ESLint configuration
     {
       "plugins": [
         // ...
         "react-hooks"
       ],
       "rules": {
         // ...
         "react-hooks/rules-of-hooks": "error"
       }
     }
     ```

     **注意：** 此插件在 Create React App 已经默认配置。

     **[⬆ 返回顶部](#目录)**

229. ### Flux 和 Redux 之间有什么区别?

     以下是 Flux 和 Redux 之间的主要区别

     | Flux | Redux |
     | ----- | ------- |
     | 状态是可变的 | 状态是不可变的 |
     | Store 包含状态和更改逻辑 | 存储和更改逻辑是分开的 |
     | 存在多个 Store | 仅存在一个 Store |
     | 所有的 Store 都是断开连接的 | 带有分层 reducers 的 Store |
     | 它有一个单独的 dispatcher | 没有 dispatcher 的概念 |
     | React 组件监测 Store | 容器组件使用连接函数 |

     **[⬆ 返回顶部](#目录)**

230. ### React Router V4 有什么好处?

     以下是 React Router V4 模块的主要优点：

     1. 在React Router v4（版本4）中，API完全与组件有关。路由器可以显示为单个组件（<BrowserRouter>），它包装特定的子路由器组件（<Route>）。
     2. 您无需手动设置历史记录。路由器模块将通过使用<BrowserRouter>组件包装路由来处理历史记录。
     3. 通过仅添加特定路由器模块（Web，core 或 native）来减少应用大小。

     **[⬆ 返回顶部](#目录)**

231. ### 您能描述一下 componentDidCatch 生命周期方法签名吗?

     在后代层级的组件抛出错误后，将调用**componentDidCatch**生命周期方法。该方法接收两个参数：

     1. error: - 抛出的错误对象
     2. info: - 具有 componentStack 键的对象，包含有关哪个组件引发错误的信息。

     方法结构如下：

     ```javascript
     componentDidCatch(error, info)
     ```

     **[⬆ 返回顶部](#目录)**

232. ### 在哪些情况下，错误边界不会捕获错误?

     以下是错误边界不起作用的情况：

     1. 在事件处理器内。
     2. **setTimeout** 或 **requestAnimationFrame** 回调中的异步代码。
     3. 在服务端渲染期间。
     4. 错误边界代码本身中引发错误时。

     **[⬆ 返回顶部](#目录)**

233. ### 为什么事件处理器不需要错误边界?

     错误边界不会捕获事件处理程序中的错误。与 render 方法或生命周期方法不同，在渲染期间事件处理器不会被执行或调用。

     如果仍然需要在事件处理程序中捕获错误，请使用下面的常规 JavaScript `try/catch` 语句：

     ```javascript
     class MyComponent extends React.Component {
       constructor(props) {
         super(props);
         this.state = { error: null };
       }
     
       handleClick = () => {
         try {
           // Do something that could throw
         } catch (error) {
           this.setState({ error });
         }
       }
     
       render() {
         if (this.state.error) {
           return <h1>Caught an error.</h1>
         }
         return <div onClick={this.handleClick}>Click Me</div>
       }
     }
     ```

     上面的代码使用普通的 JavaScript try/catch 块而不是错误边界来捕获错误。

     **[⬆ 返回顶部](#目录)**

234. ### try catch 与错误边界有什么区别?

     Try catch 块使用命令式代码，而错误边界则是使用在屏幕上呈现声明性代码。

     例如，以下是使用声明式代码的 try/catch 块：

     ```javascript
     try {
       showButton();
     } catch (error) {
       // ...
     }
     ```

     而错误边界包装的声明式代码如下：

     ```javascript
     <ErrorBoundary>
       <MyComponent />
     </ErrorBoundary>
     ```

     因此，如果在组件树深处某个位置组件的 **componentDidUpdate** 方法中，发生了由 **setState** 引发的错误，它仍然会正确地冒泡到最近的错误边界。

     **[⬆ 返回顶部](#目录)**

235. ### React 16 中未捕获的错误的行为是什么?

     在 React 16 中，未被任何错误边界捕获的错误将导致整个 React 组件树的卸载。这一决定背后的原因是，与其显示已损坏的界面，不如完全移除它。例如，对于支付应用程序来说，显示错误的金额比什么都不提供更糟糕。

     **[⬆ 返回顶部](#目录)**

236. ### 放置错误边界的正确位置是什么?

     错误边界使用的粒度由开发人员根据项目需要决定。你可以遵循这些方法中的任何一种：

     1. 可以包装顶层路由组件以显示整个应用程序中常见的错误消息。
     2. 你还可以将单个组件包装在错误边界中，以防止它们奔溃时影响到应用程序的其余部分。

     **[⬆ 返回顶部](#目录)**

237. ### 从错误边界跟踪组件堆栈有什么好处?

     除了错误消息和 JavaScript 堆栈，React 16 将使用错误边界的概念显示带有文件名和行号的组件堆栈。例如，BuggyCounter 组件显示组件堆栈信息：

     ![stacktrace](images/error_boundary.png)

     **[⬆ 返回顶部](#目录)**

238. ### 在定义类组件时，什么是必须的方法?

     在类组件中 render() 方法是唯一需要的方法。也就是说，对于类组件，除了 render() 方法之外的所有方法都是可选的。

     **[⬆ 返回顶部](#目录)**

239. ### render 方法可能返回的类型是什么?

     以下列表是 render 方法返回的类型：

     1. **React elements:** 用于告诉 React 如何渲染 DOM 节点。它包括 HTML 元素，如 `<div />` 和用户定义的元素。
     2. **Arrays and fragments:** 以数组的形式返回多个元素和包装多个元素的片段。
     3. **Portals:** 将子元素渲染到不同的 DOM 子树中。
     4. **String and numbers:** 在 DOM 中将字符串和数字都作为文本节点进行呈现。
     5. **Booleans or null:** 不会渲染任何内容，但这些类型用于有条件地渲染内容。

     **[⬆ 返回顶部](#目录)**

240. ### 构造函数的主要目的是什么?

     使用构造函数主要有两个目的：

     1. 通过将对象分配给 this.state 来初始化本地状态。
     2. 用于为组件实例绑定事件处理方法。

     例如，下面的代码涵盖了上述两种情况：

     ```javascript
     constructor(props) {
       super(props);
       // Don't call this.setState() here!
       this.state = { counter: 0 };
       this.handleClick = this.handleClick.bind(this);
     }
     ```

     **[⬆ 返回顶部](#目录)**

241. ### 是否必须为 React 组件定义构造函数?

     不，这不是强制的。也就是说，如果你不需要初始化状态且不需要绑定方法，则你不需要为 React 组件实现一个构造函数。

     **[⬆ 返回顶部](#目录)**

242. ### 什么是默认属性?

     defaultProps 被定义为组件类上的属性，用于设置组件类默认的属性值。它只适用于 undefined 的属性，而不适用于 null 属性。例如，让我们为按钮组件创建默认的 color 属性：

     ```javascript
     class MyButton extends React.Component {
       // ...
     }
     
     MyButton.defaultProps = {
       color: 'red'
     };
     
     ```

     如果未设置 props.color，则会使用默认值 `red`。 也就是说，每当你试图访问 color 属性时，它都使用默认值。

     ```javascript
     render() {
        return <MyButton /> ; // props.color will be set to red
      }
     ```

     **注意：** 如果你提供的是 null 值，它会仍然保留 null 值。

     **[⬆ 返回顶部](#目录)**

243. ### 为什么不能在 componentWillUnmount 中调用 setState() 方法?

     不应在 componentWillUnmount() 中调用 setState()，因为一旦卸载了组件实例，就永远不会再次装载它。

     **[⬆ 返回顶部](#目录)**

244. ### getDerivedStateFromError 的目的是什么?

     在子代组件抛出异常后会调用此生命周期方法。它以抛出的异常对象作为参数，并返回一个值用于更新状态。该生命周期方法的签名如下：

     ```javascript
     static getDerivedStateFromError(error)
     ```

     让我们举一个包含上述生命周期方法的错误边界示例，来说明 getDerivedStateFromError 的目的：

     ```javascript
     class ErrorBoundary extends React.Component {
       constructor(props) {
         super(props);
         this.state = { hasError: false };
       }
     
       static getDerivedStateFromError(error) {
         // Update state so the next render will show the fallback UI.
         return { hasError: true };
       }
     
       render() {
         if (this.state.hasError) {
           // You can render any custom fallback UI
           return <h1>Something went wrong.</h1>;
         }
     
         return this.props.children;
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

245. ### 当组件重新渲染时顺序执行的方法有哪些?

     更新可能由属性或状态的更改引起。在重新渲染组件时，会按以下顺序调用下列方法。

     1. static getDerivedStateFromProps()
     2. shouldComponentUpdate()
     3. render()
     4. getSnapshotBeforeUpdate()
     5. componentDidUpdate()

     **[⬆ 返回顶部](#目录)**

246. ### 错误处理期间调用哪些方法?

     在渲染期间，生命周期方法内或任何子组件的构造函数中出现错误时，将会调用以下方法：

     1. static getDerivedStateFromError()
     2. componentDidCatch()

     **[⬆ 返回顶部](#目录)**

247. ### displayName 类属性的用途是什么?

     displayName 被用于调试信息。通常，你不需要显式设置它，因为它是从定义组件的函数或类的名称推断出来的。如果出于调试目的或在创建高阶组件时显示不同的名称，可能需要显式设置它。

     例如，若要简化调试，请选择一个显示名称，以表明它是 withSubscription HOC 的结果。

     ```javascript
     function withSubscription(WrappedComponent) {
       class WithSubscription extends React.Component {/* ... */}
       WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
       return WithSubscription;
     }
     
     function getDisplayName(WrappedComponent) {
       return WrappedComponent.displayName || WrappedComponent.name || 'Component';
     }
     ```

     **[⬆ 返回顶部](#目录)**

248. ### 支持 React 应用程序的浏览器有哪一些?

     React 支持所有流行的浏览器，包括 Internet Explorer 9 和更高版本，但旧版本的浏览器（如IE 9 和 IE 10）需要一些 polyfill。如果你使用 **es5-shim and es5-sham** polyfill，那么它甚至支持不支持 ES5 方法的旧浏览器。

     **[⬆ 返回顶部](#目录)**

249. ### unmountComponentAtNode 方法的目的是什么?

     此方法可从 react-dom 包中获得，它从 DOM 中移除已装载的 React 组件，并清除其事件处理程序和状态。如果容器中没有装载任何组件，则调用此函数将不起任何作用。如果组件已卸载，则返回 true；如果没有要卸载的组件，则返回 false。该方法的签名如下：

     ```javascript
     ReactDOM.unmountComponentAtNode(container)
     ```

     **[⬆ 返回顶部](#目录)**

250. ### 什么是代码拆分?

     Code-Splitting 是 Webpack 和 Browserify 等打包工具所支持的一项功能，它可以创建多个 bundles，并可以在运行时动态加载。React 项目支持通过 dynamic import() 特性进行代码拆分。例如，在下面的代码片段中，它将使 moduleA.js 及其所有唯一依赖项作为单独的块，仅当用户点击 'Load' 按钮后才加载。

     **moduleA.js**
     ```javascript
     const moduleA = 'Hello';
     
     export { moduleA };
     ```
     **App.js**
     ```javascript
     import React, { Component } from 'react';
     
     class App extends Component {
       handleClick = () => {
         import('./moduleA')
           .then(({ moduleA }) => {
             // Use moduleA
           })
           .catch(err => {
             // Handle failure
           });
       };
     
       render() {
         return (
           <div>
             <button onClick={this.handleClick}>Load</button>
           </div>
         );
       }
     }
     
     export default App;
     ```

     **[⬆ 返回顶部](#目录)**

251. ### 严格模式有什么好处?

     在下面的情况下，<StrictMode> 将有所帮助：

     1. 使用 **unsafe lifecycle methods** 标识组件。
     2. 有关 **legacy string ref** API 用法发出警告。
     3. 检测无法预测的 **side effects**。
     4. 检测 **legacy context** API。
     5. 有关已弃用的 findDOMNode 用法的警告。

     **[⬆ 返回顶部](#目录)**

252. ### 什么是 Keyed Fragments ?

     使用显式 <React.Fragment> 语法声明的片段可能具有 key 。一般用例是将集合映射到片段数组，如下所示，

     ```javascript
     function Glossary(props) {
       return (
         <dl>
           {props.items.map(item => (
             // Without the `key`, React will fire a key warning
             <React.Fragment key={item.id}>
               <dt>{item.term}</dt>
               <dd>{item.description}</dd>
             </React.Fragment>
           ))}
         </dl>
       );
     }
     ```

     **注意：** 键是唯一可以传递给 Fragment 的属性。将来，可能会支持其他属性，例如事件处理程序。

     **[⬆ 返回顶部](#目录)**

253. ### React 支持所有的 HTML 属性么?

     从 React 16 开始，完全支持标准或自定义 DOM 属性。由于 React 组件通常同时使用自定义和与 DOM 相关的属性，因此 React 与 DOM API 一样都使用 camelCase 约定。让我们对标准 HTML 属性采取一些措施：

     ```javascript
     <div tabIndex="-1" />      // Just like node.tabIndex DOM API
     <div className="Button" /> // Just like node.className DOM API
     <input readOnly={true} />  // Just like node.readOnly DOM API
     ```

     除了特殊情况外，这些属性的工作方式与相应的 HTML 属性类似。它还支持所有 SVG 属性。

     **[⬆ 返回顶部](#目录)**

254. ### HOC 有哪些限制?

     除了它的好处之外，高阶组件还有一些注意事项。 以下列出的几个注意事项:
     1. **不要在渲染方法中使用HOC：**
        建议不要将 HOC 应用于组件的 render 方法中的组件。
        ```javascript
        render() {
          // A new version of EnhancedComponent is created on every render
          // EnhancedComponent1 !== EnhancedComponent2
          const EnhancedComponent = enhance(MyComponent);
          // That causes the entire subtree to unmount/remount each time!
          return <EnhancedComponent />;
        }
        ```
        上述代码通过重新装载，将导致该组件及其所有子组件状态丢失，会影响到性能。正确的做法应该是在组件定义之外应用 HOC ，以便仅生成一次生成的组件

     2. **静态方法必须复制：**
        将 HOC 应用于组件时，新组件不具有原始组件的任何静态方法
        ```javascript
        // Define a static method
        WrappedComponent.staticMethod = function() {/*...*/}
        // Now apply a HOC
        const EnhancedComponent = enhance(WrappedComponent);

        // The enhanced component has no static method
        typeof EnhancedComponent.staticMethod === 'undefined' // true
        ```
        您可以通过在返回之前将方法复制到输入组件上来解决此问题
        ```javascript
        function enhance(WrappedComponent) {
          class Enhance extends React.Component {/*...*/}
          // Must know exactly which method(s) to copy :(
          Enhance.staticMethod = WrappedComponent.staticMethod;
          return Enhance;
        }
        ```
     3. **Refs 不会被往下传递**
        对于HOC，您需要将所有属性传递给包装组件，但这对于 refs 不起作用。这是因为 ref 并不是一个类似于 key 的属性。在这种情况下，您需要使用 React.forwardRef API。

     **[⬆ 返回顶部](#目录)**

255. ### 如何在 DevTools 中调试 forwardRefs?

     **React.forwardRef**接受渲染函数作为参数，DevTools 使用此函数来确定为 ref 转发组件显示的内容。例如，如果您没有使用 displayName 属性命名 render 函数，那么它将在 DevTools 中显示为“ForwardRef”，

     ```javascript
     const WrappedComponent = React.forwardRef((props, ref) => {
       return <LogProps {...props} forwardedRef={ref} />;
     });
     ```

     但如果你命名 render 函数，那么它将显示为 **“ForwardRef(myFunction)”**

     ```javascript
     const WrappedComponent = React.forwardRef(
       function myFunction(props, ref) {
         return <LogProps {...props} forwardedRef={ref} />;
       }
     );
     ```

     作为替代方案，您还可以为 forwardRef 函数设置 displayName 属性，

     ```javascript
     function logProps(Component) {
       class LogProps extends React.Component {
         // ...
       }
     
       function forwardRef(props, ref) {
         return <LogProps {...props} forwardedRef={ref} />;
       }
     
       // Give this component a more helpful display name in DevTools.
       // e.g. "ForwardRef(logProps(MyComponent))"
       const name = Component.displayName || Component.name;
       forwardRef.displayName = `logProps(${name})`;
     
       return React.forwardRef(forwardRef);
     }
     ```

     **[⬆ 返回顶部](#目录)**

256. ### 什么时候组件的 props 属性默认为 true?

     如果没有传递属性值，则默认为 true。此行为可用，以便与 HTML 的行为匹配。例如，下面的表达式是等价的：

     ```javascript
     <MyInput autocomplete />
     
     <MyInput autocomplete={true} />
     ```

     **注意：** 不建议使用此方法，因为它可能与 ES6 对象 shorthand 混淆（例如，{name}，它是{ name:name } 的缩写）

     **[⬆ 返回顶部](#目录)**

257. ### 什么是 NextJS 及其主要特征?

     Next.js 是一个流行的轻量级框架，用于使用 React 构建静态和服务端渲染应用程序。它还提供样式和路由解决方案。以下是 NextJS 提供的主要功能：

     1. 默认服务端渲染
     2. 自动代码拆分以加快页面加载速度
     3. 简单的客户端路由 (基于页面)
     4. 基于 Webpack 的开发环境支持 (HMR)
     5. 能够使用 Express 或任何其他 Node.js HTTP 服务器
     6. 可自定义你自己的 Babel 和 Webpack 配置

     **[⬆ 返回顶部](#目录)**

258. ### 如何将事件处理程序传递给组件?

     可以将事件处理程序和其他函数作为属性传递给子组件。它可以在子组件中使用，如下所示：

     ```
     <button onClick={this.handleClick}>
     ```

     **[⬆ 返回顶部](#目录)**

259. ### 在渲染方法中使用箭头函数好么?

     是的，你可以用。它通常是向回调函数传递参数的最简单方法。但在使用时需要优化性能。

     ```javascript
     class Foo extends Component {
       handleClick() {
         console.log('Click happened');
       }
       render() {
         return <button onClick={() => this.handleClick()}>Click Me</button>;
       }
     }
     ```

     **注意：** 组件每次渲染时，在 render 方法中的箭头函数都会创建一个新的函数，这可能会影响性能。

     **[⬆ 返回顶部](#目录)**

260. ### 如何防止函数被多次调用?

     如果你使用一个事件处理程序，如 **onClick or onScroll** 并希望防止回调被过快地触发，那么你可以限制回调的执行速度。

     这可以通过以下可能的方式实现：

     1. **Throttling:** 基于时间的频率进行更改。例如，它可以使用 lodash 的 _.throttle 函数。
     2. **Debouncing:** 在一段时间不活动后发布更改。例如，可以使用 lodash 的 _.debounce 函数。
     3. **RequestAnimationFrame throttling:** 基于 requestAnimationFrame 的更改。例如，可以使用 raf-schd。

     > 注意：_.debounce， _.throttle 和 raf-schd 都提供了一个 cancel 方法来取消延迟回调。所以需要调用 componentWillUnmount，或者对代码进行检查来保证在延迟函数有效期间内组件始终挂载。

     **[⬆ 返回顶部](#目录)**

261. ### JSX 如何防止注入攻击?

     React DOM 会在渲染 JSX 中嵌入的任何值之前对其进行转义。因此，它确保你永远不能注入任何未在应用程序中显式写入的内容。

     ```javascript
     const name = response.potentiallyMaliciousInput;
     const element = <h1>{name}</h1>;
     ```

     这样可以防止应用程序中的XSS（跨站点脚本）攻击。

     **[⬆ 返回顶部](#目录)**

262. ### 如何更新已渲染的元素?

     通过将新创建的元素传递给 ReactDOM 的 render 方法，可以实现 UI 更新。例如，让我们举一个滴答时钟的例子，它通过多次调用 render 方法来更新时间：

     ```javascript
     function tick() {
       const element = (
         <div>
           <h1>Hello, world!</h1>
           <h2>It is {new Date().toLocaleTimeString()}.</h2>
         </div>
       );
       ReactDOM.render(element, document.getElementById('root'));
     }
     
     setInterval(tick, 1000);
     ```

     **[⬆ 返回顶部](#目录)**

263. ### 你怎么说 props 是只读的?

     当你将组件声明为函数或类时，它决不能修改自己的属性。让我们来实现一个 capital 的函数：

     ```javascript
     function capital(amount, interest) {
        return amount + interest;
     }
     ```

     上面的函数称为“纯”函数，因为它不会尝试更改输入，并总是为相同的输入返回相同的结果。因此，React 有一条规则，即“所有 React 组件的行为都必须像纯函数一样”。

     **[⬆ 返回顶部](#目录)**

264. ### 你认为状态更新是如何合并的?

     当你在组件中调用 setState() 方法时，React 会将提供的对象合并到当前状态。例如，让我们以一个使用帖子和评论详细信息的作为状态变量的 Facebook 用户为例：

     ```javascript
       constructor(props) {
         super(props);
         this.state = {
           posts: [],
           comments: []
         };
       }
     ```

     现在，你可以独立调用 setState() 方法，单独更新状态变量：

     ```javascript
      componentDidMount() {
         fetchPosts().then(response => {
           this.setState({
             posts: response.posts
           });
         });
     
         fetchComments().then(response => {
           this.setState({
             comments: response.comments
           });
         });
       }
     ```

     如上面的代码段所示，`this.setState({comments})` 只会更新 comments 变量，而不会修改或替换 posts 变量。

     **[⬆ 返回顶部](#目录)**

265. ### 如何将参数传递给事件处理程序?

     在迭代或循环期间，向事件处理程序传递额外的参数是很常见的。这可以通过箭头函数或绑定方法实现。让我们以网格中更新的用户详细信息为例：

     ```javascript
     <button onClick={(e) => this.updateUser(userId, e)}>Update User details</button>
     <button onClick={this.updateUser.bind(this, userId)}>Update User details</button>
     ```

     在这两种方法中，合成参数 e 作为第二个参数传递。你需要在箭头函数中显式传递它，并使用 bind 方法自动转发它。

     **[⬆ 返回顶部](#目录)**

266. ### 如何防止组件渲染?

     你可以基于特定的条件通过返回 null 值来阻止组件的渲染。这样它就可以有条件地渲染组件。

     ```javascript
     function Greeting(props) {
       if (!props.loggedIn) {
         return null;
       }
     
       return (
         <div className="greeting">
           welcome, {props.name}
         </div>
       );
     }
     ```

     ```javascript
     class User extends React.Component {
       constructor(props) {
         super(props);
         this.state = {loggedIn: false, name: 'John'};
       }
     
       render() {
        return (
            <div>
              //Prevent component render if it is not loggedIn
              <Greeting loggedIn={this.state.loggedIn} />
              <UserDetails name={this.state.name}>
            </div>
        );
       }
     ```

     在上面的示例中，greeting 组件通过应用条件并返回空值跳过其渲染部分。

     **[⬆ 返回顶部](#目录)**

267. ### 安全地使用索引作为键的条件是什么?

     有三个条件可以确保，使用索引作为键是安全的：

     1. 列表项是静态的，它们不会被计算，也不会更改。
     2. 列表中的列表项没有 ids 属性。
     3. 列表不会被重新排序或筛选。

     **[⬆ 返回顶部](#目录)**

268. ### keys 是否需要全局唯一?

     数组中使用的键在其同级中应该是唯一的，但它们不需要是全局唯一的。也就是说，你可以在两个不同的数组中使用相同的键。例如，下面的 book 组件在不同的组件中使用相同的数组：

     ```javascript
     function Book(props) {
       const index = (
         <ul>
           {props.pages.map((page) =>
             <li key={page.id}>
               {page.title}
             </li>
           )}
         </ul>
       );
       const content = props.pages.map((page) =>
         <div key={page.id}>
           <h3>{page.title}</h3>
           <p>{page.content}</p>
           <p>{page.pageNumber}</p>
         </div>
       );
       return (
         <div>
           {index}
           <hr />
           {content}
         </div>
       );
     }
     ```

     **[⬆ 返回顶部](#目录)**

269. ### 用于表单处理的流行选择是什么?

     Formik 是一个用于 React 的表单库，它提供验证、跟踪访问字段和处理表单提交等解决方案。具体来说，你可以按以下方式对它们进行分类：

     1. 获取表单状态输入和输出的值。
     2. 表单验证和错误消息。
     3. 处理表单提交。

     它用于创建一个具有最小 API 的可伸缩、性能良好的表单助手，以解决令人讨厌的问题。

     **[⬆ 返回顶部](#目录)**

270. ### formik 相对于其他 redux 表单库有什么优势?

     下面是建议使用 formik 而不是 redux 表单库的主要原因：

     1. 表单状态本质上是短期的和局部的，因此不需要在 redux（或任何类型的flux库）中跟踪它。
     2. 每次按一个键，Redux-Form 都会多次调用整个顶级 Redux Reducer。这样就增加了大型应用程序的输入延迟。
     3. 经过 gzip 压缩过的 Redux-Form 为 22.5 kB，而 Formik 只有 12.7 kB。

     **[⬆ 返回顶部](#目录)**

271. ### 为什么不需要使用继承?

     在 React 中，建议使用组合而不是继承来重用组件之间的代码。Props 和 composition 都为你提供了以一种明确和安全的方式自定义组件外观和行为所需的灵活性。但是，如果你希望在组件之间复用非 UI 功能，建议将其提取到单独的 JavaScript 模块中。之后的组件导入它并使用该函数、对象或类，而不需扩展它。

     **[⬆ 返回顶部](#目录)**

272. ### 我可以在 React 应用程序中可以使用 web components 么?

     是的，你可以在 React 应用程序中使用 Web Components。尽管许多开发人员不会使用这种组合方式，但如果你使用的是使用 Web Components 编写的第三方 UI 组件，则可能需要这种组合。例如，让我们使用 Vaadin 提供的 Web Components 日期选择器组件：

     ```javascript
     import React, { Component } from 'react';
     import './App.css';
     import '@vaadin/vaadin-date-picker';
     
     class App extends Component {
       render() {
         return (
           <div className="App">
             <vaadin-date-picker label="When were you born?"></vaadin-date-picker>
           </div>
         );
       }
     }
     
     export default App;
     ```

     **[⬆ 返回顶部](#目录)**

273. ### 什么是动态导入?

     动态导入语法是 ECMAScript 提案，目前不属于语言标准的一部分。它有望在不久的将来被采纳。在你的应用程序中，你可以使用动态导入来实现代码拆分。让我们举一个加法的例子：

     1. **Normal Import**
     ```javascript
     import { add } from './math';
     console.log(add(10, 20));
     ```

     2. **Dynamic Import**
     ```javascript
     import("./math").then(math => {
       console.log(math.add(10, 20));
     });
     ```

     **[⬆ 返回顶部](#目录)**

274. ### 什么是 loadable 组件?

     如果你想要在服务端渲染的应用程序中实现代码拆分，建议使用 Loadable 组件，因为 React.lazy 和 Suspense 还不可用于服务器端渲染。Loadable 允许你将动态导入的组件作为常规的组件进行渲染。让我们举一个例子：

     ```javascript
     import loadable from '@loadable/component'
     
     const OtherComponent = loadable(() => import('./OtherComponent'))
     
     function MyComponent() {
       return (
         <div>
           <OtherComponent />
         </div>
       )
     }
     ```

     现在，其他组件将以单独的包进行加载。

     **[⬆ 返回顶部](#目录)**

275. ### 什么是 suspense 组件?

     如果父组件在渲染时包含 dynamic import 的模块尚未加载完成，在此加载过程中，你必须使用一个 loading 指示器显示后备内容。这可以使用 **Suspense** 组件来实现。例如，下面的代码使用 Suspense 组件：

     ```javascript
     const OtherComponent = React.lazy(() => import('./OtherComponent'));
     
     function MyComponent() {
       return (
         <div>
           <Suspense fallback={<div>Loading...</div>}>
             <OtherComponent />
           </Suspense>
         </div>
       );
     }
     ```

     正如上面的代码中所展示的，懒加载的组件被包装在 Suspense 组件中。

     **[⬆ 返回顶部](#目录)**

276. ### 什么是基于路由的代码拆分?

     进行代码拆分的最佳位置之一是路由。整个页面将立即重新渲染，因此用户不太可能同时与页面中的其他元素进行交互。因此，用户体验不会受到干扰。让我们以基于路由的网站为例，使用像 React Router 和 React.lazy 这样的库：

     ```javascript
     import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
     import React, { Suspense, lazy } from 'react';
     
     const Home = lazy(() => import('./routes/Home'));
     const About = lazy(() => import('./routes/About'));
     
     const App = () => (
       <Router>
         <Suspense fallback={<div>Loading...</div>}>
           <Switch>
             <Route exact path="/" component={Home}/>
             <Route path="/about" component={About}/>
           </Switch>
         </Suspense>
       </Router>
     );
     ```

     在上面的代码中，代码拆分将发生在每个路由层级。

     **[⬆ 返回顶部](#目录)**

277. ### 举例说明如何使用 context?

     **Context** 旨在共享可被视为全局的数据，用于 React 组件树。例如，在下面的代码中，允许手动通过一个 theme 属性来设置按钮组件的样式。

     ```javascript
     //Lets create a context with a default theme value "luna"
     const ThemeContext = React.createContext('luna');
     // Create App component where it uses provider to pass theme value in the tree
     class App extends React.Component {
       render() {
         return (
           <ThemeContext.Provider value="nova">
             <Toolbar />
           </ThemeContext.Provider>
         );
       }
     }
     // A middle component where you don't need to pass theme prop anymore
     function Toolbar(props) {
       return (
         <div>
           <ThemedButton />
         </div>
       );
     }
     // Lets read theme value in the button component to use
     class ThemedButton extends React.Component {
       static contextType = ThemeContext;
       render() {
         return <Button theme={this.context} />;
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

278. ### 在 context 中默认值的目的是什么?

     当在组件树中的组件没有匹配到在其上方的 Provider 时，才会使用 defaultValue 参数。这有助于在不包装组件的情况下单独测试组件。下面的代码段提供了默认的主题值 Luna。

     ```javascript
     const defaultTheme = "Luna";
     const MyContext = React.createContext(defaultTheme);
     ```

     **[⬆ 返回顶部](#目录)**

279. ### 你是怎么使用 contextType?

     ContextType 用于消费 context 对象。ContextType 属性可以通过两种方式使用：

     1. **contextType as property of class:**
     可以为类的 contextType 属性分配通过 React.createContext() 创建的 context 对象。之后，你可以在任何生命周期方法和 render 函数中使用 `this.context` 引用该上下文类型最近的当前值。

     让我们在 MyClass 上按如下方式设置 contextType 属性：

     ```javascript
     class MyClass extends React.Component {
       componentDidMount() {
         let value = this.context;
         /* perform a side-effect at mount using the value of MyContext */
       }
       componentDidUpdate() {
         let value = this.context;
         /* ... */
       }
       componentWillUnmount() {
         let value = this.context;
         /* ... */
       }
       render() {
         let value = this.context;
         /* render something based on the value of MyContext */
       }
     }
     MyClass.contextType = MyContext;
     ```

     2. **Static field**
     你可以使用静态类属性来初始化 contextType 属性：

     ```javascript
     class MyClass extends React.Component {
       static contextType = MyContext;
       render() {
         let value = this.context;
         /* render something based on the value */
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

280. ### 什么是 consumer?

     Consumer 是一个订阅上下文更改的 React 组件。它需要一个函数作为子元素，该函数接收当前上下文的值作为参数，并返回一个 React 元素。传递给函数 value 参数的参数值将等于在组件树中当前组件最近的 Provider 元素的 value 属性值。举个简单的例子：

     ```javascript
     <MyContext.Consumer>
       {value => /* render something based on the context value */}
     </MyContext.Consumer>
     ```

     **[⬆ 返回顶部](#目录)**

281. ### 在使用 context 时，如何解决性能方面的问题?

     Context 使用引用标识来确定何时重新渲染，当 Provider 的父元素重新渲染时，会有一些问题即可能会在 Consumers 中触发无任何意图的渲染。 例如，下面的代码将在每次 Provider 重新渲染时，重新渲染所有的 Consumers，这是因为渲染 Provider 时，始终会为 value 属性创建一个新的对象：

     ```javascript
     class App extends React.Component {
       render() {
         return (
           <Provider value={{something: 'something'}}>
             <Toolbar />
           </Provider>
         );
       }
     }
     ```

     可以通过把 value 的值提升到父状态中来解决这个问题：

     ```javascript
     class App extends React.Component {
       constructor(props) {
         super(props);
         this.state = {
           value: {something: 'something'},
         };
       }
     
       render() {
         return (
           <Provider value={this.state.value}>
             <Toolbar />
           </Provider>
         );
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

282. ### 在 HOCs 中 forward ref 的目的是什么?

     因为 ref 不是一个属性，所以 Refs 不会被传递。就像 **key** 一样，React 会以不同的方式处理它。如果你将 ref 添加到 HOC，则该 ref 将引用最外层的容器组件，而不是包装的组件。在这种情况下，你可以使用 Forward Ref API。例如，你可以使用 React.forwardRef API 显式地将 refs 转发的内部的 FancyButton 组件。

     以下的 HOC 会记录所有的 props 变化：

     ```javascript
     function logProps(Component) {
       class LogProps extends React.Component {
         componentDidUpdate(prevProps) {
           console.log('old props:', prevProps);
           console.log('new props:', this.props);
         }
     
         render() {
           const {forwardedRef, ...rest} = this.props;
     
           // Assign the custom prop "forwardedRef" as a ref
           return <Component ref={forwardedRef} {...rest} />;
         }
       }
     
       return React.forwardRef((props, ref) => {
         return <LogProps {...props} forwardedRef={ref} />;
       });
     }
     ```

     让我们使用这个 HOC 来记录所有传递到我们 “fancy button” 组件的属性：

     ```javascript
     class FancyButton extends React.Component {
       focus() {
         // ...
       }
     
       // ...
     }
     export default logProps(FancyButton);
     ```

     现在让我们创建一个 ref 并将其传递给 FancyButton 组件。在这种情况下，你可以聚焦到 button 元素上。

     ```javascript
     import FancyButton from './FancyButton';
     
     const ref = React.createRef();
     ref.current.focus();
     <FancyButton
       label="Click Me"
       handleClick={handleClick}
       ref={ref}
     />;
     ```

     **[⬆ 返回顶部](#目录)**

283. ### ref 参数对于所有函数或类组件是否可用?

     常规函数或类组件不会接收到 ref 参数，并且 ref 在 props 中也不可用。只有在使用 React.forwardRef 定义组件时，才存在第二个 ref 参数。

     **[⬆ 返回顶部](#目录)**

284. ### 在组件库中当使用 forward refs 时，你需要额外的注意?

     当你开始在组件库中使用 forwardRef 时，你应该将其视为一个破坏性的更改，并为库发布一个新的主要版本。这是因为你的库可能具有不同的行为，如已分配了哪些引用，以及导出哪些类型。这些更改可能会破坏依赖于旧行为的应用程序和其他库。

     **[⬆ 返回顶部](#目录)**

285. ### 如何在没有 ES6 的情况下创建 React 类组件

     如果你不使用 ES6，那么你可能需要使用 create-react-class 模块。对于默认属性，你需要在传递对象上定义 getDefaultProps() 函数。而对于初始状态，必须提供返回初始状态的单独 getInitialState 方法。

     ```javascript
     var Greeting = createReactClass({
       getDefaultProps: function() {
           return {
             name: 'Jhohn'
           };
         },
       getInitialState: function() {
           return {message: this.props.message};
         },
       handleClick: function() {
          console.log(this.state.message);
       },
       render: function() {
         return <h1>Hello, {this.props.name}</h1>;
       }
     });
     ```

     **注意：** 如果使用 createReactClass，则所有方法都会自动绑定。也就是说，你不需要在事件处理程序的构造函数中使用 .bind(this)。

     **[⬆ 返回顶部](#目录)**

286. ### 是否可以在没有 JSX 的情况下使用 React?

     是的，使用 React 不强制使用 JSX。实际上，当你不想在构建环境中配置编译环境时，这是很方便的。每个 JSX 元素只是调用 React.createElement(component, props, ...children) 的语法糖。例如，让我们来看一下使用 JSX 的 greeting 示例：

     ```jsx
     class Greeting extends React.Component {
       render() {
         return <div>Hello {this.props.message}</div>;
       }
     }
     
     ReactDOM.render(
       <Greeting message="World" />,
       document.getElementById('root')
     );
     ```

     你可以在没有 JSX 的情况下编写相同的功能，如下所示：

     ```javascript
     class Greeting extends React.Component {
       render() {
         return React.createElement('div', null, `Hello ${this.props.message}`);
       }
     }
     
     ReactDOM.render(
       React.createElement(Greeting, {message: 'World'}, null),
       document.getElementById('root')
     );
     ```

     **[⬆ 返回顶部](#目录)**

287. ### 什么是差异算法?

     React 需要使用算法来了解如何有效地更新 UI 以匹配最新的树。差异算法将生成将一棵树转换为另一棵树的最小操作次数。然而，算法具有 O(n3) 的复杂度，其中 n 是树中元素的数量。在这种情况下，对于显示 1000 个元素将需要大约 10 亿个比较。这太昂贵了。相反，React 基于两个假设实现了一个复杂度为 O(n) 的算法：

     1. 两种不同类型的元素会产生不同的树结构。
     2. 开发者可以通过一个 key 属性，标识哪些子元素可以在不同渲染中保持稳定。

     **[⬆ 返回顶部](#目录)**

288. ### 差异算法涵盖了哪些规则?

     在区分两棵树时，React 首先比较两个根元素。根据根元素的类型，行为会有所不同。它在重构算法中涵盖了以下规则：

     1. **不同类型的元素：**
        每当根元素具有不同的类型时，React 将移除旧树并从头开始构建新树。例如，元素 <a> 到 <img>，或从 <Article> 到 <Comment> 的不同类型的元素引导完全重建。

     2. **相同类型的DOM元素：**
        当比较两个相同类型的 React DOM 元素时，React 查看两者的属性，保持相同的底层 DOM 节点，并仅更新已更改的属性。让我们以相同的 DOM 元素为例，除了 className 属性，

        ```javascript
        <div className="show" title="ReactJS" />

        <div className="hide" title="ReactJS" />
        ```

     3. **相同类型的组件元素：**

        当组件更新时，实例保持不变，以便在渲染之间保持状态。React 更新底层组件实例的 props 以匹配新元素，并在底层实例上调用 componentWillReceiveProps() 和 componentWillUpdate()。之后，调用 render() 方法，diff 算法对前一个结果和新结果进行递归。

     4. **递归子节点：**
        当对 DOM 节点的子节点进行递归时，React 会同时迭代两个子节点列表，并在出现差异时生成变异。例如，在子节点末尾添加元素时，在这两个树之间进行转换效果很好。

        ```javascript
        <ul>
          <li>first</li>
          <li>second</li>
        </ul>

        <ul>
          <li>first</li>
          <li>second</li>
          <li>third</li>
        </ul>

        ```
     5. **处理 Key：**

     React支持 key 属性。当子节点有 key 时，React 使用 key 将原始树中的子节点与后续树中的子节点相匹配。例如，添加 key 可以使树有效地转换，

     ```javascript
     <ul>
       <li key="2015">Duke</li>
       <li key="2016">Villanova</li>
     </ul>
     
     <ul>
       <li key="2014">Connecticut</li>
       <li key="2015">Duke</li>
       <li key="2016">Villanova</li>
     </ul>
     ```

     **[⬆ 返回顶部](#目录)**

289. ### 你什么时候需要使用 refs?

     这里是 refs 的一些使用场景：

     1. 管理聚焦、文本选择或媒体播放。
     2. 触发命令式动画。
     3. 与第三方 DOM 库集成。

     **[⬆ 返回顶部](#目录)**

290. ### 对于渲染属性来说是否必须将 prop 属性命名为 render?

     即使模式名为 `render props`，你也不必使用名为 render 的属性名来使用此模式。也就是说，组件用于知道即将渲染内容的任何函数属性，在技术上都是一个 `render props`。让我们举一个名为 children 渲染属性的示例：

     ```javascript
     <Mouse children={mouse => (
       <p>The mouse position is {mouse.x}, {mouse.y}</p>
     )}/>
     ```

     实际上，以上的 children 属性不一定需要在 JSX 元素的 `attributes` 列表中命名。反之，你可以将它直接放在元素内部：  

     ```javascript
     <Mouse>
       {mouse => (
         <p>The mouse position is {mouse.x}, {mouse.y}</p>
       )}
     </Mouse>
     ```

     当使用上述的技术，需要在 propTypes 中明确声明 children 必须为函数类型：

     ```javascript
     Mouse.propTypes = {
       children: PropTypes.func.isRequired
     };
     ```

     **[⬆ 返回顶部](#目录)**

291. ### 在 Pure Component 中使用渲染属性会有什么问题?

     如果在渲染方法中创建函数，则会否定纯组件的用途。因为浅属性比较对于新属性总是返回 false，在这种情况下，每次渲染都将为渲染属性生成一个新值。你可以通过将渲染函数定义为实例方法来解决这个问题。

     **[⬆ 返回顶部](#目录)**

292. ### 如何使用渲染属性创建 HOC?

     可以使用带有渲染属性的常规组件实现大多数高阶组件（HOC）。例如，如果希望使用 withMouse HOC 而不是 `<Mouse>` 组件，则你可以使用带有渲染属性的常规 `<Mouse>` 组件轻松创建一个 HOC 组件。

     ```javascript
     function withMouse(Component) {
       return class extends React.Component {
         render() {
           return (
             <Mouse render={mouse => (
               <Component {...this.props} mouse={mouse} />
             )}/>
           );
         }
       }
     }
     ```

     **[⬆ 返回顶部](#目录)**

293. ### 什么是 windowing 技术?

     Windowing 是一种技术，它在任何给定时间只呈现一小部分行，并且可以显著减少重新呈现组件所需的时间以及创建的 DOM 节点的数量。如果应用程序呈现长的数据列表，则建议使用此技术。react-window 和 react-virtualized 都是常用的 windowing 库，它提供了几个可重用的组件，用于显示列表、网格和表格数据。

     **[⬆ 返回顶部](#目录)**

294. ### 你如何在 JSX 中打印 falsy 值?

     Falsy 值比如 false，null，undefined 是有效的子元素，但它们不会呈现任何内容。如果仍要显示它们，则需要将其转换为字符串。我们来举一个如何转换为字符串的例子：

     ```javascript
     <div>
       My JavaScript variable is {String(myVariable)}.
     </div>
     ```

     **[⬆ 返回顶部](#目录)**

295. ### portals 的典型使用场景是什么?

     当父组件拥有 `overflow: hidden` 或含有影响堆叠上下文的属性（z-index、position、opacity 等样式），且需要脱离它的容器进行展示时，React portal 就非常有用。例如，对话框、全局消息通知、悬停卡和工具提示。

     **[⬆ 返回顶部](#目录)**

296. ### 如何设置非受控组件的默认值?

     在 React 中，表单元素的属性值将覆盖其 DOM 中的值。对于非受控组件，你可能希望能够指定其初始值，但不会控制后续的更新。要处理这种情形，你可以指定一个 **defaultValue** 属性来取代 **value** 属性。

     ```javascript
     render() {
       return (
         <form onSubmit={this.handleSubmit}>
           <label>
             User Name:
             <input
               defaultValue="John"
               type="text"
               ref={this.input} />
           </label>
           <input type="submit" value="Submit" />
         </form>
       );
     }
     ```

     这同样适用于 `select` 和 `textArea` 输入框。但对于 `checkbox` 和 `radio` 控件，需要使用 **defaultChecked**。

     **[⬆ 返回顶部](#目录)**

297. ### 你最喜欢的 React 技术栈是什么?

     尽管技术栈因开发人员而异，但最流行的技术栈用于 React boilerplate 项目代码中。它主要使用 redux 和 redux saga 进行状态管理和具有副作用的异步操作，使用 react-router 进行路由管理，使用 styled-components 库开发 React 组件，使用 axios 调用 REST api，以及其他支持的技术栈，如 webpack、reseselect、esnext、babel 等。

     你可以克隆 [https://github.com/react-boilerplate/react-boilerplate](https://github.com/react-boilerplate/react-boilerplate) 并开始开发任何新的 React 项目。

     **[⬆ 返回顶部](#目录)**

298. ### Real DOM 和 Virtual DOM 有什么区别?
     以下是Real DOM和Virtual DOM之间的主要区别：

     | Real DOM | Virtual DOM |
     | ----- | ------- |
     | 更新速度慢 | 更新速度快 |
     | DOM 操作非常昂贵 | DOM 操作非常简单 |
     | 可以直接更新 HTML | 你不能直接更新 HTML |
     | 造成太多内存浪费 | 更少的内存消耗 |
     | 如果元素更新了，创建新的 DOM 节点 | 如果元素更新，则更新 JSX 元素 |

     **[⬆ 返回顶部](#目录)**

299. ### 如何为 React 应用程序添加 bootstrap?

     Bootstrap 可以通过三种可能的方式添加到 React 应用程序中：
     1. 使用 Bootstrap CDN:
        这是添加 bootstrap 最简单的方式。在 head 标签中添加 bootstrap 相应的 CSS 和 JS 资源。
     2. 把 Bootstrap 作为依赖项：
        如果你使用的是构建工具或模块绑定器（如Webpack），那么这是向 React 应用程序添加 bootstrap 的首选选项。

        ```shell
        npm install bootstrap
        ```
     3. 使用 React Bootstrap 包:
        在这种情况下，你可以将 Bootstrap 添加到我们的 React 应用程序中，方法是使用一个以 React 组件形式对 Bootstrap 组件进行包装后包。下面的包在此类别中很流行：
        1. react-bootstrap
        2. reactstrap

     **[⬆ 返回顶部](#目录)**

300. ### 你能否列出使用 React 作为前端框架的顶级网站或应用程序?

     以下是使用 React 作为前端框架的前 10 个网站：

     1. Facebook
     2. Uber
     3. Instagram
     4. WhatsApp
     5. Khan Academy
     6. Airbnb
     7. Dropbox
     8. Flipboard
     9. Netflix
     10. PayPal

     **[⬆ 返回顶部](#目录)**

301. ### 是否建议在 React 中使用 CSS In JS 技术?

     React 对如何定义样式没有任何意见，但如果你是初学者，那么好的起点是像往常一样在单独的 *.css 文件中定义样式，并使用类名引用它们。此功能不是 React 的一部分，而是来自第三方库。但是如果你想尝试不同的方法（JS中的CSS），那么 styled-components 库是一个不错的选择。

     **[⬆ 返回顶部](#目录)**

302. ### 我需要用 hooks 重写所有类组件吗?

     不需要。但你可以在某些组件（或新组件）中尝试使用 hooks，而无需重写任何已存在的代码。因为在 ReactJS 中目前没有移除 classes 的计划。

     **[⬆ 返回顶部](#目录)**

303. ### 如何使用 React Hooks 获取数据?

     名为 useEffect 的 effect hook 可用于使用 axios 从 API 中获取数据，并使用 useState 钩子提供的更新函数设置组件本地状态中的数据。让我们举一个例子，它从 API 中获取 react 文章列表。

     ```jsx 
     import React, { useState, useEffect } from 'react';
     import axios from 'axios';
     
     function App() {
       const [data, setData] = useState({ hits: [] });
     
       useEffect(async () => {
         const result = await axios(
           'http://hn.algolia.com/api/v1/search?query=react',
         );
     
         setData(result.data);
       }, []);
     
       return (
         <ul>
           {data.hits.map(item => (
             <li key={item.objectID}>
               <a href={item.url}>{item.title}</a>
             </li>
           ))}
         </ul>
       );
     }
     
     export default App;
     ```

     记住，我们为 effect hook 提供了一个空数组作为第二个参数，以避免在组件更新时再次激活它，它只会在组件挂载时被执行。比如，示例中仅在组件挂载时获取数据。

     **[⬆ 返回顶部](#目录)**

304. ### Hooks 是否涵盖了类的所有用例?

     Hooks 并没有涵盖类的所有用例，但是有计划很快添加它们。目前，还没有与不常见的 getSnapshotBeforeUpdate 和componentDidCatch 生命周期等效的钩子。
     

**[⬆ 返回顶部](#目录)**

> [转载自 haizlin/fe-interview](https://github.com/haizlin/fe-interview/blob/master/lib/Vue.md)


# vue面试题
> 鼓励PR，持续更新（Vue v2.6.10）

## 历史题目(最新：2019.07.27)
[vue](#vue) | [vue-cli](#vue-cli) | [vue-router](#vue-router) | [vuex](#vuex)  | [ElementUI](#ElementUI) | [ElementUI](#ElementUI) | [mint-ui](#mint-ui)

### vue
- [从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织](https://github.com/haizlin/fe-interview/issues/983)
- [你知道vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解](https://github.com/haizlin/fe-interview/issues/561)
- [你知道v-model的原理吗？说说看](https://github.com/haizlin/fe-interview/issues/560)
- [你有使用过vue开发多语言项目吗？说说你的做法？](https://github.com/haizlin/fe-interview/issues/559)
- [在使用计算属性的时，函数名和data数据源中的数据可以同名吗？](https://github.com/haizlin/fe-interview/issues/558)
- [vue中data的属性可以和methods中的方法同名吗？为什么？](https://github.com/haizlin/fe-interview/issues/557)
- [怎么给vue定义全局的方法？](https://github.com/haizlin/fe-interview/issues/556)
- [vue2.0不再支持v-html中使用过滤器了怎么办？](https://github.com/haizlin/fe-interview/issues/555)
- [怎么解决vue打包后静态资源图片失效的问题？](https://github.com/haizlin/fe-interview/issues/554)
- [怎么解决vue动态设置img的src不生效的问题？](https://github.com/haizlin/fe-interview/issues/553)
- [使用vue后怎么针对搜索引擎做SEO优化？](https://github.com/haizlin/fe-interview/issues/552)
- [跟keep-alive有关的生命周期是哪些？描述下这些生命周期](https://github.com/haizlin/fe-interview/issues/551)
- [如果现在让你从vue/react/angularjs三个中选择一个，你会选哪个？说说你的理由](https://github.com/haizlin/fe-interview/issues/550)
- [你知道vue2.0兼容IE哪个版本以上吗？](https://github.com/haizlin/fe-interview/issues/549)
- [使用vue开发一个todo小应用，谈下你的思路](https://github.com/haizlin/fe-interview/issues/548)
- [你有看过vue推荐的风格指南吗？列举出你知道的几条](https://github.com/haizlin/fe-interview/issues/547)
- [你是从vue哪个版本开始用的？你知道1.x和2.x有什么区别吗？](https://github.com/haizlin/fe-interview/issues/546)
- [你知道vue中key的原理吗？说说你对它的理解](https://github.com/haizlin/fe-interview/issues/545)
- [vue中怎么重置data？](https://github.com/haizlin/fe-interview/issues/544)
- [vue渲染模板时怎么保留模板中的HTML注释呢？](https://github.com/haizlin/fe-interview/issues/508)
- [Vue.observable你有了解过吗？说说看](https://github.com/haizlin/fe-interview/issues/507)
- [你知道style加scoped属性的用途和原理吗？](https://github.com/haizlin/fe-interview/issues/506)
- [你期待vue3.0有什么功能或者改进的地方？](https://github.com/haizlin/fe-interview/issues/489)
- [vue边界情况有哪些？](https://github.com/haizlin/fe-interview/issues/478)
- [如何在子组件中访问父组件的实例？](https://github.com/haizlin/fe-interview/issues/477)
- [watch的属性用箭头函数定义结果会怎么样？](https://github.com/haizlin/fe-interview/issues/476)
- [在vue项目中如果methods的方法用箭头函数定义结果会怎么样？](https://github.com/haizlin/fe-interview/issues/475)
- [在vue项目中如何配置favicon？](https://github.com/haizlin/fe-interview/issues/474)
- [你有使用过babel-polyfill模块吗？主要是用来做什么的？](https://github.com/haizlin/fe-interview/issues/473)
- [说说你对vue的错误处理的了解？](https://github.com/haizlin/fe-interview/issues/472)
- [在vue事件中传入$event，使用e.target和e.currentTarget有什么区别？](https://github.com/haizlin/fe-interview/issues/471)
- [在.vue文件中style是必须的吗？那script是必须的吗？为什么？](https://github.com/haizlin/fe-interview/issues/470)
- [vue怎么实现强制刷新组件？](https://github.com/haizlin/fe-interview/issues/469)
- [vue自定义事件中父组件怎么接收子组件的多个参数？](https://github.com/haizlin/fe-interview/issues/468)
- [实际工作中，你总结的vue最佳实践有哪些？](https://github.com/haizlin/fe-interview/issues/467)
- [vue给组件绑定自定义事件无效怎么解决？](https://github.com/haizlin/fe-interview/issues/466)
- [vue的属性名称与method的方法名称一样时会发生什么问题？](https://github.com/haizlin/fe-interview/issues/465)
- [vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？](https://github.com/haizlin/fe-interview/issues/464)
- [vue使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？](https://github.com/haizlin/fe-interview/issues/463)
- [vue如果想扩展某个现有的组件时，怎么做呢？](https://github.com/haizlin/fe-interview/issues/462)
- [说下$attrs和$listeners的使用场景](https://github.com/haizlin/fe-interview/issues/461)
- [分析下vue项目本地开发完成后部署到服务器后报404是什么原因呢？](https://github.com/haizlin/fe-interview/issues/460)
- [v-once的使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/459)
- [说说你对vue的表单修饰符.lazy的理解](https://github.com/haizlin/fe-interview/issues/458)
- [vue为什么要求组件模板只能有一个根元素？](https://github.com/haizlin/fe-interview/issues/457)
- [EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？](https://github.com/haizlin/fe-interview/issues/456)
- [怎么修改vue打包后生成文件路径？](https://github.com/haizlin/fe-interview/issues/455)
- [你有使用做过vue与原生app交互吗？说说vue与ap交互的方法](https://github.com/haizlin/fe-interview/issues/454)
- [使用vue写一个tab切换](https://github.com/haizlin/fe-interview/issues/453)
- [vue中什么是递归组件？举个例子说明下？](https://github.com/haizlin/fe-interview/issues/452)
- [怎么访问到子组件的实例或者子元素？](https://github.com/haizlin/fe-interview/issues/451)
- [在子组件中怎么访问到父组件的实例？](https://github.com/haizlin/fe-interview/issues/450)
- [在组件中怎么访问到根实例？](https://github.com/haizlin/fe-interview/issues/449)
- [说说你对Object.defineProperty的理解](https://github.com/haizlin/fe-interview/issues/448)
- [vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？](https://github.com/haizlin/fe-interview/issues/447)
- [vue组件里的定时器要怎么销毁？](https://github.com/haizlin/fe-interview/issues/446)
- [vue组件会在什么时候下被销毁？](https://github.com/haizlin/fe-interview/issues/445)
- [使用vue渲染大量数据时应该怎么优化？说下你的思路！](https://github.com/haizlin/fe-interview/issues/444)
- [在vue中使用this应该注意哪些问题？](https://github.com/haizlin/fe-interview/issues/443)
- [你有使用过JSX吗？说说你对JSX的理解](https://github.com/haizlin/fe-interview/issues/442)
- [说说组件的命名规范](https://github.com/haizlin/fe-interview/issues/441)
- [怎么配置使vue2.0+支持TypeScript写法？](https://github.com/haizlin/fe-interview/issues/440)
- [`<template></template>`有什么用？](https://github.com/haizlin/fe-interview/issues/439)
- [vue的is这个特性你有用过吗？主要用在哪些方面？](https://github.com/haizlin/fe-interview/issues/438)
- [vue的:class和:style有几种表示方式？](https://github.com/haizlin/fe-interview/issues/437)
- [你了解什么是函数式组件吗？](https://github.com/haizlin/fe-interview/issues/436)
- [vue怎么改变插入模板的分隔符？](https://github.com/haizlin/fe-interview/issues/435)
- [组件中写name选项有什么作用？](https://github.com/haizlin/fe-interview/issues/434)
- [说说你对provide和inject的理解](https://github.com/haizlin/fe-interview/issues/433)
- [开发过程中有使用过devtools吗？](https://github.com/haizlin/fe-interview/issues/432)
- [说说你对slot的理解有多少？slot使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/431)
- [你有使用过动态组件吗？说说你对它的理解](https://github.com/haizlin/fe-interview/issues/430)
- [prop验证的type类型有哪几种？](https://github.com/haizlin/fe-interview/issues/429)
- [prop是怎么做验证的？可以设置默认值吗？](https://github.com/haizlin/fe-interview/issues/428)
- [怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢？](https://github.com/haizlin/fe-interview/issues/427)
- [说说你对vue组件的设计原则的理解](https://github.com/haizlin/fe-interview/issues/426)
- [你了解vue的diff算法吗？](https://github.com/haizlin/fe-interview/issues/425)
- [vue如何优化首页的加载速度？](https://github.com/haizlin/fe-interview/issues/424)
- [vue打包成最终的文件有哪些？](https://github.com/haizlin/fe-interview/issues/423)
- [ajax、fetch、axios这三都有什么区别？](https://github.com/haizlin/fe-interview/issues/422)
- [vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？](https://github.com/haizlin/fe-interview/issues/421)
- [vue中是如何使用event对象的？](https://github.com/haizlin/fe-interview/issues/420)
- [vue首页白屏是什么问题引起的？如何解决呢？](https://github.com/haizlin/fe-interview/issues/366)
- [说说你对单向数据流和双向数据流的理解](https://github.com/haizlin/fe-interview/issues/365)
- [移动端ui你用的是哪个ui库？有遇到过什么问题吗？](https://github.com/haizlin/fe-interview/issues/364)
- [你知道nextTick的原理吗？](https://github.com/haizlin/fe-interview/issues/363)
- [说说你对v-clock和v-pre指令的理解](https://github.com/haizlin/fe-interview/issues/362)
- [写出你知道的表单修饰符和事件修饰符](https://github.com/haizlin/fe-interview/issues/361)
- [说说你对proxy的理解](https://github.com/haizlin/fe-interview/issues/359)
- [你有自己用vue写过UI组件库吗？](https://github.com/haizlin/fe-interview/issues/358)
- [用vue怎么实现一个换肤的功能？](https://github.com/haizlin/fe-interview/issues/357)
- [有在vue中使用过echarts吗？踩过哪些坑？如何解决的？](https://github.com/haizlin/fe-interview/issues/356)
- [如果让你教一个2-3年经验前端经验的同事使用vue，你该怎么教？](https://github.com/haizlin/fe-interview/issues/355)
- [vue性能的优化的方法有哪些？](https://github.com/haizlin/fe-interview/issues/354)
- [SSR解决了什么问题？有做过SSR吗？你是怎么做的？](https://github.com/haizlin/fe-interview/issues/353)
- [说说你觉得认为的vue开发规范有哪些？](https://github.com/haizlin/fe-interview/issues/352)
- [vue部署上线前需要做哪些准备工作？](https://github.com/haizlin/fe-interview/issues/350)
- [vue过渡动画实现的方式有哪些？](https://github.com/haizlin/fe-interview/issues/349)
- [vue在created和mounted这两个生命周期中请求数据有什么区别呢？](https://github.com/haizlin/fe-interview/issues/348)
- [vue父子组件双向绑定的方法有哪些？](https://github.com/haizlin/fe-interview/issues/347)
- [vue怎么获取DOM节点？](https://github.com/haizlin/fe-interview/issues/346)
- [vue项目有做过单元测试吗？](https://github.com/haizlin/fe-interview/issues/345)
- [vue项目有使用过npm run build --report吗？](https://github.com/haizlin/fe-interview/issues/344)
- [如何解决vue打包vendor过大的问题？](https://github.com/haizlin/fe-interview/issues/343)
- [webpack打包vue速度太慢怎么办？](https://github.com/haizlin/fe-interview/issues/342)
- [vue在开发过程中要同时跟N个不同的后端人员联调接口（请求的url不一样）时你该怎么办？](https://github.com/haizlin/fe-interview/issues/341)
- [vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？](https://github.com/haizlin/fe-interview/issues/340)
- [说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？](https://github.com/haizlin/fe-interview/issues/339)
- [在移动端使用vue，你觉得最佳实践有哪些？](https://github.com/haizlin/fe-interview/issues/338)
- [你们项目为什么会选vue而不选择其它的框架呢？](https://github.com/haizlin/fe-interview/issues/337)
- [对于即将到来的vue3.0特性你有什么了解的吗？](https://github.com/haizlin/fe-interview/issues/336)
- [vue开发过程中你有使用什么辅助工具吗？](https://github.com/haizlin/fe-interview/issues/335)
- [vue和微信小程序写法上有什么区别？](https://github.com/haizlin/fe-interview/issues/334)
- [怎么缓存当前的组件？缓存后怎么更新？](https://github.com/haizlin/fe-interview/issues/333)
- [你了解什么是高阶组件吗？可否举个例子说明下？](https://github.com/haizlin/fe-interview/issues/332)
- [为什么我们写组件的时候可以写在.vue里呢？可以是别的文件名后缀吗？](https://github.com/haizlin/fe-interview/issues/331)
- [vue-loader是什么？它有什么作用？](https://github.com/haizlin/fe-interview/issues/330)
- [说说你对vue的extend（构造器）的理解，它主要是用来做什么的？](https://github.com/haizlin/fe-interview/issues/329)
- [如果将axios异步请求同步化处理？](https://github.com/haizlin/fe-interview/issues/328)
- [怎么捕获组件vue的错误信息？](https://github.com/haizlin/fe-interview/issues/327)
- [为什么vue使用异步更新组件？](https://github.com/haizlin/fe-interview/issues/326)
- [如何实现一个虚拟DOM？说说你的思路](https://github.com/haizlin/fe-interview/issues/325)
- [写出多种定义组件模板的方法](https://github.com/haizlin/fe-interview/issues/324)
- [SPA单页面的实现方式有哪些？](https://github.com/haizlin/fe-interview/issues/323)
- [说说你对SPA单页面的理解，它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/322)
- [说说你都用vue做过哪些类型的项目？](https://github.com/haizlin/fe-interview/issues/321)
- [在vue项目中如何引入第三方库（比如jQuery）？有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/320)
- [使用vue手写一个过滤器](https://github.com/haizlin/fe-interview/issues/319)
- [你有使用过render函数吗？有什么好处？](https://github.com/haizlin/fe-interview/issues/318)
- [写出你常用的指令有哪些？](https://github.com/haizlin/fe-interview/issues/317)
- [手写一个自定义指令及写出如何调用](https://github.com/haizlin/fe-interview/issues/316)
- [组件进来请求接口时你是放在哪个生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/315)
- [你有用过事件总线(EventBus)吗？说说你的理解](https://github.com/haizlin/fe-interview/issues/314)
- [说说vue的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/313)
- [DOM渲染在哪个周期中就已经完成了？](https://github.com/haizlin/fe-interview/issues/312)
- [第一次加载页面时会触发哪几个钩子？](https://github.com/haizlin/fe-interview/issues/311)
- [vue生命周期总共有几个阶段？](https://github.com/haizlin/fe-interview/issues/310)
- [vue生命周期的作用是什么？](https://github.com/haizlin/fe-interview/issues/309)
- [vue和angular有什么区别呢？](https://github.com/haizlin/fe-interview/issues/308)
- [如何引入scss？引入后如何使用？](https://github.com/haizlin/fe-interview/issues/307)
- [使用vue开发过程你是怎么做接口管理的？](https://github.com/haizlin/fe-interview/issues/306)
- [为何官方推荐使用axios而不用vue-resource？](https://github.com/haizlin/fe-interview/issues/305)
- [你了解axios的原理吗？有看过它的源码吗？](https://github.com/haizlin/fe-interview/issues/304)
- [你有封装过axios吗？主要是封装哪方面的？](https://github.com/haizlin/fe-interview/issues/303)
- [如何中断axios的请求？](https://github.com/haizlin/fe-interview/issues/302)
- [axios是什么？怎样使用它？怎么解决跨域的问题？](https://github.com/haizlin/fe-interview/issues/301)
- [说说你对vue的template编译的理解？](https://github.com/haizlin/fe-interview/issues/292)
- [v-on可以绑定多个方法吗？](https://github.com/haizlin/fe-interview/issues/291)
- [vue常用的修饰符有哪些？列举并说明](https://github.com/haizlin/fe-interview/issues/290)
- [你认为vue的核心是什么？](https://github.com/haizlin/fe-interview/issues/289)
- [v-model是什么？有什么用呢？](https://github.com/haizlin/fe-interview/issues/288)
- [说说你对vue的mixin的理解，有什么应用场景？](https://github.com/haizlin/fe-interview/issues/287)
- [SPA首屏加载速度慢的怎么解决？](https://github.com/haizlin/fe-interview/issues/286)
- [删除数组用delete和Vue.delete有什么区别？](https://github.com/haizlin/fe-interview/issues/285)
- [动态给vue的data添加一个新的属性时会发生什么？怎样解决？](https://github.com/haizlin/fe-interview/issues/284)
- [组件和插件有什么区别？](https://github.com/haizlin/fe-interview/issues/283)
- [说说你使用vue过程中遇到的问题（坑）有哪些，你是怎么解决的？](https://github.com/haizlin/fe-interview/issues/274)
- [说说你对选项el,template,render的理解](https://github.com/haizlin/fe-interview/issues/273)
- [vue实例挂载的过程是什么？](https://github.com/haizlin/fe-interview/issues/272)
- [vue在组件中引入插件的方法有哪些？](https://github.com/haizlin/fe-interview/issues/271)
- [v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？](https://github.com/haizlin/fe-interview/issues/270)
- [分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？](https://github.com/haizlin/fe-interview/issues/269)
- [$nextTick有什么作用？](https://github.com/haizlin/fe-interview/issues/268)
- [为什么data属性必须声明为返回一个初始数据对应的函数呢？](https://github.com/haizlin/fe-interview/issues/267)
- [怎么在watch监听开始之后立即被调用？](https://github.com/haizlin/fe-interview/issues/266)
- [watch怎么深度监听对象变化？](https://github.com/haizlin/fe-interview/issues/265)
- [watch和计算属性有什么区别？](https://github.com/haizlin/fe-interview/issues/264)
- [vue如何监听键盘事件？](https://github.com/haizlin/fe-interview/issues/263)
- [v-for循环中key有什么作用？](https://github.com/haizlin/fe-interview/issues/262)
- [怎么在vue中使用插件？](https://github.com/haizlin/fe-interview/issues/261)
- [你有写过自定义组件吗？](https://github.com/haizlin/fe-interview/issues/260)
- [说说你对keep-alive的理解是什么？](https://github.com/haizlin/fe-interview/issues/259)
- [怎么使css样式只在当前组件中生效？](https://github.com/haizlin/fe-interview/issues/258)
- [你有看过vue的源码吗？如果有那就说说看](https://github.com/haizlin/fe-interview/issues/235)
- [你有写过自定义指令吗？自定义指令的生命周期（钩子函数）有哪些？](https://github.com/haizlin/fe-interview/issues/234)
- [v-show和v-if有什么区别？使用场景分别是什么？](https://github.com/haizlin/fe-interview/issues/232)
- [说说你对MVC、MVP、MVVM模式的理解](https://github.com/haizlin/fe-interview/issues/231)
- [说下你对指令的理解？](https://github.com/haizlin/fe-interview/issues/230)
- [请描述下vue的生命周期是什么？](https://github.com/haizlin/fe-interview/issues/229)
- [vue组件之间的通信都有哪些？](https://github.com/haizlin/fe-interview/issues/228)
- [什么是虚拟DOM？](https://github.com/haizlin/fe-interview/issues/227)
- [什么是双向绑定？原理是什么？](https://github.com/haizlin/fe-interview/issues/226)
- [vue和react有什么不同？使用场景是什么？](https://github.com/haizlin/fe-interview/issues/225)
- [说说vue的优缺点](https://github.com/haizlin/fe-interview/issues/224)
- [有使用过vue吗？说说你对vue的理解](https://github.com/haizlin/fe-interview/issues/223)

### vue-cli
- [vue-cli提供了的哪几种脚手架模板？](https://github.com/haizlin/fe-interview/issues/543)
- [vue-cli工程中常用的npm命令有哪些？](https://github.com/haizlin/fe-interview/issues/542)
- [在使用vue-cli开发vue项目时，自动刷新页面的原理你了解吗？](https://github.com/haizlin/fe-interview/issues/541)
- [vue-cli3插件有写过吗？怎么写一个代码生成插件？](https://github.com/haizlin/fe-interview/issues/540)
- [vue-cli生成的项目可以使用es6、es7的语法吗？为什么？](https://github.com/haizlin/fe-interview/issues/488)
- [vue-cli怎么解决跨域的问题？](https://github.com/haizlin/fe-interview/issues/487)
- [vue-cli中你经常的加载器有哪些？](https://github.com/haizlin/fe-interview/issues/486)
- [你知道什么是脚手架吗？](https://github.com/haizlin/fe-interview/issues/485)
- [说下你了解的vue-cli原理？你可以自己实现个类vue-cli吗？](https://github.com/haizlin/fe-interview/issues/484)
- [怎么使用vue-cli3创建一个项目？](https://github.com/haizlin/fe-interview/issues/483)
- [vue-cli3你有使用过吗？它和2.x版本有什么区别？](https://github.com/haizlin/fe-interview/issues/482)
- [vue-cli默认是单页面的，那要弄成多页面该怎么办呢？](https://github.com/haizlin/fe-interview/issues/360)
- [不用vue-cli，你自己有搭建过vue的开发环境吗？流程是什么？](https://github.com/haizlin/fe-interview/issues/351)

### vue-router
- [vue-router怎么重定向页面？](https://github.com/haizlin/fe-interview/issues/419)
- [vue-router怎么配置404页面？](https://github.com/haizlin/fe-interview/issues/418)
- [切换路由时，需要保存草稿的功能，怎么实现呢？](https://github.com/haizlin/fe-interview/issues/417)
- [vue-router路由有几种模式？说说它们的区别？](https://github.com/haizlin/fe-interview/issues/416)
- [vue-router有哪几种导航钩子（ 导航守卫 ）？](https://github.com/haizlin/fe-interview/issues/415)
- [说说你对router-link的了解](https://github.com/haizlin/fe-interview/issues/414)
- [vue-router如何响应路由参数的变化？](https://github.com/haizlin/fe-interview/issues/383)
- [你有看过vue-router的源码吗？说说看](https://github.com/haizlin/fe-interview/issues/382)
- [切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？](https://github.com/haizlin/fe-interview/issues/381)
- [在什么场景下会用到嵌套路由？](https://github.com/haizlin/fe-interview/issues/380)
- [如何获取路由传过来的参数？](https://github.com/haizlin/fe-interview/issues/379)
- [说说active-class是哪个组件的属性？](https://github.com/haizlin/fe-interview/issues/378)
- [在vue组件中怎么获取到当前的路由信息？](https://github.com/haizlin/fe-interview/issues/377)
- [vur-router怎么重定向？](https://github.com/haizlin/fe-interview/issues/376)
- [怎样动态加载路由？](https://github.com/haizlin/fe-interview/issues/375)
- [怎么实现路由懒加载呢？](https://github.com/haizlin/fe-interview/issues/374)
- [如果让你从零开始写一个vue路由，说说你的思路](https://github.com/haizlin/fe-interview/issues/373)
- [说说vue-router完整的导航解析流程是什么？](https://github.com/haizlin/fe-interview/issues/372)
- [路由之间是怎么跳转的？有哪些方式？](https://github.com/haizlin/fe-interview/issues/371)
- [如果vue-router使用history模式，部署时要注意什么？](https://github.com/haizlin/fe-interview/issues/370)
- [route和router有什么区别？](https://github.com/haizlin/fe-interview/issues/369)
- [vue-router钩子函数有哪些？都有哪些参数？](https://github.com/haizlin/fe-interview/issues/368)
- [vue-router是用来做什么的？它有哪些组件？](https://github.com/haizlin/fe-interview/issues/367)

### vuex
- [你有写过vuex中store的插件吗？](https://github.com/haizlin/fe-interview/issues/539)
- [你有使用过vuex的module吗？主要是在什么场景下使用？](https://github.com/haizlin/fe-interview/issues/538)
- [vuex中actions和mutations有什么区别？](https://github.com/haizlin/fe-interview/issues/537)
- [vuex使用actions时不支持多参数传递怎么办？](https://github.com/haizlin/fe-interview/issues/413)
- [你觉得vuex有什么缺点？](https://github.com/haizlin/fe-interview/issues/412)
- [你觉得要是不用vuex的话会带来哪些问题？](https://github.com/haizlin/fe-interview/issues/411)
- [vuex怎么知道state是通过mutation修改还是外部直接修改的？](https://github.com/haizlin/fe-interview/issues/393)
- [请求数据是写在组件的methods中还是在vuex的action中？](https://github.com/haizlin/fe-interview/issues/392)
- [怎么监听vuex数据的变化？](https://github.com/haizlin/fe-interview/issues/391)
- [vuex的action和mutation的特性是什么？有什么区别？](https://github.com/haizlin/fe-interview/issues/390)
- [页面刷新后vuex的state数据丢失怎么解决？](https://github.com/haizlin/fe-interview/issues/389)
- [vuex的state、getter、mutation、action、module特性分别是什么？](https://github.com/haizlin/fe-interview/issues/388)
- [vuex的store有几个属性值？分别讲讲它们的作用是什么？](https://github.com/haizlin/fe-interview/issues/387)
- [你理解的vuex是什么呢？哪些场景会用到？不用会有问题吗？有哪些特性？](https://github.com/haizlin/fe-interview/issues/386)
- [使用vuex的优势是什么？](https://github.com/haizlin/fe-interview/issues/385)
- [有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？](https://github.com/haizlin/fe-interview/issues/384)

### ElementUI
- [ElementUI是怎么做表单验证的？在循环里对每个input验证怎么做呢？](https://github.com/haizlin/fe-interview/issues/402)
- [你有二次封装过ElementUI组件吗？](https://github.com/haizlin/fe-interview/issues/401)
- [ElementUI怎么修改组件的默认样式？](https://github.com/haizlin/fe-interview/issues/400)
- [ElementUI的穿梭组件如果数据量大会变卡怎么解决不卡的问题呢？](https://github.com/haizlin/fe-interview/issues/399)
- [ElementUI表格组件如何实现动态表头？](https://github.com/haizlin/fe-interview/issues/398)
- [ElementUI使用表格组件时有遇到过问题吗？](https://github.com/haizlin/fe-interview/issues/397)
- [有阅读过ElementUI的源码吗？](https://github.com/haizlin/fe-interview/issues/396)
- [项目中有使用过ElementUI吗？有遇到过哪些问题？它的使用场景主要是哪些？](https://github.com/haizlin/fe-interview/issues/395)
- [有用过哪些vue的ui？说说它们的优缺点？](https://github.com/haizlin/fe-interview/issues/394)

### mint-ui
- [mint-ui使用过程中有没有遇到什么坑？怎么解决的？](https://github.com/haizlin/fe-interview/issues/481)
- [说出几个mint-ui常用的组件](https://github.com/haizlin/fe-interview/issues/480)
- [mint-ui是什么？你有使用过吗？](https://github.com/haizlin/fe-interview/issues/479)# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1.vue 中的性能优化</summary></b>

参考答案：

1）编码优化

* 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
* v-if和v-for不能连用
* 如果需要使用v-for给每项元素绑定事件时使用事件代理
* SPA 页面采用keep-alive缓存组件
* 在更多的情况下，使用v-if替代v-show
* key保证唯一
* 使用路由懒加载、异步组件
* 防抖、节流
* 第三方模块按需导入
* 长列表滚动到可视区域动态加载
* 图片懒加载

2）用户体验优化

* 骨架屏
* PWA（渐进式WEB应用）
* 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。

3）SEO优化

* 预渲染
* 服务端渲染SSR

4）打包优化

* 压缩代码；
* Tree Shaking/Scope Hoisting；
* 使用cdn加载第三方模块；
* 多线程打包happypack；
* splitChunks抽离公共文件；
* sourceMap优化；

说明：优化是个大工程，会涉及很多方面

[参与互动](https://github.com/yisainan/web-interview/issues/392)

</details>

<b><details><summary>2.vue 的实例生命周期</summary></b>

参考答案：

![vue_002](../../images/vue_002.jpg)

（1） beforeCreate 初始化实例后 数据观测和事件配置之前调用

（2） created 实例创建完成后调用

（3） beforeMount 挂载开始前被用

（4） mounted el 被新建 vm.$el 替换并挂在到实例上之后调用

（5） beforeUpdate 数据更新时调用

（6） updated 数据更改导致的 DOM 重新渲染后调用

（7） beforeDestory 实例被销毁前调用

（8） destroyed 实例销毁后调用

Vue2 与Vue3的生命周期对比

| Vue2                                   | Vue3                               |
| ----------------------------------------- | ------------------------------------------- |
| beforeCreate(组件创建之前)                | setup(组件创建之前)                         |
| created(组件创建完成)                     | setup(组件创建完成)                         |
| beforeMount(组件挂载之前)                 | onBeforeMount(组件挂载之前)                 |
| mounted(组件挂载完成)                     | onMounted(组件挂载完成)                     |
| beforeUpdate(数据更新，虚拟DOM打补丁之前) | onBeforeUpdate(数据更新，虚拟DOM打补丁之前) |
| updated(数据更新，虚拟DOM渲染完成)        | onUpdated(数据更新，虚拟DOM渲染完成)        |
| beforeDestroy(组件销毁之前)               | onBeforeUnmount(组件销毁之前)               |
| destroyed(组件销毁之后)                   | onUnmounted(组件销毁之后)                   |

[参与互动](https://github.com/yisainan/web-interview/issues/393)

</details>

<b><details><summary>3.vue 的双向数据绑定的原理</summary></b>

参考答案：

Vue2.0 实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。

Vue3.0 用原生 Proxy 替换 Object.defineProperty。

[参与互动](https://github.com/yisainan/web-interview/issues/394)

</details>

<b><details><summary>4. 为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）</summary></b>

参考答案：

1. 在 Vue 中，Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。

2. Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。

而要取代它的Proxy有以下两个优点; 

* 可以劫持整个对象，并返回一个新对象
* 有13种劫持操作

既然Proxy能解决以上两个问题，而且Proxy作为es6的新属性在vue2.x之前就有了，为什么vue2.x不使用Proxy呢？一个很重要的原因就是：

Proxy是es6提供的新特性，兼容性不好，最主要的是这个属性无法用polyfill来兼容

[参与互动](https://github.com/yisainan/web-interview/issues/395)

</details>

<b><details><summary>5. 什么是 Proxy？</summary></b>

参考答案：

1. 含义：

Proxy 是 ES6 中新增的一个特性，翻译过来意思是"代理"，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。

2. 基本用法：

``` js
let p = new Proxy(target, handler);
```

参数：

* target 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
* handler 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。
* p 是代理后的对象。当外界每次对 p 进行操作时，就会执行 handler 对象上的一些方法。Proxy共有13种劫持操作，handler代理的一些常用的方法有如下几个：

``` 
get： 读取
set： 修改
has： 判断对象是否有该属性
construct： 构造函数
```

3. 示例：

下面就用Proxy来定义一个对象的get和set，作为一个基础demo

``` js
 let obj = {};
 let handler = {
     get(target, property) {
         console.log( `${property} 被读取` );
         return property in target ? target[property] : 3;
     },
     set(target, property, value) {
         console.log( `${property} 被设置为 ${value}` );
         target[property] = value;
     }
 }

 let p = new Proxy(obj, handler);
 p.name = 'tom' //name 被设置为 tom
 p.age; //age 被读取 3
```

 p 读取属性的值时，实际上执行的是 handler.get() ：在控制台输出信息，并且读取被代理对象 obj 的属性。

p 设置属性值时，实际上执行的是 handler.set() ：在控制台输出信息，并且设置被代理对象 obj 的属性的值。

以上介绍了Proxy基本用法，实际上这个属性还有许多内容，具体可参考[Proxy文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

三. [基于Proxy来实现双向绑定](https://www.jianshu.com/p/860418f0785c)

[参与互动](https://github.com/yisainan/web-interview/issues/396)

</details>

<b><details><summary>6. 为什么避免 v-if 和 v-for 用在一起</summary></b>

参考答案：

vue2.x 中v-for优先级高于v-if，vue3.x 相反。所以2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用，造成性能浪费；3.x 版本中 v-if 总是优先于 v-for 生效，导致v-if访问不了v-for中的变量。

解析：

一般我们在两种常见的情况下会倾向于这样做：

* 为了过滤一个列表中的项目 (比如 v-for="user in users" v-if="user.isActive")。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。

* 为了避免渲染本应该被隐藏的列表 (比如 v-for="user in users" v-if="shouldShowUsers")。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。

当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，所以这个模板：

```html
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```
将会经过如下运算：
```js
this.users.map(function (user) {
  if (user.isActive) {
    return user.name
  }
})
```
因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。

通过将其更换为在如下的一个计算属性上遍历：

```js
computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
      return user.isActive
    })
  }
}
```

```html
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```
我们将会获得如下好处：

* 过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。
* 使用 v-for="user in activeUsers" 之后，我们在渲染的时候只遍历活跃用户，渲染更高效。
* 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。

为了获得同样的好处，我们也可以把：

```html
<ul>
  <li
    v-for="user in users"
    v-if="shouldShowUsers"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```
更新为：
```html
<ul v-if="shouldShowUsers">
  <li
    v-for="user in users"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```
通过将 v-if 移动到容器元素，我们不会再对列表中的每个用户检查 shouldShowUsers。取而代之的是，我们只检查它一次，且不会在 shouldShowUsers 为否的时候运算 v-for。

反例：

```html
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>

<ul>
  <li
    v-for="user in users"
    v-if="shouldShowUsers"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

好例子

```html
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>

<ul v-if="shouldShowUsers">
  <li
    v-for="user in users"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

[参与互动](https://github.com/yisainan/web-interview/issues/397)

</details>

<b><details><summary>7. 组件的设计原则</summary></b>

参考答案：

``` 
(1)页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块)
(2)每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中)
(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑)
(3)页面不过是组件的容器，组件可以嵌套自由组合成完整的页面
```

[参与互动](https://github.com/yisainan/web-interview/issues/398)

</details>

<b><details><summary>8.vue slot是做什么的?</summary></b>

参考答案：主要是让组件的可扩展性更强，简单点说就是，能够在组件内写其他内容

解析：

### 插槽

在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的 attribute。

#### 插槽内容

Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 <slot> 元素作为承载分发内容的出口。

它允许你像这样合成组件：

```html
<navigation-link url="/profile">
  Your Profile
</navigation-link>
```
然后你在 <navigation-link> 的模板中可能会写为：
```js
<a
  v-bind:href="url"
  class="nav-link"
>
  <slot></slot>
</a>
```
#### 编译作用域

[参与互动](https://github.com/yisainan/web-interview/issues/399)

</details>

<b><details><summary>9. 对于 Vue 是一套渐进式框架的理解</summary></b>

参考答案：

渐进式代表的含义是：没有多做职责之外的事。

vue.js只提供了vue-cli生态中最核心的组件系统和双向数据绑定，像vuex、vue-router都属于围绕vue.js开发的库。

解析：

要使用Angular，必须接受以下东西：
1、必须使用它的模块机制。
2、必须使用它的依赖注入。
3、必须使用它的特殊形式定义组件（这一点每个视图框架都有，这是难以避免的）
所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。

要使用React，你必须理解：
1、函数式编程的理念。
2、需要知道它的副作用。
3、什么是纯函数。
4、如何隔离、避免副作用。
5、它的侵入性看似没有Angular那么强，主要因为它是属于软性侵入的。

Vue与React、Angular的不同是，它是渐进的：
1、可以在原有的大系统的上面，把一两个组件改用它实现，就是当成jQuery来使用。
2、可以整个用它全家桶开发，当Angular来使用。
3、可以用它的视图，搭配你自己设计的整个下层使用。
4、可以在底层数据逻辑的地方用OO(Object–Oriented)面向对象和设计模式的那套理念。
5、可以函数式，它只是个轻量视图而已，只做了最核心的东西。

场景联想

场景 1：
维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。

场景 2：
得到 boss 认可，后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化

场景 3:
越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！

场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。

[参与互动](https://github.com/yisainan/web-interview/issues/400)

</details>

<b><details><summary>10.vue.js 的两个核心是什么？</summary></b>

参考答案：数据驱动和组件化思想

[参与互动](https://github.com/yisainan/web-interview/issues/401)

</details>

<b><details><summary>11. 请问 v-if 和 v-show 有什么区别</summary></b>

参考答案：

v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏

v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果

[参与互动](https://github.com/yisainan/web-interview/issues/402)

</details>

<b><details><summary>12.Vue常用的修饰符及使用的场景</summary></b>

参考答案：

vue中修饰符分为：表单修饰符、事件修饰符、鼠标按键修饰符、键值修饰符、v-bind修饰符

1. 表单修饰符包括：lazy trim number
2. 事件修饰符包括：stop prevent self once capture passive native
3. 鼠标按钮修饰符包括：left right middle
4. 键盘修饰符包括：

解析：[参考](https://blog.csdn.net/qq_42238554/article/details/86592295)

[参与互动](https://github.com/yisainan/web-interview/issues/403)

</details>

<b><details><summary>13. v-on 可以监听多个方法吗？</summary></b>

参考答案：肯定可以的。

解析：

``` html
<input type="text" :value="name" @input="onInput" @focus="onFocus" @blur="onBlur" />
```

[参与互动](https://github.com/yisainan/web-interview/issues/404)

</details>

<b><details><summary>14.vue 中 key 值的作用</summary></b>

参考答案：

需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点
所以一句话，key 的作用主要是为了高效的更新虚拟 DOM

[参与互动](https://github.com/yisainan/web-interview/issues/405)

</details>

<b><details><summary>15.vue-cli 工程升级 vue 版本</summary></b>

参考答案：

在项目目录里运行 npm upgrade vue vue-template-compiler，不出意外的话，可以正常运行和 build。如果有任何问题，删除 node_modules 文件夹然后重新运行 npm i 即可。（简单的说就是升级 vue 和 vue-template-compiler 两个插件）

[参与互动](https://github.com/yisainan/web-interview/issues/406)

</details>

<b><details><summary>16.vue 事件中如何使用 event 对象？</summary></b>

参考答案：

v-on 指令（可以简写为 @）

1、使用不带圆括号的形式，event 对象将被自动当做实参传入；

2、使用带圆括号的形式，我们需要使用 \$event 变量显式传入 event 对象。

解析：

一、event 对象

（一）事件的 event 对象

你说你是搞前端的，那么你肯定就知道事件，知道事件，你就肯定知道 event 对象吧？各种的库、框架多少都有针对 event 对象的处理。比如 jquery，通过它内部进行一定的封装，我们开发的时候，就无需关注 event 对象的部分兼容性问题。最典型的，如果我们要阻止默认事件，在 chrome 等浏览器中，我们可能要写一个：

``` js
event.preventDefault();
```

而在 IE 中，我们则需要写：

``` js
event.returnValue = false;
```

多亏了 jquery ，跨浏览器的实现，我们统一只需要写：

``` js
event.preventDefault();
```

兼容？jquery 内部帮我们搞定了。类似的还有比如阻止事件冒泡以以及事件绑定（addEventListener / attachEvent）等，简单到很多的后端都会使用 \$('xxx').bind(... )，这不是我们今天的重点，我们往下看。

（二）vue 中的 event 对象

我们知道，相比于 jquery，vue 的事件绑定可以显得更加直观和便捷，我们只需要在模板上添加一个 v-on 指令（还可以简写为 @），即可完成类似于 \$('xxx').bind 的效果，少了一个利用选择器查询元素的操作。我们知道，jquery 中，event 对象会被默认当做实参传入到处理函数中，如下

``` js
$("body").bind("click", function(event) {
    console.log(typeof event); // object
});
```

这里直接就获取到了 event 对象，那么问题来了，vue 中呢？

``` 
<div id="app">
    <button v-on:click="click">click me</button>
</div>
...
var app = new Vue({
    el: '#app',
    methods: {
        click(event) {
            console.log(typeof event);    // object
        }
    }
});
```

这里的实现方式看起来和 jquery 是一致的啊，但是实际上，vue 比 jquery 要要复杂得多，jquery 官方也明确的说，v-on 不简单是 addEventListener 的语法糖。在 jquery 中，我们传入到 bind 方法中的回调，只能是一个函数表类型的变量或者一个匿名函数，传递的时候，还不能执行它（在后面加上一堆圆括号），否则就变成了取这一个函数的返回值作为事件回调。而我们知道，vue 的 v-on 指令接受的值可以是函数执行的形式，比如 v-on:click="click(233)" 。这里我们可以传递任何需要传递的参数，甚至可以不传递参数：

``` 
<div id="app">
    <button v-on:click="click()">click me</button>
</div>
...
var app = new Vue({
    el: '#app',
    methods: {
        click(event) {
            console.log(typeof event);    // undefined
        }
    }
});
```

咦？我的 event 对象呢？怎么不见了？打印看看 arguments.length 也是 0，说明这时候确实没有实参被传入进来。T_T，那我们如果既需要传递参数，又需要用到 event 对象，这个该怎么办呢？

（三）\$event

翻看 vue 文档，不难发现，其实我们可以通过将一个特殊变量 \$event 传入到回调中解决这个问题：

``` 
<div id="app">
    <button v-on:click="click($event, 233)">click me</button>
</div>
...
var app = new Vue({
    el: '#app',
    methods: {
        click(event, val) {
            console.log(typeof event);    // object
        }
    }
});
```

好吧，这样看起来就正常了。
简单总结来说：

使用不带圆括号的形式，event 对象将被自动当做实参传入；

使用带圆括号的形式，我们需要使用 \$event 变量显式传入 event 对象。

二、乌龙
前面都算是铺垫吧，现在真正的乌龙来了。
翻看小伙伴儿的代码，偶然看到了类似下面的代码：

``` 
<div id="app">
    <button v-on:click="click(233)">click me</button>
</div>
...
var app = new Vue({
    el: '#app',
    methods: {
        click(val) {
            console.log(typeof event);    // object
        }
    }
});
```

看到这一段代码，我的内心是崩溃的，丢进 chrome 里面一跑，尼玛还真可以，打印 arguments.length，也是正常的 1。尼玛！这是什么鬼？毁三观啊？
既没有传入实参，也没有接收的形参，这个 event 对象的来源，要么是上级作用链，要么。。。是全局作用域。。。全局的，不禁想到了 window.event
。再次上 MDN 确认了一下，果然，window.event，ie 和 chrome 都在 window 对象上有这样一个属性：

![vue_003](../../images/vue_003.jpg)

代码丢进 Firefox 中运行，event 果然就变成了 undefined 了。额，这个我也不知道说什么了。。。

[参与互动](https://github.com/yisainan/web-interview/issues/407)

</details>

<b><details><summary>17.$nextTick 的使用</summary></b>

参考答案：

1、什么是 Vue.nextTick()？

定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

所以就衍生出了这个获取更新后的 DOM 的 Vue 方法。所以放在 Vue.nextTick()回调函数中的执行的应该是会对 DOM 进行操作的 js 代码；

理解：nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数，

``` 
<template>
  <div class="hello">
    <div>
      <button id="firstBtn" @click="testClick()" ref="aa">{{testMsg}}</button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  data () {
    return {
      testMsg:"原始值",
    }
  },
  methods:{
    testClick:function(){
      let that=this;
      that.testMsg="修改后的值";
      console.log(that.$refs.aa.innerText);   //that.$refs.aa获取指定DOM，输出：原始值
    }
  }
}
</script>
```

使用 this. $nextTick()

``` js
methods: {
    testClick: function() {
        let that = this;
        that.testMsg = "修改后的值";
        that.$nextTick(function() {
            console.log(that.$refs.aa.innerText); //输出：修改后的值
        });
    }
}
```

注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM，

2、什么时候需要用的 Vue.nextTick()？？

1、Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。

``` js
created() {
    let that = this;
    that.$nextTick(function() { //不使用this.$nextTick()方法会报错
        that.$refs.aa.innerHTML = "created中更改了按钮内容"; //写入到DOM元素
    });
}
```

2、当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么，对新 DOM 一系列的 js 操作都需要放进 Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用 js 操作新的视图的时候需要使用它

``` 
<template>
  <div class="hello">
    <h3 id="h">{{testMsg}}</h3>
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  data () {
    return {
      testMsg:"原始值",
    }
  },
  methods:{
    changeTxt:function(){
      let that=this;
      that.testMsg="修改后的文本值";  //vue数据改变，改变dom结构
      let domTxt=document.getElementById('h').innerText;  //后续js对dom的操作
      console.log(domTxt);  //输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的
      if(domTxt==="原始值"){
        console.log("文本data被修改后dom内容没立即更新");
      }else {
        console.log("文本data被修改后dom内容被马上更新了");
      }
    },
  }
}
</script>
```

正确的用法是：vue 改变 dom 元素结构后使用 vue.$nextTick()方法来实现 dom 数据更新后延迟执行后续代码

``` js
    changeTxt: function() {
        let that = this;
        that.testMsg = "修改后的文本值"; //修改dom结构

        that.$nextTick(function() { //使用vue.$nextTick()方法可以dom数据更新后延迟执行
            let domTxt = document.getElementById('h').innerText;
            console.log(domTxt); //输出可以看到vue数据修改后并没有DOM没有立即更新，
            if (domTxt === "原始值") {
                console.log("文本data被修改后dom内容没立即更新");
            } else {
                console.log("文本data被修改后dom内容被马上更新了");
            }
        });
    }
```

3、在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 \$nextTick 的回调函数中执行重新应用插件的方法。

Vue.nextTick(callback) 使用原理：

原因是，Vue 是异步执行 dom 更新的，一旦观察到数据变化，Vue 就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个 watcher 被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作。而在下一个事件循环时，Vue 会清空队列，并进行必要的 DOM 更新。
当你设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。

[参与互动](https://github.com/yisainan/web-interview/issues/408)

</details>

<b><details><summary>18.vue 组件中 data 为什么必须是函数</summary></b>

参考答案：

在 new Vue() 中，data 是可以作为一个对象进行操作的，然而在 component 中，data 只能以函数的形式存在，不能直接将对象赋值给它，这并非是 Vue 自身如此设计，而是跟 JavaScript 特性相关，我们来回顾下 JavaScript 的原型链

``` js
var Component = function() {
  this.data = this.data
};
Component.prototype.data = {
    message: "Love"
};
var component1 = new Component(),
    component2 = new Component();
component1.data.message = "Peace";
console.log(component2.data.message); // Peace
```

以上**两个实例都引用同一个原型对象，当其中一个实例属性改变时，另一个实例属性也随之改变，只有当两个实例拥有自己的作用域时，才不会互相干扰** ！！！！！这句是重点！！！！！

``` js
var Component = function() {
    this.data = this.data();
};
Component.prototype.data = function() {
    return {
        message: "Love"
    };
};
var component1 = new Component(),
    component2 = new Component();
component1.data.message = "Peace";
console.log(component2.data.message); // Love
```

[参与互动](https://github.com/yisainan/web-interview/issues/409)

</details>

<b><details><summary>19. v-for 与 v-if 的优先级</summary></b>

参考答案：v-for 比 v-if 优先

1、v-for优先于v-if被解析；
2、如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能；
3、要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环；
4、如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项；

[参与互动](https://github.com/yisainan/web-interview/issues/410)

</details>

<b><details><summary>20.vue 中子组件调用父组件的方法</summary></b>

参考答案：

* 第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法
* 第二种方法是在子组件里用\$emit 向父组件触发一个事件，父组件监听这个事件就行了
* 第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法

解析：

第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法

父组件

``` 
<template>
  <div>
    <child></child>
  </div>
</template>
<script>
  import child from '~/components/dam/child';
  export default {
    components: {
      child
    },
    methods: {
      fatherMethod() {
        console.log('测试');
      }
    }
  };
</script>
```

子组件

``` html
<template>
    <div>
        <button @click="childMethod()">点击</button>
    </div>
</template>
<script>
    export default {
        methods: {
            childMethod() {
                this.$parent.fatherMethod();
            }
        }
    };
</script>
```

第二种方法是在子组件里用\$emit 向父组件触发一个事件，父组件监听这个事件就行了

父组件

``` html
<template>
    <div>
        <child @fatherMethod="fatherMethod"></child>
    </div>
</template>
<script>
    import child from "~/components/dam/child";
    export default {
        components: {
            child
        },
        methods: {
            fatherMethod() {
                console.log("测试");
            }
        }
    };
</script>
```

子组件

``` html
<template>
    <div>
        <button @click="childMethod()">点击</button>
    </div>
</template>
<script>
    export default {
        methods: {
            childMethod() {
                this.$emit("fatherMethod");
            }
        }
    };
</script>
```

第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法

父组件

``` html
<template>
    <div>
        <child :fatherMethod="fatherMethod"></child>
    </div>
</template>
<script>
    import child from "~/components/dam/child";
    export default {
        components: {
            child
        },
        methods: {
            fatherMethod() {
                console.log("测试");
            }
        }
    };
</script>
```

子组件

``` html
<template>
    <div>
        <button @click="childMethod()">点击</button>
    </div>
</template>
<script>
    export default {
        props: {
            fatherMethod: {
                type: Function,
                default: null
            }
        },
        methods: {
            childMethod() {
                if (this.fatherMethod) {
                    this.fatherMethod();
                }
            }
        }
    };
</script>
```

[参与互动](https://github.com/yisainan/web-interview/issues/411)

</details>

<b><details><summary>21.vue 中父组件调用子组件的方法</summary></b>

参考答案：使用\$refs

解析：

父组件

``` html
<template>
    <div>
        <button @click="clickParent">点击</button>
        <child ref="mychild"></child>
    </div>
</template>

<script>
    import Child from "./child";
    export default {
        name: "parent",
        components: {
            child: Child
        },
        methods: {
            clickParent() {
                this.$refs.mychild.parentHandleclick("嘿嘿嘿"); // 划重点！！！！
            }
        }
    };
</script>
```

子组件

``` html
<template>
    <div>
        child
    </div>
</template>

<script>
    export default {
        name: "child",
        props: "someprops",
        methods: {
            parentHandleclick(e) {
                console.log(e);
            }
        }
    };
</script>
```

[参与互动](https://github.com/yisainan/web-interview/issues/412)

</details>

<b><details><summary>22.vue 中 keep-alive 组件的作用</summary></b>

参考答案：keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

解析：

用法也很简单：

``` html
<keep-alive>
    <component>
        <!-- 该组件将被缓存！ -->
    </component>
</keep-alive>
```

props
_ include - 字符串或正则表达，只有匹配的组件会被缓存
_ exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存

``` js
// 组件 a
export default {
    name: "a",
    data() {
        return {};
    }
};
```

``` html
<keep-alive include="a">
    <component>
        <!-- name 为 a 的组件将被缓存！ -->
    </component>
</keep-alive>可以保留它的状态或避免重新渲染
```

``` html
<keep-alive exclude="a">
    <component>
        <!-- 除了 name 为 a 的组件都将被缓存！ -->
    </component>
</keep-alive>可以保留它的状态或避免重新渲染
```

但实际项目中, 需要配合 vue-router 共同使用. 

router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：

``` html
<keep-alive>
    <router-view>
        <!-- 所有路径匹配到的视图组件都会被缓存！ -->
    </router-view>
</keep-alive>
```

如果只想 router-view 里面某个组件被缓存，怎么办？

增加 router.meta 属性

``` js
// routes 配置
export default [{
        path: "/",
        name: "home",
        component: Home,
        meta: {
            keepAlive: true // 需要被缓存
        }
    },
    {
        path: "/:id",
        name: "edit",
        component: Edit,
        meta: {
            keepAlive: false // 不需要被缓存
        }
    }
];
```

``` 
<keep-alive>
    <router-view v-if="$route.meta.keepAlive">
        <!-- 这里是会被缓存的视图组件，比如 Home！ -->
    </router-view>
</keep-alive>

<router-view v-if="!$route.meta.keepAlive">
    <!-- 这里是不被缓存的视图组件，比如 Edit！ -->
</router-view>
```

[参与互动](https://github.com/yisainan/web-interview/issues/413)

</details>

<b><details><summary>23.vue 中如何编写可复用的组件？</summary></b>

参考答案：总结组件的职能，什么需要外部控制（即 props 传啥），组件需要控制外部吗（\$emit）, 是否需要插槽（slot）

[参与互动](https://github.com/yisainan/web-interview/issues/414)

</details>

<b><details><summary>24. 什么是 vue 生命周期和生命周期钩子函数？</summary></b>

参考答案：

vue 的生命周期就是 vue 实例从创建到销毁的过程

解析：

![vue_004](../../images/vue_004.jpg)

![vue_005](../../images/vue_005.jpg)

[参与互动](https://github.com/yisainan/web-interview/issues/415)

</details>

<b><details><summary>25.vue 生命周期钩子函数有哪些？</summary></b>

参考答案：

![vue_005](../../images/vue_005.jpg)

[参与互动](https://github.com/yisainan/web-interview/issues/416)

</details>

<b><details><summary>26.vue 如何监听键盘事件中的按键？</summary></b>

参考答案：

解析：[参考](https://blog.csdn.net/xiaxiangyun/article/details/80404768)

[参与互动](https://github.com/yisainan/web-interview/issues/417)

</details>

<b><details><summary>27.vue 更新数组时触发视图更新的方法</summary></b>

参考答案：

1.vue.set 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新

``` 
数组修改

Vue.set(array, indexOfItem, newValue)
this.array.$set(indexOfItem, newValue)
对象修改

Vue.set(obj, keyOfItem, newValue)
this.obj.$set(keyOfItem, newValue)
```

2.vue.delete 删除对象或数组中元素，通过 key 或数组索引，可以触发视图更新

``` 
数组修改

Vue.delete(array, indexOfItem)
this.array.$delete(indexOfItem)
对象修改

Vue.delete(obj, keyOfItem)
this.obj.$delete(keyOfItem)
```

3. 数组对象直接修改属性，可以触发视图更新

``` 
this.array[0].show = true;
this.array.forEach(function(item){
    item.show = true;
});
```

4. splice 方法修改数组，可以触发视图更新

``` 
this.array.splice(indexOfItem, 1, newElement)
```

5. 数组整体修改，可以触发视图更新

``` 
var tempArray = this.array;
tempArray[0].show = true;
this.array = tempArray;
```

6. 用 Object. assign 或 lodash. assign 可以为对象添加响应式属性，可以触发视图更新

``` 
//Object.assign的单层的覆盖前面的属性，不会递归的合并属性
this.obj = Object.assign({},this.obj,{a:1, b:2})

//assign与Object.assign一样
this.obj = _.assign({},this.obj,{a:1, b:2})

//merge会递归的合并属性
this.obj = _.merge({},this.obj,{a:1, b:2})
```

7.vue 提供了如下的数组的变异方法，可以触发视图更新

``` 
push()
pop()
shift()
unshift()
splice()
sort()
reverse()
```

[参与互动](https://github.com/yisainan/web-interview/issues/418)

</details>

<b><details><summary>28.vue 中对象更改检测的注意事项</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/419)

</details>

<b><details><summary>29. 解决非工程化项目初始化页面闪动问题</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/420)

</details>

<b><details><summary>30. v-for 产生的列表，实现 active 的切换</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/421)

</details>

<b><details><summary>31. v-model 语法糖的组件中的使用</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/422)

</details>

<b><details><summary>32. 十个常用的自定义过滤器</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/423)

</details>

<b><details><summary>33.vue 等单页面应用及其优缺点</summary></b>

参考答案：

优点：
1、用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。
2、前后端职责业分离（前端负责view，后端负责model），架构清晰
3、减轻服务器的压力

缺点：
1、SEO（搜索引擎优化）难度高
2、初次加载页面更耗时
3、前进、后退、地址栏等，需要程序进行管理，所以会大大提高页面的复杂性和逻辑的难度

[参与互动](https://github.com/yisainan/web-interview/issues/424)

</details>

<b><details><summary>34. 什么是 vue 的计算属性？</summary></b>

参考答案：先来看一下计算属性的定义：
当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。
计算属性和vue中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。

[参与互动](https://github.com/yisainan/web-interview/issues/425)

</details>

<b><details><summary>35.vue 父组件如何向子组件中传递数据？</summary></b>

参考答案：props传参

[参与互动](https://github.com/yisainan/web-interview/issues/426)

</details>

<b><details><summary>36.vue 弹窗后如何禁止滚动条滚动？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/427)

</details>

<b><details><summary>37.vue怎么实现页面的权限控制</summary></b>

参考答案：利用 vue-router 的 beforeEach 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。

[参与互动](https://github.com/yisainan/web-interview/issues/428)

</details>

<b><details><summary>38. $route和$router的区别</summary></b>

参考答案：$route 是路由信息对象，包括path，params，hash，query，fullPath，matched，name 等路由信息参数。

而 $router 是路由实例对象，包括了路由的跳转方法，钩子函数等

[参与互动](https://github.com/yisainan/web-interview/issues/429)

</details>

<b><details><summary>39. watch的作用是什么</summary></b>

参考答案：watch 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的。

借助 watch 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。

[参与互动](https://github.com/yisainan/web-interview/issues/430)

</details>

<b><details><summary>40. 计算属性的缓存和方法调用的区别</summary></b>

参考答案：

计算属性是基于数据的依赖缓存，数据发生变化，缓存才会发生变化，如果数据没有发生变化，调用计算属性直接调用的是存储的缓存值；

而方法每次调用都会重新计算；所以可以根据实际需要选择使用，如果需要计算大量数据，性能开销比较大，可以选用计算属性，如果不能使用缓存可以使用方法；

其实这两个区别还应加一个watch，watch是用来监测数据的变化，和计算属性相比，是watch没有缓存，但是一般想要在数据变化时响应时，或者执行异步操作时，可以选择watch

[参与互动](https://github.com/yisainan/web-interview/issues/431)

</details>

<b><details><summary>41.vue的双向绑定的原理，和angular的对比</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/432)

</details>

<b><details><summary>42.vue 如何优化首屏加载速度？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/433)

</details>

<b><details><summary>43.vue 打包命令是什么？</summary></b>

参考答案：npm run build

[参与互动](https://github.com/yisainan/web-interview/issues/434)

</details>

<b><details><summary>44.vue 打包后会生成哪些文件？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/435)

</details>

<b><details><summary>45. 如何配置 vue 打包生成文件的路径？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/436)

</details>

<b><details><summary>46.vue 的服务器端渲染</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/437)

</details>

<b><details><summary>47.vue 开发命令 npm run dev 输入后的执行过程</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/438)

</details>

<b><details><summary>48. 什么是 Virtual DOM？</summary></b>

参考答案：可以看作是一个使用 javascript 模拟了 DOM 结构的树形结构

解析：[参考](https://www.cnblogs.com/gaosong-shuhong/p/9253959.html)

[参与互动](https://github.com/yisainan/web-interview/issues/439)

</details>

<b><details><summary>49. 响应式系统的基本原理</summary></b>

参考答案：

vue响应式的原理，首先对象传入vue实例作为data对象时，首先被vue遍历所有属性，调用Object.defineProperty设置为getter和setter，每个组件都有一个watcher对象，在组件渲染的过程中，把相关的数据都注册成依赖，当数据发生setter变化时，会通知watcehr，从而更新相关联的组件

[参与互动](https://github.com/yisainan/web-interview/issues/440)

</details>

<b><details><summary>50.vue.js 全局运行机制</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/441)

</details>

<b><details><summary>51. 如何编译 template 模板？</summary></b>

参考答案：[参考](http://www.itcast.cn/news/20190110/15320198690.shtml)

[参与互动](https://github.com/yisainan/web-interview/issues/442)

</details>

<b><details><summary>52. diff 算法</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/443)

</details>

<b><details><summary>53. 批量异步更新策略及 nextTick 原理？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/444)

</details>

<b><details><summary>54.vue 中如何实现 proxy 代理？</summary></b>

参考答案：

webpack 自带的 devServer 中集成了 http-proxy-middleware。配置 devServer 的 proxy 选项即可

``` js
proxyTable: {
    '/api': {
        target: 'http://192.168.149.90:8080/', // 设置你调用的接口域名和端口号
        changeOrigin: true, // 跨域
        pathRewrite: {
            '^/api': '/'
        }
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/445)

</details>

<b><details><summary>55.vue 中如何实现 tab 切换功能？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/446)

</details>

<b><details><summary>56.vue 中如何利用 keep-alive 标签实现某个组件缓存功能？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/447)

</details>

<b><details><summary>57.vue 中实现切换页面时为左滑出效果</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/448)

</details>

<b><details><summary>58.vue 中央事件总线的使用</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/449)

</details>

<b><details><summary>59.vue 的渲染机制</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/450)

</details>

<b><details><summary>60.vue 在什么情况下在数据发生改变的时候不会触发视图更新</summary></b>

参考答案：

v-for 遍历的数组，当数组内容使用的是 arr[0].xx =xx 更改数据，vue 无法监测到
vm.arr.length = newLength 也是无法检测的到的

[参与互动](https://github.com/yisainan/web-interview/issues/451)

</details>

<b><details><summary>61.vue 的优点是什么？</summary></b>

参考答案：

低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的"View"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。

可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。

独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。

可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。

[参与互动](https://github.com/yisainan/web-interview/issues/452)

</details>

<b><details><summary>62.vue 如何实现按需加载配合 webpack 设置</summary></b>

参考答案：

``` 
webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。
不进行页面按需加载引入方式：import home from '../../common/home.vue'
进行页面按需加载的引入方式：const home = r => require.ensure( [], () => r (require('../../common/home.vue')))
```

在音乐 app 中使用的路由懒加载方式为：

``` 
const Recommend = (resolve) => {
  import('components/recommend/recommend').then((module) => {
    resolve(module)
  })
}

const Singer = (resolve) => {
  import('components/singer/singer').then((module) => {
    resolve(module)
  })
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/453)

</details>

<b><details><summary>63. 如何让 CSS 只在当前组件中起作用</summary></b>

参考答案：将当前组件的 `<style>` 修改为 `<style scoped>` 

[参与互动](https://github.com/yisainan/web-interview/issues/454)

</details>

<b><details><summary>64. 指令 v-el 的作用是什么?</summary></b>

参考答案：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标, 可以是 CSS 选择器，也可以是一个 HTMLElement 实例

[参与互动](https://github.com/yisainan/web-interview/issues/455)

</details>

<b><details><summary>65.vue-loader 是什么？使用它的用途有哪些？</summary></b>

参考答案：

vue-loader 是解析 .vue 文件的一个加载器，将 template/js/style 转换成 js 模块。

用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等。

[参与互动](https://github.com/yisainan/web-interview/issues/456)

</details>

<b><details><summary>66.vue和angular的优缺点以及适用场合?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/457)

</details>

<b><details><summary>67. 你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/458)

</details>

<b><details><summary>68.vue遇到的坑，如何解决的？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/459)

</details>

<b><details><summary>69.vuex 工作原理详解 </summary></b>

参考答案：

vuex 整体思想诞生于 flux, 可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；

解析：vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？
因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。
store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据， 导致另一个组件上的数据也会改变，就像是一个对象的引用。

[参与互动](https://github.com/yisainan/web-interview/issues/460)

</details>

<b><details><summary>70.vuex 是什么？怎么使用？哪种功能场景使用它？</summary></b>

参考答案：

vue 框架中状态管理。在 main.js 引入 store，注入。新建一个目录 store，…. . export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

main.js:

``` 
import store from './store'

new Vue({
el:'#app',
store
})
```

[参与互动](https://github.com/yisainan/web-interview/issues/461)

</details>

<b><details><summary>71.vuex 有哪几种属性？</summary></b>

参考答案：

有五种，分别是 State、 Getter、Mutation 、Action、 Module

``` 
vuex的State特性
A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data
B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中

· vuex的Getter特性
A、getters 可以对State进行计算操作，它就是Store的计算属性
B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用
C、 如果一个状态只在一个组件内使用，是可以不用getters

·  vuex的Mutation特性
Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。
```

[参与互动](https://github.com/yisainan/web-interview/issues/462)

</details>

<b><details><summary>72. 不用 Vuex 会带来什么问题？</summary></b>

参考答案：

可维护性会下降，想修改数据要维护三个地方；

可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；

增加耦合，大量的上传派发，会让耦合性大大增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。

[参与互动](https://github.com/yisainan/web-interview/issues/463)

</details>

<b><details><summary>73.vue-router 如何响应 路由参数 的变化？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/464)

</details>

<b><details><summary>74. 完整的 vue-router 导航解析流程</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/465)

</details>

<b><details><summary>75.vue-router 有哪几种导航钩子（ 导航守卫 ）？</summary></b>

参考答案：三种

第一种是全局导航钩子：router.beforeEach(to, from, next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子；
第三种：单独路由独享组件

[参与互动](https://github.com/yisainan/web-interview/issues/466)

</details>

<b><details><summary>76.vue-router 的几种实例方法以及参数传递</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/467)

</details>

<b><details><summary>77. 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？ </summary></b>

参考答案：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 使用 router 对象的 params. id

[参与互动](https://github.com/yisainan/web-interview/issues/468)

</details>

<b><details><summary>78.vue-router 如何定义嵌套路由？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/469)

</details>

<b><details><summary>79. `<router-link></router-link>` 组件及其属性</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/470)

</details>

<b><details><summary>80.vue-router 实现路由懒加载（ 动态加载路由 ）</summary></b>

参考答案：[参考](https://segmentfault.com/a/1190000011519350)

[参与互动](https://github.com/yisainan/web-interview/issues/471)

</details>

<b><details><summary>81.vue-router 路由的两种模式</summary></b>

参考答案：hash history

[参与互动](https://github.com/yisainan/web-interview/issues/472)

</details>

<b><details><summary>82. history 路由模式与后台的配合</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/473)

</details>

<b><details><summary>83.vue路由实现原理? 或 vue-router原理?</summary></b>

参考答案：

说简单点，vue-router的原理就是通过对URL地址变化的监听，继而对不同的组件进行渲染。
每当URL地址改变时，就对相应的组件进行渲染。原理是很简单，实现方式可能有点复杂，主要有hash模式和history模式。
如果想了解得详细点，建议百度或者阅读源码。

[参与互动](https://github.com/yisainan/web-interview/issues/474)

</details>

<b><details><summary>84. 什么是 MVVM？</summary></b>

参考答案：1. 拆分说明（M，V，VM 都是干啥的） 2. 之间联系（Model 和 ViewModel 的双向数据绑定）

解析：

MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象（桥梁）。

在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

[参与互动](https://github.com/yisainan/web-interview/issues/475)

</details>

<b><details><summary>85. MVC、MVP 与 MVVM 模式</summary></b>

参考答案：

一、MVC

通信方式如下

![架构_001](../../images/架构_001.png)

1. 视图（View）：用户界面。 传送指令到 Controller

2. 控制器（Controller）：业务逻辑 完成业务逻辑后，要求 Model 改变状态

3. 模型（Model）：数据保存 将新的数据发送到 View，用户得到反馈

二、MVP

通信方式如下

![架构_002](../../images/架构_002.png)

1. 各部分之间的通信，都是双向的。

2. View 与 Model 不发生联系，都通过 Presenter 传递。

3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在那里。

五、MVVM

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。通信方式如下

![架构_003](../../images/架构_003.png)

唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。

[参与互动](https://github.com/yisainan/web-interview/issues/476)

</details>

<b><details><summary>86. 常见的实现 MVVM 几种方式</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/477)

</details>

<b><details><summary>87. 解释下 Object.defineProperty()方法</summary></b>

参考答案：这是 js 中一个非常重要的方法，ES6 中某些方法的实现依赖于它，VUE 通过它实现双向绑定，此方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象

解析：

## 语法

Object.defineProperty(object, attribute, descriptor)

* 这三个参数都是必输项
* 第一个参数为 目标对象
* 第二个参数为 需要定义的属性或者方法
* 第三个参数为 目标属性所拥有的特性

## descriptor

前两个参数都很明确，重点是第三个参数 descriptor， 它有以下取值

* value: 属性的值
* writable: 属性的值是否可被重写（默认为 false）
* configurable: 总开关，是否可配置，若为 false, 则其他都为 false（默认为 false）
* enumerable: 属性是否可被枚举（默认为 false）
* get: 获取该属性的值时调用
* set: 重写该属性的值时调用

一个例子

``` js
var a = {};
Object.defineProperty(a, "b", {
    value: 123
});
console.log(a.b); //123
a.b = 456;
console.log(a.b); //123
a.c = 110;
for (item in a) {
    console.log(item, a[item]); //c 110
}
```

因为 writable 和 enumerable 默认值为 false, 所以对 a.b 赋值无效，也无法遍历它

## configurable

总开关，是否可配置，设置为 false 后，就不能再设置了，否则报错， 例子

``` js
var a = {};
Object.defineProperty(a, "b", {
    configurable: false
});
Object.defineProperty(a, "b", {
    configurable: true
});
//error: Uncaught TypeError: Cannot redefine property: b
```

## writable

是否可重写

``` js
var a = {};
Object.defineProperty(a, "b", {
    value: 123,
    writable: false
});
console.log(a.b); // 打印 123
a.b = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）
console.log(a.b); // 打印 123， 赋值不起作用。
```

## enumerable

属性特性 enumerable 定义了对象的属性是否可以在 for... in 循环和 Object.keys() 中被枚举

``` js
var a = {};
Object.defineProperty(a, "b", {
    value: 3445,
    enumerable: true
});
console.log(Object.keys(a)); // 打印["b"]
```

enumerable 改为 false

``` js
var a = {};
Object.defineProperty(a, "b", {
    value: 3445,
    enumerable: false //注意咯这里改了
});
console.log(Object.keys(a)); // 打印[]
```

## set 和 get

如果设置了 set 或 get, 就不能设置 writable 和 value 中的任何一个，否则报错

``` js
var a = {};
Object.defineProperty(a, "abc", {
    value: 123,
    get: function() {
        return value;
    }
});
//Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #<Object> at Function.defineProperty
```

对目标对象的目标属性 赋值和取值 时， 分别触发 set 和 get 方法

``` js
var a = {};
var b = 1;
Object.defineProperty(a, "b", {
    set: function(newValue) {
        b = 99;
        console.log("你要赋值给我,我的新值是" + newValue);
    },
    get: function() {
        console.log("你取我的值");
        return 2; //注意这里，我硬编码返回2
    }
});
a.b = 1; //打印 你要赋值给我,我的新值是1
console.log(b); //打印 99
console.log(a.b); //打印 你取我的值
//打印 2    注意这里，和我的硬编码相同的
```

上面的代码中，给 a.b 赋值，b 的值也跟着改变了。原因是给 a.b 赋值，自动调用了 set 方法，在 set 方法中改变了 b 的值。vue 双向绑定的原理就是这个。

扩展：[参考](https://www.cnblogs.com/zhaowj/p/9576450.html)

[参与互动](https://github.com/yisainan/web-interview/issues/478)

</details>

<b><details><summary>88. 实现一个自己的 MVVM（原理剖析）</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/479)

</details>

<b><details><summary>89. 递归组件的使用</summary></b>

参考答案：组件是可以在自己的模板中调用自身的，不过他们只能通过name选项来做这件事

解析：

[参与互动](https://github.com/yisainan/web-interview/issues/480)

</details>

<b><details><summary>90. Obj.keys()与 Obj.defineProperty</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/481)

</details>

<b><details><summary>91. 发布-订阅模式</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/482)

</details>

<b><details><summary>92. 实现 MVVM 的思路分析</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/483)

</details>

<b><details><summary>93. mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</summary></b>

参考答案：

mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。

区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。

场景：数据操作比较多的场景，更加便捷

[参与互动](https://github.com/yisainan/web-interview/issues/484)

</details>

<b><details><summary>94. 构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</summary></b>

参考答案：

1、vue.js：vue-cli 工程的核心，主要特点是 双向数据绑定 和 组件系统。

2、vue-router：vue 官方推荐使用的路由框架。

3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。

4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http 请求，基于 Promise 设计。

5、vux 等：一个专为 vue 设计的移动端 UI 组件库。

6、创建一个 emit.js 文件，用于 vue 事件机制的管理。

7、webpack：模块加载和 vue-cli 工程打包器。

[参与互动](https://github.com/yisainan/web-interview/issues/485)

</details>

<b><details><summary>95.vue-cli 工程常用的 npm 命令有哪些？</summary></b>

参考答案：npm install、npm run dev、npm run build --report 等

解析：

下载 node_modules 资源包的命令：npm install

启动 vue-cli 开发环境的 npm 命令：npm run dev

vue-cli 生成 生产环境部署资源 的 npm 命令：npm run build

用于查看 vue-cli 生产环境部署资源文件大小的 npm 命令：npm run build --report，此命令必答

命令效果：

![vue_001](../../images/vue_001.jpg)

在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、manifest.js、vendor.js 文件里面所包含代码的页面。可以具此优化 vue-cli 生产环境部署的静态资源，提升 页面 的加载速度。

[参与互动](https://github.com/yisainan/web-interview/issues/486)

</details>

<b><details><summary>96. 请说出 vue-cli 工程中每个文件夹和文件的用处</summary></b>

参考答案：

``` 
vue-cli目录解析：

build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。
config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。
dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。
node_modules：存放npm命令下载的开发环境和生产环境的依赖包。
src: 存放项目源码及需要引用的资源文件。
src下assets：存放项目中需要用到的资源文件，css、js、images等。
src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。
src下emit：自己配置的vue集中式事件管理机制。
src下router：vue-router vue路由的配置文件。
src下service：自己配置的vue请求后台接口方法。
src下page：存在vue页面组件的文件夹。
src下util：存放vue开发过程中一些公共的.js方法。
src下vuex：存放 vuex 为vue专门开发的状态管理器。
src下app.vue：使用标签<route-view></router-view>渲染整个工程的.vue组件。
src下main.js：vue-cli工程的入口文件。
index.html：设置项目的一些meta头信息和提供<div id="app"></div>用于挂载 vue 节点。
package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。
```

[参与互动](https://github.com/yisainan/web-interview/issues/487)

</details>

<b><details><summary>97. config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置</summary></b>

参考答案：

``` 
build 对象下 对于 生产环境 的配置：

index：配置打包后入口.html文件的名称以及文件夹名称
assetsRoot：配置打包后生成的文件名称和路径
assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 "./"
productionGzip：是否开发 gzip 压缩，以提升加载速度

dev 对象下 对于 开发环境 的配置：

port：设置端口号
autoOpenBrowser：启动工程时，自动打开浏览器
proxyTable：vue设置的代理，用以解决 跨域 问题
```

[参与互动](https://github.com/yisainan/web-interview/issues/488)

</details>

<b><details><summary>98. 请你详细介绍一些 package.json 里面的配置</summary></b>

参考答案：

``` 
scripts：npm run xxx 命令调用node执行的 .js 文件
dependencies：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里面
devDependencies：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不会打包进 生产环境js文件 里面。
```

[参与互动](https://github.com/yisainan/web-interview/issues/489)

</details>

<b><details><summary>99.vue-cli 中常用到的加载器</summary></b>

参考答案：

1. 安装 sass:

2. 安装 axios:

3. 安装 mock:

4. 安装 lib-flexible: --实现移动端自适应

5. 安装 sass-resourses-loader

[参与互动](https://github.com/yisainan/web-interview/issues/490)

</details>

<b><details><summary>100.vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？</summary></b>

参考答案：

第一步：在 components 目录新建你的组件文件（如：indexPage.vue），script 一定要 export default {}

第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue'

第三步：注入到 vue 的子组件的 components 属性上面, components:{indexPage}

第四步：在 template 视图 view 中使用

遇到的问题：
例如有 indexPage 命名，使用的时候则 index-page

[参与互动](https://github.com/yisainan/web-interview/issues/491)

</details>

<b><details><summary>101.vue-cli 提供的几种脚手架模板</summary></b>

参考答案：

1.webpack-simple模板
2.webpack模板

[参与互动](https://github.com/yisainan/web-interview/issues/492)

</details>

<b><details><summary>102.vue-cli 开发环境使用全局常量</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/493)

</details>

<b><details><summary>103.vue-cli 生产环境使用全局常量</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/494)

</details>

<b><details><summary>104.vue-cli 中自定义指令的使用</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/495)

</details>

<b><details><summary>105.vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法</summary></b>

参考答案：

</details>

<b><details><summary>106.vue 组件之间的通信种类</summary></b>

参考答案：

1)	父组件向子组件通信
2)	子组件向父组件通信
3)	隔代组件间通信
4)	兄弟组件间通信

</details>

<b><details><summary>107.vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法</summary></b>

参考答案：

</details>

<b><details><summary>108. 谈一谈 nextTick 的原理</summary></b>

参考答案：

* 在下次 DOM 更新循环结束之后执行延迟回调。
* nextTick主要使用了宏任务和微任务。
* 根据执行环境分别尝试采用

    Promise
    MutationObserver
    setImmediate

如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

</details>

<b><details><summary>109.vue 中的 computed 是如何实现的</summary></b>

参考答案：

</details>

<b><details><summary>110.vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</summary></b>

参考答案：

### vue 如何优化首页的加载速度？

* 路由懒加载
* ui框架按需加载
* gzip压缩

### vue 首页白屏是什么问题引起的？

* 第一种，打包后文件引用路径不对，导致找不到文件报错白屏

解决办法：修改一下config下面的index.js中bulid模块导出的路径。因为index.html里边的内容都是通过script标签引入的，而你的路径不对，打开肯定是空白的。先看一下默认的路径。

* 第二种，由于把路由模式mode设置影响

解决方法：路由里边router/index.js路由配置里边默认模式是hash，如果你改成了history模式的话，打开也会是一片空白。所以改为hash或者直接把模式配置删除，让它默认的就行 。如果非要使用history模式的话，需要你在服务端加一个覆盖所有的情况的候选资源：如果URL匹配不到任何静态资源，则应该返回一个index.html，这个页面就是你app依赖页面。

所以只要删除mode或者把mode改成hash就OK了。

* 第三种，项目中使用了es6的语法，一些浏览器不支持es6，造成编译错误不能解析而造成白屏

解决方法：

安装 npm install --save-dev babel-preset-es2015

安装 npm install --save-dev babel-preset-stage-3

在项目根目录创建一个.babelrc文件 里面内容 最基本配置是：

``` js
{
    // 此项指明，转码的规则
    "presets": [
        // env项是借助插件babel-preset-env，下面这个配置说的是babel对es6,es7,es8进行转码，并且设置amd,commonjs这样的模块化文件，不进行转码
        ["env", {
            "modules": false
        }],
        // 下面这个是不同阶段出现的es语法，包含不同的转码插件
        "stage-2"
    ],
    // 下面这个选项是引用插件来处理代码的转换，transform-runtime用来处理全局函数和优化babel编译
    "plugins": ["transform-runtime"],
    // 下面指的是在生成的文件中，不产生注释
    "comments": false,
    // 下面这段是在特定的环境中所执行的转码规则，当环境变量是下面的test就会覆盖上面的设置
    "env": {
        // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development
        "test": {
            "presets": ["env", "stage-2"],
            // instanbul是一个用来测试转码后代码的工具
            "plugins": ["istanbul"]
        }
    }
}
```

</details>

<b><details><summary>111.vue 的父组件和子组件生命周期钩子执行顺序是什么</summary></b>

参考答案：

* 加载渲染过程
    - 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted

* 子组件更新过程

    - 父beforeUpdate->子beforeUpdate->子updated->父updated

* 父组件更新过程
    - 父beforeUpdate->父updated

* 销毁过程
    - 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

</details>

<b><details><summary>112. 在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。</summary></b>

参考答案：

</details>

<b><details><summary>113. 实现通信方式</summary></b>

参考答案：

``` 
方式1: props
1)	通过一般属性实现父向子通信
2)	通过函数属性实现子向父通信
3)	缺点: 隔代组件和兄弟组件间通信比较麻烦

方式2: vue自定义事件
1)	vue内置实现, 可以代替函数类型的props
  a.	绑定监听: <MyComp @eventName="callback"
  b.	触发(分发)事件: this.$emit("eventName", data)
2)	缺点: 只适合于子向父通信

方式3: 消息订阅与发布
1)	需要引入消息订阅与发布的实现库, 如: pubsub-js
  a.	订阅消息: PubSub.subscribe('msg', (msg, data)=>{})
  b.	发布消息: PubSub.publish(‘msg’, data)
2)	优点: 此方式可用于任意关系组件间通信

方式4: vuex
1)	是什么: vuex是vue官方提供的集中式管理vue多组件共享状态数据的vue插件
2)	优点: 对组件间关系没有限制, 且相比于pubsub库管理更集中, 更方便

方式5: slot
1)	是什么: 专门用来实现父向子传递带数据的标签
  a.	子组件
  b.	父组件
2)	注意: 通信的标签模板是在父组件中解析好后再传递给子组件的
```

</details>

<b><details><summary>114. 说说Vue的MVVM实现原理</summary></b>

参考答案：

#### 理解

``` 
1)	Vue作为MVVM模式的实现库的2种技术
a.	模板解析
b.	数据绑定

2)	模板解析: 实现初始化显示
a.	解析大括号表达式
b.	解析指令

3)	数据绑定: 实现更新显示
a.	通过数据劫持实现
```

#### 原理结构图

![vue_006](../../images/vue_006.png)

</details>

<b><details><summary>115. axios的特点有哪些？</summary></b>

参考答案：

``` 
一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API
二、它可以拦截请求和响应
三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据
四、安全性更高，客户端支持防御 XSRF
```

</details>

<b><details><summary>116. axios有哪些常用方法？</summary></b>

参考答案：

``` 
一、axios.get(url[, config])   //get请求用于列表和信息查询
二、axios.delete(url[, config])  //删除
三、axios.post(url[, data[, config]])  //post请求用于信息的添加
四、axios.put(url[, data[, config]])  //更新操作
```

</details>

<b><details><summary>117. 说下你了解的axios相关配置属性？</summary></b>

``` 
`url` 是用于请求的服务器URL

`method` 是创建请求时使用的方法,默认是get

`baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对URL。它可以通过设置一个 `baseURL` 便于为axios实例的方法传递相对URL

`transformRequest` 允许在向服务器发送前，修改请求数据，只能用在'PUT','POST'和'PATCH'这几个请求方法

`headers` 是即将被发送的自定义请求头
headers:{'X-Requested-With':'XMLHttpRequest'},

`params` 是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象
params:{
ID:12345
},

`auth` 表示应该使用HTTP基础验证，并提供凭据
这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization` 头
auth:{
username:'janedoe',
password:'s00pers3cret'
},

'proxy'定义代理服务器的主机名称和端口
`auth` 表示HTTP基础验证应当用于连接代理，并提供凭据
这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。
proxy:{
host:'127.0.0.1',
port:9000,
auth::{
username:'mikeymike',
password:'rapunz3l'
}
},
```

</details>

<b><details><summary>118.vue.use是干什么的？原理是什么？</summary></b>

参考答案：vue.use 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法等。

1､检查插件是否注册，若已注册，则直接跳出；

2､处理入参，将第一个参数之后的参数归集，并在首部塞入 this 上下文；

3､执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册；

1. 插件不能重复的加载

install 方法的第一个参数是vue的构造函数，其他参数是Vue.set中除了第一个参数的其他参数； 代码：args. unshift(this)

2. 调用插件的install 方法 代码：typeof plugin.install === 'function'

3. 插件本身是一个函数，直接让函数执行。 代码：plugin.apply(null, args)

4. 缓存插件。  代码：installedPlugins.push(plugin)

</details>

<b><details><summary>119.new Vue() 发生了什么？</summary></b>

参考答案：

1）结论：new Vue()是创建Vue实例，它内部执行了根实例的初始化过程。

2）具体包括以下操作：

选项合并

$children，$refs，$slots，$createElement等实例属性的方法初始化

自定义事件处理

数据响应式处理

生命周期钩子调用 （beforecreate created）

可能的挂载

3）总结：new Vue()创建了根实例并准备好数据和方法，未来执行挂载时，此过程还会递归的应用于它的子组件上，最终形成一个有紧密关系的组件实例树。

</details>

<b><details><summary>120. 请说一下响应式数据的理解？</summary></b>

参考答案：根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。

1)对象内部通过defineReactive方法，使用Object.defineProperty() 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发；

2) 数组则通过重写数组方法来实现的。扩展它的 7 个变更⽅法，通过监听这些方法可以做到依赖收集和派发更新；( push/pop/shift/unshift/splice/reverse/sort )

这里在回答时可以带出一些相关知识点 （比如多层对象是通过递归来实现劫持，顺带提出vue3中是使用 proxy来实现响应式数据）

补充回答：

内部依赖收集是怎么做到的，每个属性都拥有自己的dep属性，存放他所依赖的 watcher，当属性变化后会通知自己对应的 watcher去更新。

响应式流程：

1､defineReactive  把数据定义成响应式的；

2､给属性增加一个 dep，用来收集对应的那些watcher；

3､等数据变化进行更新

dep.depend()  // get 取值：进行依赖收集

dep.notify() // set 设置时：通知视图更新

这里可以引出性能优化相关的内容：

1)对象层级过深，性能就会差。

2)不需要响应数据的内容不要放在data中。

3)object.freeze()  可以冻结数据。

</details>

<b><details><summary>121.vue如何检测数组变化？</summary></b>

参考答案：数组考虑性能原因没有用defineProperty对数组的每一项进行拦截，而是选择重写数组 方法以进行重写。当数组调用到这 7 个方法的时候，执行 ob.dep.notify() 进行派发通知 Watcher 更新；

重写数组方法：push/pop/shift/unshift/splice/reverse/sort

补充回答：

在Vue中修改数组的索引和长度是无法监控到的。需要通过以下7种变异方法修改数组才会触发数组对应的wacther进行更新。数组中如果是对象数据类型也会进行递归劫持。

说明：那如果想要改索引更新数据怎么办？

可以通过Vue.set()来进行处理 =》 核心内部用的是 splice 方法。

// 取出原型方法；

const arrayProto = Array.prototype 

// 拷贝原型方法；

export const arrayMethods = Object.create(arrayProto) 

// 重写数组方法；

def(arrayMethods, method, function mutator (...args) { }

ob.dep.notify()  // 调用方法时更新视图；

</details>

<b><details><summary>122.vue.set 方法是如何实现的？ </summary></b>

参考答案：为什么$set可以触发更新，我们给对象和数组本身都增加了dep属性，当给对象新增不存在的属性则触发对象依赖的watcher去更新，当修改数组索引时我们调用数组本身的splice方法去更新数组。

补充回答：

官方定义Vue.set(object, key, value) 

1) 如果是数组，调用重写的splice方法 （这样可以更新视图 ）

代码：target.splice(key, 1, val)

2) 如果不是响应式的也不需要将其定义成响应式属性。

3) 如果是对象，将属性定义成响应式的  defineReactive(ob.value, key, val)

通知视图更新  ob.dep.notify()

</details>

<b><details><summary>123.vue中模板编译原理？</summary></b>

参考答案：简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：

1. 生成AST树
2. 优化
3. codegen

* 首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

* Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。

* 那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。

* 编译的最后一步是将优化后的AST树转换为可执行的代码。

</details>

<b><details><summary>124.vue3.x响应式数据原理</summary></b>

参考答案：Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

</details>

<b><details><summary>125.vue3.x中Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</summary></b>

参考答案：判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。

</details>

<b><details><summary>126.vue3.x中监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</summary></b>

参考答案：我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

</details>

<b><details><summary>127.vue2.x中如何监测数组变化</summary></b>

参考答案：

* 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。
* 这样当调用数组api时，可以通知依赖更新。
* 如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

</details>

<b><details><summary>128. 说一下Computed和Watch</summary></b>

参考答案：

* Computed本质是一个具备缓存的watcher，依赖的响应式属性变化才会重新计算并且更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。

* Watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。常用于监听某一个值，当被监听的值发生变化时，执行对应的操作。 打开deep：true选项会深度监听对象中的属性，对对象中的每一项进行监听。 immediate: true 选项表示，初始化时就会先执行一遍该监听对应的操作

</details>

<b><details><summary>129.vue2.x和Vue3.x渲染器的diff算法分别说一下</summary></b>

参考答案：简单来说，diff算法有以下过程

* 同级比较，再比较子节点
* 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
* 比较都有子节点的情况(核心diff)
* 递归比较子节点
* 正常Diff两个树的时间复杂度是O(n^3) ，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

Vue3.x借鉴了 ivi算法和 inferno算法

在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)

</details>

<b><details><summary>130. SSR了解吗？</summary></b>

参考答案：

* SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。

* SSR有着更好的SEO、并且首屏加载速度更快等优点。

* 不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。

* 还有就是服务器会有更大的负载需求。

</details>

<b><details><summary>131. 组件中写 name选项有哪些好处及作用？</summary></b>

参考答案：

1) 可以通过名字找到对应的组件（ 递归组件 ）

2) 可以通过name属性实现缓存功能 (keep-alive)

3) 可以通过name来识别组件（跨级组件通信时非常重要）

```js
Vue.extend = function () {
    if(name) {
        Sub.options.componentd[name] = Sub
    }
}
```

</details>

<b><details><summary>132.vue 的生命周期是什么？</summary></b>

参考答案：

```
Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。
```

</details>

<b><details><summary>133.vue 的各个生命阶段是什么？</summary></b>

参考答案：

```
Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。

（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。

（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。

（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。

（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。

（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。

（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。

（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。

（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。
```

详细资料可以参考：
[《vue 生命周期深入》](https://juejin.im/entry/5aee8fbb518825671952308c)
[《Vue 实例》](https://cn.vuejs.org/v2/guide/instance.html)

</details>

<b><details><summary>134.vue 组件间的参数传递方式？</summary></b>

参考答案：

```
（1）父子组件间通信

第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事
件来向父组件发送数据。

第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组
件，这样也可以实现通信。

第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件
中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。

（2）兄弟组件间通信

第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实
例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。

第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。

（3）任意组件之间

使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。


如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候
可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个
公共数据进行读写操作，这样达到了解耦的目的。
```

详细资料可以参考：
[《VUE 组件之间数据传递全集》](https://juejin.im/entry/5ba215ac5188255c6d0d8345)

</details>

<b><details><summary>135. computed 和 watch 的差异？</summary></b>

参考答案：

```
（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。

（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。

（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。
```

详细资料可以参考：
[《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》](https://juejin.im/post/5b98c4da6fb9a05d353c5fd7)
[《深入理解 Vue 的 watch 实现原理及其实现方式》](https://juejin.im/post/5af908ea5188254265399009)

</details>

<b><details><summary>136.vue-router 中的导航钩子函数</summary></b>

参考答案：

```
（1）全局的钩子函数 beforeEach 和 afterEach

beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。

（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。

（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组
件内部直接进行定义的。
```

详细资料可以参考：
[《导航守卫》](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)

</details>

<b><details><summary>137. $route 和 $router 的区别？</summary></b>

参考答案：

```
$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。
```

</details>

<b><details><summary>138.vue 常用的修饰符？</summary></b>

参考答案：

```
.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；
```

</details>

<b><details><summary>139.vue 中 key 值的作用？</summary></b>

参考答案：

```
vue 中 key 值的作用可以分为两种情况来考虑。

第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。

第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。
```

详细资料可以参考：
[《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》](https://segmentfault.com/a/1190000016344599)
[《Vue2.0 v-for 中 :key 到底有什么用？》](https://www.zhihu.com/question/61064119)
[《vue 中 key 的作用》](https://www.cnblogs.com/RainyBear/p/8563101.html)

</details>

<b><details><summary>140. computed 和 watch 区别？</summary></b>

参考答案：

```
computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。

watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。
```

</details>

<b><details><summary>141. keep-alive 组件有什么作用？</summary></b>

参考答案：

```
如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。
```

</details>

<b><details><summary>142.vue 中 mixin 和 mixins 区别？</summary></b>

参考答案：

```
mixin 用于全局混入，会影响到每个组件实例。

mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并
```

详细资料可以参考：
[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f)
[《混入》](https://cn.vuejs.org/v2/guide/mixins.html)

</details>


<b><details><summary>143.vue 双向数据绑定原理？</summary></b>

参考答案：

```
vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。

首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。

数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。

如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。

如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数
据。
```

详细资料可以参考：
[《Vue.js 双向绑定的实现原理》](http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension)

</details>

<b><details><summary>144. Object.defineProperty 介绍？</summary></b>

参考答案：

```
Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。

一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。
```

详细资料可以参考：
[《Object.defineProperty()》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

</details>

<b><details><summary>145. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</summary></b>

参考答案：

```
有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。
```

</details>

<b><details><summary>146. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</summary></b>

参考答案：

```
我对 Virtual DOM 的理解是，

首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。

当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。

最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。
```

详细资料可以参考：
[《Virtual DOM》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf)
[《理解 Virtual DOM》](https://github.com/y8n/blog/issues/5)
[《深度剖析：如何实现一个 Virtual DOM 算法》](https://github.com/livoras/blog/issues/13)
[《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》](https://www.zhihu.com/question/31809713/answer/53544875)

</details>

<b><details><summary>147. 如何比较两个 DOM 树的差异？</summary></b>

参考答案：

```
两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。

算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。

在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。
```

</details>

<b><details><summary>148. v-model的实现原理</summary></b>

参考答案：

v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
v-bind绑定一个value属性；
v-on指令给当前元素绑定input事件。

解析：

```
<template>
  <div id="app">
    {{username}} <br/>
    <input type="text" v-model="username">
  </div>
</template>

<script>
export default {
  name: 'App',
  data(){
    return {
      username:''
    }
  }
}
</script>
```
v-model其实是个语法糖，它实际上是做了两步动作：
1、绑定数据value（v-bind）
2、触发输入事件input（v-on）
也就是说，v-model等同于：
```
<template>
  <div id="app">
    {{username}} <br/>
    <input type="text" :value="username" @input="username=$event.target.value">
  </div>
</template>

<script>
export default {
  name: 'App',
  data(){
    return {
      username:''
    }
  }
}
</script>
```
</details>

<b><details><summary>149. 说下vue 中的h函数</summary></b>

参考答案：h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的

解析：

在讲h函数之前，我们先来了解下虚拟dom：

虚拟dom简单来说就是一个普通的JavaScript对象，包含tag，props，children三个属性。。。

```js
<div id="app">
  <p className="text">lxc</p>
</div>
```
上边的HTML代码转为虚拟DOM如下：
```js
{
    tag:"div",
    props:{
        id:"app"
    },
    children:[
        {
            tag:"p",
            props:{
                className:"text"
            },
            children:[
                "lxc"
            ]
        }
    ]
}
```

该对象就是所谓的虚拟dom，因为dom对象是属性结构，所以使用JavaScript对象就可以简单表示。而原生dom有许多属性、事件，即使创建一个空div也要付出昂贵的代价。而虚拟dom提升性能的点在于DOM发生变化的时候，通过diff算法对比，计算出需要更改的DOM，只对变化的DOM进行操作，而不是更新整个视图。。。

在vue脚手架中，我们经常会看到这样一段代码：
```js
  const app = new Vue({
    ··· ···
    render: h => h(App)
  })
```
这个render方法也可以写成这样：
```js
  const app = new Vue({
    ··· ···
    render:function(createElement){
        return createElement(App)
    }
  })
```
所以h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的

参考地址：https://blog.csdn.net/qq_42778001/article/details/95959531

</details>

<b><details><summary>150. Vue.prototype、Vue.component和Vue.use的区别</summary></b>

参考答案：

1、Vue.prototype

  * 在很多组件里用到数据/实用工具，但是不想污染全局作用域。这种情况下，你可以通过在原型上定义它们使其在每个 Vue 的实例中可用
  * $ 是在 Vue 所有实例中都可用的 property 的一个简单约定。这样做会避免和已被定义的数据、方法、计算属性产生冲突
  * 常用于方法与变量

```js
import pinyin from 'js-pinyin';
Vue.prototype.$pinyin = pinyin;
```

2、vue.component

  * 注册全局组件
  * 第一个参数是调用组件时写的组件名
  * 第二个参数是引入组件时写的标签名称
  * 常用于注册自定义组件

```js
import JsTree from '@/components/JsTree';
Vue.component('JsTree', JsTree);
```

3、Vue.use

  * 注册全局插件
  * 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件
  * 插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象
  * 常用于注册第三方插件

```js
import VueContextMenu from 'vue-contextmenu';
Vue.use(VueContextMenu);
```


</details>

<b><details><summary>151.如何将axios异步请求同步化处理？</summary></b>

参考答案：async await

```js
// 统一处理axios请求
    async getHistoryData (data) {
      try {
        let res = await axios.get('/api/survey/list/', {
          params: data
        })
        this.tableData = res.data.result
        this.totalData = res.data.count
      } catch (err) {
        console.log(err)
        alert('请求出错！')
      }
    }
  }
```

</details>

<b><details><summary>152.vue组件里的定时器要怎么销毁？</summary></b>

参考答案：

```js
const timer = setInterval(() =>{
// 某些定时器操作
}, 500);
// 通过$once来监听定时器，在beforeDestroy钩子可以被清除。
this.$once('hook:beforeDestroy', () => {
clearInterval(timer);
})
```

</details>

<b><details><summary>153.`＜template＞＜/template＞`有什么用？</summary></b>

参考答案：

```
包裹嵌套其它元素，使元素具有区域性，自身具有三个特点：
*隐藏性：不会显示在页面中
*任意性：可以写在页面的任意地方
*无效性： 没有一个根元素包裹，任何HTML内容都是无效的
```

</details>

<b><details><summary>154.vue组件会在什么时候下被销毁？</summary></b>

参考答案：页面关闭、路由跳转、v-if和改变key值

</details>

<b><details><summary>155.vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？</summary></b>

参考答案：需要，原生DOM事件必须要手动销毁，否则会造成内存泄漏

</details>

<b><details><summary>156.说说你对Object.defineProperty的理解</summary></b>

参考答案：Object.defineProperty定义新属性或修改原有的属性；
vue的数据双向绑定的原理就是用的Object.defineProperty这个方法，里面定义了setter和getter方法，通过观察者模式（发布订阅模式）来监听数据的变化，从而做相应的逻辑处理。


</details>

<b><details><summary>157.在组件中怎么访问到根实例？</summary></b>

参考答案：this.$root

</details>

<b><details><summary>158.vue中什么是递归组件？举个例子说明下？</summary></b>

参考答案：组件自己调用自己，场景有用于生成树形结构菜单

</details>

<b><details><summary>159.使用vue写一个tab切换</summary></b>

参考答案：

v-for循环，利用下标和v-show显示

`<div id="app">
    <ul class="tabs">
        <li class="li-tab" v-for="(item,index) in tabsParam" 
        @click="toggleTabs(index)" 
        :class="index===nowIndex?'active':''">{{item}}</li>
    </ul>
    <div class="divTab" v-show="nowIndex===0">我是tab1</div>
    <div class="divTab" v-show="nowIndex===1">我是tab2</div>
    <div class="divTab" v-show="nowIndex===2">我是tab3</div>
    <div class="divTab" v-show="nowIndex===3">我是tab4</div>
</div>`


</details>

<b><details><summary>160.vue3带来的新特性/亮点</summary></b>

参考答案：

1. performance: 性能比vue2.x块1.2~2倍;
2. Tree shaking support: 按需编译，体积比vue2.x更小;
3. Composition API: 组合API（类似React Hooks）;
4. Fragment, Teleport, Suspense: 更先进的组件;
5. Better TypeScript support: 更好的 ts 支持;
6. Custom Render API: 暴露了自定义渲染的API;

</details>

<b><details><summary>161.在compositionAPI中如何使用生命周期函数？</summary></b>

参考答案：

需要用到哪个生命周期函数，就将对应函数的import进来，接着在setup中调用即可

</details>

<b><details><summary>162.vue3如何通过ref属性获取界面上的元素?</summary></b>

参考答案：

在vue2.x中，可以通过给元素添加ref='xxx'属性，然后在代码中通过this.$refs.xxx获取到对应的元素;


在vue3中，
1. 在template中的写法跟vue2一样，给元素添加个ref='xxx'
2. 在setup中，先创建一个响应式数据，并且要把响应式数据暴露出去
3. 当元素被创建出来的时候，就会给对应的响应数据赋值
4. 当响应式数据被赋值之后，就可以利用生命周期方法onMounted中获取对应的响应式数据，即DOM元素
5. 这样做原因很简单，在setup执行时，template中的元素还没挂载到页面上，所以必须在mounted之后才能获取到元素。

```
<template>
  <div ref='box'>I am DIV</div>
</template>
<script>
import { onMounted, ref } from 'vue';
export default{
  setup(){
    let box = ref(null);
    onMounted(()=>{
      console.log(box.value)
    });
    return {box}
  }
}
</script>
```

[参考地址](https://mp.weixin.qq.com/s?__biz=MzIwODg5MjExNQ==&mid=2247484984&idx=1&sn=da3c13cadce525003756894e6283fe62&chksm=977d7f84a00af69240b36c27790d8afb2765204cc2caf1d7b156f5b6eeaba260b23d7997336f&token=342321736&lang=zh_CN#rd)

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. HTML 对象获取问题</summary></b>

FireFox：document.getElementById("idName"); 
ie:document.idname 或者 document.getElementById("idName").

解决办法：统一使用 document.getElementById("idName"); 

[参与互动](https://github.com/yisainan/web-interview/issues/784)

</details>

<b><details><summary>2. const 问题</summary></b>

Firefox 下, 可以使用 const 关键字或 var 关键字来定义常量; 
IE 下, 只能使用 var 关键字来定义常量.

解决方法：统一使用 var 关键字来定义常量.

[参与互动](https://github.com/yisainan/web-interview/issues/785)

</details>

<b><details><summary>3. event.x 与 event.y 问题</summary></b>

说明: IE 下, event 对象有 x, y 属性, 但是没有 pageX, pageY 属性; 
Firefox 下, event 对象有 pageX, pageY 属性, 但是没有 x, y 属性.

解决方法：使用 mX(mX = event.x ? event.x : event.pageX; )来代替 IE 下的 event.x 或者 Firefox 下的 event.pageX.

[参与互动](https://github.com/yisainan/web-interview/issues/786)

</details>

<b><details><summary>4. window.location.href 问题</summary></b>

说明: IE 或者 Firefox2.0.x 下, 可以使用 window.location 或 window.location.href; 
Firefox1.5.x 下, 只能使用 window.location.

解决方法：使用 window.location 来代替 window.location.href.

[参与互动](https://github.com/yisainan/web-interview/issues/787)

</details>

<b><details><summary>5. frame 问题</summary></b>

以下面的 frame 为例：

```html
<frame src="xxx.html" id="frameId" name="frameName" />
```

(1)访问 frame 对象:
IE: 使用 window.frameId 或者 window.frameName 来访问这个 frame 对象. frameId 和 frameName 可以同名。
Firefox: 只能使用 window.frameName 来访问这个 frame 对象.
另外，在 IE 和 Firefox 中都可以使用 window.document.getElementById("frameId")来访问这个 frame 对象.
(2)切换 frame 内容:
在 IE 和 Firefox 中都可以使用 window.document.getElementById("testFrame").src = "xxx.html"或 window.frameName.location = "xxx.html"来切换 frame 的内容.
如果需要将 frame 中的参数传回父窗口(注意不是 opener, 而是 parent frame)，可以在 frame 中使用 parent 来访问父窗口。例如：parent.document.form1.filename.value="Aqing"; 

[参与互动](https://github.com/yisainan/web-interview/issues/788)

</details>

<b><details><summary>6. 模态和非模态窗口问题</summary></b>

说明: IE 下, 可以通过 showModalDialog 和 showModelessDialog 打开模态和非模态窗口; Firefox 下则不能.

解决方法：直接使用 window.open(pageURL, name, parameters)方式打开新窗口。
如果需要将子窗口中的参数传递回父窗口, 可以在子窗口中使用 window.opener 来访问父窗口.
例如：var parWin = window.opener; parWin.document.getElementById("Aqing").value = "Aqing"; 

[参与互动](https://github.com/yisainan/web-interview/issues/789)

</details>

<b><details><summary>7. firefox 与 IE 的父元素(parentElement)的区别</summary></b>

IE：obj.parentElement
firefox：obj.parentNode

解决方法: 因为 firefox 与 IE 都支持 DOM, 因此使用 obj.parentNode 是不错选择.

[参与互动](https://github.com/yisainan/web-interview/issues/790)

</details>

<b><details><summary>8. document.formName.item("itemName") 问题</summary></b>

问题说明：IE 下，可以使用 document.formName.item("itemName") 或 document.formName.elements ["elementName"]；Firefox 下，只能使用 document.formName.elements["elementName"]。

解决方法：统一使用 document.formName.elements["elementName"]。

[参与互动](https://github.com/yisainan/web-interview/issues/791)

</details>

<b><details><summary>9. 集合类对象问题</summary></b>

问题说明：IE 下，可以使用 () 或 [] 获取集合类对象；Firefox 下，只能使用 [ ]获取集合类对象。

解决方法：统一使用 [] 获取集合类对象。

[参与互动](https://github.com/yisainan/web-interview/issues/792)

</details>

<b><details><summary>10. 自定义属性问题</summary></b>

问题说明：IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox 下，只能使用 getAttribute() 获取自定义属性。

解决方法：统一通过 getAttribute() 获取自定义属性。

[参与互动](https://github.com/yisainan/web-interview/issues/793)

</details>

<b><details><summary>11. input.type 属性问题</summary></b>

问题说明：IE 下 input.type 属性为只读；但是 Firefox 下 input.type 属性为读写。

解决办法：不修改 input.type 属性。如果必须要修改，可以先隐藏原来的 input，然后在同样的位置再插入一个新的 input 元素。

[参与互动](https://github.com/yisainan/web-interview/issues/794)

</details>

<b><details><summary>12. event.srcElement 问题</summary></b>

问题说明：IE 下，even 对象有 srcElement 属性，但是没有 target 属性；Firefox 下，even 对象有 target 属性，但是没有 srcElement 属性。

解决方法：使用 srcObj = event.srcElement ?event.srcElement : event.target; 

[参与互动](https://github.com/yisainan/web-interview/issues/795)

</details>

<b><details><summary>13. 关于高度问题</summary></b>

问题说明：如果是动态地添加内容，高度最好不要定义。浏览器可以自动伸缩，然而如果是静态的内容，高度最好定好。
如果设定了高度，内容过多时，ie6 下会自动增加高度、其他浏览器会超出边框

解决方法：1. 设置 overflow:hidden; 2. 高度自增 height:auto!important; height:100px; 

[参与互动](https://github.com/yisainan/web-interview/issues/796)

</details>

<b><details><summary>14. 事件委托方法</summary></b>

问题说明：IE 下，使用 document.body.onload = inject; 其中 function inject()在这之前已被实现；在 Firefox 下，使用 document.body.onload = inject(); 

解决方法：统一使用 document.body.onload=new Function('inject()'); 或者 document.body.onload = function(){}

[注意] Function 和 function 的区别。

[参与互动](https://github.com/yisainan/web-interview/issues/797)

</details>

<b><details><summary>15. document.form.item 问题</summary></b>

问题说明：
代码中存在 document.formName.item("itemName") 这样的语句，不能在 FF 下运行

解决方法：
改用 document.formName.elements["elementName"]

[参与互动](https://github.com/yisainan/web-interview/issues/798)

</details>

<b><details><summary>16. cursor:hand VS cursor:pointer</summary></b>

问题说明：firefox 不支持 hand，但 ie 支持 pointer

解决方法: 统一使用 pointer

[参与互动](https://github.com/yisainan/web-interview/issues/799)

</details>

<b><details><summary>17. innerText 在 IE 中能正常工作，但在 FireFox 中却不行.</summary></b>

解决方法：在非 IE 浏览器中使用 textContent 代替 innerText

```js
if (navigator.appName.indexOf("Explorer") > -1) {
    document.getElementById("element").innerText = "my text";
} else {
    document.getElementById("element").textContent = "my text";
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/800)

</details>

<b><details><summary>18. CSS 透明度的设置</summary></b>

问题说明：

1. 旧的 Opacity 设置

```css
#ceng {
    -khtml-opacity: 0.5;
    -moz-opacity: 0.5;
}
```

2. 在 Firefox, Safari, Chrome 和 Opera 下的 CSS 透明度

```css
#ceng {
    opacity: 0.7;
}
```

3. IE 下的 CSS 透明度

```css
#ceng {
    filter: alpha(opacity=40);
}
```

```css
#ceng {
    filter: progid:DXImageTransform.Microsoft.Alpha(opacity=40);
    /* 第一行在IE6, IE7和IE8下有效 */
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(opacity=40)";
    /*第二行仅在IE8下有效 */
}
```

解决方法：

```css
#ceng {
    filter: alpha(opacity=50);
    -moz-opacity: 0.5;
    -khtml-opacity: 0.5;
    opacity: 0.5;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/801)

</details>

<b><details><summary>19. css 中的 width 和 padding</summary></b>

在 IE7 和 FF 中 width 宽度不包括 padding，在 Ie6 中包括 padding.

[参与互动](https://github.com/yisainan/web-interview/issues/802)

</details>

<b><details><summary>20. FF 和 IE BOX 模型解释不一致导致相差 2px</summary></b>

问题说明：
box.style{width:100; border 1px; }
ie 理解为 box.width = 100
ff 理解为 box.width = 100 + 1\*2 = 102 //加上边框 2px

解决方法：div{margin:30px!important; margin:28px; }
注意这两个 margin 的顺序一定不能写反， IE 不能识别!important 这个属性，但别的浏览器可以识别。所以在 IE 下其实解释成这样：div{maring:30px; margin:28px}
重复定义的话按照最后一个来执行，所以不可以只写 margin: XXpx!important; 

[参与互动](https://github.com/yisainan/web-interview/issues/803)

</details>

<b><details><summary>21. IE5 和 IE6 的 BOX 解释不一致</summary></b>

问题说明：
IE5 下 `div{width:300px; margin:0 10px 0 10px; }`

div 的宽度会被解释为 300px-10px(右填充)-10px(左填充)，最终 div 的宽度为 280px，而在 IE6 和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px 来计算的。

解决方法：
这时我们可以做如下修改 div{width:300px!important; width :340px; margin:0 10px 0 10px}

[参与互动](https://github.com/yisainan/web-interview/issues/804)

</details>

<b><details><summary>22. ul 和 ol 列表缩进问题</summary></b>

消除 ul、ol 等列表的缩进时，样式应写成：list-style:none; margin:0px; padding:0px; 

经验证，在 IE 中，设置 margin:0px 可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置 padding 对样式没有影响；

在 Firefox 中，设置 margin:0px 仅仅可以去除上下的空白，设置 padding:0px 后仅仅可以去掉左右缩进，还必须设置 list-style:none 才能去除列表编号或圆点。

也就是说，在 IE 中仅仅设置 margin:0px 即可达到最终效果，而在 Firefox 中必须同时设置 margin:0px、 padding:0px 以及 list-style:none 三项才能达到最终效果。

[参与互动](https://github.com/yisainan/web-interview/issues/805)

</details>

<b><details><summary>23. 元素水平居中问题</summary></b>

FF: margin:0 auto; 

IE: 父级{ text-align:center; }

[参与互动](https://github.com/yisainan/web-interview/issues/806)

</details>

<b><details><summary>24. 变量名与某 HTML 对象 id 相同的问题</summary></b>

问题说明：
在 FF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量名，IE 中不能

解决方法：
在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行
最好不要取与 HTML 对象 id 相同的变量名，以减少错误

[参与互动](https://github.com/yisainan/web-interview/issues/807)

</details>

<b><details><summary>25. margin 加倍的问题</summary></b>

问题说明：
设置为 float 的 div 在 ie 下设置的 margin 会加倍。这是一个 ie6 都存在的 bug。

解决方法：
在这个 div 里面加上 display:inline; 

例如：

```htm1
<div id="imfloat">
相应的css为
#imfloat{
   float:left;
   margin:5px;
   display:inline;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/808)

</details>

<b><details><summary>26. IE 与宽度和高度的问题</summary></b>

问题说明：
IE 不认得 min-这个定义，但实际上它把正常的 width 和 height 当作有 min 的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用 min-width 和 min-height 的话，IE 下面根本等于没有设置宽度和高度。

解决方法：
比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样

```css
#box {
    width: 80px;
    height: 35px;
}

html>body #box {
    width: auto;
    height: auto;
    min-width: 80px;
    min-height: 35px;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/809)

</details>

<b><details><summary>27. 页面的最小宽度</summary></b>

如上一个问题，IE 不识别 min，要实现最小宽度，可用下面的方法：

```css
#container {
    min-width: 600px;
    width: expression(document.body.clientWidth < 600? "600px": "auto");
}
```

第一个 min-width 是正常的；但第 2 行的 width 使用了 Javascript，这只有 IE 才认得，这也会让你的 HTML 文档不太正规。它实际上通过 Javascript 的判断来实现最小宽度。

[参与互动](https://github.com/yisainan/web-interview/issues/810)

</details>

<b><details><summary>28. DIV 浮动 IE 文本产生 3 象素的 bug</summary></b>

左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有 3px 的间距.

```css
#box {
    float: left;
    width: 800px;
}

#left {
    float: left;
    width: 50%;
}

#right {
    width: 50%;
}

html #left {
    margin-right: -3px; //这句是关键}
```

```html
<div id="box">
    <div id="left">
    </div>
    <div id="right"></div>
</div>
</div>
</div>
```

[参与互动](https://github.com/yisainan/web-interview/issues/811)

</details>

<b><details><summary>29. IE 捉迷藏的问题</summary></b>

问题说明：

当 div 应用复杂的时候每个栏中又有一些链接，div 等这个时候容易发生捉迷藏的问题。

有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。

解决办法：对#layout 使用 line-height 属性或者给#layout 使用固定高和宽。页面结构尽量简单。

[参与互动](https://github.com/yisainan/web-interview/issues/812)

</details>

<b><details><summary>30. 高度不适应</summary></b>

问题说明：高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用 margin 或 padding 时。

例：

```css
#box {}

#box p {
    margin-top: 20px;
    margin-bottom: 20px;
    text-align: center;
}
```

```html
<div id="box">
    <p>p对象中的内容</p>
</div>
```

解决办法：在 p 对象上下各加 2 个空的 div 对象 CSS 代码{height:0px; overflow:hidden; }或者为 div 加上 border 属性。

[参与互动](https://github.com/yisainan/web-interview/issues/815)

</details>

<b><details><summary>31. IE6 绝对定位的问题</summary></b>

问题说明：

```html
<div style="position:relative;border:1px solid orange;text-align:center;">
    <div style="position:absolute;top:0;left:0;background:#CCC;">
        dovapour
    </div>
    <a href="#" title="vapour的blog">内容</a>
</div>
```

解决办法：
left 的定位错误问题
1、给父层设置 zoom:1 触发 layout。
2、给父层设置宽度 width

bottom 的定位错误问题
1、给父层设置 zoom:1 触发 layout。
2、给父层设置高度 height

[参与互动](https://github.com/yisainan/web-interview/issues/816)

</details>

<b><details><summary>32. IE6 下图片下有空隙产生</summary></b>

解决这个 BUG 的技巧有很多, 可以是改变 html 的排版, 或者设置 img 为 display:block 或者设置 vertical-align 属性为 vertical-align:top/bottom/middle/text-bottom 都可以解决.

[参与互动](https://github.com/yisainan/web-interview/issues/817)

</details>

<b><details><summary>33. 对齐文本与文本输入框</summary></b>

加上 vertical-align:middle; 

```css
<style type="text/css">input {
    width: 200px;
    height: 30px;
    border: 1px solid red;
    vertical-align: middle;
}

</style>
```

经验证，在 IE 下任一版本都不适用，而 ff、opera、safari、chrome 均 OK！

[参与互动](https://github.com/yisainan/web-interview/issues/818)

</details>

<b><details><summary>34. LI 中内容超过长度后以省略号显示</summary></b>

此技巧适用与 IE、Opera、safari、chrom 浏览器，FF 暂不支持。

```css
<style type="text/css">li {
    width: 200px;
    white-space: nowrap;
    text-overflow: ellipsis;
    -o-text-overflow: ellipsis;
    overflow: hidden;
}

</style>
```

[参与互动](https://github.com/yisainan/web-interview/issues/819)

</details>

<b><details><summary>35. 捕获事件</summary></b>

问题说明：
FF 没有 setCapture()、releaseCapture()方法

解决方法：
IE:

```js
obj.setCapture();
obj.releaseCapture();
```

FF:

```js
window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
window.releaseEvents(Event.MOUSEMOVE | Event.MOUSEUP);
if (!window.captureEvents) {
    o.setCapture();
} else {
    window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
}
if (!window.captureEvents) {
    o.releaseCapture();
} else {
    window.releaseEvents(Event.MOUSEMOVE | Event.MOUSEUP);
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/820)

</details>

<b><details><summary>36. IE6 默认的 div 高度</summary></b>

问题说明：
ie6 默认 div 高度为一个字体显示的高度，所在 ie6 下 div 的高度大于等于一个字的高度，因此在 ie6 下定义高度为 1px 的容器，显示的是一个字体的高度

解决方法：为这个容器设置下列属性之一
1、设置 overflow:hidden; 
2、设置 line-height:1px; 
3、设置 zoom:0.08

[参与互动](https://github.com/yisainan/web-interview/issues/821)

</details>

<b><details><summary>37. 禁止选取网页内容</summary></b>

问题说明：
FF 需要用 CSS 禁止，IE 用 JS 禁止

解决方法：

```js
IE: obj.onselectstart = function() {
    return false;
}
FF: -moz - user - select: none;
```

[参与互动](https://github.com/yisainan/web-interview/issues/822)

</details>

<b><details><summary>38. css 滤镜的问题</summary></b>

问题说明：
css 滤镜只在 ie 中有效，Firefox, Safari(WebKit), Opera 只能够设置透明，它们不支持滤镜 filter，无法实现图片切换中间变换的效果，只能通过透明度来设置。
  
解决方法：
ff 中设置透明度 -moz-opacity:0.10; opacity:0.6; 
ie 中只设置 filter:alpha(opacity=50); 时，ie6-7 失效，还要设置
1、zoom:1; 2、width:100%; 

[参与互动](https://github.com/yisainan/web-interview/issues/823)

</details>

<b><details><summary>39. td 高度的问题</summary></b>

问题说明：
table 中 td 的宽度都不包含 border 的宽度，但是 oprea 和 ff 中 td 的高度包含了 border 的高度

解决方法：
设置 line-height 和 height 一样。在 ie 中如果 td 中的没有内容，那么 border 将不会显示

[参与互动](https://github.com/yisainan/web-interview/issues/901)

</details>

<b><details><summary>40. div 嵌套 p 时，出现空白行</summary></b>

问题说明：
div 中显示<p>文本</p>，ff、oprea、Chrome：top 和 bottom 都会出现空白行，但是在 ie 下不会出现空白行。

解决方法：
设置 p 的 margin:0px，再设置 div 的 padding-top 和 padding-bottom

[参与互动](https://github.com/yisainan/web-interview/issues/902)

</details>

<b><details><summary>41. IE6-7 图片下面有空隙的问题</summary></b>

问题说明：
块元素中含有图片时，ie6-7 中会出现图片下有空隙

解决方法：
1、在源代码中让 `<div>` 和 `<img>` 在同一行
2、将图片转换为块级对象 display:block; 
3、设置图片的垂直对齐方式 vertical-align:top/middle/bottom
4、改变父对象的属性，如果父对象的宽、高固定，图片大小随父对象而定，那么可以对父元素设置： overflow:hidden; 
5、设置图片的浮动属性 float:left; 

[参与互动](https://github.com/yisainan/web-interview/issues/903)

</details>

<b><details><summary>42. IE6 双倍边距的问题</summary></b>

问题说明：
ie6 中设置浮动，同时又设置 margin 时，会出现双倍边距的问题
例 float:left; width:100px; margin:0 100px; 

解决方法：
设置 display:inline; 

[参与互动](https://github.com/yisainan/web-interview/issues/904)

</details>

<b><details><summary>43. IE6 width 为奇数，右边多出 1px 的问题</summary></b>

问题说明：
父级元素采用相对定位，且宽度设置为奇数时，子元素采用绝对定位，在 ie6 中会出现右侧多出 1 像素

解决方法：
将宽度的奇数值改成偶数

[参与互动](https://github.com/yisainan/web-interview/issues/905)

</details>

<b><details><summary>44. IE6 两个层之间 3px 的问题</summary></b>

问题说明：
左边层采用浮动，右边没有采用浮动，这时在 ie6 中两层之间就会产生 3 像素的间距

解决方法：
1、右边层也采用浮动 float
2、左边层添加属性 margin-right:-3px; 

[参与互动](https://github.com/yisainan/web-interview/issues/906)

</details>

<b><details><summary>45. IE6 子元素绝对定位的问题</summary></b>

问题说明：
父级元素使用 padding 后，子元素使用绝对定位，不能精确定位

解决方法：
在子元素中设置 left:-20px; top:-1px; 

[参与互动](https://github.com/yisainan/web-interview/issues/907)

</details>

<b><details><summary>46. 显示手型 cursor:hand</summary></b>

问题说明：
ie6/7/8、opera 都支持
但是 safari 、 ff 不支持

解决方法：
写成 cursor:pointer; (所有浏览器都能识别)

[参与互动](https://github.com/yisainan/web-interview/issues/908)

</details>

<b><details><summary>47. IE6-7 line-height 失效的问题</summary></b>

问题说明：
在 ie 中 img 与文字放一起时， line-height 不起作用

解决方法：
都设置成 float

[参与互动](https://github.com/yisainan/web-interview/issues/909)

</details>

<b><details><summary>48. td 自动换行的问题</summary></b>

问题说明：
Table 宽度固定，td 自动换行

解决方法：
设置 Table 的 table-layout:fixed，td 的 word-wrap:break-word

[参与互动](https://github.com/yisainan/web-interview/issues/910)

</details>

<b><details><summary>49. 子容器浮动后，父容器扩展问题</summary></b>

问题说明：
子容器都 float 以后，父容器没有设定高度, 父容器将不会扩展

解决方法：
只需要添加一个 clear:both 的 div，代码如下：

```html
<div style="border:1px solid#333;width:204px">
    <divstyle="width:100px;border:1px solid #333; float:left; ">子容器a</div>
    <divstyle=" width:100px;border:1px solid #333; float:left;">子容器b
</div>
<divstyle="clear:both">
    </div>
    </div>
```

[参与互动](https://github.com/yisainan/web-interview/issues/911)

</details>

<b><details><summary>50. 透明 png 图片会带背景色</summary></b>

问题说明：
在 ie6 下透明的 png 图片会带一个背景色

解决方法：

```css
    background-image: url(icon_home.png);
    background-repeat: no-repeat;
    filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='icon_home.png');
    background-image: none;
```

[参与互动](https://github.com/yisainan/web-interview/issues/912)

</details>

<b><details><summary>51. list-style-position 默认值的问题</summary></b>

问题说明：
ie 下 list-style-position 默认为 inside, firefox 默认为 outside

解决方法：
css 中指定为 outside 即可解决兼容性问题

[参与互动](https://github.com/yisainan/web-interview/issues/913)

</details>

<b><details><summary>52. list-style-image 准确定位的问题</summary></b>

问题说明：
li 前设置图片时，图片与其后的文字对齐问题

解决方法：
1、采用背景定位 和 字符缩进的方法

```css
background:url() no-repeat left center;
text-index:16px;
```

2、采用相对定位方法
li 设置 `list-style:url(); `

li 的子元素 `position:relative; top:-5px; `

[参与互动](https://github.com/yisainan/web-interview/issues/914)

</details>

<b><details><summary>53. ul 标签默认值的问题</summary></b>

问题说明：
ul 标签在 ff 中默认是有 padding 值的, 而在 ie 中只有 margin 有值

解决方法：
定义 ul{margin:0; padding:0; }就能解决大部分问题

[参与互动](https://github.com/yisainan/web-interview/issues/915)

</details>

<b><details><summary>54. IE 中 li 指定高度后，出现排版错误</summary></b>

问题说明：
在 ie 下如果为 li 指定高度可能会出现排版错位

解决方法：
设置 line-height

[参与互动](https://github.com/yisainan/web-interview/issues/916)

</details>

<b><details><summary>55. ul 或 li 浮动后，显示在 div 外</summary></b>

问题说明：
div 中的 ul 或 li 设置 float 以后，都不在 div 中

解决方法：
必须在 ul 标签后加 `<div style="clear:both"></div>` 来闭合外层 div

[参与互动](https://github.com/yisainan/web-interview/issues/917)

</details>

<b><details><summary>56. ul 浮动后，margin 变大</summary></b>

问题说明：
ul 设置 float 后，在 ie 中 margin 将变大

解决方法：
设置 ul 的 `display:inline` ，li 的 `list-style-position:outside`

[参与互动](https://github.com/yisainan/web-interview/issues/918)

</details>

<b><details><summary>57. li 浮动后，margin 变大</summary></b>

问题说明：
li 设置 float 后，在 ie 中 margin 将变大

解决方法：
设置 li 的 display:inline

[参与互动](https://github.com/yisainan/web-interview/issues/919)

</details>

<b><details><summary>58. 嵌套使用 ul、li 的问题</summary></b>

问题说明：
ie 的 bug，嵌套使用 ul、li 时，里层的 li 设置 float 以后，外层 li 不设置 float, 里面的 ul 顶部和它外面的 li 总是有一段间距

解决方法：
设置里面的 ul 的 zoom:1

[参与互动](https://github.com/yisainan/web-interview/issues/920)

</details>

<b><details><summary>59. IE6-7 li 底部有 3px 的问题</summary></b>

问题说明：
这个 bug 产生的充要条件是 li 的子元素浮动并且 li 设置了以下 CSS 属性之一：width、height、zoom、padding-top、padding-bottom、margin-top、margin-bottom。

解决方法：

    1、div 设置 clear:left|both，这时 li 不能设置 width、height、zoom。
    2、li 设置 float:left，这时 li 可以设置 width、height、zoom。
    3、li 设置 clear:left|both，这时 li 不能设置 width、height、zoom。
    4、IE6/IE7 的这个 Bug 可以通过给 li 中的 div 设置 vertical-align:top|middle|bottom 解决。

[参与互动](https://github.com/yisainan/web-interview/issues/921)

</details>

<b><details><summary>60. IE6 垂直列表间隙的问题</summary></b>

问题说明：
li 中有 a 且设置 display:block 时，ie6 中列表间会出现空隙

解决方法：

    1、li 中加 display:inline;
    2、li 使用 float 然后 clear:both;
    3、给包含的文本末尾添加一个空格
    4、设置 width

[参与互动](https://github.com/yisainan/web-interview/issues/922)

</details>

<b><details><summary>61. IE6 列表背景颜色失效的问题</summary></b>

问题说明：
当父元素设置 position:relative; 时，在 ie6 中第一个 ul、ol、dl 的背景颜色失效

解决方法：
ul、ol、dl 都设置为 position:relative; 

[参与互动](https://github.com/yisainan/web-interview/issues/923)

</details>

<b><details><summary>62. IE6-7 列表背景颜色失效的问题</summary></b>

问题说明：
做横向导航栏时，ul 设置为 float 且有背景色，li 设置为 float。ie6-7 背景颜色失效

解决方法：
很多 ie 的 bug 都可以通过触发 layout 来解决 ul 添加属性
1、height:1%; 
2、float:left; 
3、zoom:1; 

[参与互动](https://github.com/yisainan/web-interview/issues/924)

</details>

<b><details><summary>63. 列表不能换行的问题</summary></b>

问题说明：
li 设置为浮动，后面的 li 紧随其后，不能换行

解决方法：
1、为这个 ul 定义合适的宽高
2、给包含这个 ul 的父 div 定义合适的宽高。

[参与互动](https://github.com/yisainan/web-interview/issues/925)

</details>

<b><details><summary>64. li 中的内容以省略号显示</summary></b>

问题说明：
li 中内容超过长度时，想以省略号显示， 此方法适用于 ie6-7-8、opera、safari 浏览器、ff 浏览器不支持

解决方法：

```css
li {
    width: 200px;
    white - space: nowrap;
    text - overflow: ellipsis;
    - o - text - overflow: ellipsis;
    overflow: hidden;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/926)

</details>

<b><details><summary>65. 超链接访问过后 hover 样式不出现的问题</summary></b>

问题说明：
点击超链接后，hover、active 样式没有效果

解决方法：
改变 CSS 属性的排列顺序: L-V-H-A

[参与互动](https://github.com/yisainan/web-interview/issues/927)

</details>

<b><details><summary>66. 禁用中文输入法的问题</summary></b>

问题说明：
不能在输入框中输入汉字

解决方法：
只在 ie 系列和 ff 中有效
`ime-mode:disabled` (但可以粘贴)
禁用粘贴：
 `onpaste="return false"`

[参与互动](https://github.com/yisainan/web-interview/issues/928)

</details>

<b><details><summary>67. 除去滚动条的问题</summary></b>

问题说明：
隐藏滚动条

解决方法：
1、只有 ie6-7 支持 `<body scroll="no">`

2、除 ie6-7 不支持 `body{overflow:hidden}`

 3、所有浏览器 `html{overflow:hidden}`

[参与互动](https://github.com/yisainan/web-interview/issues/929)

</details>

<b><details><summary>68. 让层显示在 FLASH 之上</summary></b>

问题说明：
想让层的内容显示在 flash 上

解决方法：
把 FLASH 设置透明
1、 `<param name=" wmode " value="transparent" />`

2、 `<param name="wmode" value="opaque"/>`

[参与互动](https://github.com/yisainan/web-interview/issues/930)

</details>

<b><details><summary>69. 去除链接虚线边框的问题</summary></b>

问题说明：
当点击超链接后，ie6/7/8 ff 会出现虚线边框 , 而 opera、safari 没有虚线边框

解决方法：
ie6/7 中 设置为 a {blr:expression_r(this.onFocus=this.blur()) }
ie8 和 ff 都不支持 expression 在 ie8 、ff 中设置为 :focus { outline: none; }

[参与互动](https://github.com/yisainan/web-interview/issues/931)

</details>

<b><details><summary>70. IE6 背景闪烁的问题</summary></b>

问题说明：
链接、按钮用 CSS sprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是: IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载

解决方法：
可以用 JavaScript 设置 ie6 缓存这些图片：
document.execCommand("BackgroundImageCache", false, true); 

[参与互动](https://github.com/yisainan/web-interview/issues/932)

</details>

<b><details><summary>71. 出现重复文字的问题</summary></b>

问题说明：

```html
    <div style="width:400px">
        <div style="float:left"></div>
        <!– _ –>
            <div style="float:right;width:400px">↓这就是多出来的那只猪</div>
    </div>
```

解决方法：

    1、改变结构，不出现【一个容器包含2两个具有“float"样式的子容器】的结构。
    2、减小第二个容器的宽度，使父容器宽度减去第二个容器宽度的值大于3
    3、去掉所有的注释。
    4、修正注释的写法。<!--[if!IE]>这里是注释内容<![endif]-->
    5、在第二个容器后面加一个或者多个<divstyle="clear"></div>来解决。

[参与互动](https://github.com/yisainan/web-interview/issues/933)

</details>

<b><details><summary>72. ff、chrome 绝对定位无效</summary></b>

问题说明：

    在 IE 给 td 设置 position:relative，然后给它包含的一个容器使用 position:absolute 进行定位是有效的，但在 FF 和 Chrome 下却不可以。

解决方法：

    设置 td 的 display:block。

[参与互动](https://github.com/yisainan/web-interview/issues/934)

</details>

<b><details><summary>73. 子容器宽度大于父容器宽度时，内容超出</summary></b>

问题说明：

    子 DIV 的宽度和父 DIV 的宽度都已经定义，在 IE6 中如果其子 DIV 的宽度大于父 DIV 的宽度，父 DIV 的宽度将会被扩展，在其他浏览器中父 DIV 的宽度将不会扩展，子 DIV 将超出父 DIV

解决方法：

    设置 overflow:hidden，子 DIV 将不会超出父 DIV。

[参与互动](https://github.com/yisainan/web-interview/issues/935)

</details>

<b><details><summary>74. float 的 div 闭合的问题</summary></b>

问题说明：

```
    例如：<div id="floatA" ><div id="floatB" ><div id="NOTfloatC" >这里的 NOTfloatC 并不希望继续平移，而是希望往下排。(其中 floatA、floatB 的属性已经设置为 float:left;)
    这段代码在 IE 中毫无问题，问题出在其他浏览器中。原因是 NOTfloatC 并非 float 标签，必须将 float 标签闭合。
```

解决方法：

```
    在 <#div class="floatB"> <#div class="NOTfloatC">之间加上 <#div class="clear">这个 div 一定要注意位置，而且必须与两个具有 float 属性的 div 同级，之间不能存在嵌套关系，否则会产生异常。并且将 clear 这种样式定义为为如下即可：.clear{ clear:both;}
```

[参与互动](https://github.com/yisainan/web-interview/issues/936)

</details>

<b><details><summary>75. 单选框、复选框与后面的文字对不齐</summary></b>

问题说明：
单选框、复选框与后面的文字对不齐。

解决方法：

```css
    .align {
        font-size: 12px;
    }

    .align input {
        display: block;
        float: left;
    }

    .align label {
        display: block;
        float: left;
        padding-top: 3px;
        padding-top: 5px;
    }
```

需注意的问题说明：

1. 设置 padding 后高度和宽带都会增加
   说明：
   除了 ie5.5，其他所有浏览器中，设置 padding 以后高度和宽带都会增加
2. 使用 XHTML 1.0Transitional 后，div 宽度
   说明：
   在使用 XHTML 1.0Transitional 以后 div 宽度都不包含 border 的宽度了，设置宽度的时候需要注意下。
3. 外层相对定位，内层绝对定位
   说明：
   ie6 下，外层 div 的 postion:relative，并设置 text-align，内层 div 的 postion: absolute，这时内层的位置是相对于 text-align 而言的
   例如：

```html
<div style="position:relative;border:1px solid orange;text-align:center;zoom:1">
    position:relative
    <div style="position:absolute;top:0;left:0;background:#CCC;">
        position:absolute
    </div>
</div>
```

[参与互动](https://github.com/yisainan/web-interview/issues/937)

</details>

<b><details><summary>76. 如何禁止保存或拷贝图像（IOS）</summary></b>

通常当你在手机或者 pad 上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：

img { -webkit-touch-callout: none; }

</details>

<b><details><summary>77. 模拟按钮 hover 效果</summary></b>

```
移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，

<html>

<head>

<meta charset="utf-8">

<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">

<meta content="yes" name="apple-mobile-web-app-capable">

<meta content="black" name="apple-mobile-web-app-status-bar-style">

<meta content="telephone=no" name="format-detection">

<meta content="email=no" name="format-detection">

<style type="text/css">

a{-webkit-tap-highlight-color: rgba(0,0,0,0);}

.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}

.btn-blue:active{background-color: #357AE8;}

</style>

</head>

<body>

<div class="btn-blue">按钮</div>

<script type="text/javascript">

document.addEventListener("touchstart", function(){}, true)

</script>

</body>

</html>

兼容性ios5+、部分android 4+、winphone 8

要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名。

<html>

<head>

<meta charset="utf-8">

<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">

<meta content="yes" name="apple-mobile-web-app-capable">

<meta content="black" name="apple-mobile-web-app-status-bar-style">

<meta content="telephone=no" name="format-detection">

<meta content="email=no" name="format-detection">

<style type="text/css">

a{-webkit-tap-highlight-color: rgba(0,0,0,0);}

.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}

.btn-blue-on{background-color: #357AE8;}

</style>

</head>

<body>

<div class="btn-blue">按钮</div>

<script type="text/javascript">

var btnBlue = document.querySelector(".btn-blue");

btnBlue.ontouchstart = function(){

    this.className = "btn-blue btn-blue-on"

}

btnBlue.ontouchend = function(){

    this.className = "btn-blue"

}

</script>

</body>

</html>
```

</details>

<b><details><summary>78. 屏幕旋转的事件和样式事件</summary></b>

```
window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；

window.onorientationchange = function(){

            switch(window.orientation){

                case -90:

                case 90:

                alert("横屏:" + window.orientation);

                case 0:

                case 180:

                alert("竖屏:" + window.orientation);

                break;

            }

}

样式

//竖屏时使用的样式

@media all and (orientation:portrait) {

    .css{}

}

//横屏时使用的样式

@media all and (orientation:landscape) {

    .css{}

}
```

</details>

<b><details><summary>79.audio 元素和 video 元素在 ios 和 andriod 中无法自动播放</summary></b>

应对方案：触屏即播

\$(‘html').one(‘touchstart', function(){

    audio.play()

})

</details>

<b><details><summary>80. 摇一摇功能</summary></b>

HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。

</details>

<b><details><summary>81. 手机拍照和上传图片</summary></b>

```
<input type="file">的accept 属性

<!– 选择照片 –>

<input type=file accept="image/*">

<!– 选择视频 –>

<input type=file accept="video/*">

使用总结：

· iOS有拍照、录像、选取本地图片功能

· 部分android只有选取本地图片功能

· winphone不支持

· input控件默认外观丑陋
```

</details>

<b><details><summary>82. 消除 transition 闪屏</summary></b>

```
.css{

    /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/

    -webkit-transform-style: preserve-3d;

    /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/

    -webkit-backface-visibility: hidden;

}

开启硬件加速

· 解决页面闪白

· 保证动画流畅

  .css {

     -webkit-transform: translate3d(0, 0, 0);

     -moz-transform: translate3d(0, 0, 0);

     -ms-transform: translate3d(0, 0, 0);

     transform: translate3d(0, 0, 0);

  }

设计高性能CSS3动画的几个要素

· 尽可能地使用合成属性transform和opacity来设计CSS3动画

· 不使用position的left和top来定位

· 利用translate3D开启GPU加速
```

</details>

<b><details><summary>83. android 上去掉语音输入按钮</summary></b>

input::-webkit-input-speech-button {display: none}

</details>

<b><details><summary>84. 移动端 HTML5 audio autoplay 失效问题</summary></b>

</details>

<b><details><summary>85. 不同浏览器的标签默认外补丁 margin 和内补丁 padding 不同</summary></b>

发生概率：100%

解决方案：使用 CSS 通配符\*，设置内外补丁为 0

\*{ margin: 0; padding: 0; }

</details>

<b><details><summary>86. 块属性标签 float 之后，又有横向的 margin 值，在 IE6 中显示会比设置的大（IE6 双边距 bug）</summary></b>

发生概率：90%

解决方案：在 float 标签样式控制中加入 display:inline; 

</details>

<b><details><summary>87. 设置较小的高度标签（一般小于 10px），在 IE6，IE7，遨游中超出自己设置的高度</summary></b>

发生概率：60%

解决方案：给超出高度的标签设置 overflow:hidden; 或者设置行高 line-height 小于你设置的高度。

</details>

<b><details><summary>88. 行内标签设置 display:block; 后又采用 float 布局，再设置横向 margin 值时，在 IE6 中显示会比设置的大（IE6 双边距 bug）</summary></b>

发生���率：20%

解决方案：在 display:block; 后面加上 display:inline; display:table; 

</details>

<b><details><summary>89. 图片默认有间距</summary></b>

发生概率：20%

解决方案：使用 float 为 img 布局

</details>

<b><details><summary>90. 标签最低高度设置 min-height 不兼容</summary></b>

发生概率：5%

解决方案：例如要设置一个标签的最小高度为 200px

{ min-height: 200px; 

height: auto!important; 

height: 200px; 

overflow: visible; }

</details>

<b><details><summary>91. 透明度兼容设置</summary></b>

发生概率：主要看你要写的东西设不设透明度

解决方案：一句话

transparent_class {

    filter:alpha(opacity=50);

       -moz-opacity:0.5;

       -khtml-opacity: 0.5;

       opacity: 0.5;

}

opacity:0.5; This is the “most important" one because it is the currentstandard in CSS. This will work in most versions of Firefox, Safari, andOpera. This would be all you need if all browsers supported current standards. Which, of course, they don't.

filter:alpha(opacity=50); This one you need for IE.

-moz-opacity:0.5; You need this one to support way old school versions of theMozilla browsers like Netscape Navigator.

-khtml-opacity:0.5; This is for way old versions of Safari (1.x) when therendering engine it was using was still referred to as KTHML, asopposed to thecurrent WebKit .

</details>

<b><details><summary>92. Box Model 的 bug</summary></b>

描述：给一个元素设置了高度和宽度的同时，还为其设置 margin 和 padding 的值，会改变该元素的实际大小。

解决办法：在需要加 margin 和 padding 的 div 内部加一个 div, 在这个 div 里设置 margin 和 padding 值。

</details>

<b><details><summary>93. IE6 中的列表 li 楼梯状 bug</summary></b>

描述：通常在 li 中的元素（比如 a）设置了浮动 float，但 li 本身不浮动。

解决办法：

ul li{float:left; }

或 ul li{display:inline; }

</details>

<b><details><summary>94.li 空白间距</summary></b>

描述：在 IE 下，会增加 li 和 li 之间的垂直间距

解决办法：给 li 里的 a 显式的添加宽度或者高度

li a{width:20px; }

或者

li a{display:block; float:left; clear:left; }

或者

li {display:inline; }

li a{display:block; }

或者

在每个列表 li 上设置一个实线的底边，颜色和 li 的背景色相同

</details>

<b><details><summary>95.overflow：auto; 和 position:relative 的碰撞</summary></b>

描述：此 bug 只出现在 IE6 和 IE7 中，有两个块级元素，父元素设置了 overflow：auto; 子元素设置了 position:relative; 且高度大于父元素，在 IE6-7 中子元素不会被隐藏而是溢出。

解决方案：给父元素也设置 position:relative; 

</details>

<b><details><summary>96. 浮动层的错位</summary></b>

描述：当内容超出外包容器定义的宽度时会导致浮动层错位问题。在 Firefox、IE7、IE8 及其他标准浏览器里, 超出的内容仅仅只是超出边缘; 但在 IE6 中容器会忽视定义的 width 值, 宽度会错误地随内容宽度增长而增长。如果在这个浮动元素之后还跟着一个浮动元素, 那么就会导致错位问题。

解决方案：overflow：hidden; 

</details>

<b><details><summary>97. IE6 克隆文本的 bug</summary></b>

描述：若你的代码结构如下

<!--这是注释-->

    <div>

       ……

   </div>

<!--这是注释-->

很有可能在 IE6 网页上出现一段空白文本

解决方案：

使用条件注释

删除所有注释

在注释前面的那个浮动元素加上 display：inline；

</details>

<b><details><summary>98. IE 的图片缩放</summary></b>

描述：图片在 IE 下缩放有时会影响其质量

解决方案：img{ -mg-interpolation-mode:bicubic; }

</details>

<b><details><summary>99. IE6 下 png 图片的透明 bug</summary></b>

描述：使用透明图片, 使用 png24 或 png32 图片在 IE6 下面显示图片会有一层淡蓝色的背景。

解决方案：

```css
.img {

    background: url('http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png');

    _background: 0;

    _filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png', sizingMethod='scale');

}

img {
    filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png', sizingMethod='scale');
}

或 <imgsrc="test.png"width="247"height="216"style="filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');"alt=""/>
```

</details>

<b><details><summary>100. `<iframe>` 透明背景 bug</summary></b>

描述：在 IE 浏览器中，<iframe>框架不会自动把背景设为透明

解决方案：

<iframesrc="content.html"allowTransparency="true"></iframe>

在 iframe 调用的 content.html 页面中设置

body{background-color: transparent; }

</details>

<b><details><summary>101. 禁用 IE 默认的垂直滚动条</summary></b>

解决方案：

html{

overflow:auto; 

}

</details>

<b><details><summary>102. 默认的内外边距不同</summary></b>

问题说明：

各个浏览器默认的内外边距不同

解决方案：

\*{margin:0; padding:0; }

</details>

<b><details><summary>103. 水平居中的问题</summary></b>

问题说明：

* 设置 text-align: center
* ie6-7 文本居中，嵌套的块元素也会居中
* ff /opera /safari /ie8 文本会居中，嵌套块不会居中
  解决方法：
* 块元素设置
* 1、margin-left:auto; margin-right:auto
* 2、margin:0 auto; 
* 3、<div align="center"></div>

</details>

<b><details><summary>104. 垂直居中的问题</summary></b>

问题说明：
在浏览器中想要垂直居中，设置 vertical-align:middle; 不起作用。例如：ie6 下文本与文本输入框对不齐，需设置 vertical-align:middle，但是文本框的内容不会垂直居中

解决方法：
给容器设置一个与其高度相同的行高
line-height: 与容器的 height 一样

</details>

<b><details><summary>105. `&nbsp;` 显示的大小不一致</summary></b>

说明：
默认字本显示问题，导致&nbsp; 显示的大小不一致，在 ie 下比较小一点，其他的浏览器都一致，当你使用了&nbsp; 造成问题时请注意。

</details>

<b><details><summary>106. 边框重叠说明</summary></b>

说明：
为 table、td 都指定了边框后，然后使用 border-collapse:collapse 让边框重叠，可以看出在发生重叠时，Firefox 是用 td 覆盖 table 的，而 IE 是用 table 覆盖 td 的。使用时候需要注意。

</details>

<b><details><summary>107. 设置 td padding 的说明</summary></b>

说明：
设置 td 的 padding 以后高度和宽带都会增加, padding-left 和 padding-right 的效果都一样增加了 td 的宽带，但是 padding-top 和 padding-bottom 的效果不一样。最好不要使用 td 的 padding-top 和 padding-bottom

</details>

<b><details><summary>108. ul 设置的说明</summary></b>

说明：
ul 一般设置：list-style-type:none; margin:0px; padding:0px；li 一般设置：list-style-type:none; list-style-position:outside

</details>

<b><details><summary>109. 使一个层垂直居中于浏览器中</summary></b>

说明：
使用百分比绝对定位, 与外补丁负值的技巧, 负值的大小为其自身宽度高度除以二
div {
position:absolute; top:50%; lef:50%; margin:-100px 0 0 -100px; 
width:200px; height:200px; border:1px solidred; 
}

</details>

<b><details><summary>110. 触发 layout</summary></b>

    说明：
    IE6 中很多 Bug 都可以通过触发 layout 得到解决.下列的 CSS 属性或取值会让一个元素获得 layout：
    position:absolute 绝对定位元素的包含区块(containingblock)就会经常在这一方面出问题
    float:left|right 由于 layout 元素的特性，浮动模型会有很多怪异的表现
    display:inline-block 当一个内联级别的元素需要 layout 的时候就往往符用到它，这也可能也是这个 CSS 属性的唯一效果----让某个元素有 layout
    width: 除 auto 外的任何值
    height: 除 auto 外的任何值
    zoom: 除 auto 外的任何值

11、如何使连续长字段自动换行
ff 最新版本 word-wrap:break-word; 就可以了
ff 旧版本 还要使用 javascript 完成文字换行

```
<style type="text/css">
div {
      width:300px;
      word-wrap:break-word;
      border:1px solid red;
       }
</style>

<scripttype="text/javascript">
function toBreakWord(intLen){
varobj=document.getElementByIdx_x("ff");
var strContent=obj.innerHTML;
var strTemp="";
while(strContent.length>intLen){
strTemp+=strContent.substr(0,intLen)+"&#10;";
strContent=strContent.substr(intLen,strContent.length);
}
strTemp+="&#10;"+strContent;
obj.innerHTML=strTemp;
}
if(document.getElementByIdx_x &&  !document.all)  toBreakWord(37)
```

</details>

<b><details><summary>111. 设置滚动条颜色 只对 ie 系列有效 在 html 中 而不是设置 body</summary></b>

```
<style type="text/css">
html {
      scrollbar-face-color:#f6f6f6;
      scrollbar-highlight-color:#fff;
      scrollbar-shadow-color:#eeeeee;
      scrollbar-3dlight-color:#eeeeee;
      scrollbar-arrow-color:#000;
      scrollbar-track-color:#fff;
      scrollbar-darkshadow-color:#fff;
       }
</style>
```

IE 不支持 float：inherit overflow:hidden 有 2 个用法，一个是隐藏溢出，另一个是清除浮动。

```
<div>, <p>, <h1>,<form>, <ul> 和 <li>是块元素的例子
<span>, <a>, <label>,<input>, <img>, <strong> 和<em>是inline元素
<body oncontextmenu="returnfalse" ondragstart="return false"  tstart="returnfalse"  scroll="auto">
这行代码放在body中，去掉了页面鼠标右键快捷菜单，达到防止图片另存为的目的。
```

</details>

<b><details><summary>112. 集合类对象问题</summary></b>

问题说明：
代码中许多集合类对象取用时使用()，IE 能接受，FF 不能
解决方法：
改用 [] 作为下标运算，例：
document.getElementsByName("inputName")(1) 改为 document.getElementsByName("inputName")[1]

</details>

<b><details><summary>113. window.event</summary></b>

问题说明：
使用 window.event 无法在 FF 上运行
解决方法：
FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通解决方法：
onMouseMove = "functionName(event)"
function functionName (e) {
e = e || window.event; 
......
}

</details>

<b><details><summary>114. HTML 对象的 id 作为对象名的问题</summary></b>

问题说明：
在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用，在 FF 中不能
解决方法：
使用对象变量时全部用标准的 getElementById("idName")

</details>

<b><details><summary>115. 用 idName 字符串取得对象的问题</summary></b>

问题说明：
在 IE 中，利用 eval_r("idName") 可以取得 id 为 idName 的 HTML 对象，在 FF 中不能
解决方法：
用 getElementById("idName") 代替 eval_r("idName")

</details>

<b><details><summary>116. 取得元素的属性</summary></b>

在 FF 中，自己定义的属性必须 getAttribute() 取得

</details>

<b><details><summary>117. 在 FF 中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes</summary></b>

    问题说明：
    childNodes 的下标的含义在 IE 和 FF 中不同，FF 的 childNodes 中会插入空白文本节点
    解决方法：
    可以通过 node.getElementsByTagName_r() 来回避这个问题
    问题说明：
    当 html 中节点缺失时，IE 和 FF 对 parentNode 的解释不同，例如：
    <form>
    <table>
    <input/>
    </table>
    </form>
    FF中 input.parentNode 的值为form，而IE中 input.parentNode 的值为空节点
    问题说明：
    FF中节点自己没有 removeNode 方法
    解决方法：
    必须使用如下方法 node.parentNode.removeChild(node)

</details>

<b><details><summary>118. body 对象</summary></b>

    FF 的 body 在 body 标签没有被浏览器完全读入之前就存在，而 IE 则必须在 body 完全被读入之后才存在
    这会产生在 IE 下，文档没有载入完时，在 body 上 appendChild 会出现空白页面的问题
    解决方法：
    一切在 body 上插入节点的动作，全部在 onload 后进行

</details>

<b><details><summary>119. url encoding</summary></b>

    问题说明：
    一般 FF 无法识别 js 中的&
    解决方法：
    在 js 中如果书写 url 就直接写&不要写&

</details>

<b><details><summary>120. nodeName 和 tagName 问题</summary></b>

    问题说明：
    在 FF 中，所有节点均有 nodeName 值，但 textNode 没有 tagName 值，在 IE 中，nodeName 的使用有问题
    解决方法：
    使用 tagName，但应检测其是否为空

</details>

<b><details><summary>121. 元素属性</summary></b>

    IE 下 input.type 属性为只读，但是 FF 下可以修改

</details>

<b><details><summary>122. document.getElementsByName() 和 document.all[name] 的问题</summary></b>

    问题说明：
    在 IE 中，getElementsByName()、document.all[name] 均不能用来取得 div 元素
    是否还有其它不能取的元素还不知道（这个问题还有争议，还在研究中）

</details>

<b><details><summary>123. 调用子框架或者其它框架中的元素的问题</summary></b>

    在 IE 中，可以用如下方法来取得子元素中的值
    document.getElementByIdx_x("frameName").(document.)elementName
    window.frames["frameName"].elementName
    在 FF 中则需要改成如下形式来执行，与 IE 兼容：
    window.frames["frameName"].contentWindow.document.elementName
    window.frames["frameName"].document.elementName

</details>

<b><details><summary>124. 对象宽高赋值问题</summary></b>

    问题说明：
    FireFox 中类似 obj.style.height = imgObj.height 的语句无效
    解决方法：
    统一使用 obj.style.height = imgObj.height + "px";

</details>

<b><details><summary>125. FORM 标签</summary></b>

这个标签在 IE 中, 将会自动 margin 一些边距, 而在 FF 中 margin 则是 0, 因此, 如果想显示一致, 所以最好在 css 中指定 margin 和 padding, 针对上面两个问题, 我的 css 中一般首先都使用这样的样式 ul, form{margin:0; padding:0; }。

</details>

<b><details><summary>126. 属性选择器(这个不能算是兼容, 是隐藏 css 的一个 bug)</summary></b>

p[id]{}div[id]{}

这个对于 IE6.0 和 IE6.0 以下的版本都隐藏, FF 和 OPera 作用. 属性选择器和子选择器还是有区别的, 子选择器的范围从形式来说缩小了, 属性选择器的范围比较大, 如 p[id]中, 所有 p 标签中有 id 的都是同样式的.

</details>

<b><details><summary>127. 为什么 FF 下文本无法撑开容器的高度</summary></b>

标准浏览器中固定高度值的容器是不会象 IE6 里那样被撑开的, 那我又想固定高度, 又想能被撑开需要怎样设置呢？办法就是去掉 height 设置 min-height:200px; 这里为了照顾不认识 min-height 的 IE6 可以这样定义:

{
height:auto!important; 
height:200px; 
min-height:200px; 
}

</details>

<b><details><summary>128. IE 和 FireFox 对空格的尺寸解释不同，FireFox 为 4px, IE 为 8px; </summary></b>

FireFox 对 div 与 div 之间的空格是忽略的，但是 IE 是处理的。因此在两个相邻 div 之间不要有空格跟回车，否则可能造成不同浏览间之间格式不正确，比如著名的 3px 偏差（多个 img 标签连着，然后定义 float: left; 结果在 firefox 里面正常，而 IE 里面显示的每个 img 都相隔了 3px。我把标签之间的空格都删除都没有作用。解决方法是在 img 外面套 li，并且对 li 定义 margin: 0; 避免方式：在必要的时候不要无视 list 标签）而且原因难以查明。

</details>

<b><details><summary>129. 条件注释</summary></b>

```
<link rel="stylesheet" type="text/css" href="css.css" />

<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="ie7.css" />
<![endif]-->

<!--[if lte IE 6]>
<link rel="stylesheet" type="text/css" href="ie.css" />
<![endif]-->

lte -- 小于等于
lt  -- 小于
gte --  大于等于
gt  --  大于
！ --  不等于
```

</details>

<b><details><summary>130. 强制渲染</summary></b>

```
<meta http-equiv=X-UA-Compatible content=IE=EmulateIE7>    //这句话的意思是强制使用IE7模式来解析网页代码！

<meta http-equiv=“X-UA-Compatible" content=“IE=8″>

<meta http-equiv=“X-UA-Compatible" content=“chrome=1″ />    //Google Chrome Frame也可以让IE用上Chrome的引擎

<meta http-equiv=“X-UA-Compatible" content=“IE=EmulateIE7″><!– IE7 mode –> 或者 <meta http-equiv=“X-UA-Compatible" content=“IE=7″><!– IE7 mode –>       //强制IE8使用IE7模式来解析

<meta http-equiv=“X-UA-Compatible" content=“IE=6″><!– IE6 mode –>   <meta http-equiv=“X-UA-Compatible" content=“IE=5″><!– IE5 mode –>   //强制IE8使用IE6或IE5模式来解析

<meta http-equiv=“X-UA-Compatible" content=“IE=5; IE=8″ />   //一个特定版本的IE支持所要求的兼容性模式多于一种
```

</details>

<b><details><summary>131.js 兼容文件</summary></b>

```
使IE5,IE6兼容到IE7模式（推荐）

<!–[if lt IE 7]>
<script src="http://ie7-js.googlecode.com/svn/version/2.0(beta)/IE7.js" type="text/javascript"></script>
<![endif]–>
使IE5,IE6,IE7兼容到IE8模式

<!–[if lt IE 8]>
<script src="http://ie7-js.googlecode.com/svn/version/2.0(beta)/IE8.js" type="text/javascript"></script>
<![endif]–>
使IE5,IE6,IE7,IE8兼容到IE9模式

<!–[if lt IE 9]>
<script src="http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js"></script>
<![endif]–>
```

</details>

<b><details><summary>132. 浏览器识别符</summary></b>

p{ \_color:red; } IE6 专用
*html p{ color:#red; } IE6 专用
p{ +color:red; } IE6, 7 专用
p{ *color:red; } IE6, 7 专用
_html p{ color:red; } IE6, 7 专用
p{_+color: red; } IE7 专用
Body> p{ color: red; } 屏蔽 IE6
p{ color:red\9; } IE8

Firefox: -moz-
Safari: -webkit-
Opera: -o-
IE: -ms-

</details>

<b><details><summary>133. 添加到主屏后的标题（IOS）</summary></b>

```html
<meta name="apple-mobile-web-app-title" content="标题" />
```

</details>

<b><details><summary>134. 启用 WebApp</summary></b>

```
全屏模式（IOS）
当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）

<meta name="apple-mobile-web-app-capable" content="yes" />

<meta name="apple-touch-fullscreen" content="yes" />
```

</details>

<b><details><summary>135. 百度禁止转码</summary></b>

```
通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：

<meta http-equiv="Cache-Control" content="no-siteapp" />

百度SiteApp转码声明：http://t.cn/R28wSBl
```

</details>

<b><details><summary>136. 设置状态栏的背景颜色（IOS）</summary></b>

```
设置状态栏的背景颜色，只有在"apple-mobile-web-app-capable" content="yes"时生效

<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

content 参数：

· default ：状态栏背景是白色。

· black ：状态栏背景是黑色。

· black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。
如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。
```

</details>

<b><details><summary>137. 移动端手机号码识别（IOS）</summary></b>

```

在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：

· 7位数字，形如：1234567

· 带括号及加号的数字，形如：(+86)123456789

· 双连接线的数字，形如：00-00-00111

· 11位数字，形如：13800138000

可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：

<meta name="format-detection" content="telephone=no" />

开启电话功能

<a href="tel:123456">123456</a>

开启短信功能：

<a href="sms:123456">123456</a>
```

</details>

<b><details><summary>138. 移动端邮箱识别（Android）</summary></b>

```
与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：

<meta content="email=no" name="format-detection" />

同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：

<a mailto:dooyoe@gmail.com">dooyoe@gmail.com</a>
```

</details>

<b><details><summary>139. 添加智能 App</summary></b>

```
广告条 Smart App Banner（IOS 6+ Safari）
<meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">
```

</details>

<b><details><summary>140. IOS Web app 启动动画</summary></b>

```
由于iPad 的启动画面是不包括状态栏区域的。所以启动图片需要减去状态栏区域所对应的方向上的20px大小，相应地在retina设备上要减去40px的大小。

<link href="apple-touch-startup-image-320×460.png" media="(device-width: 320px)" rel="apple-touch-startup-image">

<link href="apple-touch-startup-image-640×960.png" media="(device-width: 320px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image">

<link href="apple-touch-startup-image-768×1004.png" media="(device-width: 768px) and (orientation: portrait)" rel="apple-touch-startup-image">

<link href="apple-touch-startup-image-748×1024.png" media="(device-width: 768px) and (orientation: landscape)" rel="apple-touch-startup-image">

<link href="apple-touch-startup-image-1536×2008.png" media="(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image">

<link href="apple-touch-startup-image-2048×1496.png" media="(device-width: 1536px)  and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image">

（landscape：横屏 | portrait：竖屏）
```

</details>

<b><details><summary>141. 添加到主屏后的 APP 图标</summary></b>

```
指定web app添加到主屏后的图标路径，有两种略微不同的方式：

<!– 设计原图 –>

<link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed">

<!– 添加高光效果 –>

<link href="short_cut_114x114.png" rel="apple-touch-icon">

· apple-touch-icon：在IOS6及以下的版本会自动为图标添加一层高光效果（IOS7开始已使用扁平化的设计风格）

· apple-touch-icon-precomposed：使用“设计原图图标"

效果：

图标尺寸：

可通过指定size属性来为不同的设备提供不同的图标（但通常来说，我们只需提供一个114 x 114 pixels大小的图标即可 ）

官方说明如下：

Create different sizes of your app icon for different devices. If you're creating a universal app, you need to supply app

icons in all four sizes.

For iPhone and iPod touch both of these sizes are required:

57 x 57 pixels

114 x 114 pixels (high resolution)

For iPad, both of these sizes are required:

72 x 72 pixels

144 x 144 (high resolution)
```

</details>

<b><details><summary>142. 优先使用最新版本 IE 和 Chrome</summary></b>

```
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
```

</details>

<b><details><summary>143.viewport 模板</summary></b>

```
<html>

<head>

<meta charset="utf-8">

<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">

<meta content="yes" name="apple-mobile-web-app-capable">

<meta content="black" name="apple-mobile-web-app-status-bar-style">

<meta content="telephone=no" name="format-detection">

<meta content="email=no" name="format-detection">

<title>标题</title>

<link rel="stylesheet" href="index.css">

</head>

<body>

这里开始内容

</body>

</html>
```

</details>

<b><details><summary>144. 移动端如何定义字体 font-family</summary></b>

```
三大手机系统的字体：

iOS 系统

· 默认中文字体是Heiti SC

· 默认英文字体是Helvetica

· 默认数字字体是HelveticaNeue

· 无微软雅黑字体

Android 系统

· 默认中文字体是Droidsansfallback

· 默认英文和数字字体是Droid Sans

· 无微软雅黑字体

Winphone 系统

· 默认中文字体是Dengxian(方正等线体)

· 默认英文和数字字体是Segoe

· 无微软雅黑字体

各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持。

* 移动端定义字体的代码 */

body{font-family:Helvetica;}
```

</details>

<b><details><summary>145. 移动端字体单位 font-size 选择 px 还是 rem</summary></b>

```
· 对于只需要适配手机设备，使用px即可

· 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备

rem配置参考：

html {font-size:10px}

@media screen and (min-width:480px) and (max-width:639px) {

    html {

        font-size: 15px

    }

}

@media screen and (min-width:640px) and (max-width:719px) {

    html {

        font-size: 20px

    }

}

@media screen and (min-width:720px) and (max-width:749px) {

    html {

        font-size: 22.5px

    }

}

@media screen and (min-width:750px) and (max-width:799px) {

    html {

        font-size: 23.5px

    }

}

@media screen and (min-width:800px) and (max-width:959px) {

    html {

        font-size: 25px

    }

}

@media screen and (min-width:960px) and (max-width:1079px) {

    html {

        font-size: 30px

    }

}

@media screen and (min-width:1080px) {

    html {

        font-size: 32px

    }

}
```

</details>

<b><details><summary>146. 移动端 touch 事件(区分 webkit 和 winphone)</summary></b>

```
当用户手指放在移动设备在屏幕上滑动会触发的touch事件

以下支持webkit

· touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指

· touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动

· touchend——当手指离开屏幕时触发

· touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用

以下支持winphone 8

· MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指

· MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action:
none;}可以阻止默认情况的发生：阻止页面滚动

· MSPointerUp——当手指离开屏幕时触发
```

</details>

<b><details><summary>147. 移动端 click 屏幕产生 200-300 ms 的延迟响应</summary></b>

```
移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。

以下是历史原因：

2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放 (double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速 双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。

双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。

原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是
单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则 浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有 多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说
是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。

解决方案：

· fastclick可以解决在手机上点击事件的300ms延迟

· zepto的touch模块，tap事件也是为了解决在click的延迟问题

触摸事件的响应顺序

1、ontouchstart

2、ontouchmove

3、ontouchend

4、onclick

解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应。
```

</details>

<b><details><summary>148. 什么是 Retina</summary></b>

```
显示屏，带来了什么问题
retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个

在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。

那么，前端的应对方案是：

设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2

//例如图片宽高为：200px*200px，那么写法如下

.css{width:100px;height:100px;background-size:100px 100px;}

其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px

.css{font-size:20px}
```

</details>

<b><details><summary>149.ios 系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</summary></b>

```
ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。

a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)}
```

</details>

<b><details><summary>150. 部分 android 系统中元素被点击时产生的边框怎么去掉</summary></b>

```
android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果。

a,button,input,textarea{

    -webkit-tap-highlight-color: rgba(0,0,0,0;)

    -webkit-user-modify:read-write-plaintext-only;

}

-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符。

另外，有些机型去除不了，如小米2

对于按钮类还有个办法，不使用a或者input标签，直接用div标签

```

</details>

<b><details><summary>151.winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉</summary></b>

```
<meta name="msapplication-tap-highlight" content="no">
```

</details>

<b><details><summary>152.webkit 表单元素的默认外观怎么重置</summary></b>

```
.css{-webkit-appearance:none;}
```

</details>

<b><details><summary>153.webkit 表单输入框 placeholder 的颜色值能改变么</summary></b>

```
input::-webkit-input-placeholder{color:#AAAAAA;}

input:focus::-webkit-input-placeholder{color:#E
```

</details>

<b><details><summary>154.webkit 表单输入框 placeholder 的文字能换行么</summary></b>

```
iOS可以，Android不行~

1. 关闭iOS键盘首字母自动大写

在iOS中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样：

<input type="text" autocapitalize="off" />
```

</details>

<b><details><summary>155. 关闭 iOS 输入自动修正</summary></b>

```
和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉：

<input type="text" autocorrect="off" />
```

</details>

<b><details><summary>156. 禁止文本缩放</summary></b>

```
当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：

html {

       -webkit-text-size-adjust: 100%;

}

需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport。
```

</details>

<b><details><summary>157. 移动端如何清除输入框内阴影</summary></b>

```
在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：

input,

textarea {

border: 0; /* 方法1 */

-webkit-appearance: none; /* 方法2 */

}

```

</details>

<b><details><summary>158. 快速回弹滚动</summary></b>

```
我们先来看看回弹滚动在手机浏览器发展的历史：

· 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll;

· Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动；

· Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除；

· iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果

在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：

 .xxx {

        overflow: auto; /* auto | scroll */

        -webkit-overflow-scrolling: touch;

    }

PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个 iDangero Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条。iDangero官方地址： :www.idangero.us/swiper/#.VX_t9PmEB8Y
```

</details>

<b><details><summary>159. 移动端禁止选中内容</summary></b>

```
如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：

.user-select-none {

  -webkit-user-select: none;  /* Chrome all / Safari all */

  -moz-user-select: none;     /* Firefox all （移动端不需要） */

  -ms-user-select: none;      /* IE 10+ */

}
```

</details>

<b><details><summary>160. 移动端取消 touch 高亮效果</summary></b>

在做移动端页面时，会发现所有 a 标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过 css 以下方法来进行全局的禁止：

html {

    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);

}

但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的 a 标签换成其它标签，可以解决这个问题。

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

> [转载自 Advanced-Frontend/Daily-Interview-Question](https://github.com/Advanced-Frontend/Daily-Interview-Question)

<b><details><summary>第 1 题：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</summary></b>

参考答案：key 是给每一个 vnode（虚拟节点）的唯一 id, 可以依靠 key, 更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。

1. 更准确
   因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。

2. 更快
   利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。

公司：滴滴、饿了么

解析：[第 1 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1)

</details>

<b><details><summary>第 2 题： `['1', '2', '3'].map(parseInt)` what & why ?</summary></b>

参考答案：[1, NaN, NaN]

* parseInt('1', 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1
* parseInt('2', 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN
* parseInt('3', 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN

解析：[第 2 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4)

</details>

<b><details><summary>第 3 题：什么是防抖和节流？有什么区别？如何实现？</summary></b>

参考答案：

1、防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间

举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。

节流(throttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率

举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现 bug。

2、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。

公司：挖财

解析：[第 3 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5)

</details>

<b><details><summary>第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</summary></b>

参考答案：

1、Set

* 成员唯一、无序且不重复；
* [value, value]，键值与键名是一致的（或者说只有键值，没有键名）；
* 可以遍历，方法有：add、delete、has、clear、entries、forEach、keys、values
* Set 也能用来保存 NaN 和 undefined， 如果有重复的 NaN， Set 会认为就一个 NaN(实际上 NaN!=NaN); 

2、Map

* 本质上是键值对的集合，类似集合；
* 可以遍历，方法很多，可以跟各种数据格式转换。

3、WeakSet

* 成员都是对象；
* 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；
* 不能遍历，方法有 add、delete、has。

4、WeakMap

* 只接受对象作为键名（null 除外），不接受其他类型的值作为键名；
* 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；
* 不能遍历，方法有 get、set、has、delete。

解析：[第 4 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/6)

</details>

<b><details><summary>第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？</summary></b>

参考答案：

1. 深度优先遍历就是一种不撞南墙不会头的算法，他会把一条路走完之后再回溯到有分叉的节点继续遍历
2. 广度优先搜索时，会从起点开始“一层一层”扩展的方法来遍历，扩展时每发现一个点就将这个点加入到队列，直到整张图都被遍历过位置

解析：[第 5 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9)

</details>

<b><details><summary>第 6 题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？</summary></b>

参考答案：

解析：[第 6 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10)

</details>

<b><details><summary>第 7 题：ES5/ES6 的继承除了写法以外还有什么区别？</summary></b>

参考答案：

1. class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。

```js
const bar = new Bar(); // it's ok
function Bar() {
    this.bar = 42;
}

const foo = new Foo(); // ReferenceError: Foo is not defined
class Foo {
    constructor() {
        this.foo = 42;
    }
}
```

2. class 声明内部会启用严格模式。

```js
// 引用一个未声明的变量
function Bar() {
    baz = 42; // it's ok
}
const bar = new Bar();

class Foo {
    constructor() {
        fol = 42; // ReferenceError: fol is not defined
    }
}
const foo = new Foo();
```

3. class 的所有方法（包括静态方法和实例方法）都是不可枚举的。

```js
// 引用一个未声明的变量
function Bar() {
    this.bar = 42;
}
Bar.answer = function() {
    return 42;
};
Bar.prototype.print = function() {
    console.log(this.bar);
};
const barKeys = Object.keys(Bar); // ['answer']
const barProtoKeys = Object.keys(Bar.prototype); // ['print']

class Foo {
    constructor() {
        this.foo = 42;
    }
    static answer() {
        return 42;
    }
    print() {
        console.log(this.foo);
    }
}
const fooKeys = Object.keys(Foo); // []
const fooProtoKeys = Object.keys(Foo.prototype); // []
```

4. class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。

```js
function Bar() {
    this.bar = 42;
}
Bar.prototype.print = function() {
    console.log(this.bar);
};

const bar = new Bar();
const barPrint = new bar.print(); // it's ok

class Foo {
    constructor() {
        this.foo = 42;
    }
    print() {
        console.log(this.foo);
    }
}
const foo = new Foo();
const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
```

5. 必须使用 new 调用 class。

```js
function Bar() {
    this.bar = 42;
}
const bar = Bar(); // it's ok

class Foo {
    constructor() {
        this.foo = 42;
    }
}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
```

6. class 内部无法重写类名。

```js
function Bar() {
    Bar = "Baz"; // it's ok
    this.bar = 42;
}
const bar = new Bar();
// Bar: 'Baz'
// bar: Bar {bar: 42}

class Foo {
    constructor() {
        this.foo = 42;
        Foo = "Fol"; // TypeError: Assignment to constant variable
    }
}
const foo = new Foo();
Foo = "Fol"; // it's ok
```

解析：[第 7 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20)

</details>

<b><details><summary>第 8 题：setTimeout、Promise、Async/Await 的区别</summary></b>

参考答案：

1. setTimeout

```js
console.log("script start"); //1. 打印 script start
setTimeout(function() {
    console.log("settimeout"); // 4. 打印 settimeout
}); // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数
console.log("script end"); //3. 打印 script end
// 输出顺序：script start->script end->settimeout
```

2. Promise

Promise 本身是同步的立即执行函数， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。

```js
console.log("script start");
let promise1 = new Promise(function(resolve) {
    console.log("promise1");
    resolve();
    console.log("promise1 end");
}).then(function() {
    console.log("promise2");
});
setTimeout(function() {
    console.log("settimeout");
});
console.log("script end");
// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout
```

当 JS 主线程执行到 Promise 对象时，

* promise1.then() 的回调就是一个 task

* promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue

* promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中

* setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况

3. async/await

```js
async function async1() {
    console.log("async1 start");
    await async2();
    console.log("async1 end");
}
async function async2() {
    console.log("async2");
}

console.log("script start");
async1();
console.log("script end");

// 输出顺序：script start->async1 start->async2->script end->async1 end
```

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

举个例子：

```js
async function func1() {
    return 1;
}

console.log(func1());
```

很显然，func1 的运行结果其实就是一个 Promise 对象。因此我们也可以使用 then 来处理后续逻辑。

```js
func1().then(res => {
    console.log(res); // 30
});
```

await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。

更多可见[setTimeout、Promise、Async/Await](https://github.com/sisterAn/blog/issues/21)

解析：[第 8 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33)

</details>

<b><details><summary>第 9 题：Async/Await 如何通过同步的方式实现异步</summary></b>

参考答案：

公司：头条、微医

解析：[第 9 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/156)

</details>

<b><details><summary>第 10 题：异步笔试题</summary></b>

> 请写出下面代码的运行结果

```js
async function async1() {
    console.log("async1 start");
    await async2();
    console.log("async1 end");
}
async function async2() {
    console.log("async2");
}
console.log("script start");
setTimeout(function() {
    console.log("setTimeout");
}, 0);
async1();
new Promise(function(resolve) {
    console.log("promise1");
    resolve();
}).then(function() {
    console.log("promise2");
});
console.log("script end");
```

公司：头条

参考答案：

```js
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// undefined
// setTimeout
```

解析：[第 10 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)

</details>

<b><details><summary>第 11 题：算法手写题</summary></b>

> 已知如下数组：
>
> var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 
>
> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

公司：携程

参考答案：

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
    return a - b;
});
```

拆解：

```js
arr.flat(Infinity); // 1.所有元素放到同一数组
//  [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
    return a - b;
}); // 2.去重及排序
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

解析：[第 11 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/8)

</details>

<b><details><summary>第 12 题：JS 异步解决方案的发展历程以及优缺点。</summary></b>

参考答案：

公司：滴滴、挖财、微医、海康

解析：[第 12 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11)

</details>

<b><details><summary>第 13 题：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</summary></b>

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    resolve();
    console.log(2);
});

promise.then(() => {
    console.log(3);
});

console.log(4);
```

执行结果是：1243
promise 构造函数是同步执行的，then 方法是异步执行的

参考答案：

公司：微医

解析：[第 13 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/19)

</details>

<b><details><summary>第 14 题：情人节福利题，如何实现一个 new</summary></b>

参考答案：

```js
// 实现一个new
var Dog = function(name) {
    this.name = name;
};
Dog.prototype.bark = function() {
    console.log("wangwang");
};
Dog.prototype.sayName = function() {
    console.log("my name is " + this.name);
};
let sanmao = new Dog("三毛");
sanmao.sayName();
sanmao.bark();
// new 的作用
// 创建一个新对象obj
// 把obj的__proto__指向Dog.prototype 实现继承
// 执行构造函数，传递参数，改变this指向 Dog.call(obj, ...args)
// 最后把obj赋值给sanmao
var _new = function() {
    let constructor = Array.prototype.shift.call(arguments);
    let args = arguments;
    const obj = new Object();
    obj.__proto__ = constructor.prototype;
    constructor.call(obj, ...args);
    return obj;
};
var simao = _new(Dog, "simao");
simao.bark();
simao.sayName();
console.log(simao instanceof Dog); // true
```

公司：兑吧

解析：[第 14 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/12)

</details>

<b><details><summary>第 15 题：简单讲解一下 http2 的多路复用</summary></b>

参考答案：

HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。

多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。
HTTP2 中

* 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
* 单个连接上可以并行交错的请求和响应，之间互不干扰

公司：网易

解析：[第 15 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14)

</details>

<b><details><summary>第 16 题：谈谈你对 TCP 三次握手和四次挥手的理解</summary></b>

参考答案：

解析：[第 16 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15)

</details>

<b><details><summary>第 17 题：A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态</summary></b>

参考答案：

> 如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）

解析：[第 17 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/21)

</details>

<b><details><summary>第 18 题：React 中 setState 什么时候是同步的，什么时候是异步的？</summary></b>

参考答案：
公司：微医

解析：[第 18 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/17)

</details>

<b><details><summary>第 19 题：React setState 笔试题，下面的代码输出什么？</summary></b>

参考答案：

```js
class Example extends React.Component {
    constructor() {
        super();
        this.state = {
            val: 0
        };
    }

    componentDidMount() {
        this.setState({
            val: this.state.val + 1
        });
        console.log(this.state.val); // 第 1 次 log

        this.setState({
            val: this.state.val + 1
        });
        console.log(this.state.val); // 第 2 次 log

        setTimeout(() => {
            this.setState({
                val: this.state.val + 1
            });
            console.log(this.state.val); // 第 3 次 log

            this.setState({
                val: this.state.val + 1
            });
            console.log(this.state.val); // 第 4 次 log
        }, 0);
    }

    render() {
        return null;
    }
}
```

解析：[第 19 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/18)

</details>

<b><details><summary>第 20 题：介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</summary></b>

参考答案：
解析：[第 20 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22)

</details>

<b><details><summary>第 21 题：有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</summary></b>

参考答案：

> Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

解析：[第 21 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23)

</details>

<b><details><summary>第 22 题：介绍下重绘和回流（Repaint & Reflow），以及如何进行优化</summary></b>

参考答案：
解析：[第 22 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24)

</details>

<b><details><summary>第 23 题：介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</summary></b>

参考答案：
解析：[第 23 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25)

</details>

<b><details><summary>第 24 题：聊聊 Redux 和 Vuex 的设计思想</summary></b>

参考答案：
解析：[第 24 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/45)

</details>

<b><details><summary>第 25 题：说说浏览器和 Node 事件循环的区别</summary></b>

参考答案：
解析：[第 25 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26)

</details>

<b><details><summary>第 26 题：介绍模块化发展历程</summary></b>

参考答案：

可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、 `<script type="module">` 这几个角度考虑。

解析：[第 26 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28)

</details>

<b><details><summary>第 27 题：全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？</summary></b>

参考答案：

解析：[第 27 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30)

</details>

<b><details><summary>第 28 题：cookie 和 token 都存放在 header 中，为什么不会劫持 token？</summary></b>

参考答案：

token不是为了防止XSS的，而是为了防止CSRF的；

CSRF攻击的原因是浏览器会自动带上cookie，而不会带上token；

cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。

token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。

xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。

csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。

上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。

以上面的 csrf 攻击为例：

cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。

token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。

解析：[第 28 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31)

</details>

<b><details><summary>第 29 题：聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的</summary></b>

参考答案：
解析：[第 29 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/34)

</details>

<b><details><summary>第 30 题：两个数组合并成一个数组</summary></b>

参考答案：
请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。

解析： [第 30 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39)

</details>

<b><details><summary>第 31 题：改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。</summary></b>

```js
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
```

参考答案：

```js
// 解法一：
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
// 解法二：
for (var i = 0; i < 10; i++) {
    (i => {
        setTimeout(() => {
            console.log(i);
        }, 1000);
    })(i);
}
```

解析：[第 31 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43)

</details>

<b><details><summary>第 32 题：Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。</summary></b>

参考答案：
解析：[第 32 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47)

</details>

<b><details><summary>第 33 题：下面的代码打印什么内容，为什么？</summary></b>

参考答案：

```js
var b = 10;
(function b() {
    b = 20;
    console.log(b);
})();
```

解析：[第 33 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/48)

</details>

<b><details><summary>第 34 题：简单改造下面的代码，使之分别打印 10 和 20。</summary></b>

参考答案：

```js
var b = 10;
(function b() {
    b = 20;
    console.log(b);
})();
```

解析：[第 34 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51)

</details>

<b><details><summary>第 35 题：浏览器缓存读取规则</summary></b>

参考答案：

可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？

解析：[第 35 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/53)

</details>

<b><details><summary>第 36 题：使用迭代的方式实现 flatten 函数。</summary></b>

参考答案：
解析：[第 36 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/54)

</details>

<b><details><summary>第 37 题：为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？</summary></b>

参考答案：
解析：[第 37 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/65)

</details>

<b><details><summary>第 38 题：下面代码中 a 在什么情况下会打印 1？</summary></b>

```js
var a = ? ;
if (a == 1 && a == 2 && a == 3) {
    console.log(1);
}
```

参考答案：

解析：[第 38 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/57)

公司：京东

</details>

<b><details><summary>第 39 题：介绍下 BFC 及其应用。</summary></b>

参考答案：
解析：[第 39 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/59)

</details>

<b><details><summary>第 40 题：在 Vue 中，子组件为何不可以修改父组件传递的 Prop</summary></b>

如果修改了，Vue 是如何监控到属性的修改并给出警告的。

参考答案：

解析：[第 40 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/60)

</details>

<b><details><summary>第 41 题：下面代码输出什么</summary></b>

```js
var a = 10;
(function() {
    console.log(a);
    a = 5;
    console.log(window.a);
    var a = 20;
    console.log(a);
})();
```

参考答案：

解析：[第 41 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/61)

</details>

<b><details><summary>第 42 题：实现一个 sleep 函数</summary></b>

比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现

参考答案：

解析：[第 42 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/63)

</details>

<b><details><summary>第 43 题：使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</summary></b>

参考答案：
解析：[第 43 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/66)

</details>

<b><details><summary>第 44 题：介绍 HTTPS 握手过程</summary></b>

参考答案：
解析：[第 44 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70)

</details>

<b><details><summary>第 45 题：HTTPS 握手过程中，客户端如何验证证书的合法性</summary></b>

参考答案：
解析：[第 45 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74)

</details>

<b><details><summary>第 46 题：输出以下代码执行的结果并解释为什么</summary></b>

```js
var obj = {
    "2": 3,
    "3": 4,
    length: 2,
    splice: Array.prototype.splice,
    push: Array.prototype.push
};
obj.push(1);
obj.push(2);
console.log(obj);
```

参考答案：

解析：[第 46 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/76)

</details>

<b><details><summary>第 47 题：双向绑定和 vuex 是否冲突</summary></b>

参考答案：
解析：[第 47 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/81)

</details>

<b><details><summary>第 48 题：call 和 apply 的区别是什么，哪个性能更好一些</summary></b>

参考答案：

解析：[第 48 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/84)

</details>

<b><details><summary>第 49 题：为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</summary></b>

参考答案：

解析：[第 49 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/87)

</details>

<b><details><summary>第 50 题：实现 (5).add(3).minus(2) 功能。</summary></b>

> 例： 5 + 3 - 2，结果为 6

公司：百度

参考答案：

解析：[第 50 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/88)

</details>

<b><details><summary>第 51 题：Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</summary></b>

为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？

参考答案：

解析：[第 51 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90)

</details>

<b><details><summary>第 52 题：怎么让一个 div 水平垂直居中</summary></b>

参考答案：

解析：[第 52 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92)

</details>

<b><details><summary>第 53 题：输出以下代码的执行结果并解释为什么</summary></b>

```js
var a = {
    n: 1
};
var b = a;
a.x = a = {
    n: 2
};

console.log(a.x);
console.log(b.x);
```

参考答案：

解析：[第 53 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/93)

</details>

<b><details><summary>第 54 题：冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？</summary></b>

参考答案：

解析：[第 54 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/94)

</details>

<b><details><summary>第 55 题：某公司 1 到 12 月份的销售额存在一个对象里面</summary></b>

如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。

参考答案：

解析：[第 55 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/96)

</details>

<b><details><summary>第 56 题：要求设计 LazyMan 类，实现以下功能。</summary></b>

```js
LazyMan("Tony");
// Hi I am Tony

LazyMan("Tony")
    .sleep(10)
    .eat("lunch");
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan("Tony")
    .eat("lunch")
    .sleep(10)
    .eat("dinner");
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan("Tony")
    .eat("lunch")
    .eat("dinner")
    .sleepFirst(5)
    .sleep(10)
    .eat("junk food");
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

参考答案：

解析：[第 56 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98)

</details>

<b><details><summary>第 57 题：分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</summary></b>

参考答案：

解析：[第 57 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100)

</details>

<b><details><summary>第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</summary></b>

参考答案：

解析：[第 58 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101)

</details>

<b><details><summary>第 59 题：给定两个数组，写一个方法来计算它们的交集。</summary></b>

> 例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。

参考答案：

解析：[第 59 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102)

</details>

<b><details><summary>第 60 题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。</summary></b>

> `<img src="1.jpg" style="width:480px!important; ”>`

参考答案：

解析：[第 60 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105)

</details>

<b><details><summary>第 61 题：介绍下如何实现 token 加密</summary></b>

参考答案：

解析：[第 61 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106)

</details>

<b><details><summary>第 62 题：redux 为什么要把 reducer 设计成纯函数</summary></b>

参考答案：

解析：[第 62 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/107)

</details>

<b><details><summary>第 63 题：如何设计实现无缝轮播</summary></b>

参考答案：

解析：[第 63 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108)

</details>

<b><details><summary>第 64 题：模拟实现一个 Promise.finally</summary></b>

参考答案：

解析：[第 64 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/109)

</details>

<b><details><summary>第 65 题： `a.b.c.d` 和 `a['b']['c']['d']` ，哪个性能更高？</summary></b>

参考答案：

解析：[第 65 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/111)

</details>

<b><details><summary>第 66 题：ES6 代码转成 ES5 代码的实现思路是什么</summary></b>

参考答案：

解析：[第 66 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/112)

</details>

<b><details><summary>第 67 题：数组编程题</summary></b>

随机生成一个长度为 10 的整数类型的数组，例如 `[2, 10, 3, 4, 5, 11, 10, 11, 20]` ，将其排列成一个新数组，要求新数组形式如下，例如 `[[2, 3, 4, 5], [10, 11], [20]]` 。

参考答案：

解析：[第 67 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/113)

</details>

<b><details><summary>第 68 题： 如何解决移动端 Retina 屏 1px 像素问题</summary></b>

参考答案：

解析：[第 68 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/115)

</details>

<b><details><summary>第 69 题： 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 。</summary></b>

参考答案：

解析：[第 69 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/116)

</details>

<b><details><summary>第 70 题： 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的</summary></b>

参考答案：

解析：[第 70 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/118)

</details>

<b><details><summary>第 71 题： 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</summary></b>

参考答案：

解析：[第 71 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/119)

</details>

<b><details><summary>第 72 题： 为什么普通 `for` 循环的性能远远高于 `forEach` 的性能，请解释其中的原因。</summary></b>

![image-20190512225510941](https://ws2.sinaimg.cn/large/006tNc79gy1g2yxbg4ta8j31gh0u048h.jpg)

参考答案：

解析：[第 72 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/121)

</details>

<b><details><summary>第 73 题： 介绍下 BFC、IFC、GFC 和 FFC</summary></b>

参考答案：

解析：[第 73 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122)

</details>

<b><details><summary>第 74 题： 使用 JavaScript Proxy 实现简单的数据绑定</summary></b>

参考答案：

解析：[第 74 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/123)

</details>

<b><details><summary>第 75 题：数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少</summary></b>

参考答案：

解析：[第 75 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/124)

</details>

<b><details><summary>第 76 题：输出以下代码运行结果</summary></b>

```js
// example 1
var a = {},
    b = '123',
    c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

-- -- -- -- -- -- -- -- -- -- -
// example 2
var a = {},
    b = Symbol('123'),
    c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

-- -- -- -- -- -- -- -- -- -- -
// example 3
var a = {},
    b = {
        key: '123'
    },
    c = {
        key: '456'
    };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

参考答案：

这题考察的是对象的键名的转换。

* 对象的键名只能是字符串和 Symbol 类型。
* 其他类型的键名会被转换成字符串类型。
* 对象转字符串默认会调用 toString 方法。

```js
// example 1
var a = {},
    b = "123",
    c = 123;
a[b] = "b";

// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。
a[c] = "c";

// 输出 c
console.log(a[b]);

// example 2
var a = {},
    b = Symbol("123"),
    c = Symbol("123");

// b 是 Symbol 类型，不需要转换。
a[b] = "b";

// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。
a[c] = "c";

// 输出 b
console.log(a[b]);

// example 3
var a = {},
    b = {
        key: "123"
    },
    c = {
        key: "456"
    };

// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
a[b] = "b";

// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。
a[c] = "c";

// 输出 c
console.log(a[b]);
```

解析：[第 76 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/125)

</details>

<b><details><summary>第 77 题：算法题「旋转数组」</summary></b>

> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1：

```js
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
    向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
```

示例 2：

```js
输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释:
    向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100]
```

参考答案：

解析：[第 77 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/126)

</details>

<b><details><summary>第 78 题：Vue 的父组件和子组件生命周期钩子执行顺序是什么</summary></b>

参考答案：

解析：[第 78 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/128)

</details>

<b><details><summary>第 79 题：input 搜索如何防抖，如何处理中文输入</summary></b>

参考答案：

解析：[第 79 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/129)

</details>

<b><details><summary>第 80 题：介绍下 Promise.all 使用、原理实现及错误处理</summary></b>

参考答案：

解析：[第 80 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/130)

</details>

<b><details><summary>第 81 题：打印出 1 - 10000 之间的所有对称数</summary></b>

> 例如：121、1331 等

参考答案：

解析：[第 81 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/131)

</details>

<b><details><summary>第 82 题：周一算法题之「移动零」</summary></b>

> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> 示例:
>
>  

```
> 输入: [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```

>
> 说明:
>
> 1. 必须在原数组上操作，不能拷贝额外的数组。
>
> 1. 尽量减少操作次数。

参考答案：

解析：[第 82 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/132)

</details>

<b><details><summary>第 83 题：var、let 和 const 区别的实现原理是什么</summary></b>

参考答案：

解析：[第 83 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133)

</details>

<b><details><summary>第 84 题：请实现一个 add 函数，满足以下功能。</summary></b>

参考答案：

>  

```js
> add(1); // 1
>
add(1)(2); // 3
>
add(1)(2)(3)； // 6
    >
    add(1)(2, 3); // 6
>
add(1, 2)(3); // 6
>
add(1, 2, 3); // 6
>
```

解析：[第 84 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/134)

</details>

<b><details><summary>第 85 题：react-router 里的 `<Link>` 标签和 `<a>` 标签有什么区别</summary></b>

> 如何禁掉 `<a>` 标签默认事件，禁掉之后如何实现跳转。

参考答案：

解析：[第 85 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/135)

</details>

<b><details><summary>第 86 题：周一算法题之「两数之和」</summary></b>

参考答案：
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种参考答案，且同样的元素不能被重复利用。

示例：

```js
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回[0, 1]
```

解析：[第 86 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/136)

公司：京东、快手

</details>

<b><details><summary>第 87 题：在输入框中如何判断输入的是一个正确的网址。</summary></b>

参考答案：
解析：[第 87 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/138)

</details>

<b><details><summary>第 88 题：实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度</summary></b>

参考答案：
以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：

```js
// 原始 list 如下
let list = [{
        id: 1,
        name: '部门A',
        parentId: 0
    },
    {
        id: 2,
        name: '部门B',
        parentId: 0
    },
    {
        id: 3,
        name: '部门C',
        parentId: 1
    },
    {
        id: 4,
        name: '部门D',
        parentId: 1
    },
    {
        id: 5,
        name: '部门E',
        parentId: 2
    },
    {
        id: 6,
        name: '部门F',
        parentId: 3
    },
    {
        id: 7,
        name: '部门G',
        parentId: 2
    },
    {
        id: 8,
        name: '部门H',
        parentId: 4
    }
];
const result = convert(list, ...);

// 转换后的结果如下
let result = [{
    id: 1,
    name: '部门A',
    parentId: 0,
    children: [{
            id: 3,
            name: '部门C',
            parentId: 1,
            children: [{
                id: 6,
                name: '部门F',
                parentId: 3
            }, {
                id: 16,
                name: '部门L',
                parentId: 3
            }]
        },
        {
            id: 4,
            name: '部门D',
            parentId: 1,
            children: [{
                id: 8,
                name: '部门H',
                parentId: 4
            }]
        }
    ]
}, ···];
```

解析：[第 88 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/139)

</details>

<b><details><summary>第 89 题：设计并实现 Promise.race()</summary></b>

参考答案：

```js
Promise._race = promises =>
    new Promise((resolve, reject) => {
        promises.forEach(promise => {
            promise.then(resolve, reject);
        });
    });
```

解析：[第 89 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/140)

</details>

<b><details><summary>第 90 题：实现模糊搜索结果的关键词高亮显示</summary></b>

参考答案：

考虑节流、缓存。其实还可以上列表 diff+定时清理缓存

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>auto complete</title>
  <style>
    bdi {
      color: rgb(0, 136, 255);
    }

    li {
      list-style: none;
    }
  </style>
</head>
<body>
  <input class="inp" type="text">
  <section>
    <ul class="container"></ul>
  </section>
</body>
<script>

  function debounce(fn, timeout = 300) {
    let t;
    return (...args) => {
      if (t) {
        clearTimeout(t);
      }
      t = setTimeout(() => {
        fn.apply(fn, args);
      }, timeout);
    }
  }

  function memorize(fn) {
    const cache = new Map();
    return (name) => {
      if (!name) {
        container.innerHTML = '';
        return;
      }
      if (cache.get(name)) {
        container.innerHTML = cache.get(name);
        return;
      }
      const res = fn.call(fn, name).join('');
      cache.set(name, res);
      container.innerHTML = res;
    }
  }

  function handleInput(value) {
    const reg = new RegExp(`\(${value}\)`);
    const search = data.reduce((res, cur) => {
      if (reg.test(cur)) {
        const match = RegExp.$1;
        res.push(`<li>${cur.replace(match, '<bdi>$&</bdi>')}</li>`);
      }
      return res;
    }, []);
    return search;
  }

  const data = ["上海野生动物园", "上饶野生动物园", "北京巷子", "上海中心", "上海黄埔江", "迪士尼上海", "陆家嘴上海中心"]
  const container = document.querySelector('.container');
  const memorizeInput = memorize(handleInput);
  document.querySelector('.inp').addEventListener('input', debounce(e => {
    memorizeInput(e.target.value);
  }))
</script>
</html>
```

解析：[第 90 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/141)

</details>

<b><details><summary>第 91 题：介绍下 HTTPS 中间人攻击</summary></b>

参考答案：
解析：[第 91 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/142)

</details>

<b><details><summary>第 92 题：已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</summary></b>

参考答案：

>  

```js
>
const value = '112' >
    const fn = (value) => {
            >
            ...
            >
        } >
        fn(value) // 输出 [1， 11， 112]
        >
```

<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g45a04ntttj30k20wen01.jpg" height="800"/>

解析：[第 92 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/143)

</details>

<b><details><summary>第 93 题：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。</summary></b>

参考答案：
示例 1：

```js
nums1 = [1, 3];
nums2 = [2];
```

中位数是 2.0

示例 2：

```js
nums1 = [1, 2];
nums2 = [3, 4];
```

中位数是(2 + 3) / 2 = 2.5

解析：[第 93 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/144)

</details>

<b><details><summary>第 94 题：vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</summary></b>

参考答案：
解析：[第 94 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/145)

</details>

<b><details><summary>第 95 题：模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况</summary></b>

参考答案：
解析：[第 95 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/148)

</details>

<b><details><summary>第 96 题：介绍下前端加密的常见场景和方法</summary></b>

参考答案：

首先，加密的目的，简而言之就是将明文转换为密文、甚至转换为其他的东西，用来隐藏明文内容本身，防止其他人直接获取到敏感明文信息、或者提高其他人获取到明文信息的难度。
通常我们提到加密会想到密码加密、HTTPS 等关键词，这里从场景和方法分别提一些我的个人见解。

## 场景-密码传输

前端密码传输过程中如果不加密，在日志中就可以拿到用户的明文密码，对用户安全不太负责。
这种加密其实相对比较简单，可以使用 PlanA-前端加密、后端解密后计算密码字符串的 MD5/MD6 存入数据库；也可以 PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行 MD5/MD6，全程密码明文不出现在程序中。

#### PlanA

使用 Base64 / Unicode+1 等方式加密成非明文，后端解开之后再存它的 MD5/MD6 。

#### PlanB

直接使用 MD5/MD6 之类的方式取 Hash ，让后端存 Hash 的 Hash 。

## 场景-数据包加密

应该大家有遇到过：打开一个正经网站，网站底下蹦出个不正经广告——比如 X 通的流量浮层，X 信的插入式广告……（我没有针对谁）
但是这几年，我们会发现这种广告逐渐变少了，其原因就是大家都开始采用 HTTPS 了。
被人插入这种广告的方法其实很好理解：你的网页数据包被抓取->在数据包到达你手机之前被篡改->你得到了带网页广告的数据包->渲染到你手机屏幕。
而 HTTPS 进行了包加密，就解决了这个问题。严格来说我认为从手段上来看，它不算是一种前端加密场景；但是从解决问题的角度来看，这确实是前端需要知道的事情。

#### Plan

全面采用 HTTPS

## 场景-展示成果加密

经常有人开发网页爬虫爬取大家辛辛苦苦一点一点发布的数据成果，有些会影响你的竞争力，有些会降低你的知名度，甚至有些出于恶意爬取你的公开数据后进行全量公开……比如有些食谱网站被爬掉所有食谱，站点被克隆；有些求职网站被爬掉所有职位，被拿去卖信息；甚至有些小说漫画网站赖以生存的内容也很容易被爬取。

#### Plan

将文本内容进行展示层加密，利用字体的引用特点，把拿给爬虫的数据变成“乱码”。
举个栗子：正常来讲，当我们拥有一串数字“12345”并将其放在网站页面上的时候，其实网站页面上显示的并不是简单的数字，而是数字对应的字体的“12345”。这时我们打乱一下字体中图形和字码的对应关系，比如我们搞成这样：

> 图形：1 2 3 4 5
> 字码：2 3 1 5 4

这时，如果你想让用户看到“12345”，你在页面中渲染的数字就应该是“23154”。这种手段也可以算作一种加密。
具体的实现方法可以看一下《Web 端反爬虫技术方案》。

解析：[第 96 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/150)

</details>

<b><details><summary>第 97 题：React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？</summary></b>

参考答案：

解析：[第 97 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/151)

</details>

<b><details><summary>第 98 题：写出如下代码的打印结果</summary></b>

```js
function changeObjProperty(o) {
    o.siteUrl = "http://www.baidu.com";
    o = new Object();
    o.siteUrl = "http://www.google.com";
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

公司：京东

参考答案：http://www.baidu.com

解析：[第 98 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/152)

</details>

<b><details><summary>第 99 题：编程算法题</summary></b>

> 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

公司：bilibili

参考答案：

```js
function fun(num) {
    let num1 = num / 10;
    let num2 = num % 10;
    if (num1 < 1) {
        return num;
    } else {
        num1 = Math.floor(num1);
        return `${num2}${fun(num1)}`;
    }
}
var a = fun(12345);
console.log(a);
console.log(typeof a);
```

解析：[第 99 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/153)

</details>


<b><details><summary>第 100 题：请写出如下代码的打印结果</summary></b>

```js
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

公司：京东

参考答案：

输出顺序是 4 2 1

```js
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行

Foo.prototype.a = function() {
    console.log(3)
}
// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3

Foo.a = function() {
    console.log(4)
}
// 现在在 Foo 上挂载了直接方法 a ，输出值为 4

Foo.a();
// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
// # 输出 4

let obj = new Foo();
/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
2. 在新对象上挂载直接方法 a ，输出值为 2。
*/

obj.a();
// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
// # 输出 2

Foo.a();
// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
// # 输出 1
```

解析：[第 100 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/155)

</details>

<b><details><summary>第 101 题：修改以下 print 函数，使之输出 0 到 99，或者 99 到 0</summary></b>

> 要求：
>
> 1、只能修改 `setTimeout` 到 `Math.floor(Math.random() * 1000` 的代码
>
> 2、不能修改 `Math.floor(Math.random() * 1000`

>
> 3、不能使用全局变量
>
>  

```js
> function print(n) {
    >
    setTimeout(() => {
        >
        console.log(n); >
    }, Math.floor(Math.random() * 1000)); >
} >
for (var i = 0; i < 100; i++) {
    >
    print(i); >
} >
```

公司：头条

解析：[第 101 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/158)

</details>

<b><details><summary>第 102 题：不用加减乘除运算符，求整数的 7 倍</summary></b>

解析：[第 102 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/161)

</details>

<b><details><summary>第 103 题：模拟实现一个 localStorage</summary></b>

公司：阿里

解析：[第 103 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/166)

</details>

<b><details><summary>第 104 题：模拟 localStorage 时如何实现过期时间功能</summary></b>

公司：阿里

解析：[第 104 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/171)

</details>

<b><details><summary>第 105 题：编程题</summary></b>

url 有三种情况

```js
https: //www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=&local_province_id=33
    https: //www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800&local_province_id=33
    https: //www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800,700&local_province_id=33
```

匹配 elective 后的数字输出（写出你认为的最优解法）:

```js
[] || ["800"] || ["800", "700"];
```

参考答案：

```js
function getUrlValue(url) {
    if (!url) return;
    let res = url.match(/(?<=elective=)(\d+(,\d+)*)/);
    return res ? res[0].split(',') : [];
}
```

解析：[第 105 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/177)

</details>

<b><details><summary>第 106 题：分别写出如下代码的返回值</summary></b>

```js
String("11") == new String("11"); // true
String("11") === new String("11"); // false
```

公司：京东

解析：[第 106 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/180)

</details>

<b><details><summary>第 107 题：考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素。</summary></b>

> 比如有个数组有 100K 个元素，从中不重复随机选取 10K 个元素。

解析：[第 107 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/187)

</details>

<b><details><summary>第 108 题：请写出如下代码的打印结果</summary></b>

```js
var name = "Tom";
(function() {
    if (typeof name == "undefined") {
        var name = "Jack";
        console.log("Goodbye " + name);
    } else {
        console.log("Hello " + name);
    }
})();

// Goodbye Jack
```

公司：京东

解析：[第 108 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/190)

</details>

<b><details><summary>第 109 题：扩展题，请写出如下代码的打印结果</summary></b>

```js
var name = "Tom";
(function() {
    if (typeof name == "undefined") {
        name = "Jack";
        console.log("Goodbye " + name);
    } else {
        console.log("Hello " + name);
    }
})();

// Hello Tom
```

公司：京东

解析：[第 109 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/198)

</details>

<b><details><summary>第 110 题：编程题，请写一个函数，完成以下功能</summary></b>

> 输入
> `'1, 2, 3, 5, 7, 8, 10'`

> 输出
> `'1~3, 5, 7~8, 10'`

参考答案：

```js
const nums1 = [1, 2, 3, 5, 7, 8, 10];

function simplifyStr(num) {
    var result = [];
    var temp = num[0]
    num.forEach((value, index) => {
        if (value + 1 !== num[index + 1]) {
            if (temp !== value) {
                result.push(`${temp}~${value}`)
            } else {
                result.push(`${value}`)
            }
            temp = num[index + 1]
        }
    })
    return result;
}
console.log(simplifyStr(nums1).join(','))
// 1~3,5,7~8,10
```

解析：[第 110 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/201)

</details>

<b><details><summary>第 111 题：编程题，写个程序把 entry 转换成如下对象</summary></b>

>  

```js
>
var entry = {
    >
    a: {
        >
        b: {
            >
            c: {
                >
                dd: "abcdd" >
            } >
        },
        >
        d: {
            >
            xx: "adxx" >
        },
        >
        e: "ae" >
    } >
}; >
> // 要求转换成如下对象
>
var output = {
    >
    "a.b.c.dd": "abcdd",
    >
    "a.d.xx": "adxx",
    >
    "a.e": "ae" >
}; >
```

解析：[第 111 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/206)

</details>

<b><details><summary>第 112 题：编程题，写个程序把 entry 转换成如下对象（跟昨日题目相反）</summary></b>

>  

```js
>
var entry = {
    >
    "a.b.c.dd": "abcdd",
    >
    "a.d.xx": "adxx",
    >
    "a.e": "ae" >
}; >
> // 要求转换成如下对象
>
var output = {
    >
    a: {
        >
        b: {
            >
            c: {
                >
                dd: "abcdd" >
            } >
        },
        >
        d: {
            >
            xx: "adxx" >
        },
        >
        e: "ae" >
    } >
}; >
```

解析：[第 112 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/212)

</details>

<b><details><summary>第 113 题：编程题，根据以下要求，写一个数组去重函数（蘑菇街）</summary></b>

> 1. 如传入的数组元素为 `[123, "meili", "123", "mogu", 123]` ，则输出： `[123, "meili", "123", "mogu"]`

> 2. 如传入的数组元素为 `[123, [1, 2, 3], [1, "2", 3], [1, 2, 3], "meili"]` ，则输出： `[123, [1, 2, 3], [1, "2", 3], "meili"]`

> 3. 如传入的数组元素为 `[123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili"]` ，则输出： `[123, {a: 1}, {a: {b: 1}}, {a: "1"}, "meili"]`

解析：[第 113 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/215)

</details>

<b><details><summary>第 114 题：编程题，找出字符串中连续出现最多的字符和个数（蘑菇街）</summary></b>

>  

```js
> 'abcaakjbb' => {
    'a': 2,
    'b': 2
} >
'abbkejsbcccwqaa' => {
    'c': 3
} >
```

解析：[第 114 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/220)

</details>

<b><details><summary>第 115 题：写一个单向链数据结构的 js 实现并标注复杂度（水滴筹）</summary></b>

解析：[第 115 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/226)

</details>

<b><details><summary>第 116 题：输出以下代码运行结果</summary></b>

```js
1 + "1"

2 * "2"

[1, 2] + [2, 1]

"a" + +"b"
```

参考答案：

* '11'
*  4
* '1, 22, 1'
* 'aNaN'

//"a" + + "b"其实可以理解为
//   + "b" -> NaN
//"a"+NaN

解析：[第 116 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/229)

</details>

<b><details><summary>第 117 题：介绍下 http1.0、1.1、2.0 协议的区别？</summary></b>

参考答案：

#### HTTP/0.9

已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

#### HTTP/1.0

这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。

#### HTTP/1.1

持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

> HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：
> 缓存处理
> 带宽优化及网络连接的使用
> 错误通知的管理
> 消息在网络中的发送
> 互联网地址的维护
> 安全性及完整性

#### HTTP/2

> 在 HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括HTTP/1.1中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法(HPACK)。此外， HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。
>  
> 帧、消息、流和TCP连接
>  
> 有别于HTTP/1.1在连接中的明文请求，HTTP/2与SPDY一样，将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。[12]这也是HTTP/1.1与HTTP/2最大的区别所在。 HTTP/2中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个TCP通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。这个举措在SPDY中的实践表明，相比HTTP/1.1，新页面加载可以加快11.81% 到 47.7%[17]
>  
> HPACK 算法
>  
> HPACK算法是新引入HTTP/2的一个算法，用于对HTTP头部做压缩。其原理在于：
>  
> 客户端与服务端根据 RFC 7541 的附录A，维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码；
> 客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；
> 客户端和服务端根据 RFC 7541 的附录B，支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）。
>  
> 服务器推送
>  
> 网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多HTTP链接来加载页面和页面资源。
>  
> HTTP/2引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。

解析：[第 117 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/232)

</details>

<b><details><summary>第 118 题：vue 渲染大量数据时应该怎么优化？</summary></b>

参考答案：

#### 如果一次性传入大量数据

建议

1. 先打死提供数据的人 ^ v ^~ （推荐）
2. 如果打不过自己架设中间层
3. SPA + SSR处理 bigpipe （服务器渲染组件总比浏览器强，毕竟那么多核的CPU也不是花瓶）
4. 可以考虑stream（我还没看用过...）
4. 增加加载动画提升用户体验
5. 同时避免浏览器处理大量的dom（具体看下面）
6. 尽量不要再用vue的双向数据绑定了 或者只用部分页面中处理的数据

#### 如果并非一次性传入大量数据 而只是分段加载 但次数特别多

建议

1. 异步渲染组件
2. 使用vue的v-if 最多显示上中（可视区域）下三屏 避免出现大量的dom节点
3. 或者使用分页（体验可能不如上面那么好“无限加载的也要考虑dom过多的情况”）
个人建议，如有误，还劳烦指正

解析：[第 118 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/233)

</details>

<b><details><summary>第 119 题：vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</summary></b>

解析：[第 119 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/234)

</details>

<b><details><summary>第 120 题：为什么 for 循环嵌套顺序会影响性能？</summary></b>

```js
var t1 = new Date().getTime();
for (let i = 0; i < 100; i++) {
    for (let j = 0; j < 1000; j++) {
        for (let k = 0; k < 10000; k++) {}
    }
}
var t2 = new Date().getTime();
console.log("first time", t2 - t1);

for (let i = 0; i < 10000; i++) {
    for (let j = 0; j < 1000; j++) {
        for (let k = 0; k < 100; k++) {}
    }
}
var t3 = new Date().getTime();
console.log("two time", t3 - t2);
```

参考答案：

两个循环的次数的是一样的，但是 j 与 k 的初始化次数是不一样的

* 第一个循环的 j 的初始化次数是 100 次，k 的初始化次数是 10w 次
* 第二个循环的 j 的初始化次数是 1w 次， k 的初始化次数是 1000w 次

所以相同循环次数，外层越大，越影响性能 

解析：[第 120 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/235)

</details>

<b><details><summary>第 121 题：统计 1 ~ n 整数中出现 1 的次数。</summary></b>

例如统计 1 ~ 400W 出现 1 的次数。

参考答案：

```js
function findOne(n) {
    let count = 0;
    for (let i = 0; i <= n; i++) {
        count += String(i).split('').filter(item => item === '1').length
    }
    return count;
}
```

解析：[第 121 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/237)

</details>

<b><details><summary>第 122 题：webpack 打包 vue 速度太慢怎么办？</summary></b>

参考答案：

1. 使用webpack-bundle-analyzer对项目进行模块分析生成report，查看report后看看哪些模块体积过大，然后针对性优化，比如我项目中引用了常用的UI库element-ui和v-charts等

2. 配置webpack的externals ，官方文档的解释：防止将某些import的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖。
所以，可以将体积大的库分离出来：

```
// ...
externals: {
    'element-ui': 'Element',
    'v-charts': 'VCharts'
}
```

3. 然后在main.js中移除相关库的import

4. 在index.html模板文件中，添加相关库的cdn引用，如：

```js
< script src = "https://unpkg.com/element-ui@2.10.0/lib/index.js" > < /script> <
    script src = "https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js" > < /script> <
    script src = "https://cdn.jsdelivr.net/npm/v-charts/lib/index.min.js" > < /script>
```

 

解析：[第 122 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/238)

</details>

<b><details><summary>第 123 题：vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法</summary></b>

参考答案：

1. 为什么要对数组进行单独处理
在Vue现有阶段中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以我们需要对这些操作进行hack，让vue能监听到其中的变化。

2. 怎么对数组进行处理

```js
methodsToPatch.forEach(function(method) {
    // cache original method
    // 获取原方法
    var original = arrayProto[method];
    // def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值
    def(arrayMethods, method, function mutator() {
        var args = [],
            len = arguments.length;
        while (len--) args[len] = arguments[len];

        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                // [].push(1),[].unshift(1)
                // arg = [1]
                inserted = args;
                break
            case 'splice':
                // [1,2,3].splice(0,1,1)
                // 第三个参数为插入的值
                inserted = args.slice(2);
                break
        }
        if (inserted) {
            ob.observeArray(inserted);
        }
        // 监听变化，如果不是插入操作直接循环响应
        // 如果是去除数组参数方法，触发一次notify将会重新计算
        // 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以
        // 但是如果新增的是一个对象类型，就需要重新监听
        // 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听
        // notify change
        ob.dep.notify();
        return result
    });
});
```

正如该题所问，vue对push, pop, splice等方法进行了hack，hack方式很简单，如果加入新对象，对新对象进行响应式化，至于如何响应式化请参考vue源码。
举例来说对于push和unshift会推入一个新的对象到数组里(不管从前还是从后), 记录这个加入的对象，并调用Observe方法将加入的对象转换成响应式对象, 对于splice方法，如果加入了新对象也是将该对象响应式化。
最后一步是向外抛出数组变化，提醒观察者进行更新。

3. 存在问题
对于Object.defineProperty的缺陷导致如果直接改变数组下标是无法hack的，由于此点，vue提供了$set方法，最新的解决方案当然是利用Proxy对象进行监听，但是Proxy的缺陷在于兼容性，可能会为了性能以及便利而放弃兼容性吧，一切都要看尤大的决定了。

4. ps
不知道啥时候3.0才能出来，都等到迫不及待了。

解析：[第 123 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/239)

</details>

<b><details><summary>第 124 题：永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响</summary></b>

参考答案：

![大厂_001](../images/大厂_001.png)

解析：[第 124 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/241)

</details>

<b><details><summary>第 125 题：算法题</summary></b>

如何将 `[{id: 1}, {id: 2, pId: 1}, ...]` 的重复数组（有重复数据）转成树形结构的数组 `[{id: 1, child: [{id: 2, pId: 1}]}, ...]` （需要去重）

参考答案：

哈希表，时间复杂度O(n)

```js
const fn = arr => {
    const res = []
    const map = arr.reduce((res, item) => ((res[item.id] = item), res), {})
    for (const item of Object.values(map)) {
        if (!item.pId) {
            res.push(item)
        } else {
            const parent = map[item.pId]
            parent.child = parent.child || []
            parent.child.push(item)
        }
    }
    return res
}

// const arr = [{id: 1}, {id:2, pId: 1}, {id: 3, pId: 2}, {id: 4}, {id:3, pId: 2}, {id: 5, pId: 4}]
// fn(arr) => [{id: 1, child: [{id: 2, pId: 1, child: [{ id: 3, pId: 2}]}]}, {id: 4, child: [{id: 5, pId: 4}]}]
```

解析：[第 125 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/243)

</details>

<b><details><summary>第 126 题：扑克牌问题</summary></b>

> 有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；
>
> 最后桌子上的牌顺序为： (牌底) 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 (牌顶)；
>
> 问：原来那堆牌的顺序，用函数实现。

参考答案：

```js
function poke(arr) {
    let i = 1;
    let out = [];
    while (arr.length) {
        if (i % 2) {
            out.push(arr.shift());
        } else {
            arr.push(arr.shift());
        }
        i++;
    }
    return out;
}

function reverse(arr) {
    let i = 1;
    let out = [];
    while (arr.length) {
        if (i % 2) {
            out.unshift(arr.pop());
        } else {
            out.unshift(out.pop());
        }
        i++;
    }
    return out;
}

reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
// [1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]
```

解析：[第 126 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/245)

</details>

<b><details><summary>第 127 题：如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性</summary></b>

参考答案：

```css
/* 单行： */
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
/* 多行： */
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3; //行数
overflow: hidden;

/* 兼容： */
p {
    position: relative;
    line-height: 20px;
    max-height: 40px;
    overflow: hidden;
}

p::after {
    content: "...";
    position: absolute;
    bottom: 0;
    right: 0;
    padding-left: 40px;
    background: -webkit-linear-gradient(left, transparent, #fff 55%);
    background: -o-linear-gradient(right, transparent, #fff 55%);
    background: -moz-linear-gradient(right, transparent, #fff 55%);
    background: linear-gradient(to right, transparent, #fff 55%);
}
```

解析：[第 127 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/246)

</details>

<b><details><summary>第 128 题：Http 状态码 301 和 302 的应用场景分别是什么</summary></b>

参考答案：

* 301：永久重定向；
* 302：临时重定向；

解析：[第 128 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/249)

</details>

<b><details><summary>第 129 题：输出以下代码执行结果</summary></b>

```js
function wait() {
    return new Promise(resolve => setTimeout(resolve, 10 * 1000));
}

async function main() {
    console.time();
    const x = wait();
    const y = wait();
    const z = wait();
    await x;
    await y;
    await z;
    console.timeEnd();
}
main();
```

参考答案：10s 多一点

解析：[第 129 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/251)

</details>

<b><details><summary>第 130 题：输出以下代码执行结果，大致时间就好（不同于上题）</summary></b>

```js
function wait() {
    return new Promise(resolve => setTimeout(resolve, 10 * 1000));
}

async function main() {
    console.time();
    await wait();
    await wait();
    await wait();
    console.timeEnd();
}
main();
```

参考答案：30s 多一点

解析：[第 130 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/253)

</details>

<b><details><summary>第 131 题：接口如何防刷</summary></b>

参考答案：

* 1：网关控制流量洪峰，对在一个时间段内出现流量异常，可以拒绝请求（参考个人博客文章 https://mp.csdn.net/postedit/81672222）
* 2：源 ip 请求个数限制。对请求来源的 ip 请求个数做限制
* 3：http 请求头信息校验；（例如 host，User-Agent，Referer）
* 4：对用户唯一身份 uid 进行限制和校验。例如基本的长度，组合方式，甚至有效性进行判断。或者 uid 具有一定的时效性
* 5：前后端协议采用二进制方式进行交互或者协议采用签名机制
* 6：人机验证，验证码，短信验证码，滑动图片形式，12306 形式
  ————————————————
  版权声明：本文为 CSDN 博主「timy07」的原创文章，遵循 CC 4.0 by-sa 版权协议，转载请附上原文出处链接及本声明。
  原文链接：https://blog.csdn.net/timy07/article/details/86467994

解析：[第 131 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/254)

</details>

<b><details><summary>第 132 题：实现一个 Dialog 类，Dialog 可以创建 dialog 对话框，对话框支持可拖拽（腾讯）</summary></b>

解析：[第 132 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/257)

</details>

<b><details><summary>第 133 题：用 setTimeout 实现 setInterval，阐述实现的效果与 setInterval 的差异</summary></b>

解析：[第 133 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/259)

</details>

<b><details><summary>第 134 题：求两个日期中间的有效日期</summary></b>

> 如 2015-2-8 到 2015-3-3，返回【2015-2-8 2015-2-9...】

解析：[第 134 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/264)

</details>

<b><details><summary>第 135 题：算法题（盛大）</summary></b>

> 在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为: 黄、红、蓝。
>
> 例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。

解析：[第 135 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/266)

</details>

<b><details><summary>第 136 题：如何实现骨架屏，说说你的思路</summary></b>

解析：[第 136 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/270)

</details>

<b><details><summary>第 137 题：如何在 H5 和小程序项目中计算白屏时间和首屏时间，说说你的思路</summary></b>

解析：[第 137 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/272)

</details>

<b><details><summary>第 138 题：反转链表，每 k 个节点反转一次，不足 k 就保持原有顺序（哔哩哔哩）</summary></b>

解析：[第 138 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/278)

</details>

<b><details><summary>第 139 题：谈一谈 nextTick 的原理</summary></b>

解析：[第 139 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/281)

</details>

<b><details><summary>第 140 题：为什么 HTTP1.1 不能实现多路复用（腾讯）</summary></b>

解析：[第 140 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/290)

</details>

<b><details><summary>第 141 题：Vue 中的 computed 是如何实现的（腾讯、平安）</summary></b>

解析：[第 141 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/291)

</details>

<b><details><summary>第 142 题：（算法题）求多个数组之间的交集（阿里）</summary></b>

解析：[第 142 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/293)

</details>

<b><details><summary>第 143 题：将 '10000000000' 形式的字符串，以每 3 位进行分隔展示 '10.000.000.000'</summary></b>

解析：[第 143 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/296)

</details>

<b><details><summary>第 144 题：手写二进制转 Base64（阿里）</summary></b>

解析：[第 144 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/299)

</details>

<b><details><summary>第 145 题：前端项目如何找出性能瓶颈（阿里）</summary></b>

解析：[第 145 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/300)

</details>

<b><details><summary>第 146 题：Vue 中的 computed 和 watch 的区别在哪里（虾皮）</summary></b>

解析：[第 146 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/304)

</details>

<b><details><summary>第 147 题：v-if、v-show、v-html 的原理是什么，它是如何封装的？</summary></b>

解析：[第 147 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/307)

</details>

<b><details><summary>第 148 题： webpack 中 loader 和 plugin 的区别是什么（平安）</summary></b>

解析：[第 148 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308)

</details>

<b><details><summary>第 149 题：babel 怎么把字符串解析成 AST，是怎么进行词法/语法分析的？</summary></b>

解析：[第 149 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/315)

</details>

<b><details><summary>第 150 题：二分查找如何定位左边界和右边界</summary></b>

> 不使用JS数组API，查找有序数列最先出现的位置和最后出现的位置

解析：[第 150 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/320)

</details>

<b><details><summary>第 151 题：用最简洁代码实现 indexOf 方法</summary></b>

解析：[第 151 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/321)

</details>

<b><details><summary>第 152 题：实现一个 normalize 函数，能将输入的特定的字符串转化为特定的结构化数据</summary></b>

解析：[第 152 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/331)

</details>

<b><details><summary>第 153 题：实现一个批量请求函数 multiRequest(urls, maxNum)</summary></b>

要求如下：

1. 要求最大并发数 maxNum
2. 每当有一个请求返回，就留下一个空位，可以增加新的请求
3. 所有请求完成后，结果按照 urls 里面的顺序依次打出

解析：[第 153 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/378)

</details>

<b><details><summary>第 154 题：弹性盒子中 flex: 0 1 auto 表示什么意思</summary></b>

解析：[第 154 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/380)

</details>

<b><details><summary>第 155 题：求最终 left、right 的宽度</summary></b>


```js
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>

<style>
  * {
    padding: 0;
    margin: 0;
  }
  .container {
    width: 600px;
    height: 300px;
    display: flex;
  }
  .left {
    flex: 1 2 500px;
    background: red;
  }
  .right {
    flex: 2 1 400px;
    background: blue;
  }
</style>
```

解析：[第 155 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/381)

</details>

<b><details><summary>第 156 题：求最终 left、right 的宽度</summary></b>

```js
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>

<style>
  * {
    padding: 0;
    margin: 0;
  }
  .container {
    width: 600px;
    height: 300px;
    display: flex;
  }
  .left {
    flex: 1 2 300px;
    background: red;
  }
  .right {
    flex: 2 1 200px;
    background: blue;
  }
</style>
```

注：此题和 155 题 left、right 样式有些不同



解析：[第 156 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/382)

</details>

<b><details><summary>第 157 题：浏览器缓存 ETag 里的值是怎么生成的</summary></b>

解析：[第 157 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/383)

</details>

<b><details><summary>第 158 题：如何模拟实现 Array.prototype.splice</summary></b>

解析：[第 158 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/384)

</details>

<b><details><summary>第 159 题：实现 `Promise.retry`，成功后 `resolve` 结果，失败后重试，尝试超过一定次数才真正的 `reject`</summary></b>

解析：[第 159 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/387)

</details>

<b><details><summary>第 160 题：输出以下代码运行结果，为什么？如果希望每隔 1s 输出一个结果，应该如何改造？注意不可改动 square 方法</summary></b>

```js
const list = [1, 2, 3]
const square = num => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(num * num)
    }, 1000)
  })
}

function test() {
  list.forEach(async x=> {
    const res = await square(x)
    console.log(res)
  })
}
test()
```

解析：[第 160 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/389)

</details>

<b><details><summary>第 161 题：用最精炼的代码实现数组非零非负最小值 index </summary></b>

```js
// 例如：[10,21,0,-7,35,7,9,23,18] 输出 5, 7 最小
function getIndex(arr){
      let index=null;
      ...
      return index;
}
```


解析：[第 161 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/421)

</details>

<b><details><summary>第 162 题：实现对象的 Map 函数类似 Array.prototype.map</summary></b>

解析：[第 162 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/431)

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 简单描述下微信小程序的相关文件类型？</summary></b>

参考答案：微信小程序项目结构主要有四个文件类型, 如下

一. WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件. 事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。

二. WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，

三.js 逻辑处理，网络请求

四.json 小程序设置，如页面注册，页面标题及tabBar。

</details>

<b><details><summary>2. 你是怎么封装微信小程序的数据请求的？</summary></b>

参考答案：

一. 将所有的接口放在统一的js文件中并导出

二. 在app. js中创建封装请求数据的方法

三. 在子页面中调用封装的方法请求数据

</details>

<b><details><summary>3. 有哪些参数传值的方法？</summary></b>

参考答案：

一. 给HTML元素添加data-\*属性来传递我们需要的值，然后通过e. currentTarget. dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象

二. 设置id 的方法标识来传值通过e. currentTarget. id获取设置的id的值, 然后通过设置全局对象的方式来传递数值

三. 在navigator中添加参数传值

</details>

<b><details><summary>4. 你使用过哪些方法，来提高微信小程序的应用速度？</summary></b>

参考答案：

一. 提高页面加载速度

二. 用户行为预测

三. 减少默认data的大小

四. 组件化方案

</details>

<b><details><summary>5. 小程序与原生App哪个好？</summary></b>

参考答案：

小程序除了拥有公众号的低开发成本. 低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度 的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验

</details>

<b><details><summary>6. 简述微信小程序原理？</summary></b>

参考答案：

微信小程序采用JavaScript. WXML. WXSS三种技术进行开发，从技术讲和现有的前端开发差不多，但深入挖掘的话却又有所不同。

JavaScript：首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5，可以称其为伪H5，同理，微信提供的独有的某些API，H5也不支持或支持的不是特别好。

WXML：WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。

WXSS：WXSS具有CSS的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。

微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。

小程序分为两个部分webview和appService。其中webview主要用来展现UI，appService有来处理业务逻辑. 数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染. 事件的处理

</details>

<b><details><summary>7. 分析下微信小程序的优劣势？</summary></b>

参考答案：

优势：

1. 无需下载，通过搜索和扫一扫就可以打开。

2. 良好的用户体验：打开速度快。

3. 开发成本要比App要低。

4. 安卓上可以添加到桌面，与原生App差不多。

5. 为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。

劣势：

1. 限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。

2. 样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片. 导航。

3. 推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。

4. 依托于微信，无法开发后台管理功能。

</details>

<b><details><summary>8. 微信小程序与H5的区别？</summary></b>

参考答案：

第一条是运行环境的不同

传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。

第二条是开发成本的不同

只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG

第三条是获取系统级权限的不同

系统级权限都可以和微信小程序无缝衔接

第四条便是应用在生产环境的运行流畅度

长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立

</details>

<b><details><summary>9. 怎么解决小程序的异步请求问题？</summary></b>

参考答案：

在回调函数中调用下一个组件的函数：

app. js

```js
  success: function(info) {
      that.apirtnCallback(info)
  }
```

index. js

```js
onLoad: function() {
    app.apirtnCallback = res => {
        console.log(res)
    }
}
```

</details>

<b><details><summary>10. 小程序的双向绑定和vue哪里不一样？</summary></b>

参考答案：小程序直接this. data的属性是不可以同步到视图的，必须调用

```js
this.setData({
    noBind: true
})
```

</details>

<b><details><summary>11. 小程序的wxss和css有哪些不一样的地方？</summary></b>

参考答案：

一.wxss的图片引入需使用外链地址；

二. 没有Body, 样式可直接使用import导入；

</details>

<b><details><summary>12.webview中的页面怎么跳回小程序中？</summary></b>

参考答案：首先要引入最新版的jweixin-1. 3. 2. js，然后

```js
wx.miniProgram.navigateTo({
    url: '/pages/login/login' + '$params'
})
```

</details>

<b><details><summary>13. 小程序关联微信公众号如何确定用户的唯一性？</summary></b>

参考答案：使用wx. getUserInfo方法withCredentials为 true 时 可获取encryptedData，里面有 union_id。后端需要进行对称解密

</details>

<b><details><summary>14. 如何实现下拉刷新？</summary></b>

参考答案：用view代替scroll-view, , 设置onPullDownRefresh函数实现

</details>

<b><details><summary>15. 使用webview直接加载要注意哪些事项？</summary></b>

参考答案：

一. 必须要在小程序后台使用管理员添加业务域名；

二.h5页面跳转至小程序的脚本必须是1. 3. 1以上；

三. 微信分享只可以都是小程序的主名称了，如果要自定义分享的内容，需小程序版本在1. 7. 1以上；

四.h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的。

</details>

<b><details><summary>16. 小程序调用后台接口遇到哪些问题？</summary></b>

参考答案：

一. 数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；

二. 小程序不可以直接渲染文章内容页这类型的html文本内容，若需显示要借住插件，但插件渲染会导致页面加载变慢，所以最好在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签，然后其它的标签让插件来做，减轻前端的时间。

</details>

<b><details><summary>17.webview的页面怎么跳转到小程序导航的页面？</summary></b>

参考答案：小程序导航的页面可以通过switchTab，但默认情况是不会重新加载数据的。
若需加载新数据，则在success属性中加入以下代码即可：

```js
success: function(e) {
    var page = getCurrentPages().pop();
    if (page == undefined || page == null) return;
    page.onLoad();
}
```

webview的页面，则通过

```js
wx.miniProgram.switchTab({
    url: '/pages/index/index'
})
```

</details>

<b><details><summary>18. 小程序和Vue写法的区别？</summary></b>

参考答案：

一. 循环遍历的时候：小程序是wx:for="list"，而Vue是v-for="(item, index) in list"

二. 调用data模型的时候：小程序是this. data. uinfo，而Vue是this. uinfo；给模型赋值也不一样，小程序是this. setData({uinfo:1})，而Vue是直接this. uinfo=1

</details>

<b><details><summary>19. 小程序生命周期</summary></b>

参考答案：

```js
// app.js
App({
    onLaunch(options) {
        // Do something initial when launch.
    },
    onShow(options) {
        // Do something when show.
    },
    onHide() {
        // Do something when hide.
    },
    onError(msg) {
        console.log(msg)
    },
    globalData: 'I am global data'
})
```

```js 
//index.js
Page({
  data: {

    text: "This is page data."

  }, 
  onLoad: function(options) {

    // 页面创建时执行

  }, 
  onShow: function() {

    // 页面出现在前台时执行

  }, 
  onReady: function() {

    // 页面首次渲染完毕时执行

  }, 
  onHide: function() {

    // 页面从前台变为后台时执行

  }, 
  onUnload: function() {

    // 页面销毁时执行

  }, 
  onPullDownRefresh: function() {

    // 触发下拉刷新时执行

  }, 
  onReachBottom: function() {

    // 页面触底时执行

  }, 
  onShareAppMessage: function () {

    // 页面被用户分享时执行

  }, 
  onPageScroll: function() {

    // 页面滚动时执行

  }, 
  onResize: function() {

    // 页面尺寸变化时执行

  }, 
  onTabItemTap(item) {

    // tab 点击时执行
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)

  }, 
  // 事件响应函数
  viewTap: function() {

    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })

  }, 
  // 自由数据
  customData: {

    hi: 'MINA'

  }
})
```

![页面 Page 实例的生命周期](../images/miniProgram_001.png)

</details>

<b><details><summary>20. h5页面如何传递参数给小程序？</summary></b>

参考答案：

```
1、H5页面
<script src="${base}/resources/common/js/jweixin.miniProgram.js"></script>

wx.miniProgram.postMessage({
  data: {
    shareUrl:href
  }
});

注意：传参必须使用data

2、小程序页面接收

Page({
//获取H5传给小程序的参数
getMessage: function(e) {
  if (!e.detail) {
    return
  }
  var datas = e.detail.data
  var shareUrl = datas.shareUrl;
}
})

index.wxml文件
```

</details>

<b><details><summary></summary></b>

参考答案：

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 谈谈你对 webpack 的看法（webpack 的特点）</summary></b>

参考答案：WebPack 是一个模块打包工具，你可以使用 WebPack 管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包 Web 开发中所用到的 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack 有对应的模块加载器。webpack 模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。

webpack 的两大特色：

1. code splitting（可以自动完成）
2. loader 可以处理各种类型的静态文件，并且支持串联操作

webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。

webpack 具有 requireJs 和 browserify 的功能，但仍有很多自己的新特性：

1. 对 CommonJS 、 AMD 、ES6 的语法做了兼容
2. 对 js、css、图片等资源文件都支持打包
3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对 CoffeeScript、ES6 的支持
4. 有独立的配置文件 webpack.config.js
5. 可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间
6. 支持 SourceUrls 和 SourceMaps，易于调试
7. 具有强大的 Plugin 接口，大多是内部插件，使用起来比较灵活
8. webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快

[参与互动](https://github.com/yisainan/web-interview/issues/824)

</details>

<b><details><summary>2. 最具有挑战性的项目</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/825)

</details>

<b><details><summary>3. webpack plugin/loader 的区别</summary></b>

参考答案：

#### 一、webpack的常见配置

```js
const webpack = require("webpack");
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {
    // 入口文件
    entry: {
        app: path.join(__dirname, "../src/js/index.js")
    },
    // 输出文件
    output: {
        filename: "[name].bundle.js",
        path: path.resolve(__dirname, "dist"),
        publicPath: "/"
    },
    // loader配置
    module: {
        rules: [{
                test: /\.scss/,
                use: [
                    "style-loader",
                    "css-loader"
                ]
            }
            ......
        ]
    },
    // plugins配置
    plugins: [
        // 重新创建html文件
        new HtmlWebpackPlugin({
            title: "首页",
            filename: "index.html",
            template: path.resolve(__dirname, "../src/index.html")
        })
        ......
    ]
}
```

#### 二、webpack的打包原理

1. 识别入口文件
2. 通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)
3. webpack做的就是分析代码，转换代码，编译代码，输出代码
4. 最终形成打包后的代码

#### 三、什么是loader

loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中

1. 处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行
2. 第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码

#### 四、什么是plugin

在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。

#### 五、loader和plugin的区别

对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A. scss转换为A. css，单纯的文件转换过程

plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务

```js
class MyPlugin {
    constructor(options) {
        console.log("MyPlugin constructor:", options);
    }
    apply(compiler) {
        compiler.plugin("compilation", compilation => {
            console.log("MyPlugin");
        });
    }
}
module.exports = MyPlugin;

webpack.config.js配置：
module.exports = {
    ...
    plugins: [
        new MyPlugin({
            param: "my plugin"
        })
    ]
}
```

使用该plugin后，执行的顺序：

1. webpack启动后，在读取配置的过程中会执行new MyPlugin(options)初始化一个MyPlugin获取其实例
2. 在初始化compiler对象后，就会通过compiler.plugin(事件名称，回调函数)监听到webpack广播出来的事件
3. 并且可以通过compiler对象去操作webpack

[参与互动](https://github.com/yisainan/web-interview/issues/826)

</details>

<b><details><summary>4. 熟悉哪些前端框架并应用于实际项目？ 阅读过哪些前端框架源码并学到哪些？</summary></b>

参考答案：以实际情况为准，[vue源码可参考](https://vue-js.com/learn-vue/start/#_1-%E5%89%8D%E8%A8%80)

[参与互动](https://github.com/yisainan/web-interview/issues/827)

</details>

<b><details><summary>5. 写过哪些前端组件</summary></b>

参考答案：时间选择器组件，图片上传组件，轮播图组件等，一定要知道其原理。

[参与互动](https://github.com/yisainan/web-interview/issues/828)

</details>

<b><details><summary>6. 前端组件化的理解</summary></b>

参考答案：

设计组件要遵循一个原则：一个组件只专注做一件事，且把这件事做好。

带来的好处：降低耦合性，提高了系统的伸展性，降低了开发的复杂度，提升开发效率，降低开发成本。

[参与互动](https://github.com/yisainan/web-interview/issues/829)

</details>

<b><details><summary>7. 有没有写过框架</summary></b>

参考答案：以实际情况为准

[参与互动](https://github.com/yisainan/web-interview/issues/830)

</details>

<b><details><summary>8. 网站性能优化</summary></b>

参考答案：

样本一

* 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
* 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
* 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
* 当需要设置的样式很多时设置 className 而不是直接操作 style。
* 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。
* 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。
* 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
* 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。

样本二

* 减少 HTTP 请求
* 减少 DOM 操作
* 避免不必要的重绘与重排
* 优化 CSS 选择器（从右向左匹配）
* CSS/JS minify，减少文件体积
* 开启 Gzip 压缩
* 将 CSS 放到顶部，JavaScript 放到尾部
* 压缩图片以及使用 CSS Sprite
* 使用 CDN 加速，适当进行文件缓存
* 合理控制 cookie 大小（每次请求都会包含 cookie）

[参与互动](https://github.com/yisainan/web-interview/issues/831)

</details>

<b><details><summary>9. React/Vue/小程序 的语法的这些好处，坏处</summary></b>

参考答案：

一、Vue. js：

其实Vue. js不是一个框架，因为它只聚焦视图层，是一个构建数据驱动的Web界面的库。

Vue. js通过简单的API（应用程序编程接口）提供高效的数据绑定和灵活的组件系统。

Vue. js的特性如下：

1. 轻量级的框架
2. 双向数据绑定
3. 指令
4. 插件化

优点： 

1. 简单：官方文档很清晰，比 Angular 简单易学。
2. 快速：异步批处理方式更新 DOM。
3. 组合：用解耦的、可复用的组件组合你的应用程序。
4. 紧凑：~18kb min+gzip，且无依赖。
5. 强大：表达式 & 无需声明依赖的可推导属性 (computed properties)。
6. 对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。

缺点：  

1. 新生儿：Vue.js是一个新的项目，没有angular那么成熟。
2. 影响度不是很大：google了一下，有关于Vue.js多样性或者说丰富性少于其他一些有名的库。
3. 不支持IE8：

二、React：
 
React主要用于构建UI。你可以在React里传递多种类型的参数，如声明代码，帮助你渲染出UI、也可以是静态的HTML DOM元素、也可以传递动态变量、甚至是可交互的应用组件。
 
React特性如下：　

1. 声明式设计：React采用声明范式，可以轻松描述应用。
2. 高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。
3. 灵活：React可以与已知的库或框架很好地配合。

 
优点： 

1. 速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。
2. 跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。
3. 模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。
4. 单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。
5. 同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。
6. 兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

 
缺点： 

1. React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。

二、小程序：
小程序提供了一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者在微信中开发具有原生 APP 体验的服务。

[参与互动](https://github.com/yisainan/web-interview/issues/832)

</details>

<b><details><summary>10. Webpack 的代码分割，异步加载资源文件</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/833)

</details>

<b><details><summary>11. Node Proxy 代理服务, 如何把请求指向本地</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/834)

</details>

<b><details><summary>12. 如何对网站文件和资源优化</summary></b>

参考答案：文件合并及压缩、使用 CDN 托管、使用缓存

[参与互动](https://github.com/yisainan/web-interview/issues/835)

</details>

<b><details><summary>13. 从零写一个 npm 安装包</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/836)

</details>

<b><details><summary>14. 平时如何管理你的项目？</summary></b>

参考答案：

a. 先期团队必须确定好全局样式（globe. css），编码模式(utf-8) 等；

b. 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

c. 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

d. 页面进行标注（例如 页面 模块 开始和结束）；

e. CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style. css）；

f. JS 分文件夹存放 命名以该 JS 功能为准的英文翻译。

g. 图片采用整合的 images. png png8 格式文件使用 尽量整合在一起使用方便将来的管理

[参与互动](https://github.com/yisainan/web-interview/issues/837)

</details>

<b><details><summary>15. Webpack 中如何配置 Babel</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/838)

</details>

<b><details><summary>16. promise 和 await/async 的区别是什么？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/839)

</details>

<b><details><summary>17. 怎么提高首屏加载速度</summary></b>

参考答案：服务端渲染等

解析：[参考](https://juejin.im/post/5d00820b5188255ee806a1c7#heading-2)

[参与互动](https://github.com/yisainan/web-interview/issues/840)

</details>

<b><details><summary>18. 模块化开发怎么做？</summary></b>

参考答案：

* AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
* CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

* AMD 是提前执行，CMD 是延迟执行。
* AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module. exports 或 exports 的属性赋值来达到暴露模块对象的目的。

CMD 模块方式

```js
define(function(require, exports, module) {
    // 模块代码
});
```

[参与互动](https://github.com/yisainan/web-interview/issues/841)

</details>

<b><details><summary>19. 调试工具的使用</summary></b>

参考答案：

调试模式中的按钮作用
F8 跳出断点调试模式
F10、F11 代码的逐行调试

进入断点调试模式的 方法

1. 在浏览器当中打断点
2. 直接在代码中加 debugger

[参与互动](https://github.com/yisainan/web-interview/issues/842)

</details>

<b><details><summary>20. 用过哪些设计模式？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/843)

</details>

<b><details><summary>21. 简述 gulp 是什么？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/844)

</details>

<b><details><summary>22. 列举前端优化策略</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/845)

</details>

<b><details><summary>23. 首屏、白屏时间如何计算？</summary></b>

参考答案：

Performance 接口可以获取到当前页面中与性能相关的信息。<br>
该类型的对象可以通过调用只读属性 Window. performance 来获得。<br>
白屏时间：

```

performance.timing.responseStart - performance.timing.navigationStart
```

首屏时间

```

window.onload = () => {
    new Date() - performance.timing.responseStart
}
```

解析：[参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)

[参与互动](https://github.com/yisainan/web-interview/issues/846)

</details>

<b><details><summary>24. 如何利用 webpack 把代码上传服务器以及转码测试？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/847)

</details>

<b><details><summary>25. 项目上线流程是怎样的？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/848)

</details>

<b><details><summary>26. 工程化怎么管理的?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/849)

</details>

<b><details><summary>27. webpack 和 gulp 对比 webpack 打包文件太大怎么办?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/850)

</details>

<b><details><summary>28. 不想让别人盗用你的图片，访问你的服务器资源该怎么处理？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/851)

</details>

<b><details><summary>29. webpack 怎么引入第三方的库？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/852)

</details>

<b><details><summary>30. 如果线上出现 bug git 怎么操作？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/853)

</details>

<b><details><summary>31. 用过 Nginx 吗？都用过哪些？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/854)

</details>

<b><details><summary>32. 混合开发桥接 api 是怎么调用的，需要引入类库嘛? 调用的对象是什么?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/855)

</details>

<b><details><summary>33. 说一下你对支付，推送（远程，本地）的理解</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/856)

</details>

<b><details><summary>34. 后台管理项目，菜单权限如何控制的？</summary></b>

参考答案：

一般来说分为两种：一种是将所有路由数据存储在本地文件中，然后从服务端获取用户的权限信息，在路由跳转时，添加权限判断钩子，如果用户前往的页面不在权限列表内，则禁止跳转。另一种则是本地只存储基本路由，如错误处理页面、无权限控制页面等，而权限路由则从服务器获取，服务器根据用户的权限下发相应的路由数据，客户端利用这些数据进行路由的动态生成和添加。  [参考](https://www.cnblogs.com/zzayne/p/8833516.html)

[参与互动](https://github.com/yisainan/web-interview/issues/857)

</details>

<b><details><summary>35. 如何调用原生的接口？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/858)

</details>

<b><details><summary>36. 微信支付怎么做？说说流程</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/859)

</details>

<b><details><summary>37. 混合开发的注意点</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/860)

</details>

<b><details><summary>38. 说说你对手机平台的安装包后缀的理解</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/861)

</details>

<b><details><summary>39. 谈谈你对 Socket 编程的理解，及实现原理，Socket 之间是怎么通讯的</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/862)

</details>

<b><details><summary>40. WEB 应用从服务器主动推送 Data 到客户端有哪些方式?</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/863)

</details>

<b><details><summary>41. 你们原来公司如何发送的新消息推送？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/864)

</details>

<b><details><summary>42. webpack 用法</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/865)

</details>

<b><details><summary>43. 项目开发经历了哪几个阶段</summary></b>

参考答案：

* 需求分析及变更管理
* 项目模型及业务流程分析
* 系统分析及建模设计
* 界面设计及代码开发
* 系统测试，部署和文档编写
* 维护

[参与互动](https://github.com/yisainan/web-interview/issues/866)

</details>

<b><details><summary>44. WEB 应用从服务器主动推送 Data 到客户端有那些方式？</summary></b>

参考答案：

* html5 websoket
* WebSocket 通过 Flash
* XHR 长时间连接
* XHR Multipart Streaming
* 不可见的 Iframe
* `<script>` 标签的长时间连接(可跨域)

[参与互动](https://github.com/yisainan/web-interview/issues/867)

</details>

<b><details><summary>45. 模块化怎么做？</summary></b>

参考答案：

立即执行函数, 不暴露私有成员

```js
var module1 = (function() {
    var _count = 0;
    var m1 = function() {
        //...
    };
    var m2 = function() {
        //...
    };
    return {
        m1: m1,
        m2: m2
    };
})();
```

[参与互动](https://github.com/yisainan/web-interview/issues/868)

</details>

<b><details><summary>46. 简述一下你对 web 性能优化的方案</summary></b>

参考答案：

1、尽量减少 HTTP 请求
2、使用浏览器缓存
3、使用压缩组件
4、图片、JS 的预载入
5、将脚本放在底部
6、将样式文件放在页面顶部
7、使用外部的 JS 和 CSS
8、精简代码

[参与互动](https://github.com/yisainan/web-interview/issues/869)

</details>

<b><details><summary>47. 移动端性能优化</summary></b>

参考答案：

尽量使用 css3 动画，开启硬件加速。适当使用 touch 事件代替 click 事件。避免使用 css3 渐变阴影效果。 尽可能少的使用 box-shadow 与 gradients。box-shadow 与 gradients 往往都是页面的性能杀手

[参与互动](https://github.com/yisainan/web-interview/issues/870)

</details>

<b><details><summary>48. 请简要描述 web 前端性能需要考虑哪方面，你的优化思路是什么？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/871)

</details>

<b><details><summary>49. 业界常用的优化 WEB 页面加载速度的方法（可以分别从页面元素展现，请求连接，css, js, 服务器等方面介绍）</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/872)

</details>

<b><details><summary>50. 什么是响应式设计？</summary></b>

参考答案：它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常

[参与互动](https://github.com/yisainan/web-interview/issues/873)

</details>

<b><details><summary>51. 前端异常监控</summary></b>

参考答案：[前端异常监控](https://blog.csdn.net/screaming/article/details/51726150)

[参与互动](https://github.com/yisainan/web-interview/issues/874)

</details>

<b><details><summary>52. Ascii、GBK、UTF、Unicode</summary></b>

参考答案：

* Ascii（1 个字节 1 个字符）
* GBK 是国内的编码标准（汉字 2 个字节）
* Unicode 是国际编码标准（统一 2 个字节表示一个字符）
* UTF 是 Unicode 实现的另一个标准

  > unicode 同样也不完美，这里就有两个的问题，一个是，如何才能区别 unicode 和 ascii？<br>
  > 由于”半角”英文符号只需要用到低 8 位，所以其高 8 位永远是 0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间<br>
  > unicode 在很长一段时间内无法推广，直到互联网的出现，为解决 unicode 如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8 就是每次 8 个位传输数据，而 UTF-16 就是每次 16 个位。UTF-8 就是在互联网上使用最广的一种 unicode 的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度，当字符在 ASCII 码的范围时，就用一个字节表示，保留了 ASCII 字符一个字节的编码做为它的一部分，注意的是 unicode 一个中文字符占 2 个字节，而 UTF-8 一个中文字符占 3 个字节）。从 unicode 到 utf-8 并不是直接的对应，而是要过一些算法和规则来转换。

解析：[参考](https://www.zhihu.com/question/23374078/answer/69732605)

[参与互动](https://github.com/yisainan/web-interview/issues/875)

</details>

<b><details><summary>53. 页面大量图片，如何优化加载，优化用户体验</summary></b>

参考答案：

图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。

如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。

如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。

如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。

如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。

解析：[参考](https://www.jianshu.com/p/5d82bba9e1a1)

[参与互动](https://github.com/yisainan/web-interview/issues/876)

</details>

<b><details><summary>54. 渲染优化</summary></b>

参考答案：

```

1、禁止使用 iframe（阻塞父文档 onload 事件）；
*iframe 会阻塞主页面的 Onload 事件；
*搜索引擎的检索程序无法解读这种页面，不利于 SEO;
*iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript
动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。

2、禁止使用 gif 图片实现 loading 效果（降低 CPU 消耗，提升渲染性能）；
3、使用 CSS3 代码代替 JS 动画（尽可能避免重绘重排以及回流）css3 平面动画开启 translateZ(0)，打开浏览器 3d 加速，在一定程度可缓解卡顿。不宜多用；
4、对于一些小图标，可以使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费 CPU；
小图标优势在于： 1.减少 HTTP 请求； 2.避免文件跨域； 3.修改及时生效；
5、页面头部的 `<style></style>` 会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）；
6、页面头部 `<script</script>` 会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）；
7、页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)；
8、网页 Gzip，CDN 托管，data 缓存 ，图片服务器；
9、前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
10、用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
11、当需要设置的样式很多时设置 className 而不是直接操作 style。
12、少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。
13、避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。
14、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
15、 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。
对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。
向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，
能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，
本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），
减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。
16、通过改变 src 的情况下\*\*.MP3（不同于 mp3）在移动端有可能不能播放。
```

[参与互动](https://github.com/yisainan/web-interview/issues/877)

</details>

<b><details><summary>55. 什么是“前端路由"? 什么时候适合使用“前端路由"? “前端路由"有哪些优点和缺点?</summary></b>

参考答案：

1. 什么是前端路由？

   路由是根据不同的 url 地址展示不同的内容或页面

   前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。

2. 什么时候使用前端路由？

   在单页面应用，大部分页面结构不变，只改变部分内容的使用

3. 前端路由有什么优点和缺点？

   优点

   用户体验好，不需要每次都从服务器全部获取，快速展现给用户

   缺点

   使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存

   单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置

[参与互动](https://github.com/yisainan/web-interview/issues/878)

</details>

<b><details><summary>56. 前端项目监控怎么做的</summary></b>

参考答案：

</details>

<b><details><summary>57. 前后端分离的项目如何seo</summary></b>

参考答案：

</details>

<b><details><summary>58. 怎么判断页面是否加载完成？</summary></b>

参考答案：

</details>

<b><details><summary>59. 垃圾回收 新生代算法，老生代算法</summary></b>

参考答案：

</details>

<b><details><summary>60. 介绍MVP怎么组织（宝宝树）</summary></b>

参考答案：

</details>

<b><details><summary>61. 如何实现骨架屏，说说你的思路</summary></b>

参考答案：

</details>

<b><details><summary>62. 如何在 H5 和小程序项目中计算白屏时间和首屏时间，说说你的思路</summary></b>

参考答案：

</details>

<b><details><summary>63. 前端项目如何找出性能瓶颈（阿里）</summary></b>

参考答案：

</details>

<b><details><summary>64. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</summary></b>

参考答案：

</details>

<b><details><summary>65. 观察者和订阅-发布的区别，各自用在哪里（网易）</summary></b>

参考答案：

</details>

<b><details><summary>66. 文件上传如何做断点续传（网易）</summary></b>

参考答案：

</details>

<b><details><summary>67. npm2和npm3 有什么区别(宝宝树)</summary></b>

参考答案： npm3 和 npm2 对于依赖的处理不一样了，npm2所有项目依赖是嵌套关系，而npm3为了改进嵌套过多、套路过深的情况，会将所有依赖放在第二层依赖中（所有依赖只嵌套一次，彼此平行，也就是平铺的结构）

[参考](https://www.jianshu.com/p/69ba32550c08?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)

</details>

<b><details><summary>68. 移动端如何设计一个比较友好的Header组件？(携程)</summary></b>

参考答案：

</details>

<b><details><summary>69. 说说你对前端架构师的理解</summary></b>

参考答案：

1. 负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率； 
2. 带领团队完成研发工具及平台前端部分的设计、研发和维护； 
3. 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先； 
4. 负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。

</details>

<b><details><summary>70. 你如何对需求原型进行理解和拆分</summary></b>

参考答案：

</details>

<b><details><summary>71. 说说你对功能性需求的理解</summary></b>

参考答案：

</details>

<b><details><summary>72. 说说你对非功能性需求的理解</summary></b>

参考答案：

</details>

<b><details><summary>73. 你针对产品提出哪些交互和改进意见</summary></b>

参考答案：

</details>

<b><details><summary>74. 你如何理解用户痛点</summary></b>

参考答案：

</details>

<b><details><summary>75. 说说你在项目中使用过的UML 图</summary></b>

参考答案：

</details>

<b><details><summary>76. 你如何考虑组件化</summary></b>

参考答案：

</details>

<b><details><summary>77. 你如何考虑服务化</summary></b>

参考答案：

</details>

<b><details><summary>78. 你如何进行领域建模</summary></b>

参考答案：

</details>

<b><details><summary>79. 你如何划分领域边界</summary></b>

参考答案：

</details>

<b><details><summary>80. 说说你项目中的领域建模</summary></b>

参考答案：

</details>

<b><details><summary>81. 说说概要设计</summary></b>

参考答案：

</details>

<b><details><summary>82. 你使用过哪些设计模式，请介绍一下分别使用场景以及它们自身</summary></b>

参考答案：

</details>

<b><details><summary>83. 说说常用开源框架中设计模式使用分析</summary></b>

参考答案：

</details>

<b><details><summary>84. 说说你对设计原则的理解23种设计模式的设计理念</summary></b>

参考答案：

</details>

<b><details><summary>85. 设计模式之间的异同，例如策略模式与状态模式的区别</summary></b>

参考答案：

</details>

<b><details><summary>86. 设计模式之间的结合，例如策略模式 + 简单工厂模式的实践</summary></b>

参考答案：

</details>

<b><details><summary>87. 设计模式的性能，例如单例模式哪种性能更好。</summary></b>

参考答案：

</details>

<b><details><summary>88. 你系统中的前后端分离是如何做的</summary></b>

</details>

<b><details><summary>89. 说说你的开发流程</summary></b>

参考答案：

</details>

<b><details><summary>90. 你和团队是如何沟通的</summary></b>

参考答案：

</details>

<b><details><summary>91. 你如何进行代码评审</summary></b>

参考答案：

</details>

<b><details><summary>92. 说说你对技术与业务的理解</summary></b>

参考答案：

</details>

<b><details><summary>93. 说说你在项目中经常遇到的 Exception</summary></b>

参考答案：

</details>

<b><details><summary>94. 说说你在项目中遇到感觉最难 Bug，怎么解决的</summary></b>

参考答案：

</details>

<b><details><summary>95. 说说你在项目中遇到印象最深，最困难的地方，是怎么解决的</summary></b>

参考答案：

</details>

<b><details><summary>96. 你觉得你们项目还有哪些不足的地方</summary></b>

参考答案：

</details>

<b><details><summary>97. 你是否遇到过 CPU 100%，如何排查与解决</summary></b>

参考答案：

</details>

<b><details><summary>98. 你是否遇到过 内存 OOM，如何排查与解决</summary></b>

参考答案：

</details>

<b><details><summary>99. 说说你对敏捷开发的实践</summary></b>

参考答案：

</details>

<b><details><summary>100. 说说你对开发运维的实践</summary></b>

参考答案：

</details>

<b><details><summary>101. 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色</summary></b>

参考答案：

</details>

<b><details><summary>102. 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</summary></b>

参考答案：

</details>

<b><details><summary>103.在前后端分离项目里，请说说前端传递的token的流程？</summary></b>

参考答案：
```
（一）：cookie
    前端 post 账号密码，后端 response header: set-cookie, 将 token 插入 cookie 内，之后每次针对该域名下的请求都会带上 cookie。
（二）：jwt
    前端 post 账号密码，后端 generate jwt token 返回前端，前端根据 token 存储于 js 堆栈内，然后于发起请求的时候手动携带。
```

</details>

<b><details><summary>104.你觉得新开发一个网站最困难的是哪些部分？</summary></b>

参考答案：提高网站安全性，比如网站有论坛方面的功能，那需要保证不让黑客通过拦截请求信息，发起对论坛信息的破解。在比如DDOS 攻击

</details>

<b><details><summary>105.前端打包工具rollup、webpack、vite的区别</summary></b>

参考答案：

</details>

<b><details><summary>106.如何实现快速冷启动？</summary></b>

参考答案：

</details>

<b><details><summary>107.npm打包时需要注意哪些？如何利用webpack来更好的构建？</summary></b>

参考答案：

NPM模块需要注意以下问题：

1. 要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。
2. Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。
   并且如果ES5是经过转换的，请最好连同SourceMap一同上传。
3. Npm包大小应该是尽量小（有些仓库会限制包大小）
4. 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。
   这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。
5. UI组件类的模块应该将依赖的其它资源文件，例如`.css`文件也需要包含在发布的模块里。

基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化：

1.CommonJS模块化规范的解决方案： 设置output.libraryTarget='commonjs2'使输出的代码
  符合CommonJS2 模块化规范，以供给其它模块导入使用；输出ES5代码的解决方案：
  使用babel-loader把 ES6 代码转换成 2.ES5 的代码。再通过开启devtool: 'source-map'输出SourceMap
  以发布调试。
3.Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，
  最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，
  为其加入transform-runtime插件
4.不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。
5.对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：

```js
const ExtractTextPlugin = require('extract-text-webpack-plugin');

module.exports = {
  module: {
    rules: [
      {
        // 增加对 CSS 文件的支持
        test: /\.css/,
        // 提取出 Chunk 中的 CSS 代码到单独的文件中
        use: ExtractTextPlugin.extract({
          use: ['css-loader']
        }),
      },
    ]
  },
  plugins: [
    new ExtractTextPlugin({
      // 输出的 CSS 文件名称
      filename: 'index.css',
    }),
  ],
};
```

</details>

<b><details><summary></summary></b>

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 常见的浏览器内核有哪些？</summary></b>

参考答案：

Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]

Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite/SeaMonkey 等

Presto 内核：Opera7 及以上。 [Opera 内核原为：Presto，现为：Blink; ]

Webkit 内核：Safari, Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]

[参与互动](https://github.com/yisainan/web-interview/issues/328)

</details>

<b><details><summary>2. 如何实现浏览器内多个标签页之间的通信?</summary></b>

参考答案：调用 localstorge、cookies 等本地存储方式，注意sessionstorge不可以哦

[参与互动](https://github.com/yisainan/web-interview/issues/329)

</details>

<b><details><summary>3. 浏览器的渲染过程</summary></b>

参考答案：

1. 解析HTML生成DOM树。
2. 解析CSS生成CSSOM规则树。
3. 将DOM树与CSSOM规则树合并在一起生成渲染树。
4. 遍历渲染树开始布局，计算每个节点的位置大小信息。
5. 将渲染树每个节点绘制到屏幕。

解析：

* 使用 HTML 创建文档对象模型（DOM）
* 使用 CSS 创建 CSS 对象模型（CSSOM）
* 基于 DOM 和 CSSOM 执行脚本（Scripts）
* 合并 DOM 和 CSSOM 形成渲染树（Render Tree）
* 使用渲染树布局（Layout）所有元素
* 渲染（Paint）所有元素

[参考](https://jinlong.github.io/2017/05/08/optimising-the-front-end-for-the-browser/)

[参与互动](https://github.com/yisainan/web-interview/issues/330)

</details>

<b><details><summary>4. 为何会出现浏览器兼容问题</summary></b>

参考答案：

* 同一产品，版本越老 bug 越多
* 同一产品，版本越新，功能越多
* 不同产品，不同标准，不同实现方式

### 处理兼容问题的思路

1. 要不要做
* 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）
* 成本的角度 (有无必要做某件事)

2. 做到什么程度
* 让哪些浏览器支持哪些效果

3. 如何做
* 根据兼容需求选择技术框架/库(jquery)
* 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr)
* 条件注释、CSS Hack、js 能力检测做一些修补

* 渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
* 优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

解析：[参考](https://github.com/jirengu/frontend-interview/issues/35)

[参与互动](https://github.com/yisainan/web-interview/issues/331)

</details>

<b><details><summary>5. 跨标签页的通讯方式有哪些（哔哩哔哩）</summary></b>

参考答案：

```
(1) BroadCast Channel
(2) Service Worker
(3) LocalStorage + window.onstorage监听
(4) Shared Worker + 定时器轮询(setInterval)
(5) IndexedDB + 定时器轮询(setInterval)
(6) cookie + 定时器轮询(setInterval)
(7) window.open + window.postMessage
(8) Websocket
```

</details>

<b><details><summary>6. 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？</summary></b>

参考答案：

状态 类型 说明
200 form memory cache 不请求网络资源，资源在内存当中
200 form disk ceche 不请求网络资源，在磁盘当中
200 资源大小数值 从服务器下载最新资源
304 报文大小 请求服务端发现资源没有更新，使用本地资源

#### 一、前言

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。

![图形说明](../images/浏览器_002.png)

#### 二、缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

1. Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

2. Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源, 例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快, 内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？ 这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。

当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存

内存缓存中有一块重要的缓存资源是preloader相关指令（例如 ）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。

需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

3. Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。

浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住：

对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘

4. Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： - 所有的资源都能被推送，并且能够被缓存, 但是 Edge 和 Safari 浏览器支持相对比较差 - 可以推送 no-cache 和 no-store 的资源 - 一旦连接被关闭，Push Cache 就被释放 - 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 - Push Cache 中的缓存只能被使用一次 - 浏览器可以拒绝接受已经存在的资源推送 - 你可以给其他域名推送资源

如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。

那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。

解析：[参考](https://developer.aliyun.com/ask/288781)

</details>

<b><details><summary>7. 浏览器如何解析css选择器？</summary></b>

参考答案：

CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。
而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。

</details>

<b><details><summary>8. 浏览器是如何渲染UI的？</summary></b>

参考答案：

　　① 浏览器将获取的HTML文档解析成DOM树

　　② 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)

　　③ 将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象

　　④ 渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素

　　⑤ 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting

图形说明：

![图形说明](../images/浏览器_001.png)

解析：[参考](https://www.cnblogs.com/gwf93/p/10717281.html)

</details>

<b><details><summary>9. 浏览器的主要组成部分是什么？</summary></b>

参考答案：

```

       1. 用户界面:

          用户界面主要包括：地址栏，后退/前进按钮，书签目录等；（除了从服务器请求到的网页窗口）

       2. 浏览器引擎：

          用来查询及操作渲染引擎的接口；

       3. 渲染引擎：

         用来显示请求的html内容；（包括样式，图片，js）     

       4. 网络：

          主要是来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作；

        5. UI后端：

            用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。

       6. JS解释器 ：

          用来解释执行JS代码；

        7. 数据存储：

           属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术；

```

</details>

<b><details><summary>10. 浏览器性能问题-使用 Webpack 优化项目</summary></b>

参考答案：

</details>

<b><details><summary>11. 怎样选择合适的缓存策略</summary></b>

参考答案：

众所周知，想要提高系统的性能，缓存是最直接也是最简单的方法之一。缓存一方面可以减少数据库负载，另一方面还可以减少相应时间并且节省成本。今天，小编将向大家介绍几种比较常见的缓存策略，即Cache-Aside、Read-Though Cache、Write-Through Cache、Write-Around和Write-Back。下面让我们一起对比分析一下常用缓存策略的优劣以及使用场景吧！

解析：[参考](https://www.boxuegu.com/news/2860.html)

</details>

<b><details><summary>12. 说说浏览器缓存机制</summary></b>

参考答案：过期机制、验证机制

解析：

对于浏览器的缓存来讲，这些规则是在HTTP协议头部和HTML页面的Meta标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。

过期机制：指的是缓存副本的有效期。一个缓存的副本必须满足以下条件，浏览器会认为它是有效的，足够新的：
1. 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内
2. 浏览器已经使用过这个缓存的副本，并且会在一个会话中已经检查过新鲜度(即服务器上的资源是否发生改变)
满足以上两种情况的一种，浏览器会直接从缓存中获取副本进行渲染

校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag(Entity Tag), 它可以用来作为浏览器再次请求过程中的校验标识，如果发现校验标识不匹配，说明资源已经被修改或者过期，浏览器需要重新获取资源内容。

[参考](https://blog.csdn.net/hhthwx/article/details/80152728)

</details>

<b><details><summary>12. 列举 IE 与其他浏览器不一样的特性？</summary></b>

参考答案：

a. IE 的排版引擎是 Trident （又称为 MSHTML）

b. Trident 内核曾经几乎与 W3C 标准脱节（2005 年）

c. Trident 内核的大量 Bug 等安全性问题没有得到及时解决

d. JS 方面，有很多独立的方法，例如绑定事件的 attachEvent、创建事件的 createEventObject 等

e. CSS 方面，也有自己独有的处理方式，例如设置透明，低版本 IE 中使用滤镜的方式

[参与互动](https://github.com/yisainan/web-interview/issues/13)

</details>

<b><details><summary>13. 你对浏览器的理解？</summary></b>

参考答案：

   ```
   浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常
   是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请
   求资源的位置。

   HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的
   组织。

   但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。

   简单来说浏览器可以分为两部分，shell 和 内核。

   其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，
   参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些
    浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。
   ```

</details>

<b><details><summary>14. 介绍一下你对浏览器内核的理解？</summary></b>

参考答案：

   ```
   主要分成两部分：渲染引擎和 JS 引擎。

   渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也
   可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。

   JS 引擎：解析和执行 javascript 来实现网页的动态效果。

   最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。
   ```
</details>

<b><details><summary>15. 常见的浏览器内核比较</summary></b>

参考答案：

   ```
   Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多
   网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微
   软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等
   安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

   Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩
   展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

   Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的
   天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

   Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trid
   ent，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 
   前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。

   Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 B
   link 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是
   KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 
   内核，加入 Google 阵营，跟随谷歌一起研发 Blink。

   ```
   详细的资料可以参考：
   [《浏览器内核的解析和对比》](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)
   [《五大主流浏览器内核的源起以及国内各大浏览器内核总结》](https://blog.csdn.net/Summer_15/article/details/71249203)

</details>

<b><details><summary>16. 常见浏览器所用内核</summary></b>

参考答案：

   ```
    （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；

    （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；

    （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；

    （4） Safari 浏览器内核：Webkit 内核；

    （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；

    （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；

    （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；

    （8） 百度浏览器、世界之窗内核：IE 内核；

    （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；

    （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说
         是基于火狐内核。
   ```
</details>

<b><details><summary>17. 浏览器的渲染原理？</summary></b>

参考答案：

   ```
    （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

    （2）然后对 CSS 进行解析，生成 CSSOM 规则树。

    （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

    （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

    （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

     值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
   ```
   详细资料可以参考：
   [《浏览器渲染原理》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d)
   [《浏览器的渲染原理简介》](https://coolshell.cn/articles/9666.html)
   [《前端必读：浏览器内部工作原理》](https://kb.cnblogs.com/page/129756/)
   [《深入浅出浏览器渲染原理》](https://blog.fundebug.com/2019/01/03/understand-browser-rendering/)
</details>

<b><details><summary>18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</summary></b>

参考答案：

   ```
    JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么
    它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解
    析文档。

    也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的
    原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。
   ```

</details>

<b><details><summary>19. 说说你对Service worker的理解</summary></b>

参考答案：一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker 那么它可以拦截当前网站所有的请求，进行判断（需要编写相应的判断程序），如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存不再转给服务器。从而大大提高浏览体验。

</details>

<b><details><summary>20. 说说你对Web Worker的理解</summary></b>

参考答案：Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

</details>

<b><details><summary>21. 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响</summary></b>

参考答案：

</details>

<b><details><summary>22. 浏览器 Eventloop 和 Node 中的有什么区别</summary></b>

参考答案：

</details>

<b><details><summary>23. 事件循环（event loop）以及异步执行顺序（setTimeout、promise和async/await）</summary></b>

参考答案：

> 来自文章结语
1. JS是单线程执行的，同一时间只能处理一件事。但是浏览器是有多个线程的，JS引擎通过分发这些耗时的异步事件（AJAX请求、DOM操作等）给Wep APIs线程处理，因此避免了单线程被耗时的异步事件阻塞的问题。

2. Web APIs线程会将接收到的所有事件中已完成的事件根据类别分别将它们添加到相应的任务队列中。其中任务队列分以下两种：

    1. 宏任务队列（macrotask queue）：其实是叫任务队列，ES5称task queue，也即本文图中的callback queue，macrotask是我们给它的别名，原因只是为了与ES6新增的microtask队列作区分而这样称呼，HTML标准中并没有macrotask这种说法。它存放的是DOM事件、AJAX事件、setTimeout事件等。
    2. 微任务队列（microtask queue）：它存放的是Promise事件、nextTick事件等。优先级比macrotask高。

3. 事件循环（event loop） 机制是为了协调事件（events）、用户交互（user interaction）、JS脚本（scripts）、页面渲染（rendering）、网络请求（networking）等等事件的有序执行而设置（定义由HTML标准给出，实现方式是靠各个浏览器厂商自己实现）。事件循环的过程如下：

    1. JS引擎执行一个事件，当遇到异步事件时则将其交给浏览器的Web APIs线程处理，然后该事件继续执行，永远不会被抢占，一直执行到该事件结束为止（run to complete）。
    2. 当JS引擎执行完当前事件（即执行栈变为空）之后，它会先去查看microtask队列，将microtask队列中的所有待执行事件全部执行完毕。
    3. 等微任务事件全部执行完毕后，再进行页面的渲染，此时表明一轮事件循环的过程结束。然后再去查看macrotask队列，取出一个宏事件添加到执行栈执行，开始一轮新的事件，执行完毕后再去执行所有微任务事件…如此往复。此即事件循环的执行过程。

打个比方帮助理解：宏任务事件就像是普通用户，而微任务事件就像是VIP用户，执行栈要先把所有在等待的VIP用户服务好了以后才能给在等待的普通用户服务，而且每次服务完一个普通用户以后都要先看看有没有VIP用户在等待，若有，则VIP用户优先（PS：人民币玩家真的可以为所欲为，hah…）。当然，执行栈正在给一个普通用户服务的时候，这时即使来了VIP用户，他也是需要等待执行栈服务完该普通用户后才能轮到他。

4. setTimeout设置的时间其实只是最小延迟时间，并不是确切的等待时间。实际上最小延时 >=4ms，小于4ms的会被当做4ms。

5. promise 对象是由关键字 new 及Promise构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数（即 new Promise(...)中的...的内容）。这个“处理器函数”是在promise创建时是自动执行的，.then之后的内容才是异步内容，会交给Web APIs处理，然后被添加到微任务队列。

6. async/await：async函数其实是Generator函数的语法糖（解释一下“语法糖”：就是添加标准以外的语法以方便开发人员使用，本质上还是基于已有标准提供的语法进行封装来实现的），async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。执行async函数时，遇到await关键字时，await 语句产生一个promise，await 语句之后的代码被暂停执行，等promise有结果（状态变为settled）以后再接着执行。

解析:[参考地址](https://blog.csdn.net/cc18868876837/article/details/97107219)

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

如今前端市场一片混乱，典型的金字塔形状，前端从业人员很多，但高级开发及以上却非常稀缺。前端招聘也是所有猎头及 HR 的痛点所在，在这种混乱的环境中，如何让自己突出重围？需要实力，也需要技巧。这里的技巧指的就是如何写一份好的前端简历

## 注意事项

开发者最好像做项目一样维护一份自己的简历，需要的时候直接丢出去。很多同学跳槽一次，抓耳捞腮的写一次，简历质量可想而知。可以每做一个项目或者每有一段收获都整理一下，浓缩在简历里。实际写简历中可以按照以下方式写2-3家，项目经验也一样可以多写几个。不管工作经历还是项目经验都不需要过于冗余，多写精品。真正的一份好技术简历，不是在于内容有多少，而是你的内容到底是否有逼格！对于已经毕业 2 年以上的，学生时期的经历（学生会主席、拿过什么什么奖学金）就可以不用写了。

1. 简历页数：2页最佳；
2. 文件格式：word和pdf，推荐pdf；
3. 文件名字：李四-高级前端开发-3年.pdf；
4. 简历照片：不要附加照片；
5. 文档字体：通常来说选用宋体5号字，正文行间距在1.2左右；
6. 联系方式：不要在简历中写自己的微信号、QQ号。联系方式只留下一个邮箱和手机号即可。邮箱最好是126、163、outlook或者gmail，不建议使用qq邮箱；

## 注意用词

简历中对某项技术的描述一般有以下几个词语：

>了解：理解基本概念，有过简单的使用经验 —— “用过” 熟悉：基本操作很熟练，有过密集的使用经验 ——“用得不少” 精通：深入理解其底层原理及各种实现方式，并有丰富的项目经验——“有研究”

切记准确用词，慎用“精通”！！

## 标题

如：李四的个人简历

## 个人信息
```
姓名：李四 性别：男
毕业院校：xx学校/xxx专业
工作年限：3年
应聘职位：前端开发
GitHub地址：https://github.com/xxx（此处可选其他技术站点）
联系邮箱：xxx@163.com
```
## 专业技能
```
3年web开发设计经验，具有多端（H5，Native App，微信小程序，Nodejs服务端）开发能力；
熟练原生JavaScript语言并有开发公用组件的经验，对于主流框架Vue.js及React.js有3个以上大型项目开发经验；
熟悉性能优化，对于webpack等前端工程化解决方案有较深的涉及；
熟悉产品设计研发上线以及版本迭代流程和项目管理流程；
.....
总之要多写自己的强项！
```
## 工作经历

如：

```
2016/09 - 至今  XXX公司 | WEB高级前端
岗位职责：
负责前端项目需求分析，技术选型，项目架构搭建和整体业务流程把控；
负责项目中所以公用代码的封装及优化，制定规范的代码结构；
配合后端完成项目中测试环境及线上环境的数据完整性；

2014/09 - 2016/09  XXX公司 | WEB中级前端
岗位职责：
负责前端项目需求分析，技术选型，项目架构搭建和整体业务流程把控；
负责项目中所以公用代码的封装及优化，制定规范的代码结构；
配合后端完成项目中测试环境及线上环境的数据完整性；

2011/09 - 2014/09  XXX公司 | WEB初级前端
岗位职责：
负责前端项目需求分析，技术选型，项目架构搭建和整体业务流程把控；
负责项目中所以公用代码的封装及优化，制定规范的代码结构；
配合后端完成项目中测试环境及线上环境的数据完整性；
```

## 自我评价

如：有三年的前端开发经验，能快速对接产品需求、前后端工作。对web前端有很大的兴趣并有独立自主学习的能力，具备独立分析并解决问题的能力。业余时间会自主钻研前端技术丰富自己的前端技能栈。代码强迫症患者，注重团队合作，具有良好的沟通能力。
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

链接：https://pan.baidu.com/s/1bxs9HrmewXFVN6G9CVMjjA 提取码：a7Hw 

若链接失效，请关注公众号，加群获取。---
name: 浏览器面试题模板
about: 这是一个用于发布浏览器面试题的模板
title: "[浏览器] "
labels: 浏览器
assignees: ''

---


# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1.用 H5+CSS3 解决下导航栏最后一项掉下来的问题</summary></b>

参考答案：box-sizing: border-box;

</details>

<b><details><summary>2.请用 CSS 实现：一个矩形内容，有投影，有圆角，hover 状态慢慢变透明</summary></b>

参考答案：

```html
<div class="test"></div>
```

```css
.test {
  width: 200px;
  height: 100px;
  border-radius: 10px;
  box-shadow: 10px 10px 5px #888888;
  background-color: green;
  transition: 0.7s;
}
.test:hover {
  opacity: 0;
}
```

</details>

<b><details><summary>3.描述下 CSS3 里实现元素动画的方法</summary></b>

参考答案：

1. 创建动画：@keyframes 规则

方式一：from{属性：值;} to{属性：值;}

```css
@keyframes myflash {
  from {
    width: 200px;
    height: 200px;
  }
  to {
    position: relative;
    left: 50px;
    transform: rotate(360deg);
  }
}
```

方式二：0%{属性：值;} 100%{属性：值;}
0% 是动画的开始，100% 是动画的完成。可以在二者之间加入 25%，50%等

```css
@keyframes myflash {
  0% {
    background: red;
  }
  50% {
    background: yellow;
  }
  75% {
    background: green;
  }
  100% {
    background: blue;
  }
}
```

2. 将动画绑定到选择器

在样式中，设置动画属性 animation，自定义动画名称和时长。

animation：动画名 时长；

此时就可以完成一个简单的动画了，要进行更多设置还需要其他属性。

```css
#first {
  animation: myflash 10s;
  animation-delay: 2s;
  animation-iteration-count: 2;
  animation-timing-function: ease-in;
}
```

解析：[参考](https://jingyan.baidu.com/article/363872ec01c1146e4ba16fa5.html)

</details>

<b><details><summary>4.你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计?</summary></b>

参考答案：

</details>

<b><details><summary>5.如何用css实现瀑布流布局</summary></b>

参考答案：
利用column-count和break-inside这两个CSS3属性即可，复制如下代码即可察看效果
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }
        .waterfall-container {
            /*分几列*/
            column-count: 2;
            width: 100%;
            /* 列间距 */
            column-gap: 10px;
        }

        .waterfall-item {
            break-inside: avoid;
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
            background: #ddd;
            column-gap: 0;
            text-align: center;
            color: #fff;
            font-size: 40px;
        }
    </style>
</head>
<body>
    <div class="waterfall-container">
        <div class="waterfall-item" style="height: 100px">1</div>
        <div class="waterfall-item" style="height: 300px">2</div>
        <div class="waterfall-item" style="height: 400px">3</div>
        <div class="waterfall-item" style="height: 100px">4</div>
        <div class="waterfall-item" style="height: 300px">5</div>
        <div class="waterfall-item" style="height: 600px">6</div>
        <div class="waterfall-item" style="height: 400px">7</div>
        <div class="waterfall-item" style="height: 300px">8</div>
        <div class="waterfall-item" style="height: 700px">9</div>
        <div class="waterfall-item" style="height: 100px">10</div>
    </div>
</body>
</html>
```

</details>

<b><details><summary>6.已知父级盒子的宽高，子级img宽高未知，想让img铺满父级盒子且图片不能变形</summary></b>

参考答案：需要用到`css`的`object-fit`属性

```css
div {
    width: 200px;
    height: 200px;
}
img {
    object-fit: cover;
    width: 100%;
    height: 100%;
}
```

解析：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit)

</details>

<b><details><summary>7.有下面这样一段 HTML 结构，使用 css 实现这样的效果：</summary></b>

```html
<!-- 左边容器无论宽度如何变动，右边容器都能自适应填满父容器剩余的宽度。 -->
<div class="warp">
  <div class="left"></div>
  <div class="right"></div>
</div>
```

参考答案：

</details>

<b><details><summary></summary></b>

参考答案：

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1.请写出一张图片的 HTML 代码，已知道图片地址为"images/abc.jpg",宽 100px，高 50px</summary></b>

参考答案：

```html
<img src="images/abc.jpg"  alt="" width="100" height="50"/>
```

</details>

<b><details><summary>2.canvas绘制五角星</summary></b>

参考答案：

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>canvas绘制五角星 </title>
  <script type="text/javascript" >
    window.onload = function () {
      var canvas = document.getElementById("canvas");
      if (canvas) {
        var context = canvas.getContext("2d");
        drawStar(context, 50, 100, 100);
      } else {
        document.writeln("浏览器不支持canvas组件");
      }
    }
    function drawStar(context, r, x, y) {
      context.lineWidth = 5;
      context.beginPath();
      var dit = Math.PI * 4 / 5;
      var sin = Math.sin(0) * r + y;
      var cos = Math.cos(0) * r + x;
      console.log(0+":"+0);
      context.moveTo(cos, sin);
      for (var i = 0; i < 5; i++) {
        var tempDit = dit * i;
        sin = Math.sin(tempDit) * r + y;
        cos = Math.cos(tempDit) * r + x;
        context.lineTo(cos, sin);
        console.log(sin+":"+sin+":"+tempDit);
      }
      context.closePath();
      context.strokeStyle = "red";
      context.fillStyle = "#ffc107";
      context.fill();
    }
  </script>
</head>
<body>
<canvas id="canvas" ></canvas>
</body>
</html>
```

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. 如何获取浏览器 URL 中查询字符串中的参数？</summary></b>

参考答案：

方法一：(基础版)

``` js
function getQueryString() {
    var sHref = window.location.href;
    var args = sHref.split("?");
    if (args[0] == sHref) {
        // 没有参数，直接返回空即可
        return "";
    }
    var arr = args[1].split("&");
    var obj = {};
    for (var i = 0; i < arr.length; i++) {
        var arg = arr[i].split("=");
        obj[arg[0]] = arg[1];
    }
    return obj;
}
var href = getQueryString();
console.log(href["categoryId"]);
```

方法二：(正则版, URL 存在#则不适用)

``` js
function getQueryString(name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) return unescape(r[2]);
    return null;
}
console.log(getQueryString("categoryId"));
```

方法三：(正则升级版)

``` js
function getQueryString(name) {
    // 未传参，返回空
    if (!name) return null;
    // 查询参数：先通过search取值，如果取不到就通过hash来取
    var after = window.location.search;
    after = after.substr(1) || window.location.hash.split("?")[1];
    // 地址栏URL没有查询参数，返回空
    if (!after) return null;
    // 如果查询参数中没有"name"，返回空
    if (after.indexOf(name) === -1) return null;
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
    // 当地址栏参数存在中文时，需要解码，不然会乱码
    var r = decodeURI(after).match(reg);
    // 如果url中"name"没有值，返回空
    if (!r) return null;
    return r[2];
}
console.log(getQueryString("categoryId"));
```

[参与互动](https://github.com/yisainan/web-interview/issues/549)

</details>

<b><details><summary>2. js 实现一个打点计时器</summary></b>

问题描述：

1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console. log 一个数字，每次数字增幅 1
2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作
3、第一个数需要立即输出

参考答案：

``` js
// 实现法一（setTimeout()方法）：

function count(start, end) {
    if (start <= end) {
        console.log(start++);
        st = setTimeout(function() {
            count(start, end);
        }, 100);
    }
    return {
        cancel: function() {
            clearTimeout(st);
        }
    };
}
count(1, 10);

// 实现法二（setInterval()方法）：

function count(start, end) {
    console.log(start++);
    var timer = setInterval(function() {
        if (start <= end) {
            console.log(start++);
        }
    }, 100);
    return {
        cancel: function() {
            clearInterval(timer);
        }
    };
}
count(1, 10);
```

知识点：
setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。
语法：setTimeout(code, millisec)
注意：setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。

setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。
语法：setInterval(code , millisec[, "lang"])
setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。

[参与互动](https://github.com/yisainan/web-interview/issues/550)

</details>

<b><details><summary>3. 用 js 实现一个标准的排序算法</summary></b>

参考答案：

一. 冒泡排序

> 它是最慢的排序算法之一，但也是一种最容易实现的排序算法。
> 之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时将它们进行互换。

``` js
function BubbleSort(array) {
    var length = array.length;
    for (var i = length - 1; i > 0; i--) {
        //用于缩小范围
        for (var j = 0; j < i; j++) {
            //在范围内进行冒泡，在此范围内最大的一个将冒到最后面
            if (array[j] > array[j + 1]) {
                var temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
        console.log(array);
        console.log("-----------------------------");
    }
    return array;
}

var arr = [10, 9, 8, 7, 7, 6, 5, 11, 3];
var result = BubbleSort(arr);
console.log(result);
/*
[ 9, 8, 7, 7, 6, 5, 10, 3, 11 ]
-----------------------------
[ 8, 7, 7, 6, 5, 9, 3, 10, 11 ]
-----------------------------
[ 7, 7, 6, 5, 8, 3, 9, 10, 11 ]
-----------------------------
[ 7, 6, 5, 7, 3, 8, 9, 10, 11 ]
-----------------------------
[ 6, 5, 7, 3, 7, 8, 9, 10, 11 ]
-----------------------------
[ 5, 6, 3, 7, 7, 8, 9, 10, 11 ]
-----------------------------
[ 5, 3, 6, 7, 7, 8, 9, 10, 11 ]
-----------------------------
[ 3, 5, 6, 7, 7, 8, 9, 10, 11 ]
-----------------------------
[ 3, 5, 6, 7, 7, 8, 9, 10, 11 ]
*/
```

二. 选择排序

> 选择排序从数组的开头开始，将第一个元素和其他元素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有数据便完成了排序。

``` js
function SelectionSort(array) {
    var length = array.length;
    for (var i = 0; i < length; i++) {
        //缩小选择的范围
        var min = array[i]; //假定范围内第一个为最小值
        var index = i; //记录最小值的下标
        for (var j = i + 1; j < length; j++) {
            //在范围内选取最小值
            if (array[j] < min) {
                min = array[j];
                index = j;
            }
        }
        if (index != i) {
            //把范围内最小值交换到范围内第一个
            var temp = array[i];
            array[i] = array[index];
            array[index] = temp;
        }
        console.log(array);
        console.log("---------------------");
    }
    return array;
}

var arr = [1, 10, 100, 90, 65, 5, 4, 10, 2, 4];
var result = SelectionSort(arr);
console.log(result);
/*
[ 1, 10, 100, 90, 65, 5, 4, 10, 2, 4 ]
---------------------
[ 1, 2, 100, 90, 65, 5, 4, 10, 10, 4 ]
---------------------
[ 1, 2, 4, 90, 65, 5, 100, 10, 10, 4 ]
---------------------
[ 1, 2, 4, 4, 65, 5, 100, 10, 10, 90 ]
---------------------
[ 1, 2, 4, 4, 5, 65, 100, 10, 10, 90 ]
---------------------
[ 1, 2, 4, 4, 5, 10, 100, 65, 10, 90 ]
---------------------
[ 1, 2, 4, 4, 5, 10, 10, 65, 100, 90 ]
---------------------
[ 1, 2, 4, 4, 5, 10, 10, 65, 100, 90 ]
---------------------
[ 1, 2, 4, 4, 5, 10, 10, 65, 90, 100 ]
---------------------
[ 1, 2, 4, 4, 5, 10, 10, 65, 90, 100 ]
---------------------
[ 1, 2, 4, 4, 5, 10, 10, 65, 90, 100 ]
*/
```

三. 插入排序

> 插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。

``` js
function InsertionSort(array) {
    var length = array.length;
    for (var i = 0; i < length - 1; i++) {
        //i代表已经排序好的序列最后一项下标
        var insert = array[i + 1];
        var index = i + 1; //记录要被插入的下标
        for (var j = i; j >= 0; j--) {
            if (insert < array[j]) {
                //要插入的项比它小，往后移动
                array[j + 1] = array[j];
                index = j;
            }
        }
        array[index] = insert;
        console.log(array);
        console.log("-----------------------");
    }
    return array;
}

var arr = [100, 90, 80, 62, 80, 8, 1, 2, 39];
var result = InsertionSort(arr);
console.log(result);
/*
[ 90, 100, 80, 62, 80, 8, 1, 2, 39 ]
-----------------------
[ 80, 90, 100, 62, 80, 8, 1, 2, 39 ]
-----------------------
[ 62, 80, 90, 100, 80, 8, 1, 2, 39 ]
-----------------------
[ 62, 80, 80, 90, 100, 8, 1, 2, 39 ]
-----------------------
[ 8, 62, 80, 80, 90, 100, 1, 2, 39 ]
-----------------------
[ 1, 8, 62, 80, 80, 90, 100, 2, 39 ]
-----------------------
[ 1, 2, 8, 62, 80, 80, 90, 100, 39 ]
-----------------------
[ 1, 2, 8, 39, 62, 80, 80, 90, 100 ]
-----------------------
[ 1, 2, 8, 39, 62, 80, 80, 90, 100 ]
*/
```

四. 希尔排序

> 希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。

```js
function shellSort(arr) {
  let len = arr.length;
  // gap 即为增量
  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
    for (let i = gap; i < len; i++) {
      let j = i;
      let current = arr[i];
      while(j - gap >= 0 && current < arr[j - gap]) {
        arr[j] = arr[j - gap];
        j = j - gap;
      }
      arr[j] = current;
    }
    console.log(arr);
    console.log("-----------------------");
  }
}

var arr = [3,5,7,1,4,56,12,78,25,0,9,8,42,37];
shellSort(arr);

/*
[3, 5, 0, 1, 4, 42, 12, 78, 25, 7, 9, 8, 56, 37]
-----------------------
[1, 4, 0, 3, 5, 8, 7, 9, 25, 12, 37, 42, 56, 78]
-----------------------
[0, 1, 3, 4, 5, 7, 8, 9, 12, 25, 37, 42, 56, 78]
-----------------------
*/
```

五. 归并排序

> 归并排序把一系列排好序的子序列合并成一个大的完整有序序列。我们需要两个排好序的子数组，然后通过比较数据大小，从最小的数据开始插入，最后合并得到第三个数组。然而，在实际情况中，归并排序还有一些问题，我们需要更大的空间来合并存储两个子数组。

```js
var array = [3,5,7,1,4,56,12,78,25,0,9,8,42,37];
console.log(array);
console.log("-----------------------");
var len = array.length;
sort(0,len);
console.log(array);
function sort(begin,end) {
    if (end - begin < 2) {
        return;
    }
    let mid = (begin + end) >> 1;
    sort(begin, mid);
    sort(mid, end);
    merge(begin,mid,end);
}
function merge(begin,mid,end) {
    let li = 0,le = mid - begin;
    let ri = mid,re = end;
    let ai = begin;
    let leftArray = [];
    for (let i = li;i<le;i++) {
        leftArray[i] = array[begin + i];
    }
    while(li < le){
        if(ri < re && array[ri] < leftArray[li]){
            array[ai++] = array[ri++];
        }else{
            array[ai++] = leftArray[li++];
        }
    }
}
/*
[3, 5, 7, 1, 4, 56, 12, 78, 25, 0, 9, 8, 42, 37]
-----------------------
[0, 1, 3, 4, 5, 7, 8, 9, 12, 25, 37, 42, 56, 78]
*/
```

六. 快速排序

> 快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方法将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。
这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。

```js
function quickSort(arr, i, j) {
  if(i < j) {
    let left = i;
    let right = j;
    let pivot = arr[left];
    while(i < j) {
      while(arr[j] >= pivot && i < j) {  // 从后往前找比基准小的数
        j--;
      }
      if(i < j) {
        arr[i++] = arr[j];
      }
      while(arr[i] <= pivot && i < j) {  // 从前往后找比基准大的数
        i++;
      }
      if(i < j) {
        arr[j--] = arr[i];
      }
    }
    arr[i] = pivot;
    quickSort(arr, left, i-1);
    quickSort(arr, i+1, right);
    return arr;
  }
}

let arr = [2, 10, 4, 1, 0, 9, 5 ,2];
console.log(quickSort(arr, 0 , arr.length-1));
/*
[0, 1, 2, 2, 4, 5, 9, 10]
*/
```


[参与互动](https://github.com/yisainan/web-interview/issues/551)

</details>

<b><details><summary>4. 正则表达式，验证手机号码，验证规则：11 位数字，以 1 位开头</summary></b>

参考答案：

``` js
checkphonenumber(number) {
    if (number == null || number.length != 11) {
        return false
    } else {
        // 移动号段正则表达式
        var pat1 = '^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\d{8}|(1705)\\d{7}$';
        // 联通号段正则表达式
        var pat2 = '^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\d{8}|(1709)\\d{7}$';
        // 电信号段正则表达式
        var pat3 = '^((133)|(153)|(177)|(18[0,1,9])|(149))\\d{8}$';
        // 虚拟运营商正则表达式
        var pat4 = '^((170))\\d{8}|(1718)|(1719)\\d{7}$';
        if (!part1.test(number)) {
            return false
        }
        if (!part2.test(number)) {
            return false
        }
        if (!part3.test(number)) {
            return false
        }
        if (!part4.test(number)) {
            return false
        }
    }
    return true
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/552)

</details>

<b><details><summary>5. 请给 Array 本地对象增加一个原型方法，用于删除数组中重复的条目并按升序排序，返回值是被删除条目的新数组</summary></b>

参考答案：

``` js
Array.prototype.distinct = function() {
    var ret = [];
    for (var i = 0; i < this.length; i++) {
        for (var j = i + 1; j < this.length;) {
            if (this[i] === this[j]) {
                ret.push(this.splice(j, 1)[0]);
            } else {
                j++;
            }
        }
    }
    return ret;
};
let arr = ["a", "b", "c", "d", "b", "a", "e"];
console.log(arr.distinct()); // ['a', 'b']
console.log(arr); // ['a', 'b', 'c', 'd', 'e']
```

[参与互动](https://github.com/yisainan/web-interview/issues/553)

</details>

<b><details><summary>6. 为字符串扩展一个 rewrite 函数，接收一个正则 pattern 和一个字符串 result, 如果该字符串符合 pattern， 则以 result 对结果进行转义输出。</summary></b>

参考答案：

``` js
"/foo".rewrite(/^\/foo/, "/bar");
"u1234".rewrite(/^\/u(\d+)/, "/user/$1");
"/i".rewrite(/^\o/, "/ooo");
```

[参与互动](https://github.com/yisainan/web-interview/issues/554)

</details>

<b><details><summary>7. 实现一个 js 对象序列化函数，将 js 对象序列化为可反序列化的代码，要求 1. 尽量和 json 兼容，2. 支持不可序列化的值，如 undefined/NaN/Infinify-Infinity，3. 支持特殊对象，如正则、Date 等</summary></b>

参考答案：

``` js
serialize({});
serialize({
    a: "b"
});
serialize({
    a: 0 / 0
});
serialize({
    a: /foo/
});
```

[参与互动](https://github.com/yisainan/web-interview/issues/555)

</details>

<b><details><summary>8. 设计一道 JavaScript 的 range 算法如下：</summary></b>

range(1, 10, 3) 返回 [1, 4, 7, 10]; 
range('A', 'F', 2) 返回 ['A', 'C', 'E']; 
请使用 JavaScript 语言实现该功能（可以使用 ES6）

参考答案：

``` js
function range() {
    var args = [].slice.call(arguments); // 相当于Array.slice.call(arguments)，目的是将arguments对象的数组提出来转化为数组，arguments本身并不是数组而是对象
    var str = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
    var result = [];
    if (args.length > 2) {
        if (typeof args[0] === 'number') { // 如果是number型数据
            for (var i = args[0]; i <= args[1]; i = i + args[2]) {
                result.push(i);
            }
        } else {
            for (var i = str.indexOf(args[0]); i <= str.indexOf(args[1]); i = i + args[2]) {
                result.push(str[i]);
            }
        }
    }
    return result;
}

range(1, 10, 3); //  [1, 4, 7, 10]
// range('A', 'F', 2); // ['A', 'C', 'E']
```

[参与互动](https://github.com/yisainan/web-interview/issues/556)

</details>

<b><details><summary>9. 头条的视频网站上支持了弹幕，假设一个视频有很多弹幕，弹幕的数据是一个数组，格式定义如下：</summary></b>

``` 

[
    {
        time: Number,
        content: String
    },
    {
        time: Number,
        content: String
    }...
]
(其中 time 表示时间，content表示弹幕内容)，那么如何快速定位到某个时间点的弹幕，请编码实现（不使用数组的 sort 方法）

```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/557)

</details>

<b><details><summary>10. 请写出以下代码的执行结果</summary></b>

``` 
(function() {
    fn();
    var fn = function() {
        alert(1);
    }
    fn();
    function fn() {
        alert(2)
    }
})()
```

参考答案：

第一次弹出2，第二个弹出1

``` 
// 变量提升之后的代码：
(function() {
    function fn() {
        alert(2)
    }
    var fn;
    fn();
    fn = function() {
        alert(1);
    }
    fn();
})()
```

[参与互动](https://github.com/yisainan/web-interview/issues/558)

</details>

<b><details><summary>11. 请说明以下各种情况的执行结果，并注明产生对应结果的理由</summary></b>

``` 
function doSomething() {
    alert(this);
}

a) element.onclick = doSomething, 点击 element 元素后
b) element.onclick = function() doSomething(){}, 点击 element 元素后
c) 直接执行 doSomething()
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/559)

</details>

<b><details><summary>12. 请写出以下代码的执行结果</summary></b>

例1：

```js
var obj = new Object();
var events = {m1: 'clicked', m2: 'changed'};

for (var e in events) {
    (function() {
        var aValue = e;
        obj[e] = function() {
            // var aValue = e;
            console.log(events[aValue]);
        };
    }());
};

console.log(obj.m1 === obj.m2); // false

obj.m1(); // clicked
obj.m2(); // changed
```

例2：

```js
var obj = new Object();
var events = {m1: 'clicked', m2: 'changed'};

for (var e in events) {
    (function() {
        // var aValue = e;
        obj[e] = function() {
            var aValue = e;
            console.log(events[aValue]);
        };
    }());
};

console.log(obj.m1 === obj.m2); // false

obj.m1(); // changed
obj.m2(); // changed
```

参考答案：

例1：false clicked changed
例2：false changed changed

解析：

以上两个例子中，除了var aValue = e;这一句位置不同：例1位于外层匿名函数中、例2位于内层匿名函数中，其他部分完全相同。为什么结果不同？

例1：for 循环进行的过程中，就把当时的 e 像拍照一样封存在了aValue变量里（注意，这里每一次循环都产生了一个新的闭包，所以循环了几次就有几个aValue同时存在，本例是2个，它们的值分别是'm1' 和 'm2'），当你调用obj.m1() 时，取的是闭包中的aValue，而不是现在的 e 了。

例2：内层函数obj.m1和obj.m2是在循环结束后才执行的，此时循环变量e的值为'm2'（注意 e 是 for 循环的循环变量，而当你调用 obj.m1() 和 obj.m2()的时候，for循环早已结束了，因此它的循环变量 e 已经永远地停留在了 'm2'），因此obj.m1和obj.m2中的局部变量aValue的值只能是'm2'。

[参与互动](https://github.com/yisainan/web-interview/issues/560)

</details>

<b><details><summary>13. 请写出类 Son 继承类 Father</summary></b>

function Father() {}
function Son() {}

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/561)

</details>

<b><details><summary>14. 请用 JS 写出一个遍历 DOM 节点树的方法</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/562)

</details>

<b><details><summary>15. 尝试实现注释部分的 JavaScript 代码， 可在其他任何地方添加更多代码。</summary></b>

``` 
var Obj = function(msg) {
    this.msg = msg;
    this.shout = function () {
        alert(this.msg)
    }
    this.waitAndShout = function() {
        // 隔五秒钟后执行上面的 shout 方法
    }
}
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/565)

</details>

<b><details><summary>16. 请编写一个 JavaScript 函数 parseQuerySting, 它的用途是把 URL 参数解析为一个对象，如</summary></b>

``` 
var url = "http://www.58.com/index.aspx?key0=0&key1=1&key2=2..."
var obj = parseQuerySting(url);
alert(obj.key0) // 输出 0
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/566)

</details>

<b><details><summary>17. 请给 Array 本地对象添加一个原型方法，它用于删除数组条目中重复的条目（可能有多个重复），返回值是一个包含被删除的重复条目的新数组</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/567)

</details>

<b><details><summary>18. 我们把一个数字倒着读和原数字相同的数字称之为对称数，例如（1, 121, 88, 8998）, 不考虑性能，请找出 1 - 10000 之间的对称数，要求用 JS 实现</summary></b>

参考答案：

```js
function findSymmetryNum(s, o) {
	var arr = [];
	for (var i = s; i <= o; i++) {
		var str = '' + i,
		sl = str.length,
		middle = 0,
		flag = true;
        // 字符串分割成两半，记录中间数值middle
		if (sl % 2 === 0) {
			middle = sl / 2;
		} else {
			middle = (sl - 1) / 2;
		}
        // 判断middle左右的数是否对称
		for (var m = 0; m < middle; m++) {
			if (str.substr(0 + m, 1) !== str.substr( - 1 - m, 1)) {
				flag = false;
			}
		}
		flag && arr.push(i);
	}
	console.log(arr);
	return arr;
}
findSymmetryNum(1, 10000);
```

[参与互动](https://github.com/yisainan/web-interview/issues/568)

</details>

<b><details><summary>19. 以下代码输出多少</summary></b>

``` js
var name = "world";
(function() {
    if (typeof name === "undefined") {
        var name = "jack";
        console.log("Hi!" + name);
    } else {
        console.log("Hello," + name)
    }
})()

==
>
Hi!jack

var name = "world";
(function(name) {
    if (typeof name === "undefined") {
        var name = "jack";
        console.log("Hi!" + name);
    } else {
        console.log("Hello," + name)
    }
})(name)

==
>
Hello, world
```

[参与互动](https://github.com/yisainan/web-interview/issues/569)

</details>

<b><details><summary>20. js 数组拍平(数组扁平化)的六种方式</summary></b>

参考答案：

1. 数组拍平也称数组扁平化，就是将数组里面的数组打开，最后合并为一个数组

2. 实现

``` js
var arr = [1, 2, [3, 4, 5, [6, 7, 8], 9], 10, [11, 12]];
```

a：递归实现

``` js
function fn(arr) {
    let arr1 = [];
    arr.forEach(val => {
        if (val instanceof Array) {
            arr1 = arr1.concat(fn(val));
        } else {
            arr1.push(val);
        }
    });
    return arr1;
}
```

b：reduce 实现

``` js
function fn(arr) {
    return arr.reduce((prev, cur) => {
        return prev.concat(Array.isArray(cur) ? fn(cur) : cur);
    }, []);
}
```

c:flat

参数为层数(默认一层)

``` js
arr.flat(Infinity);
```

d：扩展运算符

``` js
function fn(arr) {
    let arr1 = [];
    let bStop = true;
    arr.forEach(val => {
        if (Array.isArray(val)) {
            arr1.push(...val);
            bStop = false;
        } else {
            arr1.push(val);
        }
    });
    if (bStop) {
        return arr1;
    }
    return fn(arr1);
}
```

e：toString

``` js
let arr1 = arr
    .toString()
    .split(",")
    .map(val => {
        return parseInt(val);
    });
console.log(arr1);
```

f：apply

``` js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat.apply([], arr);
    }
    return arr;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/570)

</details>

<b><details><summary>21. 如何解决数组塌陷问题</summary></b>

什么叫数组塌陷？

一个数组在进行删除数据单元操作的时候，删除掉这个单元之后，后面的数据单元会自动的补充的这个位置上来，造成数组长度的减少，这种情况被称之为数组塌陷。

例：循环删除数组中的数据，每循环一次，删除一个数据单元

``` js
var arr = [0,1,2,3,4,5,6,7,8,9];
for (var i = 0; i < arr.length; i++) {
    arr.splice(i, 1);
}
console.log(arr) // [1, 3, 5, 7, 9]
```

那么 现在的输出是 [1, 3, 5, 7, 9] 还剩 5 个 单元 ，也就是还有一半没有删除。

因为：我们使用for 循环遍历 arr, 当i = 0的时候, 我们删除了位置为 0 的元素,此时位置为 1 的元素接替了位置 0 , 但同时 i 也累加了, 下次执行删除操作的时候 i 变为 1,再次执行删除操作,其实是删除了现在位置为 1 的元素, 中间跳过了, 所以最后的结果只删除了一半。

如何解决数组塌陷问题呢？

参考答案：

``` js
// 方法1 使用i--
for (var i = 0; i < arr.length; i++) {
    arr.splice(i, 1);
    i--;
}
console.log(arr); // []

// 方法2 从数组的末尾一项开始遍历
for (var i = arr.length - 1; i >= 0; i--) {
    arr.splice(i, 1);
}
console.log(arr); // []
```

[参与互动](https://github.com/yisainan/web-interview/issues/571)

</details>

<b><details><summary>22. 大部分人都会做错的经典 JS 闭包面试题</summary></b>

``` js
function fun(n,o) {
　　console.log(o)
　　return {
       fun:function(m){
　　　　   　return fun(m,n);
　　    }
　　};
}
var a = fun(0); a.fun(1); a.fun(2); a.fun(3); // undefined,?,?,?
var b = fun(0).fun(1).fun(2).fun(3); // undefined,?,?,?
var c = fun(0).fun(1); c.fun(2); c.fun(3); // undefined,?,?,?
```
问:三行a,b,c的输出分别是什么？

这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。

可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？

参考答案：
a: undefined,0,0,0
b: undefined,0,1,2
c: undefined,0,1,1


1、第一行a

var a = fun(0); a.fun(1); a.fun(2); a.fun(3);
　　可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。

遂：在第一次调用fun(0)时，o为undefined；第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0；第四次同理；

即：最终答案为undefined,0,0,0

2、第二行b

var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。 

遂：在第一次调用第一层fun(0)时，o为undefined；第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；

 即最终答案：undefined,0,1,2

3、第三行c

var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,?
根据前面两个例子，可以得知：fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。

遂：在第一次调用第一层fun(0)时，o为undefined；第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1

 即最终答案：undefined,0,1,1

解析：[参考](https://www.cnblogs.com/lilistyle/p/13791398.html)、

[参与互动](https://github.com/yisainan/web-interview/issues/572)

</details>

<b><details><summary>23. 编写一个数组去重的方法</summary></b>

参考答案：

1、利用ES6 Set去重（ES6中最常用）

```js
var arr = [1,1,8,8,12,12,15,15,16,16];
function unique (arr) {
  return Array.from(new Set(arr))
}

console.log(unique(arr)) //[1,8,12,15,16]
```
不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。

2、利用for嵌套for，然后splice去重（ES5中最常用）

```js
var arr = [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];

function unlink(arr) {
    for (var i = 0; i < arr.length; i++) {    // 首次遍历数组
        for (var j = i + 1; j < arr.length; j++) {   // 再次遍历数组
            if (arr[i] == arr[j]) {          // 判断连个值是否相等
                arr.splice(j, 1);           // 相等删除后者
                j--;
            }
        }
    }
    return arr
}
console.log(unlink(arr));
// NaN和{}没有去重，两个null直接消失了
```


双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。

3、利用indexOf去重

```js
var arr = [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];
function unlink(arr) {
    if (!Array.isArray(arr)) {
        console.log('错误！')
        return
    }
    var array = [];
    for (var i = 0; i < arr.length; i++) {    // 首次遍历数组
        if (array.indexOf(arr[i]) === -1) {   // 判断索引有没有等于
            array.push(arr[i])
        }
    }
    return array
}
console.log(unlink(arr));
// NaN、{}没有去重
```


新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。

4、利用includes

```js
var arr = [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array =[];
    for(var i = 0; i < arr.length; i++) {
        if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
            array.push(arr[i]);
        }
    }
    return array
}
console.log(unique(arr))
```

5、利用filter

```js
var arr = [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];
function unlink(arr) {
    return arr.filter(function (item, index, arr) {
        //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
        return arr.indexOf(item, 0) === index;
    });
}
console.log(unlink(arr));
```

[参与互动](https://github.com/yisainan/web-interview/issues/573)

</details>

<b><details><summary>24. 已知 id 的 input 输入框，希望获取这个输入框的输入值，怎么做？（不使用第三方框架）</summary></b>

参考答案：

``` js
document.getElementById("id").value;
```

[参与互动](https://github.com/yisainan/web-interview/issues/574)

</details>

<b><details><summary>25. 获取到页面中所有的 checkbox 怎么做？（不使用第三方框架）</summary></b>

参考答案：

``` js
var domList = document.getElementsByTagName("input");
var ckList = []; // 返回的所有的 checkbox
var len = domList.length;
for (var i = 0; i < len; i++) {
    if (domList[i].type == "checkbox") {
        ckList.push(domList[i]);
    }
}
console.log(ckList)
```

[参与互动](https://github.com/yisainan/web-interview/issues/575)

</details>

<b><details><summary>26. 设置一个已知 id 的 div 的 html 内容为 xxxx，字体颜色设置为黑色（不使用第三方框架）</summary></b>

参考答案：

``` js
var dom = document.getElementById("id");
dom.innerHTML = "xxxx";
dom.style.color = "#000"; // 'black'
```

[参与互动](https://github.com/yisainan/web-interview/issues/576)

</details>

<b><details><summary>27. JavaScript 中的相等性判断</summary></b>

参考答案：

``` js
2 == true[] == false[] == ![]
```

解析：[参考](https://www.cnblogs.com/youyoui/p/8385542.html)

[参与互动](https://github.com/yisainan/web-interview/issues/577)

</details>

<b><details><summary>28. 已知有字符串 foo="get-element-by-id", 写一个 function 将其转化为驼峰表示法"getElementById"</summary></b>

参考答案：

``` js
var string = "get-element-by-id";

function combo(msg) {
    var arr = msg.split("-"); //split("-")以-为分隔符截取字符串，返回数组
    for (var i = 1; i < arr.length; i++) {
        arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
    }
    msg = arr.join(""); //join()返回字符串
    return msg;
}
console.log(combo(string));
```

[参与互动](https://github.com/yisainan/web-interview/issues/578)

</details>

<b><details><summary>29. 看下面代码，如何输出1 2 3</summary></b>

``` js
for (var i = 1; i <= 3; i++) {
    console.log(i);
}
// 输出 1 2 3
```

但是

``` js
for (var i = 1; i <= 3; i++) {
    setTimeout(() => {
        // setTimout在for里面是异步执行的，在延迟输出的时候，i的值已经是4了
        console.log(i);
    }, 0);
}
// 输出 4 4 4
```

如何输出 1 2 3

参考答案：

1. 立即执行函数

``` js
for (var i = 1; i <= 3; i++) {
    setTimeout(
        (i => {
            console.log(i);
        })(i),
        0
    );
}
```

2. 闭包

``` js
for (var i = 1; i <= 3; i++) {
    setTimeout(
        (() => {
            var j = i;
            return function() {
                console.log(j);
            };
        })(),
        0
    );
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/579)

</details>

<b><details><summary>30. JS 字符串使用堆栈处理 "(a, b, (c, d), f, g)"</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/580)

</details>

<b><details><summary>31. 二维数组操作</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/581)

</details>

<b><details><summary>32. 用最简单的方式，求一个数组中最大的元素</summary></b>

例如 arr = [5, 7, 9, 42, 18, 29]

参考答案：

``` js
var a = [1, 2, 3, 5];
alert(Math.max.apply(null, a)); //最大值
alert(Math.min.apply(null, a)); //最小值
```

[参与互动](https://github.com/yisainan/web-interview/issues/582)

</details>

<b><details><summary>33. 写一个 function，清除字符串前后的空格（兼容所有的浏览器）</summary></b>

参考答案：

``` js
// 重写trim方法
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+/, "").replace(/\s+$/, "");
    };
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/583)

</details>

<b><details><summary>34. 运算符面试题</summary></b>

``` js
var a = 10,
    b = 20,
    c = 30;
++a;
a++;
e = ++a + ++b + c++ + a++;
console.log(e);
```

参考答案：77

解析：

1：后置++ 是将自身的值赋给变量，之后自身再加1；
2：前置++ 是将自身+1 后的值赋给变量，同时自身加1；

```js
e = 13 + 21 + 30 + 13
```

[参与互动](https://github.com/yisainan/web-interview/issues/584)

</details>

<b><details><summary>35. this 面试题</summary></b>

参考答案：

``` 
 this指向了谁？
 看函数在执行的时候是如何调用的，
 1 如果这个函数是用普通函数调用模式来进行调用，它内部的this指向了window;
 2 如果一个函数在调用的时候是通过对象方法模式来进行调用，则它内部的this就是我们的对象;
 3 如果一个函数在调用的时候通过构造函数模式调用，则它内部的this指向了生成的实例;
 4 如果这个函数是通过方法借用模式调用，则这个函数内部的this就是我们手动指定this。
```

``` js
//第1题
function Fn() {
    console.log(this);
}
Fn(); //window 普通函数调用模式
new Fn(); //{}  构造函数调用模式
Fn.apply(Fn); // Fn的函数体   方法借用模式

//第2题
var o = {
    f: function() {
        console.log(this);
    },
    2: function() {
        console.log(this);
        console.log(this.__proto__ === o[2].prototype);
    }
};
o.f(); // o   对象调用模式
o[2](); // o  对象调用模式
new o[2](); //存疑，存在着优先级的问题 {}  通过构造函数模式进行调用
o.f.call([1, 2]); //[1,2]   call方法进行方法借用。
o[2].call([1, 2, 3, 4]); // [1,2,3,4]  call方法进行方法借用

//第3题
var name = "out";
var obj = {
    name: "in",
    prop: {
        name: "inside",
        getName: function() {
            return this.name;
        }
    }
};

console.log(obj.prop.getName()); //对象调用模式来进行调用  obj.prop.name  'inside'
var test = obj.prop.getName; // 把test这个变量指向了obj.prop.getName所在的内存地址。
console.log(test()); //普通函数模式来进行调用  window 'out'
console.log(obj.prop.getName.apply(window)); //方法借用模式  'out'
console.log(obj.prop.getName.apply(this)); //方法借用模式  'out'
console.log(this === window); //true

//第4题
var length = 10;

function fn() {
    console.log(this.length);
}
var obj = {
    length: 5,
    method: function(f) {
        console.log(this);
        f(); // f在调用的时候是什么调用模式？普通函数调用模式  window.length  10
        arguments[0](); // 通过什么模式来进行调用的。执行之前有[]和.就是对象调用模式。
        //arguments是一个类数组，也就是一个对象，就是通过arguments来进行调用的
        //arguments.length实参的数量。实参长度是1
        //通过arguments对象进行调用，因此函数内部的this是  arguments
        // 如果一个函数在调用的时候它前面有call和apply那么就肯定是方法借用模式调用
        arguments[0].call(this);
        // 调用method方法是通过obj.method 因此在这里的this就是 obj
        //通过call方法把fn内的this指向了obj
        // 输出obj.length  5
    }
};
obj.method(fn);

//第5题
function Foo() {
    getName = function() {
        console.log(1);
    };
    return this;
}
Foo.getName = function() {
    console.log(2);
};
Foo.prototype.getName = function() {
    console.log(3);
};
var getName = function() {
    console.log(4);
};

function getName() {
    console.log(5);
}
//请写出以下输出结果：
Foo.getName(); //2
getName(); //4
Foo().getName(); //1
getName(); //1
new Foo.getName(); //2
new Foo().getName(); //3
new new Foo().getName(); //3
// new Foo()创建了一个构造函数，然后这个函数再去访问getName这个函数，
//对它进行调用
/*console.log(new Foo().getName)*/
/*var o = new new Foo().getName(); //
    console.log(o.__proto__===Foo.prototype.getName.prototype)*/
//用new Foo创建出来了一个实例，然后这个实例去访问 (new Foo().getName)

/*console.log(new new Foo().getName())

    console.log(new Foo().getName())*/

/*function Foo() {
        getName = function () {
            console.log(1);
        };
        return this;
    }
    var getName;
    Foo.getName = function () {
        console.log(2);
    };
    Foo.prototype.getName = function () {
        console.log(3);
    };
    getName = function () {
        console.log(4);
    };
    //请写出以下输出结果：
    Foo.getName();// 2
    getName();//4
/!*    Foo().getName();//!*!/
    window.getName()//1
    getName();//1
  /!*  var o = new Foo.getName();//2
    console.log(o);// {}
    console.log(o.__proto__===Foo.getName.prototype)//true*!/
    new Foo.getName();// 2
    new Foo().getName();//
    new new Foo().getName();*/

//第6题
var obj = {
    fn: function() {
        console.log(this);
    }
};
obj.fn(); //obj
var f = obj.fn;
f(); //window
console.log(f === obj.fn); // true

// f和obj.fn是同一个函数，但是他们在调用的时候使用的函数调用模式不同，因此，它们内部的this指向也就不同。

// #7题
var arr = [
    function() {
        console.log(this);
    }
];
arr[0](); //数组本身
//数组也是一个复杂数据类型，也是一个对象，那用数组去调用函数，使用的模式就是对象方法调用模式。
function f() {
    console.log(this);
}

function fn() {
    console.log(arguments); // 类数组，也是就一个对象    [0:function f(){}]
    console.log(this); // window
    arguments[0]();
    console.log(arguments[0]); //内部的this就是arguments
    // 通过arguments对f这个方法进行调用，使用的是对象方法调用模式。
}
fn(f);

// #8题
function SuperClass() {
    this.name = "women";
    this.bra = ["a", "b"];
}

SuperClass.prototype.sayWhat = function() {
    console.log("hello");
};

function SubClass() {
    this.subname = "you sister";
    SuperClass.call(this);
}

var sub = new SubClass();
console.log(sub.sayWhat());
```

[参与互动](https://github.com/yisainan/web-interview/issues/585)

</details>

<b><details><summary>36. 实现一个 new 操作符</summary></b>

参考答案：

``` js
function realizeNew () {
    //创建一个新对象
    let obj  = {};
    //获得构造函数
    let Con = [].shift.call(arguments);
    //链接到原型（给obj这个新生对象的原型指向它的构造函数的原型）
    obj.__proto__ = Con.prototype;
    //绑定this
    let result = Con.apply(obj,arguments);
    //确保new出来的是一个对象
    return typeof result === "object" ? result : obj
}
```


[参考](https://blog.csdn.net/q1424966670/article/details/92839918)、
[参与互动](https://github.com/yisainan/web-interview/issues/586)

</details>

<b><details><summary>37. 用js实现一个 call 或 apply 方法</summary></b>

参考答案：

1. call

``` js
Function.prototype.call2 = function(context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for (var i = 1, len = arguments.length; i < len; i++) {
        args.push("arguments[" + i + "]");
    }

    var result = eval("context.fn(" + args + ")");

    delete context.fn;
    return result;
};
```

2. apply

``` js
Function.prototype.apply2 = function(context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    } else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push("arr[" + i + "]");
        }
        result = eval("context.fn(" + args + ")");
    }

    delete context.fn;
    return result;
};
```

[参与互动](https://github.com/yisainan/web-interview/issues/587)

</details>

<b><details><summary>38. 实现一个 Function.bind</summary></b>

参考答案：

``` js
Function.prototype.bind2 = function(context) {
    if (typeof this !== "function") {
        throw new Error(
            "Function.prototype.bind - what is trying to be bound is not callable"
        );
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var fNOP = function() {};
    var fbound = function() {
        self.apply(
            this instanceof self ? this : context,
            args.concat(Array.prototype.slice.call(arguments))
        );
    };
    fNOP.prototype = this.prototype;
    fbound.prototype = new fNOP();
    return fbound;
};
```

[参与互动](https://github.com/yisainan/web-interview/issues/588)

</details>

<b><details><summary>39. 实现一个继承</summary></b>

参考答案：

``` js
function Parent(name) {
    this.name = name;
}

Parent.prototype.sayName = function() {
    console.log("parent name:", this.name);
};

function Child(name, parentName) {
    Parent.call(this, parentName);
    this.name = name;
}

function create(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
Child.prototype = create(Parent.prototype);
Child.prototype.sayName = function() {
    console.log("child name:", this.name);
};

Child.prototype.constructor = Child;
var parent = new Parent("汪某");
parent.sayName(); // parent name: 汪某
var child = new Child("son", "汪某");
```

[参与互动](https://github.com/yisainan/web-interview/issues/589)

</details>

<b><details><summary>40. 手写一个 Promise(中高级必考)</summary></b>

参考答案：

``` js
function myPromise(constructor) {
    let self = this;
    self.status = "pending";
    //定义状态改变前的初始状态
    self.value = undefined;
    //定义状态为resolved的时候的状态
    self.reason = undefined;
    //定义状态为rejected的时候的状态
    function resolve(value) {
        //两个==="pending"，保证了状态的改变是不可逆的
        if (self.status === "pending") {
            self.value = value;
            self.status = "resolved";
        }
    }

    function reject(reason) {
        //两个==="pending"，保证了状态的改变是不可逆的
        if (self.status === "pending") {
            self.reason = reason;
            self.status = "rejected";
        }
    }
    //捕获构造异常
    try {
        constructor(resolve, reject);
    } catch (e) {
        reject(e);
    }
}

//同时，需要在 myPromise的原型上定义链式调用的 then方法：
myPromise.prototype.then = function(onFullfilled, onRejected) {
    let self = this;
    switch (self.status) {
        case "resolved":
            onFullfilled(self.value);
            break;
        case "rejected":
            onRejected(self.reason);
            break;
        default:
    }
};

//测试一下：
var p = new myPromise(function(resolve, reject) {
    resolve(1);
});
p.then(function(x) {
    console.log(x);
});
```

[参与互动](https://github.com/yisainan/web-interview/issues/590)

</details>

<b><details><summary>41. 手写防抖(Debouncing)和节流(Throttling)</summary></b>

参考答案：

``` js
// 防抖函数
function debounce(fn, wait) {
    let timer;
    return function() {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, arguments);
        }, wait);
    };
}

// （参考博客https://segmentfault.com/a/1190000018428170）
function debounce(fn, delay) {
    let timer = null //借助闭包
    return function() {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(fn, delay) // 简化写法
    }
}
```

``` js
// 节流函数 通过时间戳差值是否大于指定间隔时间来做判定
function throttle(fn, wait) {
    let prev = new Date();
    return function() {
        const args = arguments;
        const now = new Date();
        if (now - prev > wait) {
            fn.apply(this, args);
            prev = new Date();
        }
    };
}

// 通过setTimeout的返回的标记当做判断条件实现（参考博客https://segmentfault.com/a/1190000018428170）
function throttle(fn, delay) {
    let valid = true
    return function() {
        if (!valid) {
            //休息时间 暂不接客
            return false
        }
        // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/591)

</details>

<b><details><summary>42. 手写一个 JS 深拷贝</summary></b>

参考答案：

``` js
function deepCopy(obj) {
    //判断是否是简单数据类型，
    if (typeof obj == "object") {
        //复杂数据类型
        var result = obj.constructor == Array ? [] : {};
        for (let i in obj) {
            result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i];
        }
    } else {
        //简单数据类型 直接 == 赋值
        var result = obj;
    }
    return result;
}
```

``` js
let o1 = {
    a: {
        b: 1
    }
};
let o2 = JSON.parse(JSON.stringify(o1));
```

另一种方法

``` js
function deepCopy(s) {
    const d = {};
    for (let k in s) {
        if (typeof s[k] == "object") {
            d[k] = deepCopy(s[k]);
        } else {
            d[k] = s[k];
        }
    }

    return d;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/592)

</details>

<b><details><summary>43. 看下面代码，给出输出结果(考察闭包及++运算符)</summary></b>

参考答案：

``` js
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    };
}
var f1 = Foo(),
    f2 = Foo();

f1(); // 0
f1(); // 1
f2(); // 0
```

``` js
function fn() {
    var a = 1;
    return function() {
        a++;
        console.log(a);
    };
}
var b = fn();
console.log(b());
// 2
```

``` js
function fn() {
    var a = 1;
    return function() {
        console.log(a++);
    };
}
var b = fn();
console.log(b());
// 1
```

[参与互动](https://github.com/yisainan/web-interview/issues/593)

</details>

<b><details><summary>44. 看下面代码，给出输出结果(考察时间戳)</summary></b>

参考答案：

``` js
//总结：第一个setTimeout，时间间隔<1000的话，输出1000多，>1000的话，输出间隔值多
//     第二个setTimeout，是1000+时间间隔
var dateNum = new Date();
setTimeout(function() {
    console.log(new Date() - dateNum);
}, 1200); //1200多
while (new Date() - dateNum < 1000) {
    var a = 1;
}
setTimeout(function() {
    console.log(new Date() - dateNum);
}, 1500); // 2500左右
```

[参与互动](https://github.com/yisainan/web-interview/issues/594)

</details>

<b><details><summary>45. 编写一个元素拖拽的插件</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/595)

</details>

<b><details><summary>46. 什么是代理和通知，写一下他们基本的实现方法</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/596)

</details>

<b><details><summary>47. 看题写结果</summary></b>

``` js
var output = function(i) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
};

for (var i = 0; i < 5; i++) {
    output(i); // 这里传过去的 i 值被复制了
}

console.log(i);
```

参考答案：

5
0
1
2
3
4

解析：[参考](https://www.cnblogs.com/adouwt/p/6481479.html)

[参与互动](https://github.com/yisainan/web-interview/issues/597)

</details>

<b><details><summary>48. 告诉我参考答案是多少</summary></b>

``` js
(function(x) {
    delete x;
    alert(x);
})(1 + 5);
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/598)

</details>

<b><details><summary>49. 写一个通用的事件侦听器函数</summary></b>

参考答案：

``` js
// event(事件)工具集，来源：https://github.com/markyun
markyun.Event = {
    // 页面加载完成后
    readyEvent: function(fn) {
        if (fn == null) {
            fn = document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != "function") {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent: function(element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + type, function() {
                handler.call(element);
            });
        } else {
            element["on" + type] = handler;
        }
    },
    // 移除事件
    removeEvent: function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.datachEvent) {
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = null;
        }
    },
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation: function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault: function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget: function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent: function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};
```

[参与互动](https://github.com/yisainan/web-interview/issues/599)

</details>

<b><details><summary>50. 谈一下 JS 中的递归函数，并且用递归简单实现阶乘</summary></b>

参考答案：递归即是程序在执行过程中不断调用自身的编程技巧，当然也必须要有一个明确的结束条件，不然就会陷入死循环。

[参与互动](https://github.com/yisainan/web-interview/issues/600)

</details>

<b><details><summary>51. 请用正则表达式写一个简单的邮箱验证</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/601)

</details>

<b><details><summary>52. 完成 foo()函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/602)

</details>

<b><details><summary>53. 完成函数 showImg()，要求能够动态根据下拉列表的选项变化，更新图片的显示</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/630)

</details>

<b><details><summary>54. 截取字符串 abcdefg 中的 efg</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/631)

</details>

<b><details><summary>55. 在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</summary></b>

参考答案：

伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用 getElementsByTagName, document. childNodes 之类的, 它们都返回 NodeList 对象都属于伪数组。可以使用 Array. prototype. slice. call(fakeArray)将数组转化为真正的 Array 对象。

假设我们要给每个 log 方法添加一个"(app)"前缀，比如'hello world!' ->'(app)hello world!'。方法如下：

``` js
function log() {
    var args = Array.prototype.slice.call(arguments); //为了使用unshift数组方法，将argument转化为真正的数组
    args.unshift("(app)");
    console.log.apply(console, args);
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/632)

</details>

<b><details><summary>56. 判断一个字符串中出现次数最多的字符，统计这个次数</summary></b>

参考答案：

``` js
var str = "asdfssaaasasasasaa";
var json = {};
for (var i = 0; i < str.length; i++) {
    if (!json[str.charAt(i)]) {
        json[str.charAt(i)] = 1;
    } else {
        json[str.charAt(i)]++;
    }
}
var iMax = 0;
var iIndex = "";
for (var i in json) {
    if (json[i] > iMax) {
        iMax = json[i];
        iIndex = i;
    }
}
alert("出现次数最多的是:" + iIndex + "出现" + iMax + "次");
```

[参与互动](https://github.com/yisainan/web-interview/issues/633)

</details>

<b><details><summary>57. 写一个获取非行间样式的函数</summary></b>

参考答案：

``` js
function getStyle(obj, attr, value) {
    if (!value) {
        if (obj.currentStyle) {
            return obj.currentStyle(attr);
        } else {
            obj.getComputedStyle(attr, false);
        }
    } else {
        obj.style[attr] = value;
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/634)

</details>

<b><details><summary>58. 字符串反转，如将 '12345678' 变成 '87654321'</summary></b>

参考答案：

``` js
//思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串
var str = "12345678";
str = str
    .split("")
    .reverse()
    .join("");
```

[参与互动](https://github.com/yisainan/web-interview/issues/635)

</details>

<b><details><summary>59. 将数字 12345678 转化成 RMB 形式 如： 12, 345, 678</summary></b>

参考答案：

``` js
//个人方法；
//思路：先将数字转为字符， str= str + '' ;
//利用反转函数，每三位字符加一个 ','最后一位不加； re()是自定义的反转函数，最后再反转回去！
for (var i = 1; i <= re(str).length; i++) {
    tmp += re(str)[i - 1];
    if (i % 3 == 0 && i != re(str).length) {
        tmp += ",";
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/636)

</details>

<b><details><summary>60. 生成 5 个不同的随机数</summary></b>

参考答案：

``` js
//思路：5个不同的数，每生成一次就和前面的所有数字相比较，如果有相同的，则放弃当前生成的数字！
var num1 = [];
for (var i = 0; i < 5; i++) {
    num1[i] = Math.floor(Math.random() * 10) + 1; //范围是 [1, 10]
    for (var j = 0; j < i; j++) {
        if (num1[i] == num1[j]) {
            i--;
        }
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/637)

</details>

<b><details><summary>61. 去掉数组中重复的数字</summary></b>

参考答案：

方法一

``` js
//思路：每遍历一次就和之前的所有做比较，不相等则放入新的数组中！
//这里用的原型 个人做法；
Array.prototype.unique = function() {
    var len = this.length,
        newArr = [],
        flag = 1;
    for (var i = 0; i < len; i++, flag = 1) {
        for (var j = 0; j < i; j++) {
            if (this[i] == this[j]) {
                flag = 0; //找到相同的数字后，不执行添加数据
            }
        }
        flag ? newArr.push(this[i]) : "";
    }
    return newArr;
};
```

方法二

``` js
(function(arr) {
    var len = arr.length,
        newArr = [],
        flag;
    for (var i = 0; i < len; i += 1, flag = 1) {
        for (var j = 0; j < i; j++) {
            if (arr[i] == arr[j]) {
                flag = 0;
            }
        }
        flag ? newArr.push(arr[i]) : "";
    }
    alert(newArr);
})([1, 1, 22, 3, 4, 55, 66]);
```

[参与互动](https://github.com/yisainan/web-interview/issues/638)

</details>

<b><details><summary>62. 阶乘函数</summary></b>

参考答案：

``` js
//原型方法
Number.prototype.N = function() {
    var re = 1;
    for (var i = 1; i <= this; i++) {
        re *= i;
    }
    return re;
};
var num = 5;
alert(num.N());
```

[参与互动](https://github.com/yisainan/web-interview/issues/639)

</details>

<b><details><summary>63. 看题做答</summary></b>

参考答案：

``` js
function f1() {
    var tmp = 1;
    this.x = 3;
    console.log(tmp); //A
    console.log(this.x); //B
}
var obj = new f1(); //1
console.log(obj.x); //2
console.log(f1()); //3
```

解析：   
     这道题让我重新认识了对象和函数，首先看代码（1），这里实例话化了 f1 这个类。相当于执行了 f1 函数。所以这个时候 A 会输出 1， 而 B 这个时候的 this 代表的是 实例化的当前对象 obj B 输出 3. 。 代码（2）毋庸置疑会输出 3， 重点 代码（3）首先这里将不再是一个类，它只是一个函数。那么 A 输出 1， B 呢？这里的 this 代表的其实就是 window 对象，那么 this. x 就是一个全局变量 相当于在外部 的一个全局变量。所以 B 输出 3。最后代码由于 f 没有返回值那么一个函数如果没返回值的话，将会返回 underfined ，所以参考答案就是 ： 1， 3， 3， 1， 3， underfined 。

[参与互动](https://github.com/yisainan/web-interview/issues/640)

</details>

<b><details><summary>64. 下面输出多少？</summary></b>

参考答案：

``` js
var o1 = new Object();
var o2 = o1;
o2.name = "CSSer";
console.log(o1.name);
```

解析：

如果不看参考答案，你回答真确了的话，那么说明你对 javascript 的数据类型了解的还是比较清楚了。js 中有两种数据类型，分别是：基本数据类型和引用数据类型（object Array）。对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值。对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象。参考答案就清楚了：  CSSer; 

[参与互动](https://github.com/yisainan/web-interview/issues/641)

</details>

<b><details><summary>65. 下面输出多少？</summary></b>

参考答案：

``` js
function changeObjectProperty(o) {
    o.siteUrl = "http://www.csser.com/";
    o = new Object();
    o.siteUrl = "http://www.popcg.com/";
}
var CSSer = new Object();
changeObjectProperty(CSSer);
console.log(CSSer.siteUrl); //
```

解析：

如果 CSSer 参数是按引用传递的，那么结果应该是 `"http://www.popcg.com/"，但实际结果却仍是"http://www.csser.com/"。事实是这样的：在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存。` 
    （补充：内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能。）

[参与互动](https://github.com/yisainan/web-interview/issues/642)

</details>

<b><details><summary>66. 输出多少？</summary></b>

参考答案：

``` js
var a = 6;
setTimeout(function() {
    var a = 666;
    alert(a); // 输出666，
}, 1000);
a = 66;
```

因为 var a = 666; 定义了局部变量 a，并且赋值为 666，根据变量作用域链，
全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量 。

``` js
var a = 6;
setTimeout(function() {
    alert(a); // 输出undefined
    var a = 666;
}, 1000);
a = 66;
```

因为 var a = 666; 定义了局部变量 a，同样覆盖了全局变量，但是在 alert(a); 之前
a 并未赋值，所以输出 undefined。

``` js
var a = 6;
setTimeout(function() {
    alert(a);
    var a = 66;
}, 1000);
a = 666;
alert(a);
// 666, undefined;
```

记住： 异步处理，一切 OK 声明提前

[参与互动](https://github.com/yisainan/web-interview/issues/643)

</details>

<b><details><summary>67. JS 的继承性？</summary></b>

参考答案：

``` js
window.color = "red";
var o = {
    color: "blue"
};

function sayColor() {
    alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red this-window对象
sayColor.call(window); //red
sayColor.call(o); //blue
```

[参与互动](https://github.com/yisainan/web-interview/issues/644)

</details>

<b><details><summary>68. 精度问题: JS 精度不能精确到 0. 1 所以  。。。。同时存在于值和差值中</summary></b>

参考答案：

``` js
var n = 0.3,
    m = 0.2,
    i = 0.2,
    j = 0.1;
alert(n - m == i - j); //false
alert(n - m == 0.1); //false
alert(i - j == 0.1); //true
```

[参与互动](https://github.com/yisainan/web-interview/issues/645)

</details>

<b><details><summary>69. 加减运算</summary></b>

参考答案：

``` js
alert("5" + 3); //53 string
alert("5" + "3"); //53 string
alert("5" - 3); //2 number
alert("5" - "3"); //2 number
```

[参与互动](https://github.com/yisainan/web-interview/issues/646)

</details>

<b><details><summary>70. 结果是什么？</summary></b>

参考答案：

``` js
function foo() {
    foo.a = function() {
        alert(1);
    };
    this.a = function() {
        alert(2);
    };
    a = function() {
        alert(3);
    };
    var a = function() {
        alert(4);
    };
}
foo.prototype.a = function() {
    alert(5);
};
foo.a = function() {
    alert(6);
};
foo.a(); //6
var obj = new foo();
obj.a(); //2
foo.a(); //1
```

[参与互动](https://github.com/yisainan/web-interview/issues/647)

</details>

<b><details><summary>71. 输出结果</summary></b>

参考答案：

``` js
var a = 5;

function test() {
    a = 0;
    alert(a);
    alert(this.a); //没有定义 a这个属性
    var a;
    alert(a);
}
test(); // 0, 5, 0
new test(); // 0, undefined, 0 //由于类它自身没有属性a， 所以是undefined
```

[参与互动](https://github.com/yisainan/web-interview/issues/648)

</details>

<b><details><summary>72. 计算字符串字节数</summary></b>

参考答案：

``` js
new(function(s) {
    if (!arguments.length || !s) return null;
    if ("" == s) return 0;
    var l = 0;
    for (var i = 0; i < s.length; i++) {
        if (s.charCodeAt(i) > 255) l += 2;
        else l += 1; //charCodeAt()得到的是unCode码
    } //汉字的unCode码大于 255bit 就是两个字节
    alert(l);
})("hello world!");
```

[参与互动](https://github.com/yisainan/web-interview/issues/649)

</details>

<b><details><summary>73. 输出结果</summary></b>

参考答案：

var bool = !!2;  alert(bool); //true; 
双向非操作可以把字符串和数字转换为布尔值

[参与互动](https://github.com/yisainan/web-interview/issues/650)

</details>

<b><details><summary>74. 声明对象，添加属性，输出属性</summary></b>

参考答案：

``` js
var obj = {
    name: "leipeng",
    showName: function() {
        alert(this.name);
    }
};
obj.showName();
```

[参与互动](https://github.com/yisainan/web-interview/issues/651)

</details>

<b><details><summary>75. 匹配输入的字符：第一个必须是字母或下划线开头，长度 5-20</summary></b>

参考答案：

``` js
var reg = /^[a-zA-Z][a-zA-Z0-9_]{5,20}/,
    name1 = "leipeng",
    name2 = "0leipeng",
    name3 = "你好leipeng",
    name4 = "hi";
alert(reg.test(name1));
alert(reg.test(name2));
alert(reg.test(name3));
alert(reg.test(name4));
```

[参与互动](https://github.com/yisainan/web-interview/issues/652)

</details>

<b><details><summary>76. 检测变量类型</summary></b>

参考答案：

``` js
function checkStr(str) {
    typeof str == "string" ? alert("true") : alert("false");
}
checkStr("leipeng");
```

[参与互动](https://github.com/yisainan/web-interview/issues/653)

</details>

<b><details><summary>77. 如何在 HTML 中添加事件，几种方法？</summary></b>

参考答案：

``` 
1、标签之中直接添加 onclick="fun()";
2、JS 添加 Eobj.onclick = method;
3、现代事件  IE： obj.attachEvent('onclick', method);
            FF: obj.addEventListener('click', method, false);
```

[参与互动](https://github.com/yisainan/web-interview/issues/654)

</details>

<b><details><summary>78. 请问代码实现 outerHTML</summary></b>

参考答案：

``` js
//说明：outerHTML其实就是innerHTML再加上本身；
Object.prototype.outerHTML = function() {
    var innerCon = this.innerHTML, //获得里面的内容
        outerCon = this.appendChild(innerCon); //添加到里面
    alert(outerCon);
};
```

演示代码：

```html     
<! DOCTYPE html>
<html>
  <head>

    <meta charset="UTF-8" />
    <title>Document</title>

  </head>
  <body>

    <div id="outer">
      hello
    </div>
    <script>
      Object.prototype.outerHTML = function() {
        var innerCon = this.innerHTML, //获得里面的内容
          outerCon = this.appendChild(innerCon); //添加到里面
        alert(outerCon);
      };
      function $(id) {
        return document.getElementById(id);
      }
      alert($("outer").innerHTML);
      alert($("outer").outerHTML);
    </script>

  </body>
</html>

``` 

[参与互动](https://github.com/yisainan/web-interview/issues/655)

</details>

<b><details><summary>79.JS 中的简单继承 call 方法</summary></b>

参考答案：

```js
//顶一个父母类，注意：类名都是首字母大写的哦！
function Parent(name, money) {
  this.name = name;
  this.money = money;
  this.info = function() {
    alert("姓名： " + this.name + " 钱： " + this.money);
  };
} //定义孩子类
function Children(name) {
  Parent.call(this, name); //继承 姓名属性，不要钱。
  this.info = function() {
    alert("姓名： " + this.name);
  };
} //实例化类
var per = new Parent("parent", 800000000000);
var chi = new Children("child");
per.info();
chi.info();
```

[参与互动](https://github.com/yisainan/web-interview/issues/656)

</details>

<b><details><summary>80. 解析 URL 成一个对象？</summary></b>

参考答案：

``` js
String.prototype.urlQueryString = function() {
    var url = this.split("?")[1].split("&"),
        len = url.length;
    this.url = {};
    for (var i = 0; i < len; i += 1) {
        var cell = url[i].split("="),
            key = cell[0],
            val = cell[1];
        this.url["" + key + ""] = val;
    }
    return this.url;
};
var url = "?name=12&age=23";
console.log(url.urlQueryString().age);
```

[参与互动](https://github.com/yisainan/web-interview/issues/657)

</details>

<b><details><summary>81. 看下列代码输出什么？</summary></b>

参考答案：

``` js
var foo = "11" + 2 - "1";
console.log(foo);
console.log(typeof foo);
// 执行完后foo的值为111，foo的类型为Number。
```

[参与互动](https://github.com/yisainan/web-interview/issues/658)

</details>

<b><details><summary>82. 看下列代码, 输出什么？</summary></b>

参考答案：

``` js
var a = new Object();
a.value = 1;
b = a;
b.value = 2;
alert(a.value);
// 执行完后输出结果为2
```

[参与互动](https://github.com/yisainan/web-interview/issues/659)

</details>

<b><details><summary>83. 已知数组 var stringArray = ["This", "is", "Baidu", "Campus"]，Alert 出"This is Baidu Campus"。</summary></b>

参考答案：alert(stringArray. join(""))

[参与互动](https://github.com/yisainan/web-interview/issues/660)

</details>

<b><details><summary>84. 请描述出下列代码运行的结果</summary></b>

参考答案：

``` js
function d() {
    console.log(this);
}
d();
```

[参与互动](https://github.com/yisainan/web-interview/issues/661)

</details>

<b><details><summary>85. 需要将变量 e 的值修改为"a+b+c+d", 请写出对应的代码</summary></b>

var e="abcd"; 

参考答案：

e. split(''). join('+')

[参与互动](https://github.com/yisainan/web-interview/issues/662)

</details>

<b><details><summary>86. 设计一段代码能够遍历下列整个 DOM 节点</summary></b>

``` html
<div>
    <p>
        <span><a></a></span>
        <span><a></a></span>
    </p>
    <ul>
        <li></li>
        <li></li>
    </ul>
</div>
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/663)

</details>

<b><details><summary>87. 怎样实现两栏等高？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/664)

</details>

<b><details><summary>88. 使用 js 实现这样的效果：在文本域里输入文字时，当按下 enter 键时不换行，而是替换成"{{enter}}", (只需要考虑在行尾按下 enter 键的情况). </summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/665)

</details>

<b><details><summary>89. 以下代码中 end 字符串什么时候输出</summary></b>

``` js
var t = true;
setTimeout(function() {
    console.log(123);
    t = false;
}, 1000);
while (t) {}
console.log("end");
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/666)

</details>

<b><details><summary>90. specify('hello, world')//=>'h, e, l, l, o, w, o, r, l, d'实现 specify 函数</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/667)

</details>

<b><details><summary>91. 请将一个 URL 的 search 部分参数与值转换成一个 json 对象</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/668)

</details>

<b><details><summary>92. 请用原生 js 实现 jquery 的 get\post 功能，以及跨域情况下</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/669)

</details>

<b><details><summary>93. 请写出三种以上的 Firefox 有但 IE 没有的属性和函数</summary></b>

参考答案：

1、在 IE 下可通过 `document.frames["id"];` 得到该 IFRAME 对象，

而在火狐下则是通过 `document.getElementById("content_panel_if").contentWindow;` 

2、IE 的写法： `_tbody=_table.childNodes[0]` 
在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白""， 而 ie 不会返回空白
可以通过 `if("" != node.nodeName)` 过滤掉空白子对象

3、模拟点击事件

``` js
if (document.all) {
    //ie下
    document.getElementById("a3").click();
} else {
    //非IE
    var evt = document.createEvent("MouseEvents");
    evt.initEvent("click", true, true);
    document.getElementById("a3").dispatchEvent(evt);
}
```

4、事件注册

``` js
if (isIE) {
    window.attachEvent("onload", init);
} else {
    window.addEventListener("load", init, false);
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/670)

</details>

<b><details><summary>94. 写出 3 个使用 this 的典型应用</summary></b>

参考答案：

（1）、在 html 元素事件属性中使用，如：

``` html
<input type="button" οnclick="showInfo(this);" value="点击一下" />
```

（2）、构造函数

``` js
function Animal(name, color) {
    this.name = name;
    this.color = color;
}
```

（3）、input 点击，获取值

``` js
< input type = "button"
id = "text"
value = "点击一下" / >
    <
    script type = "text/javascript" >
    var btn = document.getElementById("text");
btn.onclick = function() {
        alert(this.value); //此处的this是按钮元素
    } <
    /script>
```

(4)、apply()/call()求数组最值

``` js
var numbers = [5, 458, 120, -215];
var maxInNumbers = Math.max.apply(this, numbers);
console.log(maxInNumbers); // 458
var maxInNumbers = Math.max.call(this, 5, 458, 120, -215);
console.log(maxInNumbers); // 458
```

[参与互动](https://github.com/yisainan/web-interview/issues/671)

</details>

<b><details><summary>95. 下面这个 ul，如何点击每一列的时候 alert 其 index?（闭包）</summary></b>

``` html
<ul id="test">
    <li>这是第一条</li>
    <li>这是第二条</li>
    <li>这是第三条</li>
</ul>
```

参考答案：

``` js
// 方法一：
var lis = document.getElementById("test").getElementsByTagName("li");
for (var i = 0; i < 3; i++) {
    lis[i].index = i;
    lis[i].onclick = function() {
        alert(this.index);
    };
}
//方法二：
var lis = document.getElementById("test").getElementsByTagName("li");
for (var i = 0; i < 3; i++) {
    lis[i].index = i;
    lis[i].onclick = (function(a) {
        return function() {
            alert(a);
        };
    })(i);
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/672)

</details>

<b><details><summary>96. 小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：</summary></b>

参考答案：

``` js
function Dog() {
    this.wow = function() {
        alert("Wow");
    };
    this.yelp = function() {
        this.wow();
    };
}
```

小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）

``` js
function MadDog() {
    this.yelp = function() {
        var self = this;
        setInterval(function() {
            self.wow();
        }, 500);
    };
}
MadDog.prototype = new Dog();
//for test
var dog = new Dog();
dog.yelp();
var madDog = new MadDog();
madDog.yelp();
```

[参与互动](https://github.com/yisainan/web-interview/issues/673)

</details>

<b><details><summary>97. 实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Numer、String、Object、Array、Boolean）进行值复制</summary></b>

参考答案：

* 察点 1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚
* 察点 2：是否知道如何判断一个变量是什么类型的
* 考察点 3：递归算法的设计

``` js
// 方法一：
Object.prototype.clone = function() {
    var o = this.constructor === Array ? [] : {};
    for (var e in this) {
        o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
    }
    return o;
};
/**
 * 克隆一个对象
 * @param Obj
 * @returns
 */
//方法二：
function clone(Obj) {
    var buf;
    if (Obj instanceof Array) {
        buf = []; //创建一个空的数组
        var i = Obj.length;
        while (i--) {
            buf[i] = clone(Obj[i]);
        }
        return buf;
    } else if (Obj instanceof Object) {
        buf = {}; //创建一个空对象
        for (var k in Obj) {
            //为这个对象添加新的属性
            buf[k] = clone(Obj[k]);
        }
        return buf;
    } else {
        //普通变量直接赋值
        return Obj;
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/674)

</details>

<b><details><summary>98. 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序。</summary></b>

参考答案：

``` js
var iArray = [];
funtion getRandom(istart, iend) {
        var iChoice = istart - iend + 1;
        return Math.floor(Math.random() * iChoice + istart;
        }
        for (var i = 0; i < 10; i++) {
            iArray.push(getRandom(10, 100));
        }
        iArray.sort();
```

[参与互动](https://github.com/yisainan/web-interview/issues/675)

</details>

<b><details><summary>99. 输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26</summary></b>

参考答案：

``` js
var d = new Date();
// 获取年，getFullYear()返回4位的数字
var year = d.getFullYear();
// 获取月，月份比较特殊，0是1月，11是12月
var month = d.getMonth() + 1;
// 变成两位
month = month < 10 ? "0" + month : month;
// 获取日
var day = d.getDate();
day = day < 10 ? "0" + day : day;
alert(year + "-" + month + "-" + day);
```

[参与互动](https://github.com/yisainan/web-interview/issues/676)

</details>

<b><details><summary>100. 写出函数 DateDemo 的返回结果，系统时间假定为今天</summary></b>

``` js
function DateDemo() {
    var d,
        s = "今天日期是：";
    d = new Date();
    s += d.getMonth() + "/";
    s += d.getDate() + "/";
    s += d.getYear();
    return s;
}
```

参考答案：今天日期是：7/17/2019

[参与互动](https://github.com/yisainan/web-interview/issues/677)

</details>

<b><details><summary>101. 下列 JavaScript 代码执行后，依次 alert 的结果是</summary></b>

``` js
var obj = {
    proto: {
        a: 1,
        b: 2
    }
};

function F() {}
F.prototype = obj.proto;
var f = new F();
obj.proto.c = 3;
obj.proto = {
    a: -1,
    b: -2
};
alert(f.a);
alert(f.c);
delete F.prototype["a"];
alert(f.a);
alert(obj.proto.a);
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/678)

</details>

<b><details><summary>102. 下列 JavaScript 代码执行后，运行的结果是</summary></b>

``` html
<button id="btn">点击我</button>
```

``` js
var btn = document.getElementById("btn");
var handler = {
    id: "_eventHandler",
    exec: function() {
        alert(this.id);
    }
};
btn.addEventListener("click", handler.exec.false);
```

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/679)

</details>

<b><details><summary>103. 输出结果是多少？</summary></b>

1）

``` js
var a; // undefined
var b = a * 0; // NaN
if (b == b) {
    // false
    console.log(b * 2 + "2" - 0 + 4);
} else {
    console.log(!b * 2 + "2" - 0 + 4); // 22 + 4 = 26
}
```

参考答案：26

2）

``` js
< script >
    var a = 1; <
/script> <
script >
    var a;
var b = a * 0;
if (b == b) { // true
    console.log(b * 2 + "2" - 0 + 4); // 6
} else {
    console.log(!b * 2 + "2" - 0 + 4);
} <
/script>
```

参考答案：6

3）

``` js
var t = 10;

function test(t) {
    var t = t++;
}
test(t);
console.log(t); // 外部不能访问函数内的变量
```

参考答案：10

4）

``` js
var t = 10;

function test(test) {
    var t = test++;
}
test(t);
console.log(t);
```

参考答案：10

6）

``` js
var t = 10;

function test(test) {
    t = test++;
    console.log(t);
}
test(t);
console.log(t);
```

参考答案：10

7）

``` js
var t = 10;

function test(test) {
    t = t + test;
    console.log(t);
    var t = 3;
}
test(t);
console.log(t);
```

参考答案：NaN 10

8）

``` js
var a;
var b = a / 0;
if (b == b) {
    console.log(b * 2 + "2" - 0 + 4);
} else {
    console.log(!b * 2 + "2" - 0 + 4);
}
```

参考答案：26

9）

``` js
< script >
    var a = 1; <
/script> <
script >
    var a;
var b = a / 0;
if (b == b) {
    console.log(b * 2 + "2" + 4);
} else {
    console.log(!b * 2 + "2" + 4);
} <
/script>
```

参考答案：Infinity24

[参与互动](https://github.com/yisainan/web-interview/issues/680)

</details>

<b><details><summary>104. 下列 JavaScript 代码执行后，iNum 的值是</summary></b>

``` js
var iNum = 0;
for (var i = 1; i < 10; i++) {
    if (i % 5 == 0) {
        continue;
    }
    iNum++;
}
console.log(iNum);
```

参考答案：8

[参与互动](https://github.com/yisainan/web-interview/issues/681)

</details>

<b><details><summary>105. 下列 JavaScript 代码执行后，依次打印的结果是</summary></b>

``` js
(function test() {
    var a = (b = 5);
    console.log(typeof a);
    console.log(typeof b);
})();
console.log(typeof a);
console.log(typeof b);
```

参考答案：

``` 
number
number
undefined
number
```

[参与互动](https://github.com/yisainan/web-interview/issues/682)

</details>

<b><details><summary>106. 不用任何插件，如何实现一个 tab 栏切换？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/683)

</details>

<b><details><summary>107. js 中如何实现一个 map</summary></b>

参考答案：

``` 
数组的map方法：

概述
map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。

语法
array.map(callback[, thisArg])

参数
callback

原数组中的元素经过该方法后返回一个新的元素。

currentValue

callback 的第一个参数，数组中当前被传递的元素。

index

callback 的第二个参数，数组中当前被传递的元素的索引。

array

callback 的第三个参数，调用 map 方法的数组。

thisArg

执行 callback 函数时 this 指向的对象。
```

实现：

``` js
Array.prototype.map2 = function(callback) {
    for (var i = 0; i < this.length; i++) {
        this[i] = callback(this[i]);
    }
};
```

[参与互动](https://github.com/yisainan/web-interview/issues/684)

</details>

<b><details><summary>108. 有 1 到 10w 这个 10w 个数，去除 2 个并打乱次序，如何找出那两个数？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/685)

</details>

<b><details><summary>109. 如何获取对象 a 拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）</summary></b>

参考答案：

``` js
Object.keys—— IE9 +
```

或者使用 for…in 并过滤出继承的属性

``` js
for (o in obj) {
    if (obj.hasOwnproperty(o)) {
        //把o这个属性放入到一个数组中
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/686)

</details>

<b><details><summary>110. 约瑟夫环—已知 n 个人（以编号 1，2，3…分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/687)

</details>

<b><details><summary>111. FF 与 IE 中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/688)

</details>

<b><details><summary>112. 下列控制台都输出什么</summary></b>

参考答案：

第 1 题：

``` js
function setName() {
    name = "张三";
}
setName();
console.log(name);
```

参考答案："张三"

第 2 题：

``` js
//考点：1、变量声明提升 2、变量搜索机制
var a = 1;

function test() {
    console.log(a);
    var a = 1;
}
test();
```

参考答案：undefined

第 3 题：

``` js
var b = 2;

function test2() {
    window.b = 3;
    console.log(b);
}
test2();
```

参考答案：3

第 4 题：

``` js
c = 5; //声明一个全局变量c
function test3() {
    window.c = 3;
    console.log(c); //参考答案：undefined，原因：由于此时的c是一个局部变量c，并且没有被赋值
    var c;
    console.log(window.c); //参考答案：3，原因：这里的c就是一个全局变量c
}
test3();
```

第 5 题：

``` js
var arr = [];
arr[0] = "a";
arr[1] = "b";
arr[10] = "c";
alert(arr.length); //参考答案：11
console.log(arr[5]); //参考答案：undefined
```

第 6 题：

``` js
var a = 1;
console.log(a++); //参考答案：1
console.log(++a); //参考答案：3
```

第 7 题：

``` js
console.log(null == undefined); //参考答案：true
console.log("1" == 1); //参考答案：true，因为会将数字1先转换为字符串1
console.log("1" === 1); //参考答案：false，因为数据类型不一致
```

第 8 题：

``` js
typeof 1;
("number");
typeof "hello";
("string");
typeof /[0-9]/;
("object");
typeof {};
("object");
typeof null;
("object");
typeof undefined;
("undefined");
typeof [1, 2, 3];
("object");
typeof

function() {}; //"function"
```

第 9 题：

``` js
parseInt(3.14); //3
parseFloat("3asdf"); //3
parseInt("1.23abc456");
parseInt(true); //"true" NaN
```

第 10 题：

``` js
//考点：函数声明提前
function bar() {
    return foo;
    foo = 10;

    function foo() {}
    //var foo = 11;
}
alert(typeof bar()); //"function"
```

第 11 题：考点：函数声明提前

``` js
var foo = 1;

function bar() {
    foo = 10;
    return;

    function foo() {}
}
bar();
alert(foo); //参考答案：1
```

第 12 题：

``` js
console.log(a); //是一个函数
var a = 3;

function a() {}
console.log(a); ////3
```

第 13 题：

``` js
//考点：对arguments的操作
function foo(a) {
    arguments[0] = 2;
    alert(a); //参考答案：2，因为：a、arguments是对实参的访问，b、通过arguments[i]可以修改指定实参的值
}
foo(1);
265、 第14题：
function foo(a) {
    alert(arguments.length); //参考答案：3，因为arguments是对实参的访问
}
foo(1, 2, 3);
```

第 15 题

``` js
bar(); //报错
var foo = function bar(name) {
    console.log("hello" + name);
    console.log(bar);
};
//alert(typeof bar);
foo("world"); //"hello"
console.log(bar); //undefined
console.log(foo.toString());
bar(); //报错
```

第 16 题

``` js
function test() {
    console.log("test函数");
}
setTimeout(function() {
    console.log("定时器回调函数");
}, 0);
test();

function foo() {
    var name = "hello";
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/689)

</details>

<b><details><summary>113. console. log( 8 | 1 ); 输出值是多少？</summary></b>

参考答案：9

[参与互动](https://github.com/yisainan/web-interview/issues/690)

</details>

<b><details><summary>114. 只允许使用 + - _ / 和 Math. _ ，求一个函数 y = f(x, a, b); 当 x > 100 时返回 a 的值，否则返回 b 的值，不能使用 if else 等条件语句，也不能使用|, ?:, 数组。</summary></b>

参考答案：

``` js
function f(x, a, b) {
    var temp = Math.ceil(Math.min(Math.max(x - 100, 0), 1));
    return a * temp + b * (1 - temp);
}
console.log(f(-10, 1, 2));
```

[参与互动](https://github.com/yisainan/web-interview/issues/691)

</details>

<b><details><summary>115. JavaScript alert(0. 4\*0. 2); 结果是多少？和你预期的一样吗？如果不一样该如何处理？</summary></b>

参考答案：有误差，应该比准确结果偏大。 一般我会将小数变为整数来处理。当前之前遇到这个问题时也上网查询发现有人用 try catch return 写了一个函数，
当然原理也是一致先转为整数再计算。看起来挺麻烦的，我没用过。

[参与互动](https://github.com/yisainan/web-interview/issues/692)

</details>

<b><details><summary>116. 如何显示/隐藏一个 dom 元素？请用原生的 JavaScript 方法实现</summary></b>

参考答案：

dom. style. display="none"; 
dom. style. display="block"; 

[参与互动](https://github.com/yisainan/web-interview/issues/693)

</details>

<b><details><summary>117. 编写一个 JavaScript 函数，输入指定类型的选择器(仅需支持 id，class，tagName 三种简单 CSS 选择器，无需兼容组合选择器)可以返回匹配的 DOM 节点，需考虑浏览器兼容性和性能。</summary></b>

参考答案：

``` js
/*** @param selector {String} 传入的CSS选择器。* @return {Array}*/
var query = function(selector) {
    var reg = /^(#)?(\.)?(\w+)$/gim;
    var regResult = reg.exec(selector);
    var result = [];
    //如果是id选择器
    if (regResult[1]) {
        if (regResult[3]) {
            if (typeof document.querySelector === "function") {
                result.push(document.querySelector(regResult[3]));
            } else {
                result.push(document.getElementById(regResult[3]));
            }
        }
    } //如果是class选择器
    else if (regResult[2]) {
        if (regResult[3]) {
            if (typeof document.getElementsByClassName === "function") {
                var doms = document.getElementsByClassName(regResult[3]);
                if (doms) {
                    result = converToArray(doms);
                }
            } //如果不支持getElementsByClassName函数
            else {
                var allDoms = document.getElementsByTagName("*");
                for (var i = 0, len = allDoms.length; i < len; i++) {
                    if (allDoms[i].className.search(new RegExp(regResult[2])) > -1) {
                        result.push(allDoms[i]);
                    }
                }
            }
        }
    } //如果是标签选择器
    else if (regResult[3]) {
        var doms = document.getElementsByTagName(regResult[3].toLowerCase());
        if (doms) {
            result = converToArray(doms);
        }
    }
    return result;
};

function converToArray(nodes) {
    var array = null;
    try {
        array = Array.prototype.slice.call(nodes, 0); //针对非IE浏览器
    } catch (ex) {
        array = new Array();
        for (var i = 0, len = nodes.length; i < len; i++) {
            array.push(nodes[i]);
        }
    }
    return array;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/694)

</details>

<b><details><summary>118. 如现在有一个效果，有显示用户头像、用户昵称、用户其他信息；当用户鼠标移到头像上时，会弹出用户的所有信息；如果是你，你会如何实现这个功能，请用代码实现？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/695)

</details>

<b><details><summary>119. call 与 apply 有什么作用？又有什么什么区别？用 callee 属性实现函数递归？</summary></b>

参考答案：apply 的参数是数组, call 的参数是单个的值，除此之外，两者没有差别，重点理解 this 的改变，callee 已经不推荐使用

[参与互动](https://github.com/yisainan/web-interview/issues/696)

</details>

<b><details><summary>120. 用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的 6~30 的字符串？</summary></b>

参考答案：var reg=/^[a-ZA-Z][\da-za-z_]{5, 29}/; 

[参与互动](https://github.com/yisainan/web-interview/issues/697)

</details>

<b><details><summary>121. 写一个函数可以计算 sum(5, 0, -5); 输出 0; sum(1, 2, 3, 4); 输出 10; </summary></b>

参考答案：

``` js
function calc() {
    var result = 0;
    for (var i = 0; i < arguments.length; i++) {
        var obj = arguments[i];
        result += obj;
    }
    return result;
}
alert(calc(1, 2, 3, 4));
```

[参与互动](https://github.com/yisainan/web-interview/issues/698)

</details>

<b><details><summary>122. 请评价以下代码并给出改进意见</summary></b>

参考答案：

``` js
if (window.addEventListener) {
    var addListener = function(el, type, listener, useCapture) {
        el.addEventListener(type, listener, useCapture);
    };
} else if (document.all) {
    addListener = function(el, type, listener) {
        el.attachEvent("on" + type, function() {
            listener.apply(el);
        });
    };
}
```

*　不应该在 if 和 else 语句中声明 addListener 函数，应该先声明；
*　不需要使用 window. addEventListener 或 document. all 来进行检测浏览器，应该使用能力检测； \*　由于 attachEvent 在 IE 中有 this 指向问题，所以调用它时需要处理一下

改进如下：

``` js
function addEvent(elem, type, handler) {
    if (elem.addEventListener) {
        elem.addEventListener(type, handler, false);
    } else if (elem.attachEvent) {
        elem["temp" + type + handler] = handler;
        elem[type + handler] = function() {
            elem["temp" + type + handler].apply(elem);
        };
        elem.attachEvent("on" + type, elem[type + handler]);
    } else {
        elem["on" + type] = handler;
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/699)

</details>

<b><details><summary>123. 对于 apply 和 call 两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</summary></b>

参考答案：但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数：?apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）。? 如 func. call(func1, var1, var2, var3)对应的 apply 写法为：func. apply(func1, [var1, var2, var3]) 。

[参与互动](https://github.com/yisainan/web-interview/issues/700)

</details>

<b><details><summary>124. 《正则》写出正确的正则表达式匹配固话号，区号 3-4 位，第一位为 0，中横线，7-8 位数字，中横线，3-4 位分机号格式的固话号</summary></b>

参考答案：/0[0-9]{2, 3}-\d{7, 8}/

[参与互动](https://github.com/yisainan/web-interview/issues/701)

</details>

<b><details><summary>125. 《算法》 一下 A, B 可任选一题作答，两题全答加分</summary></b>

A: 农场买了一只羊，第一年是小羊，第二年底生一只，第三年不生，第四年底再生一只，第五年死掉。

B: 写出代码对下列数组去重并从大到小排列{5, 2, 3, 6, 8, 6, 5, 4, 7, 1, 9}

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/702)

</details>

<b><details><summary>126. 给 String 对象添加一个方法，传入一个 string 类型的参数，然后将 string 的每个字符间加个空格返回，例如：addSpace("hello world") // -> 'h e l l o  w o r l d'</summary></b>

参考答案：

``` js
String.prototype.spacify = function() {
    return this.split("").join(" ");
};
```

接着上述问题参考答案提问，1）直接在对象的原型上添加方法是否安全？尤其是在 Object 对象上。(这个我没能答出？希望知道的说一下。)　 2）函数声明与函数表达式的区别？

参考答案：在 js 中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。

[参与互动](https://github.com/yisainan/web-interview/issues/703)

</details>

<b><details><summary>127. 请写一个正则表达式：要求最短 6 位数，最长 20 位，阿拉伯数和英文字母（不区分大小写）组成</summary></b>

参考答案：^(?=. *\d)(?=. *[a-z])(?=. *[A-Z])[a-zA-Z\d]{6, 20}$

[参与互动](https://github.com/yisainan/web-interview/issues/704)

</details>

<b><details><summary>128. 统计 1 到 400 亿之间的自然数中含有多少个 1？比如 1-21 中，有 1、10、11、21 这四个自然数有 13 个 1</summary></b>

参考答案：

归纳法

归纳法，对于个位出现的1：(n / 10) * 1 + (n % 10) >= 1 ? 1 : 0;
对于十位出现的1：(n / 100) * 10 + if (k > 19) 10 else if (k < 10) 0 else k - 10 + 1;
对于百位出现的1：(n / 1000) * 100 + if (k > 199) 10 else if (k < 100) 0 else k - 100 + 1;
最终归纳出: (n / (i * 10)) * i + if (k > 2 * i - 1) i else if (k < i) 0 else k - i + 1, 其中k = n % (i * 10);

代码：

```js
var countDigitOne = function(n) {
    let count = 0;

    for (let i = 1; i <= n; i *= 10) {
        let divide = i * 10;
        let p = Math.floor(n / divide), k = n % divide, rest = 0;

        count += p * i;
        rest = (k > (2 * i - 1)) ? i : ((k < i) ? 0 : k - i + 1);
        count += rest;
    }
    return count;
};
countDigitOne(40000000000)
```

[参与互动](https://github.com/yisainan/web-interview/issues/705)

</details>

<b><details><summary>129. 删除与某个字符相邻且相同的字符，比如 fdaffdaaklfjklja 字符串处理之后成为"fdafdaklfjklja"</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/706)

</details>

<b><details><summary>130. 请写出一个程序，在页面加载完成后动态创建一个 form 表单，并在里面添加一个 input 对象并给它任意赋值后义 post 方式提交到：http://127.0.0.1/save.php</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/707)

</details>

<b><details><summary>131. 定义一个 log 方法，让它可以代理 console. log 的方法。</summary></b>

参考答案：

可行的方法一：

``` js
function log(msg) {
    console.log(msg);
}
log("hello world!"); // hello world!
```

如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：

``` js
function log() {
    console.log.apply(console, arguments);
}
```

到此，追问 apply 和 call 方法的异同。

对于 apply 和 call 两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。

但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）。  如 func. call(func1, var1, var2, var3)对应的 apply 写法为：func. apply(func1, [var1, var2, var3]) 。

[参与互动](https://github.com/yisainan/web-interview/issues/708)

</details>

<b><details><summary>132. 编写一个快速方法将 html 的 sup 提取转换为一个数组</summary></b>

``` js
// 编写一个快速方法将html的sup提取转换为一个数组，如：
let str = "气量(10<sup>8</sup>m<sup>3</sup>)";
// 输出结果
// ['气量(10',8,'m',3,')']
```

参考答案：

``` js
// 方法1
str.split(/\<\/?sup\>/);
// 方法2
str.split(/<[^>]+>/);
```

[参与互动](https://github.com/yisainan/web-interview/issues/709)

</details>

<b><details><summary>133. 求 num 的值</summary></b>

参考答案：

``` js
// 面试题1
var num = 123;

function f1() {
    console.log(num); // 123
}

function f2() {
    var num = 456;
    f1();
}
f2();

// 面试题1 变式
var num = 123;

function f1(num) {
    console.log(num); // 456
}

function f2() {
    var num = 456;
    f1(num);
}
f2();

// 面试题1 变式
var num = 123;

function f1() {
    console.log(num); // 456
}
f2();

function f2() {
    num = 456; //这里是全局变量
    f1();
}
console.log(num); // 456
```

[参与互动](https://github.com/yisainan/web-interview/issues/710)

</details>

<b><details><summary>134. 有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行 3 次，再次执行无效，如何实现</summary></b>

这个题目是考察闭包的使用

参考答案：

``` js
function sayHi() {
    console.log("hi");
}

function threeTimes(fn) {
    let times = 0;
    return () => {
        if (times++ < 3) {
            fn();
        }
    };
}

const newFn = threeTimes(sayHi);
newFn();
newFn();
newFn();
newFn();
newFn(); // 后面两次执行都无任何反应
```

通过闭包变量 `times` 来控制函数的执行

[参与互动](https://github.com/yisainan/web-interview/issues/711)

</details>

<b><details><summary>135. 实现 add 函数, 让 add(a)(b)和 add(a, b)两种调用结果相同</summary></b>

参考答案：

``` js
function add(a, b) {
    if (b === undefined) {
        return function(x) {
            return a + x;
        };
    }
    return a + b;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/712)

</details>

<b><details><summary>136. 格式化金钱，每千分位加逗号</summary></b>

参考答案：

``` js
function format(str) {
    let s = "";
    let count = 0;
    for (let i = str.length - 1; i >= 0; i--) {
        s = str[i] + s;
        count++;
        if (count % 3 == 0 && i != 0) {
            s = "," + s;
        }
    }
    return s;
}
```

``` js
function format(str) {
    return str.replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/713)

</details>

<b><details><summary>137. 反转数组</summary></b>

### 要求

**input**: I am a student <br>
**output**: student a am I <br>
输入是数组 输出也是数组<br>
不允许用 `split`  `splice`  `reverse` <br>

参考答案：

#### 解法一

``` js
function reverseArry(arry) {
    const str = arry.join(" ");
    const result = [];
    let word = "";
    for (let i = 0, len = str.length; i < len; i++) {
        if (str[i] != " ") {
            word += str[i];
        } else {
            result.unshift(word);
            word = "";
        }
    }

    result.unshift(word);
    return result;
}

console.log(reverseArry(["I", "am", "a", "student"]));
// ["student", "a", "am", "I"]
```

#### 解法二

``` js
function reverseArry(arry) {
    const result = [];
    const distance = arry.length - 1;
    for (let i = distance; i >= 0; i--) {
        result[distance - i] = arry[i];
    }

    return result;
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/714)

</details>

<b><details><summary>138. 说出以下函数的作用是？空白区域应该填写什么？</summary></b>

参考答案：

``` js
//define
(function(window) {
    function fn(str) {
        this.str = str;
    }
    fn.prototype.format = function() {
        var arg = ______;
        return this.str.replace(_____, function(a, b) {
            return arg[b] || "";
        });
    };
    window.fn = fn;
})(window);
//use
(function() {
    var t = new fn('<p><a href="{0}">{1}</a><span>{2}</span></p>');
    console.log(t.format("http://www.alibaba.com", "Alibaba", "Welcome"));
})();
```

参考答案：访函数的作用是使用 format 函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果：
第一个空是：arguments
第二个空是：/\{(\d+)\}/ig

[参与互动](https://github.com/yisainan/web-interview/issues/715)

</details>

<b><details><summary>139. （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生 JS）</summary></b>

参考答案：

回答出概念即可，下面是几个要点

1. 给需要拖拽的节点绑定 mousedown, mousemove, mouseup 事件
2. mousedown 事件触发后，开始拖拽
3. mousemove 时，需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置
4. mouseup 时，拖拽结束
5. 需要注意浏览器边界的情况

[参与互动](https://github.com/yisainan/web-interview/issues/716)

</details>

<b><details><summary>140. 原生 JS 的 window. onload 与 Jquery 的\$(document). ready(function(){})有什么不同？如何用原生 JS 实现 Jq 的 ready 方法？</summary></b>

参考答案：

window. onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。
\$(document). ready()是 DOM 结构绘制完毕后就执行，不必等到加载完毕。

``` js
/*
 * 传递函数给whenReady()
 * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用
 */
var whenReady = (function() {
    //这个函数返回whenReady()函数
    var funcs = []; //当获得事件时，要运行的函数
    var ready = false; //当触发事件处理程序时,切换为true //当文档就绪时,调用事件处理程序
    function handler(e) {
        if (ready) return; //确保事件处理程序只完整运行一次 //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好
        if (e.type === "onreadystatechange" && document.readyState !== "complete") {
            return;
        } //运行所有注册函数 //注意每次都要计算funcs.length //以防这些函数的调用可能会导致注册更多的函数
        for (var i = 0; i < funcs.length; i++) {
            funcs[i].call(document);
        } //事件处理函数完整执行,切换ready状态, 并移除所有函数
        ready = true;
        funcs = null;
    } //为接收到的任何事件注册处理程序
    if (document.addEventListener) {
        document.addEventListener("DOMContentLoaded", handler, false);
        document.addEventListener("readystatechange", handler, false); //IE9+
        window.addEventListener("load", handler, false);
    } else if (document.attachEvent) {
        document.attachEvent("onreadystatechange", handler);
        window.attachEvent("onload", handler);
    } //返回whenReady()函数
    return function whenReady(fn) {
        if (ready) {
            fn.call(document);
        } else {
            funcs.push(fn);
        }
    };
})();
```

如果上述代码十分难懂，下面这个简化版：

``` js
function ready(fn) {
    if (document.addEventListener) {
        //标准浏览器
        document.addEventListener(
            "DOMContentLoaded",
            function() {
                //注销事件, 避免反复触发
                document.removeEventListener(
                    "DOMContentLoaded",
                    arguments.callee,
                    false
                );
                fn(); //执行函数
            },
            false
        );
    } else if (document.attachEvent) {
        //IE
        document.attachEvent("onreadystatechange", function() {
            if (document.readyState == "complete") {
                document.detachEvent("onreadystatechange", arguments.callee);
                fn(); //函数执行
            }
        });
    }
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/717)

</details>

<b><details><summary>141. 对作用域上下文和 this 的理解，看下列代码：</summary></b>

``` js
var User = {
    count: 1,
    getCount: function() {
        return this.count;
    }
};
console.log(User.getCount()); // what?
var func = User.getCount;
console.log(func()); // what?
```

问两处 console 输出什么？为什么？

参考答案：1 和 undefined。func 是在 winodw 的上下文中被执行的，所以会访问不到 count 属性。

解析：

继续追问，那么如何确保 Uesr 总是能访问到 func 的上下文，即正确返回 1。正确的方法是使用 Function. prototype. bind。兼容各个浏览器完整代码如下：

``` js
Function.prototype.bind =
    Function.prototype.bind ||
    function(context) {
        var self = this;
        return function() {
            return self.apply(context, arguments);
        };
    };
var func = User.getCount.bind(User);
console.log(func());
```

[参与互动](https://github.com/yisainan/web-interview/issues/718)

</details>

<b><details><summary>142. 手动封装一个请求函数，可以设置最大请求次数，请求成功则不再请求，请求失败则继续请求直到超过最大次数(流利说)</summary></b>

参考答案：

</details>

<b><details><summary>143. 实现一个函数判断数据类型(哔哩哔哩)</summary></b>

参考答案：

</details>

<b><details><summary>144. 对象数组如何去重？（烈熊网络）</summary></b>

参考答案：

</details>

<b><details><summary>145. 实现数组的filter方法</summary></b>

参考答案：

</details>

<b><details><summary>146. 实现数组的flat方法</summary></b>

参考答案：

</details>

<b><details><summary>147. 如何实现一个模板引擎</summary></b>

参考答案：

</details>

<b><details><summary>148. 实现一个最基本的数据绑定</summary></b>

参考答案：

</details>

<b><details><summary>149. 请实现一个函数，找出这个树形结构中所有child的name，返回数组</summary></b>

参考答案：

</details>

<b><details><summary>150. 解析 URL Params 为对象</summary></b>

参考答案：

</details>

<b><details><summary>151. 统计 1 ~ n 整数中出现 1 的次数。</summary></b>

参考答案：

</details>

<b><details><summary>152. 如何将 [{id: 1}, {id: 2, pId: 1}, ... ] 的重复数组（有重复数据）转成树形结构的数组 [{id: 1, child: [{id: 2, pId: 1}]}, ... ] （需要去重）</summary></b>

参考答案：

</details>

<b><details><summary>153. 扑克牌问题</summary></b>

参考答案：

</details>

<b><details><summary>154. 如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性</summary></b>

参考答案：

</details>

<b><details><summary>155. 实现一个 Dialog 类，Dialog可以创建 dialog 对话框，对话框支持可拖拽</summary></b>

参考答案：

</details>

<b><details><summary>156. 用 setTimeout 实现 setInterval，阐述实现的效果与setInterval的差异</summary></b>

参考答案：

</details>

<b><details><summary>157. 求两个日期中间的有效日期</summary></b>

参考答案：

</details>

<b><details><summary>158. （算法题）求多个数组之间的交集</summary></b>

参考答案：

</details>

<b><details><summary>159. 手写二进制转base64（阿里）</summary></b>

参考答案：

</details>

<b><details><summary>160. （算法题）求多个数组之间的交集</summary></b>

参考答案：

</details>

<b><details><summary>161. Async/Await 如何通过同步的方式实现异步</summary></b>

参考答案：

</details>

<b><details><summary>162. 模拟实现一个 localStorage</summary></b>

参考答案：

</details>

<b><details><summary>163. 模拟 localStorage 时如何实现过期时间功能</summary></b>

参考答案：

</details>

<b><details><summary>164. 考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素</summary></b>

参考答案：

</details>

<b><details><summary>165. 写一个单向链数据结构的 js 实现并标注复杂度</summary></b>

参考答案：

</details>

<b><details><summary>166. 使用 JavaScript Proxy 实现简单的数据绑定</summary></b>

参考答案：

</details>

<b><details><summary>167. 算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</summary></b>

参考答案：

</details>

<b><details><summary>168. 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m n))。</summary></b>

参考答案：

</details>

<b><details><summary>169. 某公司 1 到 12 月份的销售额存在一个对象里面，如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。</summary></b>

参考答案：

</details>

<b><details><summary>170. 模拟实现一个 Promise. finally</summary></b>

参考答案：

</details>

<b><details><summary>171. ES6 代码转成 ES5 代码的实现思路是什么</summary></b>

参考答案：

</details>

<b><details><summary>172. 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。</summary></b>

参考答案：

</details>

<b><details><summary>173. 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 AbC 变成 aBc 。</summary></b>

参考答案：

</details>

<b><details><summary>174. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</summary></b>

参考答案：

</details>

<b><details><summary>175. setTimeout、Promise、Async/Await 的区别</summary></b>

参考答案：

</details>

<b><details><summary>176. 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。</summary></b>

参考答案：

</details>

<b><details><summary>177. 实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现</summary></b>

参考答案：

</details>

<b><details><summary>178. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</summary></b>

参考答案：

</details>

<b><details><summary>179. 怎样实现千位分隔符</summary></b>

参考答案：

</details>

<b><details><summary>180. 请写一个正则，去除掉html标签字符串里的所有属性，并保留src和href两种属性</summary></b>

参考答案：

</details>

<b><details><summary>181. (开放题）2万小球问题：在浏览器端，用js存储2万个小球的信息，包含小球的大小，位置，颜色等，如何做到对这2万条小球信息进行最优检索和存储</summary></b>

参考答案：

</details>

<b><details><summary>182. 如何遍历一个dom树</summary></b>

参考答案：

</details>

<b><details><summary>183. 实现Array数组的flat方法</summary></b>

参考答案：

</details>

<b><details><summary>184. 获取元素的最终background-color</summary></b>

参考答案：

</details>

<b><details><summary>185. 10w 条记录的数组，一次性渲染到页面上，如何处理可以不冻结UI？</summary></b>

参考答案：

</details>

<b><details><summary>186. 说下 [1, 2, 3]. map(parseInt) 结果</summary></b>

参考答案：[1, NaN, NaN]

</details>

<b><details><summary>187. 写一个发布订阅 EventEmitter方法</summary></b>

参考答案：

</details>

<b><details><summary>188. 使用setTimeout代替setInterval进行间歇调用</summary></b>

参考答案：

</details>

<b><details><summary>189. 实现一个私有变量</summary></b>

参考答案：

</details>

<b><details><summary>190. 实现一个instanceOf</summary></b>

参考答案：

</details>

<b><details><summary>191. 实现一个JS函数柯里化</summary></b>

参考答案：

</details>

<b><details><summary>192. 手写一个继承</summary></b>

参考答案：

</details>

<b><details><summary>193. 实现一个JSON. parse</summary></b>

参考答案：

</details>

<b><details><summary>194. 实现一个JSON. stringify</summary></b>

参考答案：

</details>

<b><details><summary>195. 实现一个new操作符</summary></b>

参考答案：

</details>

<b><details><summary>196. 实现一个new操作符</summary></b>

参考答案：

</details>

<b><details><summary>197. 基本数据类型和引用类型在存储上的差别</summary></b>

参考答案：

</details>

<b><details><summary>198. 如何实现一个 apply 函数？</summary></b>

参考答案：

</details>

<b><details><summary>199. 如何实现一个 call 函数？</summary></b>

参考答案：

</details>

<b><details><summary>200. 如何实现一个 bind 函数？</summary></b>

参考答案：

</details>

<b><details><summary>201. 题目如下：可使用任意前端框架，实现一个页面</summary></b>

``` 
页面上至少包含两个element
一个input输入框，一个output[用什么容器，标签都可以]
input要求输入一个数，表示图形面积
output要求输出一个六芒星[必须自己用css+html画出来，不能使用第三方]，六芒星面积是input的数值。
当input发生改变时，输出图形使用css3新特性进行过渡。
【请注意考虑边界条件和异常输入】
加分项：input可以处理汉字表示的数字如：十一 十二
```

参考答案：

</details>

<b><details><summary>202. 下面的代码输出什么？</summary></b>

``` js
var y = 1;
if (function f() {}) {
    y += typeof f;
}
console.log(y);
```

参考答案：1undefined

JavaScript中if语句求值其实使用eval函数，eval(function f(){}) 返回 function f(){} 也就是 true。

下面我们可以把代码改造下，变成其等效代码。

``` js
var k = 1;
if (1) {
    eval(function foo() {});
    k += typeof foo;
}
console.log(k);
```

上面的代码输出其实就是 1undefined。为什么那？我们查看下 eval() 说明文档即可获得参考答案

该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。

恰恰 function f(){} 语句的返回值是 undefined，所以一切都说通了。

注意上面代码和以下代码不同。

``` js
var k = 1;
if (1) {
    function foo() {};
    k += typeof foo;
}
console.log(k); // output 1function
```

</details>

<b><details><summary>203. 写一个mul函数，使用方法如下。</summary></b>

``` js
console.log(mul(2)(3)(4)); // output : 24 
console.log(mul(4)(3)(4)); // output : 48
```

参考答案：

``` js
function mul(x) {
    return function(y) { // anonymous function 
        return function(z) { // anonymous function 
            return x * y * z;
        };
    };
}
```

简单说明下： mul 返回一个匿名函数，运行这个匿名函数又返回一个匿名函数，最里面的匿名函数可以访问 x, y, z 进而算出乘积返回即可。

</details>

<b><details><summary>204. 下面代码输出什么？</summary></b>

``` js
var output = (function(x) {
    delete x;
    return x;
})(0);

console.log(output);
```

参考答案：输出是 0。 delete 操作符是将object的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。

</details>

<b><details><summary>205. 下面代码输出什么？</summary></b>

``` js
var x = {
    foo: 1
};
var output = (function() {
    delete x.foo;
    return x.foo;
})();

console.log(output);
```

参考答案：输出是 undefined。x虽然是全局变量，但是它是一个object。delete作用在x. foo上，成功的将x. foo删去。所以返回undefined

</details>

<b><details><summary>206. 下面代码输出什么？</summary></b>

``` js
var Employee = {
    company: 'xyz'
}
var emp1 = Object.create(Employee);
delete emp1.company
console.log(emp1.company);
```

参考答案：输出是 xyz，这里的 emp1 通过 prototype 继承了 Employee的 company。emp1自己并没有company属性。所以delete操作符的作用是无效的。

</details>

<b><details><summary>207. 下面代码输出什么？</summary></b>

``` js
var trees = ["xyz", "xxxx", "test", "ryan", "apple"];
delete trees[3];

console.log(trees.length);
```

参考答案：输出是5。因为delete操作符并不是影响数组的长度。

</details>

<b><details><summary>208. 下面代码输出什么？</summary></b>

``` js
var bar = true;
console.log(bar + 0);
console.log(bar + "xyz");
console.log(bar + true);
console.log(bar + false);
```

参考答案：

``` 
1
truexyz
2
1
```

</details>

<b><details><summary>209. 下面代码输出什么？</summary></b>

``` js
var z = 1,
    y = z = typeof y;
console.log(y);
```

参考答案：输出是 undefined。js中赋值操作结合律是右至左的 ，即从最右边开始计算值赋值给左边的变量。

</details>

<b><details><summary>210. 下面代码输出什么？</summary></b>

``` js
var foo = function bar() {
    return 12;
};
typeof bar();
```

参考答案：输出是抛出异常，bar is not defined。

如果想让代码正常运行，需要这样修改代码：

``` js
var bar = function() {
    return 12;
};
typeof bar();
```

或者是

``` js
function bar() {
    return 12;
};
typeof bar();
```

明确说明这个下问题

``` js
var foo = function bar() {
    // foo is visible here 
    // bar is visible here
    console.log(typeof bar()); // Work here :)
};
// foo is visible here
// bar is undefined here
```

</details>

<b><details><summary>207. 下面代码输出什么？</summary></b>

``` js
var salary = "1000$";

(function() {
    console.log("Original salary was " + salary);

    var salary = "5000$";

    console.log("My New Salary " + salary);
})();
```

参考答案：

``` 
Original salary was undefined
My New Salary 5000$
```

这题同样考察的是变量提升。等价于以下代码

``` js
var salary = "1000$";
(function() {
    var salary;
    console.log("Original salary was " + salary);
    salary = "5000$";
    console.log("My New Salary " + salary);
})();
```

</details>

<b><details><summary>208. 什么是 instanceof 操作符？下面代码输出什么？</summary></b>

``` js
function foo() {
    return foo;
}

console.log(new foo() instanceof foo);
```

instanceof操作符用来判断是否当前对象是特定类的对象。

参考答案：返回 false

``` js
function Animal() {
    //或者不写return语句
    return this;
}
var dog = new Animal();
dog instanceof Animal // Output : true
```

</details>

<b><details><summary>209. 如果我们使用JavaScript的"关联数组"，我们怎么计算"关联数组"的长度？</summary></b>

``` js
var counterArray = {
    A: 3,
    B: 4
};
counterArray["C"] = 1;
```

参考答案：其实参考答案很简单，直接计算key的数量就可以了。

``` js
Object.keys(counterArray).length // Output 3
```

</details>

<b><details><summary>210. 针对json数组，根据某一个值排序 </summary></b>

参考答案：

``` js
var arrJson = [{
        flight: "ERWIO",
        price: 350
    },
    {
        flight: "WW250",
        price: 120
    },
    {
        flight: "QQ350",
        price: 100
    },
    {
        flight: "SDJIN",
        price: 300
    },
    {
        flight: "MH370",
        price: 120
    }
];

function sortByKey(array, key) {
    return array.sort(function(a, b) {
        var x = a[key];
        var y = b[key];
        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    });
}
arrJson = sortByKey(arrJson, 'price');
```

</details>

<b><details><summary>211. 下面代码输出什么？</summary></b>

``` js
var a = {};
b = {
    key: 'b'
};
c = {
    key: 'c'
};
a[b] = 123;
a[c] = 456;
console.log(a[b]);
```

参考答案：456

首先a声明为一个对象，b和c也是对象，执行a[b] = 123时，b会转成字符串(调用toString()方法)来当作a对象的键，b.toString() === '[object Object]'，所以a对象此时是这样的  a = {'[object Object]':123}，同理可知，c也是一个对象，所以a[c] = 456执行，其实也是a['[object Object]'] = 456，把原本的123覆盖了，故输出a[b]也就是输出a['[object Object]']，输出456。

</details>

<b><details><summary>212. 下面代码输出什么？</summary></b>

``` js
(function(x){
    return (function(y){
        console.log(x);
    })(2)
})(1);
```

参考答案：1

很简单，一个自执行函数返回了一个自执行函数，所以二者都会顺利执行，外层函数1当作x传入，内层函数2当作2传入，内层函数可以访问外层函数的变量，打印的x就是1 。

</details>

<b><details><summary>213.变量提升</summary></b>

```js
// 1
console.log(tt);
tt = "dd";
console.log(tt);
// 变量提升之后的代码：
var tt;
console.log(tt); //undefined
tt = "dd";
console.log(tt); //'dd'
```

```js
// 2
if (!a) {
  var a = 2;
}
console.log(a);
// 变量提升之后的代码：
var a; //undefined
if (!a) {
  //true
  a = 2;
}
console.log(a); //2
```

</details>

<b><details><summary>214.函数提升</summary></b>

```js
// 1
if (false) {
  function fn() {
    console.log(1);
  }
}
console.log(fn);
fn();
// 变量提升之后的代码：
var fn; //undefined
if (false) {
  function fn() {
    console.log(1);
  }
}
console.log(fn); //undefined
fn(); // fn is not a function
```

```js
// 2
function fn() {
  foo();
  return;
  function foo() {}
}
fn();
// 变量提升之后的代码：
function fn() {
  function foo() {}
  foo(); // 没有输出也不会报一个错误，因为foo是一个函数
  return;
}
fn();
```

```js
// 3
function bar() {
  console.log(foo);
  return;
  var foo = function() {};
}
bar();
// 变量提升之后的代码：
function bar() {
  var foo;
  console.log(foo); // undefined
  return; // 函数return之后的代码依旧会发生变量提升
  foo = function() {};
}
bar();
```

```js
// 4
console.log(f1);
console.log(f2);
function f1() {}
var f2 = function() {};
// 变量提升之后的代码：
function f1() {} // 函数提升，整个代码块提升到文件的最开始
var f2;
console.log(f1); // function f1() {}
console.log(f2); // undefined
f2 = function() {};
```

</details>

<b><details><summary>215.函数和变量同时提升</summary></b>

```js
// 1
console.log(fn);
var fn = function() {
  console.log(1);
};
console.log(fn);
function fn() {
  console.log(2);
}
console.log(fn);
// 变量提升之后的代码：
var fn;
function fn() {
  console.log(2);
}
console.log(fn); // 2
fn = function() {
  console.log(1);
};
console.log(fn); // 1
console.log(fn); // 1
```

```js
// 2
console.log(f1());
console.log(f2);
function f1() {
  console.log("aa");
}
var f2 = function() {};
// 变量提升之后的代码：
var f2
function f1() {
  console.log("aa"); // "aa"
}
f2 = function() {};
console.log(f1()); // undefined
console.log(f2); // ƒ () {}
```

```js
// 3
(function() {
  console.log(a);
  a = "aaa";
  var a = "bbb";
  console.log(a);
})();
// 变量提升之后的代码：
```

```js
// 4
console.log(a);
var a = 1;
console.log(a);
function a() {}
console.log(a);
// 变量提升之后的代码： 函数的提升后的位置是在变量提升后的位置之后的
var a;
function a() {}
console.log(a); // a()
a = 1;
console.log(a); // 1
console.log(a); // 1
```

```js
// 5
console.log(a);
var a = 1;
console.log(a);
function a() {}
console.log(a);
console.log(b);
var b = 2;
console.log(b);
function b() {}
console.log(b);
// 变量提升之后的代码：
var a;
var b;
function a() {}
function b() {}
console.log(a); // a()
a = 1;
console.log(a); // 1
console.log(a); // 1
console.log(b); // b()
b = 2;
console.log(b); // 2
console.log(b); // 2
```

```js
// 6
console.log(a);
console.log(b); // 报错 隐式全局变量不会提升
b = "aaa";
var a = "bbb";
console.log(a);
console.log(b);
```

</details>

<b><details><summary>216.原型链面试题</summary></b>

参考答案：

```js
// 1
function A() {}
function B() {}
B.prototype = new A();
var a = new A();
B.prototype = a;
var b = new B();
console.log(b.constructor); // 构造函数A

//2

console.log(Function.constructor === Function);
// Function 是一个构造函数
console.log(Function.__proto__.constructor === Function);

// 默认原型上面的constructor属性指向了原型所在的构造函数。

console.log(Object.constructor === Function);
// Object本身没有constructor这个属性，那么就到它的原型链上去查找，
Object.__proto__ === Function.prototype;

console.log(Function.__proto__.__proto__ === Object.prototype);
Function.__proto__ === Function.prototype;
Function.prototype.__proto__ === Object.prototype;
```

</details>

<b><details><summary>217.原型链面试题</summary></b>

参考答案：

```js
var o = new Object();
function foo(obj) {
  obj.name = "腐女";
  obj = new Object();
  obj.name = "屌丝"; //这是另一个新对象的name
}
foo(o);
console.log(o.name); //想要的是原来对象的name，所以输出腐女
```

</details>

<b><details><summary>218.箭头函数问题</summary></b>

参考答案：

第 1 题

在使用=>定义函数的时候，this 的指向是定义时所在的对象，而不是使用时所在的对象；

```js
class Animal {
  constructor() {
    this.type = "animal";
  }
  say(val) {
    setTimeout(function() {
      console.log(this); //window
      console.log(this.type + " says " + val);
    }, 1000);
  }
}
var animal = new Animal();
animal.say("hi"); //undefined says hi
```

```js
class Animal {
  constructor() {
    this.type = "animal";
  }
  say(val) {
    setTimeout(() => {
      console.log(this); //Animal
      console.log(this.type + " says " + val);
    }, 1000);
  }
}
var animal = new Animal();
animal.say("hi"); //animal says hi
```

第二题：

箭头函数里面根本没有自己的 this，而是引用外层的 this

```js
// ES6
function foo() {
  setTimeout(() => {
    console.log("id:", this.id);
  }, 100);
}

// 转成ES5
function foo() {
  var _this = this;

  setTimeout(function() {
    console.log("id:", _this.id);
  }, 100);
}
```


</details>

<b><details><summary>219.把以下代码使用两种方法，依次输出 0-9</summary></b>

参考答案：

```js
var funcs = [];
for (var i = 0; i < 10; i++) {
  funcs.push(function() {
    console.log(i);
  });
}
funcs.forEach(function(func) {
  func(); //输出十个10
});
```

解决办法：

方法一：使用立即执行函数

```js
var funcs = [];
for (var i = 0; i < 10; i++) {
  funcs.push(
    (function(value) {
      return function() {
        console.log(value);
      };
    })(i)
  );
}
funcs.forEach(function(func) {
  func(); //依次输出0-9
});
```

方法二：使用闭包

```js
function show(i) {
  return function() {
    console.log(i);
  };
}
var funcs = [];
for (var i = 0; i < 10; i++) {
  funcs.push(show(i));
}
funcs.forEach(function(func) {
  func(); //0 1 2 3 4 5 6 7 8 9
});
```

方法三：使用 let

```js
var funcs = [];
for (let i = 0; i < 10; i++) {
  funcs.push(function() {
    console.log(i);
  });
}
funcs.forEach(function(func) {
  func(); //依次输出0-9
});
```

</details>

<b><details><summary>220.手写一个 promise</summary></b>

参考答案：

```js
var promise = new Promise((resolve, reject) => {
  if (success) {
    // 操作成功
    resolve(value);
  } else {
    reject(error);
  }
});

promise
  .then(res => console.log(res))
  .catch(err => {
    console.log(err);
  });
```

</details>

<b><details><summary>221.怎么解决回调函数里面回调另一个函数，另一个函数的参数需要依赖这个回调函数。需要被解决的代码如下：</summary></b>

```js
$http.get(url).success(function (res) {
  if (success != undefined) {
    success(res);
  }
}).error(function (res) {
  if (error != undefined) {
    error(res);
  }
});

function success(data) {
  if（ data.id != 0） {
    var url = "getdata/data?id=" + data.id + "";
    $http.get(url).success(function (res) {
      showData(res);
    }).error(function (res) {
      if (error != undefined) {
        error(res);
      }
    });
  }
}
```

参考答案：使用 Promise/async/await 解决

解析：

```js
function awaitMethod(num) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(2 * num); // 此处模拟接口的请求
    }, 2000);
  });
}
// 打个比方，await是学生，async是校车，必须等人齐了再开车
async function test() {
  let result = await awaitMethod(30); // await 这个关键字只能在使用async定义的函数里面使用
  console.log(result); // 2秒钟之后控制台输出60 ; 后面利用 result 继续调用函数
  let next = await awaitMethod(result);
  console.log(next); // 4秒钟之后控制台输出120
  return next;
}
// 在async里，必须要将结果return回来，不然的话.then .catch获取不到值
test()
  .then(success => console.log("成功", success))
  .catch(error => console.log("失败", error));
```

</details>

<b><details><summary>222.以下代码依次输出的内容是？</summary></b>

```js
setTimeout(function() {
  console.log(1);
}, 0);
new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});
console.log(5);
```

参考答案：打印顺序 2 3 5 4 1

解析：

首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。

然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。

然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。

因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。

[参考](https://juejin.im/post/5b1ffff96fb9a01e345ba704)

</details>

<b><details><summary>223.jQuery 的 ajax 返回的是 promise 对象吗？</summary></b>

参考答案：

jquery 的 ajax 返回的是 deferred 对象，通过 promise 的 resolve()方法将其转换为 promise 对象。

var jsPromise = Promise.resolve(\$.ajax('/whatever.json'));

</details>

<b><details><summary>224.promise 只有 2 个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？</summary></b>

参考答案：

```
使用promise.all()

Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。

Promise.all方法接受一个数组作为参数，数组里的元素都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）

示例：
var p =Promise.all([p1,p2,p3]);
p的状态由p1、p2、p3决定，分为两种情况。
当该数组里的所有Promise实例都进入Fulfilled状态：Promise.all**返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数**。

当该数组里的某个Promise实例都进入Rejected状态：Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。
```

</details>

<b><details><summary>225.Promise 编程题</summary></b>

参考答案：

第 1 题

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
```

```
运行结果及原因

运行结果：
1 2 4 3

原因：
Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。
```

第 2 题

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success");
  }, 1000);
});
const promise2 = promise1.then(() => {
  throw new Error("error!!!");
});

console.log("promise1", promise1);
console.log("promise2", promise2);

setTimeout(() => {
  console.log("promise1", promise1);
  console.log("promise2", promise2);
}, 2000);
```

运行结果及原因

```
运行结果：
promise1 Promise { <pending> }
promise2 Promise { <pending> }
Uncaught (in promise) Error: error!!!
promise1 Promise { 'success' }
promise2 Promise {
  <rejected> Error: error!!!
    at promise.then (...)
    at <anonymous> }


原因：
promise 有 3 种状态：pending（进行中）、fulfilled（已完成，又称为Resolved） 或 rejected（已失败）。状态改变只能是 pending->fulfilled 或者 pending->rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。
```

第 3 题

```js
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});

promise
  .then(res => {
    console.log("then: ", res);
  })
  .catch(err => {
    console.log("catch: ", err);
  });
```

```
运行结果及原因

运行结果：
then：success1

原因：
构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。
```

第 4 题

```js
Promise.resolve(1)
  .then(res => {
    console.log(res); // 打印1
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res); // 打印2
  });
```

运行结果：
1 2

原因：
promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。

第 5 题

```js
Promise.resolve()
  .then(() => {
    return new Error("error!!!");
  })
  .then(res => {
    console.log("then: ", res);
  })
  .catch(err => {
    console.log("catch: ", err);
  });
```

```
运行结果
then: Error: error!!!
    at Promise.resolve.then (...)
    at ...

原因
.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：
return Promise.reject(new Error('error!!!'))
throw new Error('error!!!')

因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error('error!!!') 等价于 return Promise.resolve(new Error('error!!!'))。
```

第 6 题

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log("once");
    resolve("success");
  }, 1000);
});

const start = Date.now();
promise.then(res => {
  console.log(res, Date.now() - start);
});
promise.then(res => {
  console.log(res, Date.now() - start);
});
```

```
运行结果：
once
success 1001
success 1001
注：1001不是准确数值，也可能是998、999、1000、1002 等

原因：
promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。
```

第 7 题

```js
const promise = Promise.resolve().then(() => {
  return promise;
});
promise.catch(console.error);
```

```
运行结果
TypeError: Chaining cycle detected for promise #<Promise>...

原因
.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。
```

第 8 题

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log);
```

```
运行结果
1

原因
.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。
```

第 9 题

```js
Promise.resolve()
  .then(
    function success(res) {
      throw new Error("error");
    },
    function fail1(e) {
      console.error("fail1: ", e);
    }
  )
  .catch(function fail2(e) {
    console.error("fail2: ", e);
  });
```

```
运行结果
fail2: Error: error
    at success (...)
    at ...

原因
.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。
```

第 10 题

```js
process.nextTick(() => {
  console.log("nextTick");
});
Promise.resolve().then(() => {
  console.log("then");
});
setImmediate(() => {
  console.log("setImmediate");
});
console.log("end");
```

```
运行结果
end
nextTick
then
setImmediate

原因
process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。
```

</details>

<b><details><summary>226.看题算结果</summary></b>

```js
var tasks = []; // 这里存放异步操作的 Promise
var output = i =>
  new Promise(resolve => {
    setTimeout(() => {
      console.log(new Date(), i);
      resolve();
    }, 1000 * i);
  });

// 生成全部的异步操作
for (var i = 0; i < 5; i++) {
  tasks.push(output(i));
}

console.log(new Date, i);
```

参考答案：
```
Mon Aug 12 2019 09:37:36 GMT+0800 (中国标准时间) 5
Mon Aug 12 2019 09:33:55 GMT+0800 (中国标准时间) 0
然后每隔1s打印
Mon Aug 12 2019 09:33:56 GMT+0800 (中国标准时间) 1
Mon Aug 12 2019 09:33:57 GMT+0800 (中国标准时间) 2
Mon Aug 12 2019 09:33:58 GMT+0800 (中国标准时间) 3
Mon Aug 12 2019 09:33:59 GMT+0800 (中国标准时间) 4
```

解析：[参考](https://www.cnblogs.com/adouwt/p/6481479.html)

</details>

<b><details><summary>227.看题算结果</summary></b>

```js
// 模拟其他语言中的 sleep，实际上可以是任何异步操作
const sleep = timeountMS =>
  new Promise(resolve => {
    setTimeout(resolve, timeountMS);
  });

(async () => {
  // 声明即执行的 async 函数表达式
  for (var i = 0; i < 5; i++) {
    await sleep(1000);
    console.log(new Date(), i);
  }

  await sleep(1000);
  console.log(new Date(), i);
})();
```

参考答案：每隔1s打印
```
Mon Aug 12 2019 09:39:02 GMT+0800 (中国标准时间) 0
Mon Aug 12 2019 09:39:03 GMT+0800 (中国标准时间) 1
Mon Aug 12 2019 09:39:04 GMT+0800 (中国标准时间) 2
Mon Aug 12 2019 09:39:05 GMT+0800 (中国标准时间) 3
Mon Aug 12 2019 09:39:06 GMT+0800 (中国标准时间) 4
Mon Aug 12 2019 09:39:07 GMT+0800 (中国标准时间) 5
```


解析：[参考](https://www.cnblogs.com/adouwt/p/6481479.html)

</details>

<b><details><summary>228.简单实现async/await中的async函数</summary></b>

参考答案：

</details>

<b><details><summary>229.简单实现项目代码按需加载，例如import { Button } from antd，打包的时候只打包button</summary></b>

参考答案：

</details>

<b><details><summary>230.前端开发都应该懂的事件循环（event loop）以及异步执行顺序（setTimeout、promise和async/await）</summary></b>

参考答案：按着参考地址的文章，很容易

> 来自文章结语
1. JS是单线程执行的，同一时间只能处理一件事。但是浏览器是有多个线程的，JS引擎通过分发这些耗时的异步事件（AJAX请求、DOM操作等）给Wep APIs线程处理，因此避免了单线程被耗时的异步事件阻塞的问题。

2. Web APIs线程会将接收到的所有事件中已完成的事件根据类别分别将它们添加到相应的任务队列中。其中任务队列分以下两种：

    1. 宏任务队列（macrotask queue）：其实是叫任务队列，ES5称task queue，也即本文图中的callback queue，macrotask是我们给它的别名，原因只是为了与ES6新增的microtask队列作区分而这样称呼，HTML标准中并没有macrotask这种说法。它存放的是DOM事件、AJAX事件、setTimeout事件等。
    2. 微任务队列（microtask queue）：它存放的是Promise事件、nextTick事件等。优先级比macrotask高。

3. 事件循环（event loop） 机制是为了协调事件（events）、用户交互（user interaction）、JS脚本（scripts）、页面渲染（rendering）、网络请求（networking）等等事件的有序执行而设置（定义由HTML标准给出，实现方式是靠各个浏览器厂商自己实现）。事件循环的过程如下：

    1. JS引擎执行一个事件，当遇到异步事件时则将其交给浏览器的Web APIs线程处理，然后该事件继续执行，永远不会被抢占，一直执行到该事件结束为止（run to complete）。
    2. 当JS引擎执行完当前事件（即执行栈变为空）之后，它会先去查看microtask队列，将microtask队列中的所有待执行事件全部执行完毕。
    3. 等微任务事件全部执行完毕后，再进行页面的渲染，此时表明一轮事件循环的过程结束。然后再去查看macrotask队列，取出一个宏事件添加到执行栈执行，开始一轮新的事件，执行完毕后再去执行所有微任务事件…如此往复。此即事件循环的执行过程。

打个比方帮助理解：宏任务事件就像是普通用户，而微任务事件就像是VIP用户，执行栈要先把所有在等待的VIP用户服务好了以后才能给在等待的普通用户服务，而且每次服务完一个普通用户以后都要先看看有没有VIP用户在等待，若有，则VIP用户优先（PS：人民币玩家真的可以为所欲为，hah…）。当然，执行栈正在给一个普通用户服务的时候，这时即使来了VIP用户，他也是需要等待执行栈服务完该普通用户后才能轮到他。

4. setTimeout设置的时间其实只是最小延迟时间，并不是确切的等待时间。实际上最小延时 >=4ms，小于4ms的会被当做4ms。

5. promise 对象是由关键字 new 及Promise构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数（即 new Promise(...)中的...的内容）。这个“处理器函数”是在promise创建时是自动执行的，.then之后的内容才是异步内容，会交给Web APIs处理，然后被添加到微任务队列。

6. async/await：async函数其实是Generator函数的语法糖（解释一下“语法糖”：就是添加标准以外的语法以方便开发人员使用，本质上还是基于已有标准提供的语法进行封装来实现的），async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。执行async函数时，遇到await关键字时，await 语句产生一个promise，await 语句之后的代码被暂停执行，等promise有结果（状态变为settled）以后再接着执行。


> 以下是文章中的练习题

4.1 简单融合

```js
//请写出输出内容
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});

console.log('script end');

```

```
输出的结果：

script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

自己打印成功


4.2 变形1

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    //async2做出如下更改：
    new Promise(function(resolve) {
	    console.log('promise1');
	    resolve();
	}).then(function() {
	    console.log('promise2');
    });
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise3');
    resolve();
}).then(function() {
    console.log('promise4');
});

console.log('script end');

```

```
输出的结果：

script start
async1 start
promise1
promise3
script end
promise2
async1 end
promise4
setTimeout

```

```
自己的打印

script start
async1 start
promise1
promise3
script end
async1 end
promise2
promise4
setTimeout



async1 end
promise2
位置不对
```

4.3 变形2
```js
async function async1() {
    console.log('async1 start');
    await async2();
    //更改如下：
    setTimeout(function() {
        console.log('setTimeout1')
    },0)
}
async function async2() {
    //更改如下：
	setTimeout(function() {
		console.log('setTimeout2')
	},0)
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout3');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});

console.log('script end');
```
```
输出的结果：

script start
async1 start
promise1
script end
promise2
setTimeout3
setTimeout2
setTimeout1
```
```
自己的打印，后部分错了

script start
async1 start
promise1
script end
setTimeout2
setTimeout1
setTimeout3
promise2
```


4.4 变形3

```js
async function a1 () {
    console.log('a1 start')
    await a2()
    console.log('a1 end')
}
async function a2 () {
    console.log('a2')
}

console.log('script start')

setTimeout(() => {
    console.log('setTimeout')
}, 0)

Promise.resolve().then(() => {
    console.log('promise1')
})

a1()

let promise2 = new Promise((resolve) => {
    resolve('promise2.then')
    console.log('promise2')
})

promise2.then((res) => {
    console.log(res)
    Promise.resolve().then(() => {
        console.log('promise3')
    })
})
console.log('script end')

```

```
输出的结果：

script start
a1 start
a2
promise2
script end
promise1
a1 end
promise2.then
promise3
setTimeout
```

```
自己的打印：后部分错了


script start
a1 start
a2
promise2
script end
promise1
promise2.then
promise3
a1 end
setTimeout
```

[参考地址](https://blog.csdn.net/cc18868876837/article/details/97107219)

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. Http 状态码，Http2 是什么</summary></b>

参考答案：

200 欢迎回来，主人 （正常；请求已完成。）

301 人家搬家了 （已移动 — 请求的数据具有新的位置且更改是永久的。）

307 不是这里，换个地方啦 （重新请求的 URL，客户端自动重新请求新的地址）

400 不要把奇怪的东西给人家嘛 （错误请求 — 请求中有语法问题，或不能满足请求。）

403 这里不可以啦！（禁止 — 即使有授权也不需要访问。）

404 这里什么都没有 --- 人家是平的啦。 （找不到 — 服务器找不到给定的资源；文档不存在。）

405 打开方式不对 （资源被禁止）

414 这... 太长了啦 （请求 - URI 太长）

500 服务姬坏掉了啦 （内部错误 — 因为意外情况，服务器不能完成请求。）

503 不要... 人家还没准备好啦 （无法获得服务 — 由于临时过载或维护，服务器无法处理请求。）

101 服务姬傲娇中 （服务器将遵从客户的请求转换到另外一种协议）

100 人家... 还要... （初始的请求已经接受，客户应当继续发送请求的其余部分。）

HTTP/2（超文本传输协议第 2 版，最初命名为 HTTP 2.0），是 HTTP 协议的的第二个主要版本，使用于万维网。HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议（是 Google 开发的基于 TCP 的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。

与 HTTP 1.1 相比，主要区别包括

* HTTP/2 采用二进制格式而非文本格式
* HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
* 使用报头压缩，HTTP/2 降低了开销
* HTTP/2 让服务器可以将响应主动“推送”到客户端缓存中

解析：

| 状态码 | 类别                             | 描述                   |
| ------ | -------------------------------- | ---------------------- |
| 1xx    | Informational（信息状态码）      | 接受请求正在处理       |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕       |
| 3xx    | Redirection（重定向状态码）      | 需要附加操作已完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求     |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求出错     |

[参与互动](https://github.com/yisainan/web-interview/issues/938)

</details>

<b><details><summary>2. http1.1 时如何复用 tcp 连接（网易）</summary></b>

参考答案：在发送 http 的请求头中设置 Connection: keep-alive

[参与互动](https://github.com/yisainan/web-interview/issues/939)

</details>

<b><details><summary>3. Http 请求的整个过程</summary></b>

参考答案：

简洁版： 1. 域名解析 --> 2. 发起 TCP 的 3 次握手 --> 3. 建立 TCP 连接后发起 http 请求 --> 4. 服务器响应 http 请求，浏览器得到 html 代码 --> 5. 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等） --> 6. 浏览器对页面进行渲染呈现给用户

[参与互动](https://github.com/yisainan/web-interview/issues/940)

</details>

<b><details><summary>4. http 缓存配置怎么设置</summary></b>

参考答案：

前端设置 http 缓存, 前端设置 html 页面缓存方法：静态的 html 页面想要设置使用缓存需要通过 HTTP 的 META 设置 expires 和 cache-control

设置如下网页元信息:

```html
<meta http-equiv="Cache-Control" content="max-age=7200" />
<meta http-equiv="Expires" content="Mon, 20 Jul 2013 23:00:00 GMT" />
```

解答:
cache-control：||no-cache||no-store||max-age

1.no-cache：

表面意为“数据内容不被缓存”，而实际数据是被缓存到本地的，只是每次请求时候直接绕过缓存这一环节直接向服务器请求最新资源，由于浏览器解释不一样，

例如 ie 中我们设置了 no-cache 之后，请求虽然不会直接使用缓存，但是还会用缓存数据与服务器数据进行一致性检测(也就是说还是有几率会用到缓存的), 

firefox 中则完全无视 no-cache 存在，详细解释见 no-store; 

2.no-store：

指示缓存不存储此次请求的响应部分。与 no-cache 比较来说，一个是不用缓存，一个是不存储缓存; 按理来说这个设置更加粗暴直接禁用缓存，

但是具体实现起来 浏览器之间差异却特别大，一般不会直接用该字段进行设置，不过 no-store 是为了防止缓存被恶意修改存储路径导致信息被泄露而设置的，

毕竟有它的用处，在 firefox 中实现缓存是通过文件另存为将缓存副本保存到本地，直接利用 no-cache 对其是无效的，如果加上 no-store 设置的话 则可以起到与 no-cache 一样的效果; 

即：cache-control:no-cache, no-store; 可以确保在支持 http1.1 版本中各大浏览器回车后退刷新无缓存；

再加上 Pragma: no-cache 设置兼容版本 1.0 即可(不过为了防止一致性检测时候的万一我们还是最好加上一致性检测的内容，如下所示几种方式)；

3.max-age：

例如 Cache-control: max-age=3；表示此次请求成功后 3 秒之内发送同样请求不会去服务器重新请求，而是使用本地缓存；同样我们如果设置 max-age=0 表示立即抛弃缓存直接发送请求到服务器

以下内容来自:http://www.runoob.com/tags/att-meta-http-equiv.html

HTML <meta> http-equiv 属性
HTML meta 标签参考手册 HTML <meta> 标签

实例
每隔 30 秒刷新一次文档：

```html
<head>
    <meta http-equiv="refresh" content="30" />
</head>
```

扩展：

与缓存有关的 header
我们来看看每个 header 的具体含义。

* Request

Cache-Control: max-age=0 以秒为单位
If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。
If-None-Match: "0693f67a67cc1:0" 缓存文件的 Etag 值
Cache-Control: no-cache 不使用缓存
Pragma: no-cache 不使用缓存

* Response

Cache-Control: public 响应被缓存，并且在多用户间共享，  （公有缓存和私有缓存的区别，请看另一节）
Cache-Control: private 响应只能作为私有缓存，不能在用户之间共享
Cache-Control:no-cache 提醒浏览器要从服务器提取文档进行验证
Cache-Control:no-store 绝对禁止缓存（用于机密，敏感文件）
Cache-Control: max-age=60 60 秒之后缓存过期（相对时间）
Date: Mon, 19 Nov 2012 08:39:00 GMT 当前 response 发送的时间
Expires: Mon, 19 Nov 2012 08:40:01 GMT 缓存过期的时间（绝对时间）
Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间
ETag: "20b1add7ec1cd1:0" 服务器端文件的 Etag 值

[参与互动](https://github.com/yisainan/web-interview/issues/941)

</details>

<b><details><summary>5. 常见的浏览器端的存储技术有哪些， 以及它们的优缺点和使用场景？</summary></b>

参考答案：

#### 1. cookie

h5 之前，存储主要用 cookies，缺点是在请求头上带着数据，导致流量增加。大小限制 4k

操作方式：

```html
document.cookie = "username=John Doe; expires=Thu, 18 Dec 2013 12:00:00
GMT;path=/" // 设置 cookie document.cookie = "username=; expires=Thu, 01 Jan
1970 00:00:00 GMT" // 删除 cookie
```

设置 cookie 的方法比较简单，其中有几个参数可以添加

expires
过期时间，当过了到期日期时，浏览器会自动删除该 cookie，如果想删除一个 cookie，只需要把它过期时间设置成过去的时间即可
比如希望设置过期时间一年：new Date().getTime() + 365 _ 24 _ 60 _ 60 _ 1000

如果不设置过期时间，则表示这个 cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie 就消失了。

path
路径，值可以是一个目录，或者是一个路径。

如果 cc.com/test/index.html 建立了一个 cookie，那么在 cc.com/test/目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个 cookie。因此在 cc.com/test/test2/test3 里的任何页面都可以访问 cc.com/test/index.html 建立的 cookie。若 cc.com/test/ 若想访问 cc.com/test/index.html 设置的 cookes，需要把 cookies 的 path 属性设置成“/”。
在指定路径的时候，凡是来自同一服务器，URL 里有相同路径的所有 WEB 页面都可以共享 cookies。

domain
主机名，是指同一个域下的不同主机，例如：www.baidu.com 和 map.baidu.com 就是两个不同的主机名。默认情况下，一个主机中创建的 cookie 在另一个主机下是不能被访问的，但可以通过 domain 参数来实现对其的控制：document.cookie = "name=value; domain=.baidu.com"
这样，所有\*.baidu.com 的主机都可以访问该 cookie。

#### 2. localStorage

以键值对(Key-Value)的方式存储，永久存储，永不失效，除非手动删除。IE8+支持，每个域名限制 5M

打开同域的新页面也能访问得到

操作方式：

window.localStorage.username = 'hehe' // 设置
window.localStorage.setItem('username', 'hehe') // 设置
window.localStorage.getItem('username') // 读取
window.localStorage.removeItem('username') // 删除
window.localStorage.key(1) // 读取索引为 1 的值
window.localStorage.clear() // 清除所有
可以存储数组、数字、对象等可以被序列化为字符串的内容

#### 3. sessionStorage

sessionStorage 操作的方法与 localStroage 是一样的，区别在于 sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用 sessionStorage 就比较方便。

注意，刷新页面 sessionStorage 不会清除，但是打开同域新页面访问不到

#### 4. cookie、localStorage、sessionStorage 之间的区别

他们都是保存在浏览器端的存储方式，他们之间的区别：

cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。
存储大小限制不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。
数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
作用域不同，sessionStorage 不在不同的浏览器页面中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。
Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。
Web Storage 的 api 接口使用更方便，cookie 的原生接口不友好，需要自己封装。

#### 5. 安全性

需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储你系统中的敏感数据。

#### 6. 在浏览器多个 tab 页中，cookie、localStorage 可以共享数据，sessionStorage 仅保存在当前 tab 页中不能共享

[参与互动](https://github.com/yisainan/web-interview/issues/942)

</details>

<b><details><summary>6. 在 HTTP 响应 Header 中，set-cookie 选项有哪些，分别代表什么含义？</summary></b>

参考答案：

Set-Cookie: `<cookie-name>=<cookie-value>`

* Expires=`<date>`
* Max-Age=`<non-zero-digit>`
* Domain=`<domain-value>`
* Path=`<path-value>`
* Secure
* HttpOnly
* SameSite=Strict
* SameSite=Lax

```js
name = name; // 需要设置cookie的值(name不能使用";"和","号),有多个name值时用";"分隔例如：name1=name1;name2=name2;name3=name3

expires; //cookie的有效期限,格式为:expires="Wdy,DD-Mon-YYYY HH:MM:SS"

path; //设置cookie支持的路径,如果path是一个路径，则cookie对这个目录下的所有文件及子目录生效，例如：path="/cgi-bin/"，如果path是一个文件，则cookie指对这个文件生效，例如：path="/cgi-bin/cookie.cgi"

domain; //对cookie生效的域名，例如：domain="gzdzw.51.net"

secure; //如果给出此标志，表示cookie只能通过SSL协议的https服务器来传递,cookie的接收是通过设置环境变量HTTP_COOKIE来实现的，CGI程序可以通过检索该变量获取cookie信息
```

解析：Cookie 相关的 Http 头

有两个 Http 头部和 Cookie 有关：Set-Cookie 和 Cookie

* Set-Cookie 由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个 Cookie
* Cookie 头由客户端发送，包含在 HTTP 请求的头部中。注意，只有 cookie 的 domain 和 path 与请求的 URL 匹配才会发送这个 cookie。

[参考](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)

[参与互动](https://github.com/yisainan/web-interview/issues/943)

</details>

<b><details><summary>7. 何为跨域？ 跨域请求数据有几种方式？图片/脚本 等资源有什么跨域问题。如何解决？跨域请求时如何携带 cookie</summary></b>

参考答案：

#### 1. 何为跨域？

* 由于浏览器同源策略，凡是发送请求 url 的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。
* 同源策略限制了一个源(origin)中加载文本或脚本与来自其它源(origin)中资源的交互方式。同源指的是协议、域名、端口相同，同源策略是一种安全协议。

#### 2. 跨域请求数据有几种方式？

（1）JSONP 动态创建 script 标签

但缺点是只支持 get 请求，并且很难判断请求是否失败（一般通过判断请求是否超时）。

（2）Proxy 代理

这种方式首先将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。

（3）CORS 跨域

是现代浏览器提供的一种跨域请求资源的方法，需要客户端和服务器端的同时支持。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。

#### 3. 图片/脚本 等资源有什么跨域问题。如何解决？

#### 4. 跨域请求时如何携带 cookie

[参与互动](https://github.com/yisainan/web-interview/issues/944)

</details>

<b><details><summary>8. 简要描述 HTTPS 的安全机制，以及在 web 服务工程实践中需要注意的问题。描述 http2 和 https 的关系</summary></b>

参考答案：

* HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS。
* 默认 HTTP 的端口号为 80，HTTPS 的端口号为 443。

[参与互动](https://github.com/yisainan/web-interview/issues/945)

</details>

<b><details><summary>9. 什么是点击劫持？如何防范？</summary></b>

参考答案：

```
什么点击劫持？最常见的是恶意网站使用 <iframe> 标签把我方的一些含有重要信息类如交易的网页嵌入进去，然后把 iframe 设置透明，用定位的手段的把一些引诱用户在恶意网页上点击。这样用户不知不觉中就进行了某些不安全的操作。
```

有两种方式可以防范：

1. 使用 JS 防范：
   if (top.location.hostname !== self.location.hostname) {
   alert("您正在访问不安全的页面，即将跳转到安全页面！"); 
   top.location.href = self.location.href; 
   }

2. 使用 HTTP 头防范：
   通过配置 nginx 发送 X-Frame-Options 响应头，这样浏览器就会阻止嵌入网页的渲染。更详细的可以查阅 MDN 上关于 X-Frame-Options 响应头的内容。
   add_header X-Frame-Options SAMEORIGIN; 

[参与互动](https://github.com/yisainan/web-interview/issues/946)

</details>

<b><details><summary>10. 什么是 CSRF, 怎么造成的，有什么防御方法？</summary></b>

参考答案：

CSRF 概念：CSRF 跨站点请求伪造(Cross—Site Request Forgery)，跟 XSS 攻击一样，存在巨大的危害性，你可以这样来理解：
攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中 Web A 为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，User C 为 Web A 网站的合法用户。

CSRF 攻击攻击原理及过程如下：

       1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

       2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

       3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

       4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

       5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

防御 CSRF 攻击：

       目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

解析：

CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。

### 特点

* 依靠用户标识危害网站
* 利用网站对用户标识的信任
* 欺骗用户的浏览器发送 HTTP 请求给目标站点
* 另外可以通过 IMG 标签会触发一个 GET 请求，可以利用它来实现 CSRF 攻击。

### 防御

* 通过 referer、token 或者验证码来检测用户提交。
* 尽量不要在页面的链接中暴露用户隐私信息。
* 对于用户修改删除等操作最好都使用 post 操作 。
* 避免全站通用的 cookie，严格设置 cookie 的域。

[参与互动](https://github.com/yisainan/web-interview/issues/947)

</details>

<b><details><summary>11. 请简述如何在 HTML 中开启和关闭 DNS 预读取?</summary></b>

参考答案：

### DNS 预读取

#### 概念：

浏览器主动去执行域名解析功能。

当浏览网页时，浏览器会对网页中的域名进行解析缓存，这样当单击当前网页中的连接时就无需进行 DNS 解析，减少用户等待时间，提高用户体验。

#### 范围：

图片、CSS、JS 或 html 上的 link 等 URL。

#### 开关和使用：

```html
<meta http-equiv="x-dns-prefetch-control" content="off" />

<link rel="dns-prefetch" href="//www.spreadfirefox.com" />
```

#### 前端优化：

减少 DNS 请求次数；

进行 DNS 预获取；

[参与互动](https://github.com/yisainan/web-interview/issues/948)

</details>

<b><details><summary>12. 什么是回源？域名回源的含义是什么？</summary></b>

参考答案：在搜索引擎中所谓的域名回源就是搜索引擎的蜘蛛在爬行的过程中直接抓取源地址上的内容而不是存在各个节点（CDN）上的缓存内容。

解析：

CDN 回源率计算方法

#### 如何计算回源比？

回源比分为回源请求数比例及回源流量比例两种

**回源请求数比**：统计数据来自所有边缘节点上的请求记录，其中，对于没有缓存或缓存过期（可缓存）的请求以及不可缓存的请求，均计入回源请求中，其他直接命中缓存的，则为命中请求。

**回源流量比**：回源流量是回源请求文件大小产生的流量和请求本身产生的流量 回源流量比=回源流量/回源流量+用户请求访问的流量

源站内容有更新的时候，源站主动把内容推送到 CDN 节点。
常规的 CDN 都是回源的。即：当有用户访问某一个 URL 的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么 CDN 节点不会主动去源站拿的。

回源域名一般是 cdn 领域的专业术语，通常情况下，是直接用 ip 进行回源的，但是如果客户源站有多个 ip，并且 ip 地址会经常变化，对于 cdn 厂商来说，为了避免经常更改配置（回源 ip），会采用回源域名方式进行回源，这样即使源站的 ip 变化了，也不影响原有的配置。

CDN 本来是给我们的网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。

[参与互动](https://github.com/yisainan/web-interview/issues/949)

</details>

<b><details><summary>13. https 实现原理</summary></b>

参考答案：

HTTPS 在通讯过程中的原理，总共分为 8 步
STEP 1: 客户端发起 HTTPS 请求
STEP 2: 服务端的配置
STEP 3: 传送证书
STEP 4: 客户端解析证书
STEP 5: 传送加密信息
STEP 6: 服务端解密信息
STEP 7: 传输加密后的信息
STEP 8: 客户端解密信息

[参与互动](https://github.com/yisainan/web-interview/issues/950)

</details>

<b><details><summary>14. HTML5 的离线储存怎么使用，工作原理能不能解释一下</summary></b>

参考答案：

如何使用：只要在在页面头部加入 mainfest 的属性就行了。

```html
<!DOCTYPE html>
<html manifest="cache.manifest">

</html>
```

工作原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就像 cookie 一样被存储下来。当无网时，浏览器会通过被离线存储的数据进行展示

[参与互动](https://github.com/yisainan/web-interview/issues/951)

</details>

<b><details><summary>15. XSS</summary></b>

参考答案：

### XSS 是什么

XSS 是一种经常出现在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其它用户使用的页面中。<br>
比如这些代码包括 HTML 代码和客户端脚本。攻击者利用 XSS 漏洞旁路掉访问控制——例如同源策略(same origin policy)。<br>
这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。<br>
对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而 JavaScript 是新型的“ShellCode”。

```
示例：
<script>alert(document.cookie)</script>
```

### 特点

能注入恶意的 HTML/JavaScript 代码到用户浏览的网页上，从而达到 Cookie 资料窃取、会话劫持、钓鱼欺骗等攻击。
<攻击代码不一定（非要）在 <script></script> 中>

### 原因

* Web 浏览器本身的设计不安全。浏览器能解析和执行 JS 等代码，但是不会判断该数据和程序代码是否恶意。
* 输入和输出是 Web 应用程序最基本的交互，而且网站的交互功能越来越丰富。如果在这过程中没有做好安全防护，很容易会出现 XSS 漏洞。
* 程序员水平参差不齐，而且大都没有过正规的安全培训，没有相关的安全意识。
* XSS 攻击手段灵活多变。

### 危害

* 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
* 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
* 盗窃企业重要的具有商业价值的资料
* 非法转账
* 强制发送电子邮件
* 网站挂马
* 控制受害者机器向其它网站发起攻击

### 如何防范

* 将重要的 cookie 标记为 http only, 这样的话 Javascript 中的 document.cookie 语句就不能获取到 cookie 了.
* 表单数据规定值的类型，例如：年龄应为只能为 int、name 只能为字母数字组合。。。。
* 对数据进行 Html Encode 处理
* 过滤或移除特殊的 Html 标签， 例如: `<script>, <iframe> , &lt; for <, &gt; for >, &quot for`
* 过滤 JavaScript 事件的标签。例如 "onclick=", "onfocus" 等等。

解析：参考资料：<br>
https://www.cnblogs.com/phpstudy2015-6/p/6767032.html<br>
https://www.cnblogs.com/443855539-wind/p/6055816.html<br>
https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin

[参与互动](https://github.com/yisainan/web-interview/issues/952)

</details>

<b><details><summary>16. CSRF cookie 问题？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/953)

</details>

<b><details><summary>17. CDN 原理</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/954)

</details>

<b><details><summary>18. 如何启动浏览器硬件加速，小 Hack</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/955)

</details>

<b><details><summary>19. 什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/956)

</details>

<b><details><summary>20. 三次握手</summary></b>

参考答案：

TCP 协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。

在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”

第一次握手，客户端向服务器端发送一个带 SYN 标志的数据包，等待服务器确认

第二次握手，服务器端向客户端回传一个带有 SYN/ACK 标志的数据包，通知客户端收到了连接请求

第三次握手，客户端再次向服务器端回传一个带 ACK 标志的数据包，确认连接，“握手”结束。

[参与互动](https://github.com/yisainan/web-interview/issues/957)

</details>

<b><details><summary>21. 四次挥手</summary></b>

参考答案：

1、客户端向服务器发送一个断开连接的请求（不早了，我该走了）；

2、服务器接到请求后发送确认收到请求的信号（知道了）；

3、服务器向客户端发送断开通知（我也该走了）；

4、客户端接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；

解析：

第一次挥手：主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。

第三次挥手：被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

[参与互动](https://github.com/yisainan/web-interview/issues/958)

</details>

<b><details><summary>22. 线程与进程的区别</summary></b>

参考答案：

a. 一个程序至少有一个进程，一个进程至少有一个线程

b. 线程的划分尺度小于进程，使得多线程程序的并发性高

c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率

d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配

[参与互动](https://github.com/yisainan/web-interview/issues/959)

</details>

<b><details><summary>23. WEB 应用从服务器主动推送 Data 到客户端有那些方式？</summary></b>

参考答案：

a. html5 websoket

b. WebSocket 通过 Flash

c. XHR 长时间连接

d. XHR Multipart Streaming

e. 不可见的 Iframe

f. 标签的长时间连接(可跨域)

[参与互动](https://github.com/yisainan/web-interview/issues/960)

</details>

<b><details><summary>24. HTTP 的几种请求方法用途</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/961)

</details>

<b><details><summary>25. 常见 web 安全及防护原理</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/962)

</details>

<b><details><summary>26. 为什么要有同源限制？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/963)

</details>

<b><details><summary>27. 域名发散和域名收敛是什么？</summary></b>

参考答案：

PC 时代为了突破浏览器的域名并发限制。有了域名发散。
浏览器有并发限制，是为了防止DDOS攻击。
* 域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。
* 域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。

域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。

[参与互动](https://github.com/yisainan/web-interview/issues/964)

</details>

<b><details><summary>28. 什么是 HTTPS，做什么用的呢？如何开启 HTTPS？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/965)

</details>

<b><details><summary>29. TCP 和 UDP 的区别</summary></b>

参考答案：

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才能建立起来

UDP（User Data Protocol，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。

什么时候用TCP，什么时候用UDP呢？

对某些实时性要求比较高的时候，选择udp，比如游戏，媒体通信和实时视频流，即出现传输错误也可以容忍。其他大部分情况，HTTP都是用TCP，因为要求传输内容可靠，不出现丢失。

[参与互动](https://github.com/yisainan/web-interview/issues/966)

</details>

<b><details><summary>30. Web Worker 和 webSocket</summary></b>

参考答案：

worker 主线程:

    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。

    2.通过worker.postMessage( data ) 方法来向worker发送数据。

    3.绑定worker.onmessage方法来接收worker发送过来的数据。

    4.可以使用 worker.terminate() 来终止一个worker的执行。

WebSocket 是 Web 应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个 Html5 协议，WebSocket 的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。

[参与互动](https://github.com/yisainan/web-interview/issues/967)

</details>

<b><details><summary>31. 为什么 HTTPS 安全</summary></b>

参考答案：因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。https 之所以比 http 安全，是因为他利用 ssl/tls 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等。保障了传输过程的安全性

[参与互动](https://github.com/yisainan/web-interview/issues/968)

</details>

<b><details><summary>32.sql 注入原理</summary></b>

参考答案：就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

总的来说有以下几点：

1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。

2. 永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。

3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4. 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息。

[参与互动](https://github.com/yisainan/web-interview/issues/969)

</details>

<b><details><summary>33. XSS 原理及防范</summary></b>

参考答案：

Xss(cross-site scripting)攻击指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

[参与互动](https://github.com/yisainan/web-interview/issues/970)

</details>

<b><details><summary>34. XSS 防范方法</summary></b>

参考答案：

首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”, ”>”, ”; ”, ”’”等字符做过滤；其次任何内容写到页面之前都必须加以 encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的 XSS 攻击。

首先，避免直接在 cookie 中泄露用户隐私，例如 email、密码等等。

其次，通过使 cookie 和系统 ip 绑定来降低 cookie 泄露后的危险。这样攻击者得到的 cookie 没有实际价值，不可能拿来重放。

如果网站不需要再浏览器端对 cookie 进行操作，可以在 Set-Cookie 末尾加上 HttpOnly 来防止 javascript 代码直接获取 cookie 。

尽量采用 POST 而非 GET 提交表单

[参与互动](https://github.com/yisainan/web-interview/issues/971)

</details>

<b><details><summary>35. XSS 与 CSRF 有什么区别吗？</summary></b>

参考答案：

XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：

* 登录受信任网站 A，并在本地生成 Cookie。
* 在不登出 A 的情况下，访问危险网站 B。

[参与互动](https://github.com/yisainan/web-interview/issues/972)

</details>

<b><details><summary>36. CSRF 的防御</summary></b>

参考答案：

* 服务端的 CSRF 方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。
* 通过验证码的方法

[参与互动](https://github.com/yisainan/web-interview/issues/973)

</details>

<b><details><summary>37. 请你谈谈 Cookie 的弊端？</summary></b>

参考答案：

1. `Cookie`数量和长度的限制。每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。
2. 安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。
3. 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

[参与互动](https://github.com/yisainan/web-interview/issues/974)

</details>

<b><details><summary>38. HTTP 协议中，header 信息里面，怎么控制页面失效时间（last-modified, cache-control, Expires 分别代表什么）</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/975)

</details>

<b><details><summary>39. 本地存储（Local Storage ）和 cookies（储存在用户本地终端上的数据）之间的区别是什么？</summary></b>

参考答案：

Cookies: 服务器和客户端都可以访问；大小只有 4KB 左右；有有效期，过期后将会删除；

本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过 POST 或者 GET 的通道发送到服务器；每个域 5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用 Javascript 代码移除

[参与互动](https://github.com/yisainan/web-interview/issues/976)

</details>

<b><details><summary>40. Accept 和 Content-Type</summary></b>

参考答案：

Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用 MIME 类型来表示。
服务器使用 Content-Type 应答头通知客户端它的选择。

```
Accept: text/html
Accept: image/*
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

1. Accept 属于请求头， Content-Type 属于实体头。 <br>
Http 报头分为通用报头，请求报头，响应报头和实体报头。 <br>
请求方的 http 报头结构：通用报头|请求报头|实体报头 <br>
响应方的 http 报头结构：通用报头|响应报头|实体报头<br>

2. Accept 代表发送端（客户端）希望接受的数据类型。 <br>
比如：Accept：text/xml; <br>
代表客户端希望接受的数据类型是 xml 类型<br>

Content-Type 代表发送端（客户端|服务器）发送的实体数据的数据类型。 <br>
比如：Content-Type：text/html; <br>
代表发送端发送的数据格式是 html。<br>

二者合起来， <br>
Accept:text/xml； <br>
Content-Type:text/html <br>
即代表希望接受的数据类型是 xml 格式，本次请求发送的数据的数据格式是 html。<br>

[参与互动](https://github.com/yisainan/web-interview/issues/977)

</details>

<b><details><summary>41.http 协议缓存机制</summary></b>

参考答案：[参考](https://segmentfault.com/a/1190000010690320)

[参与互动](https://github.com/yisainan/web-interview/issues/978)

</details>

<b><details><summary>42. 如何处理不让别人盗用你的图片，访问你的服务器资源</summary></b>

参考答案：

* http header, 对 refer 做判断看来源是不是自己的网站，如果不是就拒绝
* 通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源

[参与互动](https://github.com/yisainan/web-interview/issues/979)

</details>

<b><details><summary>43. Http 与 Https 的区别</summary></b>

参考答案：

* HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
* HTTP 是不安全的，而 HTTPS 是安全的
* HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
* 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层
* HTTP 无法加密，而 HTTPS 对传输的数据进行加密
* HTTP 无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书

解析：[参考](https://zhuanlan.zhihu.com/p/33778904)

[参与互动](https://github.com/yisainan/web-interview/issues/980)

</details>

<b><details><summary>44. 什么是 Http 协议无状态协议? 怎么解决 Http 协议无状态协议?</summary></b>

参考答案：

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，<br>
当客户端一次 HTTP 请求完成以后，客户端再发送一次 HTTP 请求，HTTP 并不知道当前客户端是一个”老用户“。<br>

可以使用 Cookie 来解决无状态的问题，Cookie 就相当于一个通行证，第一次访问的时候给客户端发送一个 Cookie，<br>
当客户端再次来的时候，拿着 Cookie(通行证)，那么服务器就知道这个是”老用户“。<br>

解析：[参考](https://zhuanlan.zhihu.com/p/33778904)

[参与互动](https://github.com/yisainan/web-interview/issues/981)

</details>

<b><details><summary>45. 常用的 HTTP 方法有哪些</summary></b>

参考答案：

* GET：用于请求访问已经被 URL（统一资源标识符）识别的资源，可以通过 URL 传参给服务器。
* POST：用于传输信息给服务器，主要功能与 Get 方法类似，但一般推荐 POST 方式。
* PUT：传输文件，报文主体包含文件内容，保存到对应 URL 位置。
* HEAD：获取报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URL 是否有效。
* DELET：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。OPTIONS：查询相应 URL 支持的 HTTP 方法。

[参与互动](https://github.com/yisainan/web-interview/issues/982)

</details>

<b><details><summary>46. 一次完整的 HTTP 请求所经历的 7 个步骤</summary></b>

参考答案：

HTTP 通信机制是在一次完整的 HTTP 通信过程中，Web 浏览器与 Web 服务器之间将完成下列 7 个步骤：

* 建立 TCP 连接

在 HTTP 工作开始之前，Web 浏览器首先要通过网络与 Web 服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80。

* Web 浏览器向 Web 服务器发送请求行

一旦建立了 TCP 连接，Web 浏览器就会向 Web 服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。

* Web 浏览器发送请求头

浏览器发送其请求命令之后，还要以头信息的形式向 Web 服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

* Web 服务器应答

客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

* Web 服务器发送应答头

正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

* Web 服务器向浏览器发送数据

Web 服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 应答头信息所描述的格式发送用户所请求的实际数据。

* Web 服务器关闭 TCP 连接

一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码：

```
Connection:keep-alive
```

TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

建立 TCP 连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断 TCP 连接

解析：[参考](https://juejin.im/post/5a8102e0f265da4e710f5910)

[参与互动](https://github.com/yisainan/web-interview/issues/983)

</details>

<b><details><summary>47. webSocket 如何兼容低版本浏览器？</summary></b>

参考答案：对于低端不支持 websocket 的浏览器，一般有几个解决方案

1. 使用轮询或长连接的方式实现伪 websocket 的通信

2. 使用 flash 或其他方法实现一个 websocket 客户端 ：

[参考](https://segmentfault.com/q/1010000005000671/a-1020000005003936)
[参考](https://blog.csdn.net/u011925826/article/details/17532465)

[参与互动](https://github.com/yisainan/web-interview/issues/984)

</details>

<b><details><summary>48. 介绍 SSL 和 TLS（寺库）</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/985)

</details>

<b><details><summary>49. 说说网络的五层模型（寺库）</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/986)

</details>

<b><details><summary>50. cookie 和 token 都存放在 header 中，为什么不会劫持 token？</summary></b>

参考答案：

token不是为了防止XSS的，而是为了防止CSRF的；

CSRF攻击的原因是浏览器会自动带上cookie，而不会带上token；

cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。

token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。

xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。

csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。

上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。

以上面的 csrf 攻击为例：

cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。

token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。

[参与互动](https://github.com/yisainan/web-interview/issues/987)

</details>

<b><details><summary>51.v8 有了解过吗？讲讲了解过 v8 的那几个模块和部分，比如解释一下 v8 的 hidden class</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/988)

</details>

<b><details><summary>52. 前端如何实现即时通讯？</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/989)

</details>

<b><details><summary>53. Http 状态码 301 和 302 的应用场景分别是什么</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/990)

</details>

<b><details><summary>54. 接口如何防刷</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/991)

</details>

<b><details><summary>55. 为什么 HTTP1.1 不能实现多路复用</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/992)

</details>

<b><details><summary>56. HTTPS 握手过程中，客户端如何验证证书的合法性</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/993)

</details>

<b><details><summary>57. 介绍 HTTPS 握手过程</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/994)

</details>

<b><details><summary>58. 简单讲解一下 http2 的多路复用</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/995)

</details>

<b><details><summary>59. HTTP2.0 的多路复用和 HTTP1. X 中的长连接复用区别</summary></b>

参考答案：

[参与互动](https://github.com/yisainan/web-interview/issues/996)

</details>

<b><details><summary>60. 单工、半双工和全双工的区别</summary></b>

参考答案：

根据通信双方的分工和信号传输方向可将通信分为三种方式：单工、半双工与全双工。在计算机网络中主要采用双工方式，其中：局域网采用半双工方式，城域网和广域网采用全双年方式。 

1. 单工(Simplex)方式：通信双方设备中发送器与接收器分工明确，只能在由发送器向接收器的单一固定方向上传送数据。采用单工通信的典型发送设备如早期计算机的读卡器，典型的接收设备如打印机。 
2. 半双工(Half Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以相互传送数据，但某一时刻则只能向一个方向传送数据。例如，步话机是半双工设备，因为在一个时刻只能有一方说话。 
3. 全双工(Full Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以同时在两个方向上传送数据。例如，电话是全双工设备，因为双方可同时说话。

[参与互动](https://github.com/yisainan/web-interview/issues/996)

</details>

<b><details><summary>61. 长连接与短连接</summary></b>

参考答案：

所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。 
短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接，一般银行都使用短连接。 
比如http的，只是连接、请求、关闭，过程时间较短, 服务器若是一段时间内没有收到请求即可关闭连接。 
其实长连接是相对于通常的短连接而说的，也就是长时间保持客户端与服务端的连接状态。 
 
长连接与短连接的操作过程 
通常的短连接操作步骤是： 
连接→数据传输→关闭连接； 

而长连接通常就是： 
连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接； 
这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态，短连接在没有数据传输时直接关闭就行了 

什么时候用长连接，短连接？ 
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 

而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。 

总之，长连接和短连接的选择要视情况而定。 

发送接收方式 
1.1、异步 
报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况： 
(1)异步双工：接收和发送在同一个程序中，由两个不同的子进程分别负责发送和接收 
(2)异步单工：接收和发送是用两个不同的程序来完成。 
1.2、同步 
报文发送和接收是同步进行，既报文发送后等待接收返回报文。 同步方式一般需要考虑超时问题，即报文发出去后不能无限等待，需要设定超时时间，超过该时间发送方不再等待读返回报文，直接通知超时返回。 

在长连接中一般是没有条件能够判断读写什么时候结束，所以必须要加长度报文头。读函数先是读取报文头的长度，再根据这个长度去读相应长度的报文。 

[参与互动](https://github.com/yisainan/web-interview/issues/996)

</details>

<b><details><summary>62.应用层--HTTP 协议</summary></b>

应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、
有哪些字段等等。

#### 概况

HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传
输层协议，保证了数据传输的可靠性。

HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。

HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护
一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP
连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a
live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持
同时建立 6 个持久连接。

#### HTTP 请求报文

HTTP 报文有两种，一种是请求报文，一种是响应报文。

HTTP 请求报文的格式如下：

```http

GET / HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*

```

HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这
个空行不能省略，它用来划分首部与实体。

请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。

方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。
POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应
中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但
更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参
看[文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。

#### HTTP 响应报文

HTTP 报文有两种，一种是请求报文，一种是响应报文。

HTTP 响应报文的格式如下：

```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。

状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。

实体部分是报文的主要部分，它包含了所请求的对象。

常见的状态有

200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理
301-永久移动、302-临时移动、304-所请求的资源未修改、
400-客户端请求的语法错误、404-请求的资源不存在
500-服务器内部错误。

一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。

更多关于状态码的可以查看：

[《HTTP 状态码》](http://www.runoob.com/http/http-status-codes.html)

#### 首部行

首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设
置，区别在于请求首部和响应首部。

常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。

常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。

常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。

常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修
改时间。

更多关于首部的资料可以查看：

[《HTTP 首部字段详细介绍》](https://www.cnblogs.com/jycboy/p/http_head.html)

[《图解 HTTP》](https://blog.csdn.net/qq_34289537/article/details/52971516)

#### HTTP/1.1 协议缺点

HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序
是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许
多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他
资源请求完成后才能发起请求。

为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的
原因。

</details>

<b><details><summary>63.应用层--HTTP/2 协议</summary></b>

### HTTP/2 协议

2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明
可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。

HTTP/2 主要有以下新的特性：

#### 二进制协议

HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是
二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。
帧的概念是它实现多路复用的基础。

#### 多路复用

HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回
应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。

#### 数据流

HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的
请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每
个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。

#### 头信息压缩

HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是
重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，
客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引
号，这样就能提高速度了。

#### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源
，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用
SSE 等方式向客户端发送即时数据的推送是不同的。

详细的资料可以参考：
[《HTTP 协议入门》](http://www.ruanyifeng.com/blog/2016/08/http.html)
[《HTTP/2 服务器推送（Server Push）教程》](http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)

#### HTTP/2 协议缺点

因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵
守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都
会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。

#### HTTP/3 协议

由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC
协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能

详细资料可以参考：
[《如何看待 HTTP/3 ？》](https://www.zhihu.com/question/302412059)

</details>

<b><details><summary>64.应用层--HTTPS 协议</summary></b>

#### HTTP 存在的问题

1. HTTP 报文使用明文方式发送，可能被第三方窃听。

2. HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。

3. HTTP 还存在认证的问题，第三方可以冒充他人参与通信。

#### HTTPS 简介

HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/
SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立
刻发现。它还配备了身份证书，防止身份被冒充的情况出现。


#### TLS 握手过程

1. 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。

2. 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。

3. 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服
   务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。

4. 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。

5. 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥
   来加密信息。

#### 实现原理

TLS 的握手过程主要用到了三个方法来保证传输的安全。

首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就
是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。
这就要用到非对称加密的方法。

非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只
有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，
都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加
密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以
非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存
在的问题。

但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取
了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥
解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成
一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合
在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证
处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改
了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有
这样我们才能保证数据的安全。

详细资料可以参考：
[《一个故事讲完 https》](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)
[《SSL/TLS 协议运行机制的概述》](http://ruanyifeng.com/blog/2014/02/ssl_tls.html)
[《图解 SSL/TLS 协议》](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
[《RSA 算法原理（一）》](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
[《RSA 算法原理（二）》](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)
[《分分钟让你理解 HTTPS》](https://juejin.im/post/5ad6ad575188255c272273c4)

</details>

<b><details><summary>65.应用层--DNS 协议</summary></b>

#### 概况

DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分
布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号
端口。

#### 域名的层级结构

域名的层级结构可以如下

```
主机名.次级域名.顶级域名.根域名

# 即

host.sld.tld.root
```

根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。

#### 查询过程

DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。

1. 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
2. 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
3. 从"次级域名服务器"查出"主机名"的 IP 地址。

比如我们如果想要查询 www.baidu.com 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务
器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名
服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com
的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服
务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。

#### DNS 记录和报文

DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为

（Name，Value，Type，TTL）

其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。

常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。

1. 如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标
   准的主机名到 IP 地址的映射。

2. 如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式
   查询时，返回下一级需要查询的 DNS 服务器的信息。

3. 如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名
   对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供
   一个便于记忆的简单的别名。

4. 如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一
   样的，都是为了解决规范主机名不利于记忆的缺点。

#### 递归查询和迭代查询

递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归
查询，用户只需要发出一次查询请求。

迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出
多次的查询请求。

一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我
们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次
查询的结果，下一级的查询由本地 DNS 服务器自己进行。

#### DNS 缓存

DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本
地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。

#### DNS 实现负载平衡

DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应
多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在
每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不
同的服务器上，这样来实现负载均衡。

详细资料可以参考：
[《DNS 原理入门》](http://www.ruanyifeng.com/blog/2016/06/dns.html)
[《根域名的知识》](http://www.ruanyifeng.com/blog/2018/05/root-domain.html)

</details>

<b><details><summary>66.传输层--多路复用与多路分解</summary></b>

传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。

### 多路复用与多路分解

将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。

在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。

无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一
个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端
口号，那么不同的报文段将会转交到同一个 UDP 套接字中。

面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了
源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个
值来将报文段定向到相应的套接字。

</details>

<b><details><summary>67.传输层--UDP 协议</summary></b>

参考答案：

UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差
错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。

特点：

1. 使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手
   过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。

2. UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。

3. UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。

4. 因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互
   通信。

5. UDP 首部小，只有 8 个字节。

#### UDP 报文段结构

UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长
度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。
虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。

![UDP 报文段结构](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png)


</details>

<b><details><summary>68.传输层--TCP 协议</summary></b>

参考答案：

TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。

特点：

1. TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。

2. TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。

3. TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。

4. TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。

5. TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。

6. TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送
   速率，避免因为缓存填满而造成的数据包的丢失。

#### TCP 报文段结构

TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。

源端口和目的端口号用于报文段的多路复用和分解。

32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。

16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。

4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。

6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字
段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。

校验和提供了对数据的差错检测。

![TCP 报文段结构](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png)

#### TCP 三次握手的过程

第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的
随机数。它代表的是客户端数据的初始序号。

第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向
客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，
同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加
一。

第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务
器端的报文段的确认。第三次握手可以在报文段中携带数据。

在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。
第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否
已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。

详细资料可以参考：
[《TCP 为什么是三次握手，而不是两次或四次？》](https://www.zhihu.com/question/24853633)
[《TCP 的三次握手与四次挥手》](https://blog.csdn.net/qzcsu/article/details/72861891)

#### TCP 四次挥手的过程

因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。

第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的
连接。发送后客户端进入 FIN_WAIT_1 状态。

第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的
请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务
器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。

第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS
T_ACK 状态。

第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，
这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到
服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被
释放了。

TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代
表不能再向对方发送数据，连接处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器
端不能正常关闭。

详细资料可以参考：

[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c447392e51d45524b02eaf5)

#### 状态转化图

![客户端状态图](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-18.png)

![服务端状态图](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-19.png)

#### ARQ 协议

ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的
机制。

它分为停止等待 ARQ 协议和连续 ARQ 协议。

一、停止等待 ARQ 协议

停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认
回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。

对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余
分组的确认。当收到分组损坏的情况的时候，直接丢弃。

使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。

二、连续 ARQ 协议

连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的
确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。

1. 滑动窗口协议

使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发
送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分
组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定
时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没
有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分
组。

接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那
么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，
所以发送窗口可以移动到已确认分组的后面。

滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况
的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。

2. 选择重传协议

因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。

选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，
已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协
议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的
定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分
组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。

在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分
组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。

详细资料可以参考：
[《TCP 连续 ARQ 协议和滑动窗口协议》](https://blog.csdn.net/guoweimelon/article/details/50879588)

#### TCP 的可靠运输机制

TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。

TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但
未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发
送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。
如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如
果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送
但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，
说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发
送但确认的报文段。

接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文
段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都
已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。

发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文
段的发送速率。

但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重
传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。

#### TCP 的流量控制机制

TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大
于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据
接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。

#### TCP 的拥塞控制机制

TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的
速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。

TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。

慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探
，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达
到一个阈值的时候就进入拥塞避免算法。

拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。
这样将窗口的增长速率由指数增长，变为加法线性增长。

快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的
丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。

快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥
塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。

TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四
种机制来达到拥塞控制的目的。

详细资料可以参考：
[《TCP 的拥塞控制机制》](https://www.jianshu.com/p/7d59f9292b03)
[《网络基本功：TCP 拥塞控制机制》](http://www.voidcn.com/article/p-vrdkquop-ms.html)

</details>

<b><details><summary>69.网络层</summary></b>

参考答案：

网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选
择协议。

IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用
32 位来分配地址，还有 IPv6 使用 128 位来分配地址。

路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。

</details>

<b><details><summary>70.数据链路层</summary></b>

参考答案：

数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，
这是由网络适配器决定的，在全世界都是独一无二的。

</details>

<b><details><summary>71.物理层</summary></b>

参考答案：

物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质
是什么。

详细资料可以参考：
[《搞定计算机网络面试，看这篇就够了（补充版）》](https://juejin.im/post/5b7be0b2e51d4538db34a51e#heading-1)
[《互联网协议入门（一）》](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)
[《互联网协议入门（二）》](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)

</details>


<b><details><summary>72. TLS/SSL 中什么一定要用三个随机数，来生成"会话密钥"？</summary></b>

参考答案：

```
客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主
机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，
一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。
```

</details>

<b><details><summary>73. SSL 连接断开后如何恢复？</summary></b>

参考答案：

```
一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。

使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器
如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是
这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那
么就无法恢复对话。

另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的
，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器
上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。
```

</details>

<b><details><summary>74. RSA 算法的安全性保障？</summary></b>

参考答案：

```
对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在102
4位的 RSA 密钥基本安全，2048位的密钥极其安全。
```

</details>

<b><details><summary>75. DNS 为什么使用 UDP 协议作为传输层协议？</summary></b>

参考答案：

```
DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地
址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大
多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，
UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的
DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不
会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一
个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。

DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，
所以现在有了 DNS over HTTPS 来解决这个问题。
```

详细资料可以参考：
[《为什么 DNS 使用 UDP 而不是 TCP？》](https://www.zhihu.com/question/310145373)

</details>

<b><details><summary>76. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</summary></b>

参考答案：

```
（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，
将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字
符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新
的请求。

（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果
有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域
名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地
址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用
户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源
端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给
数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地
址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果
在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该
转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应
该为网关的地址。

（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接
收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的
确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立
状态，此时双方的连接就建立起来了。

（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版
本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证
书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后
发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解
密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加
密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行
解析，开始页面的渲染过程。

（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端
是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建
立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页
面进行绘制。这个时候整个页面就显示出来了。

（9）最后一步是 TCP 断开连接的四次挥手过程。
```

详细资料可以参考：
[《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》](http://blog.jobbole.com/84870/)

</details>

<b><details><summary>77. 谈谈 CDN 服务？</summary></b>

参考答案：

```
CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的
功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源
的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。
```

详细资料可以参考：
[《CDN 是什么？使用 CDN 有什么优势？》](https://www.zhihu.com/question/36514327?rf=37353035)

</details>

<b><details><summary>78. 什么是正向代理和反向代理？</summary></b>

参考答案：

```
我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的
服务都被代理服务器代替来请求。

反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知
道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向
代理器一般用来实现负载平衡。
```

详细资料可以参考：
[《正向代理与反向代理有什么区别》](https://mp.weixin.qq.com/s/ikrI3rmSYs83wdSWqq2QIg?)
[《webpack 配置 proxy 反向代理的原理是什么？》](https://segmentfault.com/q/1010000017502539/a-1020000017532348)

</details>

<b><details><summary>79. 负载平衡的两种实现方式？</summary></b>

参考答案：

```
一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实
现集群的负载平衡。

另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一
个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在
每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服
务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解
析仍然返回的是那个 IP 地址，就会造成访问的问题。
```

详细资料可以参考：
[《负载均衡的原理》](https://mp.weixin.qq.com/s?__biz=MzA5Njc2OTg4NQ==&mid=2247483870&idx=1&sn=bab36544ec62c394c104df699cf85154&chksm=90aa43eca7ddcafa01634cefee12fd8a332250d3f49d8b6647f536c215ac297e4b6a53af8253#rd)

</details>

<b><details><summary>80. http 请求方法 options 方法有什么用？</summary></b>

参考答案：

```
 OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请
 求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest
 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。
```

相关资料可以参考：
[《HTTP 请求方法》](https://itbilu.com/other/relate/EkwKysXIl.html)

</details>

<b><details><summary>81. http1.1 和 http1.0 之间有哪些区别？</summary></b>

参考答案：

```
http1.1 相对于 http1.0 有这样几个区别：
（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。

（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。
```

详细资料可以参考：
[《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》](https://juejin.im/entry/5981c5df518825359a2b9476)
[《HTTP 协议入门》](http://www.ruanyifeng.com/blog/2016/08/http.html)
[《网络---一篇文章详解请求头 Host 的概念》](https://blog.csdn.net/netdxy/article/details/51195560)

</details>

<b><details><summary>82. 网站域名加 www 与不加 www 的区别？</summary></b>

参考答案：

详细资料可以参考：
[《为什么域名前要加 www 前缀 www 是什么意思？》](https://www.f9seo.com/post-816.html)
[《为什么越来越多的网站域名不加「www」前缀？》](https://www.zhihu.com/question/20414602)
[《域名有 www 与没有 www 有什么区别？》](https://blog.csdn.net/andybruse/article/details/7982278)

</details>

<b><details><summary>83. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</summary></b>

参考答案：

```
短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。

短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行
响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客
户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 ht
tp 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。

长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将
这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。
客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的
优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。

SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通
方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断
地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机
制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不
需要建立过多的 http 请求，相比之下节约了资源。

上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协
议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置
比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能
由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。
```

详细资料可以参考：
[《轮询、长轮询、长连接、websocket》](https://cloud.tencent.com/developer/article/1076547)
[《Server-Sent Events 教程》](http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)
[《WebSocket 教程》](http://www.ruanyifeng.com/blog/2017/05/websocket.html)

</details>

<b><details><summary>84. 怎么实现多个网站之间共享登录状态</summary></b>

参考答案：

```
在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发
送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该
token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站
点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将
页面重定向会单点登录页面。
```

详细资料可以参考：
[《HTTP 是个无状态协议，怎么保持登录状态？》](https://www.zhihu.com/question/35906139)

</details>

<b><details><summary>85. token相对cookie的优势</summary></b>

参考答案：

* 无状态
基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。

服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。

* 防跨站请求伪造（CSRF）
举个CSRF攻击的例子，在网页中有这样的一个链接
![](http://bank.com?withdraw=1000&to=tom)，假设你已经通过银行的验证并且cookie中存在验证信息，同时银行网站没有CSRF保护。一旦用户点了这个图片，就很有可能从银行向tom这个人转1000块钱。

但是如果银行网站使用了token作为验证手段，攻击者将无法通过上面的链接转走你的钱。（因为攻击者无法获取正确的token）

* 多站点使用
cookie绑定到单个域。foo.com域产生的cookie无法被bar.com域读取。使用token就没有这样的问题。这对于需要向多个服务获取授权的单页面应用程序尤其有用。

使用token，使得用从myapp.com获取的授权向myservice1.com和myservice2.com获取服务成为可能。

* 支持移动平台
好的API可以同时支持浏览器，iOS和Android等移动平台。然而，在移动平台上，cookie是不被支持的。

* 性能
一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。

详细资料可以参考：
[Cookie和Token](https://www.jianshu.com/p/ce9802589143)

</details>

<b><details><summary>86.JWT是什么</summary></b>

参考答案：

JWT(JSON Web Token), 顾名思义就是可以在Web上传输的token，这种token是用JSON格式进行format的。它是一个开源标准(RFC 7519)，定义了一个紧凑的自包含的方式在不同实体之间安全的用JSON格式传输信息。

基于JWT的信息可以通过数字签名进行校验。校验的方法即可以使用消息摘要（HMAC），或者非对称加密（RSA）。

JWT具有两个特点：

紧凑。由于其较小的尺寸，JWT可以通过URL，POST参数或者HTTP头发送。较小的尺寸会带来传输速度的优势；
自包含：token中包含了用户的所有必须信息，避免了多次查询数据库的需要。

#### 应用场景

以下是JWT有用的一些场景

验证：这是JWT最常用的场景。一旦用户登陆成功，每个后续的请求将包括JWT，服务器在对JWT进行验证后，允许用户访问服务和资源。单点登陆是一个广泛使用JWT的场景，因为它的开销相对较小，并且能够在不同的域中轻松使用。
信息交换：JWT是在可以安全地传输信息。因为JWT可以被签名，收信人可以确认发信人的身份，同时也能够验证内容是否被篡改。

格式
JWT包括三个部分：头部、载荷和签名，这三个部分通过.连接起来。

因此，一个典型的JWT长这样xxxxx.yyyyy.zzzzz。

头部
头部通常包括两部分：token类型（JWT），和使用到的算法，如HMAC、SHA256或RSA，下面是一个例子，说明这是一个JWT，使用的签名算法是HS256。

{
  "alg": "HS256",
  "typ": "JWT"
}
头部会通过Base64Url编码形成JWT的第一部分

载荷
第二部分是载荷，要传递出去的声明，其中包含了实体（通常是用户）和附加元数据。有三种类型的声明：

保留声明：这是一组预定义的声明，非强制性，用来帮助接收方（服务器）更好地理解这个JWT。其中包括：iss（issuer，该JWT的签发者），exp（expiration time，过期时间），sub（subject，该JWT所面向的用户），aud（audience，JWT的接收者），和另外一些声明
公共声明：这些可以用使用JWT的人随意定义。但是为了避免冲突，应在在IANA JSON WEB令牌注册表中定义它们，或者将其定义为包含防冲突命名空间的URI。
私有声明：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明。
下面是一个例子

{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
载荷会通过Base64Url编码形成JWT的第二部分

签名
将上面两部分编码后，使用.连接在一起，形成了xxxxx.yyyyyy。

最后，采用头部指定的算法，和私钥对上面的字符串进行签名。

加入采用的是HMAC SHA256 算法，签名将通过下面的方式生成

HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)
该签名用户验证JWT发送者的身份，并确保该消息没有被篡改。

#### JWT工作流程

在身份验证过程中，一旦用户使用其凭据成功登陆，服务器将返回JWT，该JWT必须在客户端本地保存。这和服务器创建会话并返回cookie的传统方法不同。

每次用户要请求受保护的资源时，必须在请求中带上JWT。通常在Authorization头Bearer中，如下：

Authorization: Bearer <token>
这是一种无状态的认证机制，因为用户状态永远不会保存在服务器内存中。服务器的受保护路由将在授权头中检查有效的JWT，如果存在，则允许用户访问受保护的资源。由于JWT是自说明的，包含了所有必要的信息，这就减少了多次查询数据库的需要。

这样可以完全依赖无状态的数据API，甚至可以向下游服务发出请求。API的作用域并不重要，因此跨源资源共享（CORS）不会是一个问题，因为它不使用Cookie。

整个流程如下图：

![网络及安全防护_001](../images/网络及安全防护_001.png)

#### 使用JWT的理由

现在来谈谈JWT与简单网页令牌（SWT）和安全断言标记语言令牌（SAML）相比的优势。

由于JSON比XML更短小，编码时其大小也较小，使得JWT比SAML更紧凑。这使得JWT成为在HTML和HTTP环境中能更快地传递。

从安全角度来说，SWT只能通过使用HMAC算法的共享密钥进行对称签名。但是，JWT和SAML令牌可以以X.509证书的形式使用公钥/私钥对进行签名。与简单的JSON签名相比，使用XML数字签名签名XML而不引入模糊的安全漏洞是非常困难的。

JSON解析器在大多数编程语言中很常见，因为它们直接映射到对象。相反，XML没有自然的文档对对象映射。这使得使用JWT比SAML断言更容易。

从使用平台来说，JWT在Internet规模上使用。这突出了客户端处理多个平台上特别是移动平台上的JSON Web令牌的便利性。

参考链接：https://www.jianshu.com/p/ce9802589143

</details>

<b><details><summary>87. Cookie、Session、Token、JWT对比与总结</summary></b>

参考答案：

#### 什么是认证（Authentication）

通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）

互联网中的认证：

用户名密码登录

邮箱发送登录链接

手机号接收验证码

只要你能收到邮箱/验证码，就默认你是账号的主人

#### 什么是授权（Authorization）

用户授予第三方应用访问该用户某些资源的权限

你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）

你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）

实现授权的方式有：cookie、session、token、OAuth

#### 什么是凭证（Credentials）

实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份

在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。

在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。

在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。

#### 什么是 Cookie

HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。

cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。

#### 什么是 Session

session 是另一种记录服务器和客户端会话状态的机制

session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

#### Cookie 和 Session 的区别

安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。

存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。

有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

#### 什么是 Token（令牌）

Acesss Token
访问资源接口（API）时所需要的资源凭证

简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）

特点：

服务端无状态化、可扩展性好

支持移动端设备

安全

支持跨程序调用

#### Token 和 Session 的区别

Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。

Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。

所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。

#### 什么是 JWT

JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。

是一种认证授权机制。

JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。

可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。

参考地址：https://blog.csdn.net/wangzhipeng47/article/details/107867617

</details>

<b><details><summary>88.http中的301、302、307、308有什么区别？</summary></b>

参考答案：

```
301：永久移动
302：发现
307：临时重定向
308：永久重定向
```

</details>

<b><details><summary>89.说说你对短连接的理解，它有什么应用场景呢？</summary></b>

参考答案：短连接的理解就是，在进行三次握手建立连接之后，发送数据包并且获得服务器返回结果之后之后，再进行第四次握手关闭断开。
应用场景是区别于长连接（即在非服务端超时或者客户端主动断开的情况下，不断开连接），常用于低频率请求，页面刷新不频繁的场景。

</details>

<b><details><summary>90.列举你所了解的计算机存储设备类型？</summary></b>

参考答案：

现代计算机以存储器为中心，主要由 CPU、I / O 设备以及主存储器三大部分组成。各个部分之间通过总线进行连接通信，具体如下图所示： 

[!示例图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40d43236ef74ed4a3ae4fd2a697b8b9~tplv-k3u1fbpfcp-watermark.awebp)

上图是一种多总线结构的示意图，CPU、主存以及 I / O 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 CPU 的吞吐量（CPU 不需要直接跟 I / O 设备通信），而使用高速总线（更贴近 CPU）和 DMA 总线则是为了提升高速 I / O 设备（外设存储器、局域网以及多媒体等）的执行效率。
主存包括随机存储器 RAM 和只读存储器 ROM，其中 ROM 又可以分为 MROM（一次性）、PROM、EPROM、EEPROM 。ROM 中存储的程序（例如启动程序、固化程序）和数据（例如常量数据）在断电后不会丢失。RAM  主要分为静态 RAM（SRAM） 和动态 RAM（DRAM） 两种类型（DRAM 种类很多，包括 SDRAM、RDRAM、CDRAM 等），断电后数据会丢失，主要用于存储临时程序或者临时变量数据。 DRAM  一般访问速度相对较慢。由于现代 CPU 读取速度要求相对较高，因此在 CPU 内核中都会设计 L1、L2 以及 L3 级别的多级高速缓存，这些缓存基本是由 SRAM 构成，一般访问速度较快。

</details>

<b><details><summary></summary></b>

参考答案：

</details>【黑马前端39期】链接: https://pan.baidu.com/s/15sXO4ZgFSabAh9NjglDU5A 提取码: ea4t

【前端书籍】 链接: https://pan.baidu.com/s/14mYsbhn-apotwu9rMrxPWQ 提取码: pdas

【尚学堂WEB前端+移动端全套视频教程】 链接: https://pan.baidu.com/s/14mYsbhn-apotwu9rMrxPWQ 提取码: pdas

【传智黑马前端36期】 链接: https://pan.baidu.com/s/1APGFFPi3lLNzk_6xdY6eSQ 提取码: hf3e

【WEB前端开发赠送项目实战】 链接: https://pan.baidu.com/s/1vYDrgF-D-WoWfPLSqgJjTw 提取码: q5ss

【简历模板】 链接: https://pan.baidu.com/s/1J020ZE1kR4ycTH_fQ9zzkA 提取码: 8q1d

【Vue.js 2.5 + cube-ui 重构饿了么 App】 链接: https://pan.baidu.com/s/1IOubcRr688vcZRB27HuGJg 提取码: 4bun

【Vue2.x实战项目】 链接: https://pan.baidu.com/s/1crT-nlRptMV0yNZoSLg7UQ 提取码: skzu

【微信小程序入门与实战】 链接: https://pan.baidu.com/s/1T4dO3anh44n1_vJHdlFQvA 提取码: nijy

【Angular JS 仿拉勾网 WebApp】 链接: https://pan.baidu.com/s/1yIkM_IGkhfXBazKPs4r7sw 提取码: ei69

【6小时 jQuery开发一个前端应用】 链接: https://pan.baidu.com/s/18wc8293s5H-2jv7X_VH7lw 提取码: 2ttq

【vue去哪儿无密APP】 链接: https://pan.baidu.com/s/13k_74Zy8FKUn0-2KLeUwaA 提取码: tvsj

【webApp书城整站开发】 链接: https://pan.baidu.com/s/1dJO7B2edvE29dgIiz7sb4Q 提取码: tzra

【vue.js高仿饿了么（1-13章全）】链接: https://pan.baidu.com/s/1Zso5w2G2vU6tUVQJfV4wPw 提取码: wkq5

【Vue全家桶+SSR+Koa2全栈开发美团网】 链接: https://pan.baidu.com/s/1sw_ePpsizMUa-uy9Hps75Q 提取码: hfrs

【Vue 2.0 高级实战-开发移动端音乐 WebApp】 链接: https://pan.baidu.com/s/1vTQzzvJ-5bkw1lR27Ybe5Q 提取码: t5yc

【Vue核心技术 Vue+Vue-Router+Vuex+SSR实战精讲】 链接: https://pan.baidu.com/s/1578CAkg-OtiCh3nJo_qsVA 提取码: uvsi

【vue2.0+node.js+MongoDB全栈打造商城（完整版）】 链接: https://pan.baidu.com/s/1YiXCxi475lcDatgaE_E23g 提取码: h9my## 工作动机、个人愿望
（1）问题：请给我们谈谈你自己的一些情况

回答：简要的描述你的相关工作经历以及你的一些特征，包括与人相处的能力和个人的性格特征。如果你一下子不能够确定面试者到底需要什么样的内容，你可以这样说：“有没有什么您特别感兴趣的范围？”

点评：企业以此来判断是否应该聘用你。通过你的谈论，可以看出你想的是如何为公司效力还是那些会影响工作的个人问题。当然，还可以知道你的一些背景。

（2）问题：你是哪年出生的？你是哪所大学毕业的？等等

回答：我是XXXX年出生的。我是XX大学毕业的。

点评：这类问题至为关键的是要针对每个问题简洁明了的回答，不可拖泥带水，也不必再加什么说明。完全不必再画蛇添足的说“我属X，今年XX岁”之类的话。至于专业等或许主考官接下来的问题就是针对此而言的，故而不必迫不及待和盘托出。

（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？

回答：可根据你先前对该公司的情报收集，叙述一下你对公司的了解。适当的对公司的声誉、产品和发展情况予以赞美。还可以提提你为了了解公司的情况所做的努力然后就说你非常喜欢这个工作，而且你的能力也非常适合并能胜任这份工作。

点评：此问目的测试一下你对公司的了解和喜欢的程度，看看你的能力是否符合公司的要求和方向。看看你是真正地愿意为公司效力，还是仅仅冲着公司的福利、声望和工作的稳定。

（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？

回答：
1.是的。
2.我看不见得。

点评：
一般按1回答，一切便大功告成。
有些同学为了显示自己的“不卑不亢“，强调个人尊严，故按2回答。结果，用人单位打消了录用该生的念头，理由是：“此人比较傲“一句话，断送了该生一次较好的就业机会。

（5）问题：你是怎么应聘到我们公司的？

回答：贵公司是国际上有名的汽车工业公司，虽然我学的专业不是汽车专业，但我一直留意、关心贵公司的发展，特别是贵公司注重对员工的培训，更让我心动，另外象贵公司这样大的企业，我想是各种专业人才都需要的，便毅然前来应聘。

点评：该毕业生的专业虽然不是该公司紧缺的专业，但他分析了公司招聘职位的具体要求，认为可以应试该公司的某一种职位要求。（如管理、营销、秘书），如食品工程专业的求职面远不只局限于食品的加工企业，可延伸至饮品、酒类、保健品、调味品甚至酒楼等多个行业。都会有适合自己的职位。

（6）问题：请你谈谈对我单位的看法

回答：我对贵单位还没什么了解，故谈不出看法

点评：象这样的回答，一般面试不成功多，如你很想进入该单位，就不妨实地去单位“侦察”一番，或收集有关的资料。如有一位毕业生，他有意去国家进出口银行工作，便通过朋友的关系弄到了一本进出口银行的基本业务材料，从而在面试中对答如流，赢得了招聘单位的赏识。并能以自身的优势来说明为何应聘这工作，做到有的防矢，给主考官留下了深刻的印象。因此，收集资料，了解单位，可以帮助求职者认清主要方向，更精确，更客观地审视主聘单位，选择适合自己发展的单位，避免走弯路。

（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？

回答：
1.哎，没办法，一时没有应聘到大企业，况且，毕业时间又到了，否则只能回当地就业，因此先就业再说。
2.小企业有他自己的优势，在用人方面非常重视，自己虽然资历条件尚可，我想，在你们这样的企业更能发挥自己的作用。

点评：一个还未工作就想以后跳槽的员工，是无论如何不能指望他尽心尽力的干好工作的，因此，即使有此想法，也不能说出来，说不定工作后受到企业重用，本人的作用也发挥的特别好，而不想再走了呢？

（8）问题：你为什么希望到我们公司工作？

回答：我觉得贵公司力量雄厚，领导得力，上下一心，适于一切有才干的人发展。
忌：“我是学电子的，我到这里才是专业对口。”看情况而定。
“我来这里上班离家近。”
“我喜欢你们这儿。”
“听说你们公司月薪较高。”

点评：回答问题要从对方入题，引起对方好感，使对方感到你能尊重，关心公司的需要，愿为公司尽微薄之力。

（9）问题：如果本公司录用你，你最希望在哪个部门工作？

回答：
忌：“到哪个部门都行”
应：“本人希望到XX部门，但也很乐意接受公司的其他安排。

点评：不要说得太随意，太肯定。比较稳妥的办法是首先表明自己的志向和兴趣，再表示服从安排。

（10）问题：你愿意被外派工作吗？你愿意经常出差吗？

回答：愿意，反正我无牵无挂，到哪儿工作都可以。

点评：这是主试者通过提问来透露他要找的是什么样的人，此信息已经很明白地告诉你，他所期待的回答是什么。对于此类问题应聘者留意倾听。从“话中之话”中找出应试者实际需要的线索。

（11）问题：我怎样相信对这个职位你是最好的人选呢？

回答：根据这个职位的性质和我们刚才的谈话，我推断你需要的是工作积极的人，能够设定目标，不惧怕挑战的人。我就具有这些品质，让我再告诉你一些我在校时的经历，它们能说明我确实是你所需要的最好的人选。

点评：设身处地替面试官想一想，考虑一下招聘者需要什么样的人，你又在哪些方面符合他们的要求。根据要求，谈出自己应聘的优势。

（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？

回答：就是这份工作。

点评：你可能觉得这是个怪问题，事实上常有这样的问题。这个问题是假设每个人都有未实现的梦想，都不能做他真正想做的事，亦即或多或少每个人都在妥协。若你真的谈了你的梦想，而他只会为圆你梦想的梦，而不录用你。因此，你确实要这份工作，那么参考答案只有一个。

（13）问题：为什么你还没有找到工作？

回答：我正在谨慎选择我的工作，本来我可以选择别的工作的，可是那些工作和现在这一个不同，我实在看不出它们会对我的事业进展有帮助。

点评：如果你真的拒绝了其他人的录取，那是再好不过了，如果其他企业都没有录取你，哪也不一定有问题。别人不能只因为你现在没有工作，就断定都没有人录取你，不要给人这样的错觉。

（14）问题：你对我们公司有多少了解？

回答：
1.完全不了解。
2.因为对贵公司有关方面相当有兴趣,所以才来应聘.

点评：若回答1.那就没有必要再说下去了，但录用的机会也就小了。最好的回答是2，这是公司想测试应聘者对公司的兴趣，关注程度，以后进公司工作的意愿的问题，因此，最好要稍稍记住公司的简介内容和招聘人事广告内容。

（15）问题：你对公司有何印象？

回答：感觉很好，在其他公司没有这样的感受。

点评：或者说出面试当天的印象就可以了，因为还没有正式进入公司上班，所以主试者也不会太过刁难。

（16）问题：你谈谈选择这份工作的动机？

回答：“这个职位刚好是我的专业对口，能把学的书本知识在实践中更好地应用。”
“我虽然学的专业与这职位有区别，但我对这方面的能力较强，相信自己能干好这份工作。

点评：这是测试面试者对这份工作的理解程度及热忱，并筛选因一时兴起而来应聘的人。

（17）问题：你家在外地，我们单位无住宿，你如何看待呢？

回答：家在外地，贵单位无住宿条件，这些都不影响我来应聘贵公司，住宿我可以自己解决，无须单位操心，我看重贵公司的发展前途。

点评：不要因为个人生活上的小问题，而错失良机。主试者也想看看你对困难的看法，自信心程度。

（18）问题：我们不限定固定职位，你认为自己最适合做什么？

回答：
忌：“公司安排我做什么就做什么！”太随意。
“理想的职位就是有机会让我一展专长，为公司的发展贡献自己的学识。”太空。
应：我学的是XX专业，我认为XX职位比较适合我。

点评：主试者问你问题，就是想要一个明确的参考答案，且明确的回答给人以有思想、有主见、有活力的印象。象上面的回答，是犯了一个错误，然而几乎每个人都会犯同样的错误，他们总是说自己干什么都可以。因此，回答这样的问题，干脆用自己的心里话表白，实事求是，至少让主试者听起来感到舒服些。

（19）问题：你希望从事什么样的工作？

回答：根据贵公司的招聘职位，我认为**职位可能比较适合我，有利于我的能力的发挥。当然，其他有些职位也是可做的，人贵在学习。

点评：应试者可以应聘的职位作出大致的设想，让主试人了解自己的抱负与努力方向。由于每个单位都有自己的人事政策，其工作安排未必能完全与求职者的愿望相一致，尤其对一个初出茅庐的大学生来说，从基层做起，从小事做起也是应该的。但是，又不能随便回答：“到哪里工作都可以。”这让人觉得像在“乞讨工作”，被人看轻。所以要掌握分寸。

（20）问题：你为什么要应聘我们公司？

回答：看了贵公司的广告及要求，感到自己比较符合公司的招聘条件，另外，对贵公司也有些了解，自己若能有幸成为贵公司的一员，是能有助于自己能力的发挥与发展的。

点评：这样的回答，可显示出自己积极进取的态度。在谈论用人单位时，态度要诚恳、谦和。不论大单位或小单位，都有其优胜和劣势，应试者应视其实际情况，提出自己的见解，不要牵强附会，如果一味往对方脸上贴金，反而会令人反感。

（21）问题：你在以前实习的公司从事什么样的工作？

回答：在具体说明对工作的理解程度和熟悉度时，回答要领有三个方面：担任的工作内容、职务、成绩三项。

点评：这个问题可以让公司知道面试者是否符合所要招聘的职位，以前在其他公司的职位是否重要，来判断应聘者的发展可能。

（22）问题：为何辞去原来的工作？

回答：工作地点离家较远，路上花费时间多，发生交通问题时，影响工作。贵公司的工作岗位更适合自己专业（个性）的发展。

点评：为了避免应聘者以相同的原因辞职，公司尽量能做到对这方面原因的了解，有助于创造一个良好的工作环境和人际氛围。因此，应聘者最好说出对方能信服的理由。如果自己确有缺点，要说出“将尽量克服自己缺点”，作为有信心改变这类情况的答复。

（23）问题：你为何选择应聘我们公司？

回答：我对贵公司有一定的了解，特别对公司的XX经营理念，产品质量及员工培训比较看好。

点评：为了表明应聘原因及工作意愿，应聘者在回答时最好要了解企业状况，不要笼统回答因为自己将来有发展，更不要回答为了安定等参考答案。

（24）问题：在公司想做什么样的工作？

回答：现在想在某工作方面冲刺，将来则希望能在某方面努力等。朝自己想要的目标陈述即可。

点评：同时招聘很多职种的公司，最有可能问到这样的问题，这是判断应聘者个人的能力倾向。面试者如果不论职种都回答“可以”的话，反而会让人怀疑工作态度。如果这家公司只招聘一个职种，还是被问到这个问题时，是为了确认应聘者有无犹豫，应聘者只要清楚的叙述自己想做的事就可以了。

（25）问题：你为何要跳槽？

回答：虽然在前面公司工作挺顺的，同事间合作也很愉快，但我感到贵公司更适合我的发展。

点评：公司根据你跳槽原因，意在了解你的就业动机。

（26）问题：请问你有什么样的工作观？

回答：我认为工作是为了实现自己的人生价值，发挥自己的最大潜能，解决自己的生活问题。

点评：此话是问工作在你的生活中意味着什么？为何而工作？从工作中得到了什么？几年后想变成怎样等。因此，别把它想得太复杂，可根据自己的具体情况回答。

（27）问题：你是否可以接受加班？

回答：我愿意接受挑战。在自己责任范围内的工作，不能算是加班。

点评：这是面试者针对应聘者的工作热忱而提的问题，因无理的加班不一定是好的。

（28）问题：你认为这份工作最重要的是什么？

回答：最重要的是对自己的挑战和提高。

点评：对工作要加上自己的看法。
兴趣、学业、优点、缺点

（29）问题：你现在最感兴趣的是什么？

回答：做个人网站，练习口语，但越做越感到自己知识欠缺。

点评：可以简述你的兴趣，及这个兴趣带给你个性或能力的正面效果。

（30）问题：空闲时喜欢什么消遣？

回答：看书、集邮、上网。有空与朋友聚聚聊聊也不错。

点评：对工作之外，拥有其他兴趣的应聘者较受欢迎。

（31）问题：你在自我调节方面做何种努力？

回答：一般情况下，我会听音乐来放松自己，若能约上几个朋友一起搞搞运动感觉也是很好的。

点评：听到这种提问，你可以舒坦地笑一下。此问是为了了解应聘者自我管理能力、自我调节、自我完善的能力。

（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？

回答：回答时只要将所学过的重要课程以及与所应聘的工作岗位有关的课程说出来就行了，不必把每一门课程都罗列出来。可稍为详细地介绍一下与应聘岗位有关的科目。

点评：不要强调所学科目会对今后的工作会有极大的作用，只着重强调打好了理论和技能基础。

问题；你有哪些兴趣爱好或具备什么资格证书？

回答：“书法、乐器、体育、集邮、唱歌、舞蹈等，如钢琴能达到十级水平。我还有打字达到A级，中英文都比较熟练，同时还有一张驾驶执照呢。”

点评：一个人的兴趣爱好，能显示他的多方面的才能和修养，这样的人除比别人多一种技能外，更重要的是，他们往往有进取心，有发散性的思维，比较热爱生活，另外，打字、计算机、口译证书、驾驶证、报关员证书等也可以作为技能，但一般要求有资格证书作证明，如果拥有这类操作性技能证书，则也是一张“硬派司”。在开放度极大的都市里，企业最欣赏的是一专多能的复合型人才。如没有，则说实话，如爱好广泛，但都不太精。

（33）问题：你的学习成绩如何？

回答：
“较好。”
“一般。”我在学校里除课堂上学习的知识外，比较喜欢扩充自己的其他方面的知识，对XX类的书也看了不少。

点评：对自己的学习成绩一定要如实回答。如果成绩优秀，应该用平和的口气，实事求是地介绍，决不可自我炫耀，让人觉得轻浮；如果成绩不好则应说明理由，或者哪门课程不好，隐瞒或欺骗，只会暴露自己的不良品行。总之，应表现出对学习的态度是认真的，努力的，对成绩又看得比较客观。这样即使你的成绩不太理想，主试人的反应也不会太强烈。

（34）问题：请谈一谈你的弱点。

回答：
我是一个完美主义者，总是追求事物完美无缺。
我对准时要求得非常严格。
我从不轻易放弃，以至有些固执。
我喜欢独立工作，而不喜欢主管领导在我的工作中安排一切。

点评：一般的策略是说出一些表面上是弱点，实际上却是优点的特征。当你在叙述个人弱点时，要能够说出过去的具体相关事例，来说明你的观点。这点非常重要。当然，你也可以说一个你明显的缺点，然后举出例子说明你是怎样克服这个缺点的。此问是主试者看看你是不是由于缺少某种经验、训练，甚至由于某些性格弱点而不能胜任工作。

（35）问题：请谈谈你的优点。

回答：我非常喜欢和善于学习新东西，在工作中有责任心，真诚，有热情，有灵活性，能够合理地安排时间使工作有条理、有效率，能够在紧张压力下工作等等。

点评：以上回答要有具体实例来证明你的说法。优点除了你的工作技能、具有的各类证书和实践经验外，主试者要想听的优点不见得是你最突出的优点，而应该是和你应聘的那份工作相关的优点，从中找出雇佣你的理由，同时可以知道你对自己的了解程度，看看你对自己有没有自信，以及你到底适合不适合这份工作。因此，你要精确地描述，不可泛泛说些无意义的话，例如，适应力强，具有幽默感，合群等等。

（36）问题：你认为自己最大的缺点是什么？

回答：我认为自己的长处是能够热衷于某件事情，并且始终乐此不疲，能够专心致志直到完成。从某方面来讲，这也是我的短处，有时过分热衷于某件事，有时对一些事的看法可能会有失偏颇。其实我也了解自己的这一点，因此，今后会经常反思和检讨的。

点评：
这个问题也是较难回答的，它考察你的应变能力的成分多于问题参考答案的本身。
一个人的最大的缺点可能对你的家人和朋友来讲更清楚一些，自己可能有时会意识不到，所谓不识庐山真面目，只缘身在此山中。但是对一个大学生来说，应该能够意识到自己性格中的缺点。聘方知道你的优缺点就可以知道你是否能够适合某个职位。

（37）问题：你所取得的最大成就是什么？

回答：从你过去或目前的相关工作中，找出具体的实例来加以说明。如为了举办校园歌手比赛，成功地联系了一家企业作为赞助商，使比赛开展的很成功，或大三开始，自己边学习，边工作，勤工助学，生活不依靠父母，完全自立等等。

点评：进一步了解你的能力和背景，你要有备而去，想些可能成就比较小，但和他们的需求比较相关的一件成就来叙述。

（38）问题：请你说说在以前的工作上成功与失败的地方？

回答：
在学校里，我成功地组织了一次“创业与知识”的主题讨论会，得到了老师与同学的肯定，在组织中碰到了不少问题，但使我感到做任何事情，只要有信心，困难都会迎刃而解的。
在班级里，曾组织过一次活动，原来想活动肯定有意义，但实际上参加的人不多，活动是失败的，事后了解，有些同学对此活动不感兴趣。主观上找了原因，是和同学沟通不够，使我在以后工作中注意了凡事多与同学商量。

点评：成功的地方可举出目前为止的实绩，来强调对经历的自信，也可以叙述工作所带来的乐趣；失败经验可以说曾经遇到的业务或人际障碍，也可以将如何克服失败的经验说出来，并说出由失败中所得到的教训。

（39）问题：你的好朋友怎样形容你？

回答：他们说我开朗大方，对朋友的困难会尽力帮助，很有号召力，但有时不拘小节。

点评：这类问题是你表现自己的最好机会，不要错过。因此也最需要预先准备，否则你可能不知道从何说起，往往要想一会儿才答，或者随便回答，这两种情形都不会争取到好印象。

（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？

回答：是的，我的学习成绩不是很理想，即学习分数不是很高，但我注重实践能力的锻炼，我已经实习过好几家企业，他们对我反映都不错。

点评：这类问题往往是一种“压迫法”的面试技巧，主试者故意提出应试者的弱点，令其尴尬，看他在压力之下怎样反应。故提到的弱点，不是问题关键所在。因此，应试者应沉着应付，想办法扭转劣势，表现出自己的急才与修养。

（41）问题：你认为你的优势在哪些方面？

回答：
1.我性格开朗活泼，善于与人沟通，有较强的亲和力，营销工作与管理工作比较适合我。
2．我和其他同学相比不是很活跃，可能最合适我的工作是财务与行政工作，我有信心做好这样的工作。

点评：回答2.他在面试者前谈了自己的“缺点”，显示了他的诚实和勇敢，他知道什么工作适合自己，显示了很强的自我意识，人家谈优点，他没有人云亦云，而坚持原则是财务与行政人员重要的素质之一。
工作经验、工作态度

（42）问题：你有什么社会实践经验？

回答：一年级暑假参加过学校的社会实践调查。调查“****”写了一篇《****》小论文。二、三年级时利用暑假（周末）、业余时间做英语家教，受到学生家长的好评。还曾在****公司、****公司打过工，这是企业对我的评价。

点评：现在的就业市场相当重视工作经验。如果应试者曾在假期或业余时间外出打工，积累了一定的社会工作经验，将会令用人单位更加满意，哪怕应试者的打工与求职的工作无关，如果应试者曾在大学里担任过一些学生工作或参加一些社团活动，也应作些介绍，表明自己具有一定的阅历与能力。用人单位都有这样的共识，具有社会经验的人往往比较成熟，能够更快地适应工作环境。

（43）问题：你为什么选择现在的学校和专业？

回答：高考填报志愿时，当然有好几个高校是我理想的选择。按高考进入现在的学校，它是我的选择之一，当然这个专业是我喜欢的专业。喜欢的、或感兴趣的专业，也是我学习的动力之一，事实上，通过四年的的学习生活，我对我的学校所学专业感觉很好。

点评：回答这一问题时，要对自己的学校和所学的专业有一种崇高和热爱的心情，并应抱有信心。随意菲薄母校和所学的专业是一种极不负责的态度，会引起别人的反感，甚至让人怀疑应试者是否有真才实学。

（44）问题：你比较喜欢独立工作还是集体工作？

回答：我对独立工作或集体工作没有什么偏好，如果工作比较接近团队工作，我会做的很愉快的。如工作需要相当的自主性，我也很喜欢负责那样的工作。

点评：如果你知道应聘的工作性质是自主的或需要依赖集体合作的，那么你可以顺势决定回答这个问题。但是如果你一无所知，不论你怎么回答都可能惹祸上身。因此，不要让自己必须在两者中抉择，你不必非得说出喜欢哪一种不可。

（45）问题：请你谈一下和本工作有关的工作经验

回答：如果你做过这一类工作，说出地点，并以具体的实例来说明你的工作成绩，不要用空洞的词语。如果你没有做过这类工作，就应强调你有能力来学做这个工作，你要表明你非常喜欢这个工作，也非常想学习新东西。尽可能把你过去经历中和这个工作有联系的内容提出来，尽可能将你具有的与这个工作有关联的技能提出来。

点评：此问题判断你能不能做这份工作。

（46）问题：若你到我们公司后，如何看待你本人的地位。

回答：
1.把自己当主人，能极大地发挥个人的潜能，与公司有共同的忧患意识。
2.不计较个人暂时得失，做到以公司利益为重，不急功近利或搞短期行为，在工作上任劳任怨、兢兢业业。
3.公司以真待我，我以诚回应。

点评：只有把“自己当主人”，才能干劲十足，激发活力，迸发才智，干出业绩，最终凭业绩成为该企业的主人。而如果这山望着那山高，不专心工作岗位，公司稍一陷入困境就辞职走人，只同甘不共苦，把自己当成打工仔，人格上就低人一等。

（47）问题：你希望在本公司工作多长时间？

回答：如果我们彼此感到满意的话，我将很乐意一直继续工作下去。

点评：一般情况下，公司都希望所提供的工作和氛围能使未来的雇员才华得到最大程度的发挥，而你也不乐意自己的大好时光耗费在一份自己不喜欢或不适合的工作上。因此这是一个比较好的回答。

（48）问题：你对本公司（或这份工作）有什么看法吗？

回答：我对贵公司（或这份工作）很感兴趣，很乐意在公司里发挥自己的潜能，我也相信以自己积极的心态，努力工作，在贵公司我会得以发展的。

点评：考官问这个问题的真正目的想要了解你能做这份工作吗？你在这公司工作安心吗？若你感到没有准备的话，你最好先说：“让我想一下”然后深呼吸放松，再做回答，这有助于增加你在回答问题时的自信。

（49）问题：你为什么要离开前一家单位？

回答：事实上，离开原来的单位对我来说是比较痛苦的选择，因为我在那里工作了x年之后（一段时间），与那里的领导和同事相处的非常好，同时，通过我的努力，也取得了大家的信任，大家不愿我离开。但是，我心中一直希望自己在xx领域内有所发展，由于客观原因，在前面的单位里一直没能实现这个愿望，所以我还是做出了这个选择，离开前一个单位。

点评：这个问题看起来较为简单，但回答要注意。你回答的如果不合适，对方就可能产生这样的想法，离开前一个单位是不是你不得已而为之，问题在你个人，你会因为同样或者类似的原因离开我们？因此，要避免过多的抱怨前一雇主。要强调自己个人发展需要的原因，不要归咎于别人。要让聘方相信，你在原单位也是工作出色，人际关系良好，但是为了你个人的某种理想和追求，你愿意到新公司工作。

（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？

回答：
1.“不见得吧！”“我看未必”“不会！”“完全不是这么回事！”等等。
2．“这样的说法未必全对”“这样的看法值得探讨”“这样的说法有一定的道理，但恐怕不能完全接受。”等等。

点评：
1.象这样的回答方式虽然求职者也能表达清楚个人的想法并对主考官的设问进行反驳或申诉，但由于语气太过生硬，否定太过直接而会引起主考官的不悦。
2.在表达的过程中较为委婉地表示出自己的不同意见，不致会影响到主考官的情绪。

（51）问题：你如何看自己缺少工作经验这问题？

回答：
忌：“本人想到贵公司，目的也就是为了取得工作经验。”
应：“自己确实缺乏工作经验，在读书时，我就注意这个问题，作为学生、只能利用假期进行社会实践，到公司去打工，锻炼，平时勤工助学，曾在.XX公司工作过，这是XX公司对我的评价。”

点评：如何理解，如何解释缺少经验，缺少经验并不是毫无经验。一人在同一职位干了五年的人，并不意味着此人就具备了五年的经验，他极有可能只是将一年经验重复了五次而已。

（52）问题：你没有营销方面的经验，不是吗？

回答：
1.“我很喜欢营销方面的挑战，我会达到你们的要求，而且我也期望能扩大增长我的经验。营销这一行很吸引我，因为我适应力强，接受新知识能力又较快，我自信会干好营销工作的。”
2.“是啊，我是没有这方面的经验。”

点评：记住！如果这真的是一个问题，企业就不会请你来面试了。因此，不要按2.回答，按1.的回答显示了你的热忱和自信，无形中多了一些应征的可能，所以，要懂得化缺点为优点，转劣势为优势。
能力表现

（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？

回答：没有。我个人认为大学生最好不要谈恋爱，因为大学生毕竟不是很成熟，自控力比较差，因恋爱荒废学业、不求上进的大有人在，大学生应集中精力搞好学业、锻炼能力。

点评：通过这个问题来考察应试者的成熟程度和处理生活事务的能力，考察应试者的人生观和价值观。因此，应提高认识的层次，从用人单位领导的角度思考问题。

（54）问题：你有能力胜任应聘的职位吗？

回答：没问题！这虽然较难，但是我会想办法做好的！对我来说这是一个新的挑战，我相信能够战胜它。
忌:“对不起，我缺乏经验，可能做不好吧？”“一个人做，恐怕我现在不行”
如果听到这种毫无生气与活力的话时，自然会在失望之余产生一种想法：“也许他是一个缺乏能力与自信的人吧！“

点评：掌握好谦虚的度，实在是一个大有学问的问题。中国的传统教育总是教导人们处事要谦虚，这方面的古训很多，“满招损，谦受益”；久而久之。一方面想出人头地，一方面又自觉不自觉的受这种思想的左右，不敢大胆的发表自己的意见，礼让过头，贬低自己。这种虚伪的过谦，特别在应聘外企中很不合时宜。往往弊大于利，适得其反。作为一个企业，理所当然的选择自信敬业的人。

（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？

回答：
1.“YES”说明你这个人“身在曹营心在汉。”
2.“NO”说明你的能力有问题或是对自己自信心不足，总之你会左右为难。而如果你说“不知道”或“不清楚”。则又拒绝回答之嫌。
3.“不可一概而论。”
“或许我能找到比贵公司更好的企业，但别的企业或许在对人才培养方面不如贵公司重视，机会也不如贵公司多，或许我找不到更好的企业，我想珍惜已有的最为重要的。”

点评：象上面这个问题以3回答最好，可以说把一个“模糊”的参考答案抛给主考官，做到滴水不漏。这类问题的特点是主考官设定了一个特定的背景式条件，让求职者作出回答，有时任何一种条件参考答案都不是很理想，这时就需要用模糊语言表示。

（56）问题：你的面试通过了，现在我们签约。

回答：让我考虑一下，我要和父母商量过再决定。

点评：其实这是一种不成熟的回答，在应聘外企时不可取得，设想如果将来让这样的人代表公司和客户谈判，凡事都回公司请示报告，到手的生意也会飞了。该同学是一个条件很不错的人选，应聘的是一家非常出名的跨国公司。她走后，公司马上通知了“替补队员”（为防意外，公司面试人数比正式录取的人数总多1—2名）那位小伙子看完公司聘函立即签了约。他表示，我就想到该公司工作。待女孩子回来。说跟家人商量好了，同意签约，而此时，那个职位已招到新人，就是那位替补队员。所以当机会来临时，千万要抓住，犹豫就会错失良机，后悔也无济于事。

（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？

回答：恐怕不能一下子讲清，得具体情况具体分析，比如贵公司现在所最需要的是行政管理方面的人才，虽然前来应征的都是这方面的对口人才，但我深信我在大学四年中担任过的学生干部及组织过多次大型活动的经验已经为我打下了扎实的基础，我想这一点恐怕也是我自认为比较突出的一点。

点评：这样的回答可以说比较圆滑，以免主考官抓住某一“把柄”，再度发难。此问题是考察求职者随机应变的能力。无论你列举多少优点别人总有比你更多的优点，因此，你从正面去回答这样的问题毫无意义的。

（58）问题：听说你对XX工作（业务）很精通，不妨谈些你的看法吧？

回答：谈不上精通，只是略知一二，可以共同探讨一下。

点评：给自己留下一点回旋的余地。对于此类问题，特别要谨慎，这往往是一个“陷阱”，是主考官有意想进一步对求职者有更加深入的了解所设定的“圈套”。因此，求职者要小心回答问题，即使你真的对XX业务很精通，也千万不要自以为是，否则你将面临难度更大的问题。

（59）问题：如果你被录用，是否马上就可来上班？

回答：今天听到你的聘用邀请十分感激，但学校里学业还未全部结束，论文撰写正是关键的时候，还在准备论文答辩阶段，容我回去征求导师意见，看能否抽出时间上班，所以允许我明天正式回复。

点评：面对开门见山的质问，如当时无法确定答复，且自己未决定真正意愿应允，应考虑到事后可能还会有更让自己心动的工作机会。在回答时即应巧妙预设一个转弯的空间。同时，避免得罪对方而错失良机，这比“对不起，我还不能回答这个问题，我必须仔细考虑看看。”这种答复圆滑的多。

（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。

回答：不，先生，你弄错了吧，我未曾救过任何人
考官：年轻人，你说的很对，是我弄错了，我很欣赏你的诚实，我决定，不是优先，而是你的复试已经通过了

点评：此问题是考官设的一个“陷阱”。一个人的优秀品质会引起他人喜欢的，而诚实是招聘者看重的必备品质。因此大学生虽有良好的资历和优秀的学业成绩，更必备诚实的品格。

（61）问题：“会打羽毛球吗？”

“给你们一辆小轿车，有没有把握学会驾驶？”
“厨房里有蔬菜，你俩能不能给我做几样拿手的好菜？”

回答：
男：会女：打的不好
男：有女：不敢保证
男：没问题女：做得不好

点评：
此应聘面试单位是一家中外合资公司，已经过了几道关卡的面试，此是最后复试，主考经理是外国人，以上是闲聊中随便地问了三个问题。最后，公司录用了男学生，淘汰了女学生。公司对女学生的评价是：有自卑情绪，缺乏自信心，无法胜任本公司职务。其实，该女同学是个不错的羽毛球选手。

（62）问题：在工作中你怎样看待错误？

回答：
1.我尽量不出错误
2.我并不担心自己会出错，但我能做到不重复同样的一个错误。

点评：对回答1的公司没有录用。
人非圣贤，熟能无过？错误是必不可少的，但关键是要能很快地吸取经验教训，总结经验。求职也如此，不要害怕失败，你应牢牢记住：“失败乃成功之母！”“失败是成功的踏脚石。”通往成功的路从不平坦，跌倒是难免的，但是，跌倒了并不是失败，真正的失败是跌倒了怕不起来了。”

（63）问题：我们公司今年计划一般不招女学生

回答：贵公司的用人计划我了解，但我想性别差异并非是挑选人才的关键，还是要看个人的基本素质，何况我各方面表现都较优秀，有些男同学还赶不上我，而且女生在贵公司的职位更能显示女同学的优势。

点评：女同学碰到此类问题，不要愤怒、憎恨，要靠耐心和韧性，回答问题不要带怒意，要不卑不亢，充满自信，介绍自己的优势，有与男同学一比高低的勇气。

（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。

回答：这三分钟的表现，可以成为你去留的依据，有的学生充分显示实力，把握了机会，有的学生则不会表现而被淘汰。有的学生为了显得谦虚，尽量少讲自己的优点，少表现自己，结果也失去了这个机会。

点评：此类面试问题一般是企业总经理面试时提的，他们的话简单明了：“你连自己都推销不掉，你帮我推什么？要帮我推销商品，推销企业形象，首先学会推销自己。”因此针对不同的面试对象，自己认真准备好几个三分钟是有必要的。因此，自我表现时要充满自信，落落大方，态度诚恳。

（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？

回答：
1.你们是什么样的鬼单位，在这里摆摊招舞女。”说完头也不回扬长而去。
2.若是工作需要，要陪客人跳舞，跳跳也无妨。若是客人另有意思，那可约男同事一起去娱乐。

点评：此是外贸进出口公司在人才会上招聘秘书，单位是很正派很有声望的企业，提出这一问题，考官只是想试试求职者的口头应变能力和处事能力。该小姐只要冷静下来，思考考官提出的问题，把自己的看法如实说出，作机敏的回答，就不至于失去一份很有前途的工作。

（66）问题：你喜欢和何种人共事？

回答：总的说来我是一个开朗的人，我喜欢和有相同个性的人打交道。

点评：此句意在了解求职者本身的个性特点，并借此来分析求职者一旦进入新的机构后与现职位的其他人员的相容程度，主考官据此判断此人是否能与其他人融洽相处。按照一句时髦的话来说，就是看看求职者是否具有团队精神。作为求职者，应当注意不要过分对此句话“躲躲闪闪”或是故意回避，回答这个问题时，要先大概介绍一下自己的个性特点，然后再说喜欢同什么样的人相处，总之要言之有理，顺理成章。

（67）问题：你对大学生就业市场的评价如何？

回答：这个问题很大，很难用三言两语概括清楚。在双向选择，自主择业的政策下，要就业，找市场已被学生接受，虽然就业市场形势严峻，但我们乐意在市场中参与竞争，选择合适自己的职业。

点评：主试人为测验应试者分析问题与逻辑思维能力，有意提一些很难回答的问题。回答此问题时应边说边想。若想好了再说，主试人会认为你反映迟钝。为了赢得思考的时间，开头可以先说一句开场白，后面边想边说，分条回答。想起一条答一条，在答第一条时就想第二条，依此类推。回答完了的时候，再从中找出一两个重点。这样就容易获得构思敏捷，思路清晰，善于抓住要害的好评。

（68）问题：你喜欢什么样的上司？

回答：
忌：“谁做我的上司都喜欢。”或“不知道”
应：“我本人比较喜欢有真才实学，公正严明的上司。”

点评：大多数应聘者对上司的背景毫不知情，因此，用一些普通适用的公认标准为好

（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？

回答：“只要需要，我不会斤斤计较。”“如果有客人到我所在的那个部门，我会主动倒茶端水，这些杂务只是我的工作内容的一小部分而已。”

点评：这是一个试探性问题，目的是观察应聘者的反应，以判断你对工作的态度。因没有任何一家公司会聘用大学毕业生专门从事杂务工作。若明确拒绝接受这类杂务，则意味着拒绝接受职位，且在面试时与主试者争论差别毫无意义。

（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？

回答：
1.贵公司是我的第一选择。
2.我不敢奢望有两家公司同时看上我，即使有此情况，我还是首选贵公司。

点评：无论你到哪家公司应聘，都应这么回答，在未确定最后的归属前，回答这个问题不能有丝毫犹豫。

（71）问题：你对营销、管理工作如何看待？

回答：现在社会竞争非常激烈，营销、管理工作不是光凭热情能干好的，它需要经常做些调查研究，了解社会需求，提出目标、计划，同时，需要各方面的配合，才能把工作做的更好。

点评：应聘者对所应聘的岗位不能仅仅是有热情，同时还要冷静、理智地作出一些工作设想，这既说明了工作的积极主动性，也表明了应聘者是一个聪慧且思考成熟的人。

（72）问题：你认为对员工的管理严厉的好，还是宽松的好？

回答：我想这要因时因人而定的，不能千篇一律。有些人对严厉的管理方法反应良好，有些人却需要鼓励才能做得更好。好的管理人员应该知道怎么使他的部属发挥更大的潜力。

点评：你不清楚企业需要的是什么样的管理作风，也是测试你能接受什么样的管理风格，如你确实不能接受他们的管理风格，那等到录取了再抉择。

（73）问题：你好象不适合到我们公司工作？

回答：可能在刚才的陈述中没把问题谈清楚，是我引起你的误解。其实我对贵公司非常尊重，对公司业务也有一些了解，我想在贵公司经过培训和工作后，是能够达到贵公司要求的，请务必再次考虑录用的问题。

点评：应答时，千万要注意不可反问对方提出的此问题的理由。此问有时也是主试者考验应试者到企业的决心，和应试者的自信心。

（74）问题：你的计算机能力如何？

回答：
如果你这方面能力较差的话，你就应该告诉他们你的计算机能力较为欠缺，但是你目前还在继续学习计算机。
如果能力强的话，就可直接告诉他们你所得到的高级或中级编程员证书，及计算机的其他能力。

点评：遇到的问题属于自己的长处，也不要洋洋洒洒，滔滔不绝。对方问到自己的短处，不要避而不谈，或者转移话题，其实每一个人即使是非常优秀的人都会有自己的弱点，这种情况下应该正面回答对方的问题，同时如果自己认为这是一个欠缺而又是对方的招聘条件的话，应该积极表示自己现在的或者即将的行动用来克服这方面的缺点。

（75）问题：你的外语水平如何？

回答：
如果你水平高的话，对方又是懂外语的面试官你可以直接用外语进行回答你外语所具备的能力，得到的证书或托福的考分，以表示你的能力。但表示还不够，还需努力继续学习。
若你的水平较低，就应如实回答，讲出低的原因，如笔头翻译不差，口语听力稍差，或专业词汇较熟悉，人文词汇掌握较少等。并表示你目前还在学习。

点评：遇到的问题属于自己的长处，也不要洋洋洒洒，滔滔不绝。对方问到自己的短处，不要避而不谈，或者转移话题，其实每一个人即使是非常优秀的人都会有自己的弱点，这种情况下应该正面回答对方的问题，同时如果自己认为这是一个欠缺而又是对方的招聘条件的话，应该积极表示自己现在的或者即将的行动用来克服这方面的缺点。

（76）问题：能否介绍一下你的社会活动能力

回答：
1.我的外交能力较强，在校学生会我担任外联部长。
2.我在校尽可能多地参加一些能发挥自己特长的活动，使社会活动能力得到了一定的提高。
3.我善于组织同学开展活动，如组织演讲赛，辩论赛，知识抢答赛等等，而且活动也较成功，从中可以证实我有一定的社会活动能力。
4.在校期间，我曾担任过班长职务。为了把班级基础文明建设搞好，组织全班同学进行校规校纪学习，集思广益，制定了“班规十条”，并要求全班同学严格遵守班级纪律。经过大家的努力，我班评为校先进班级，全班同学学习努力，团结友爱。

点评：
1.过于简单，草率，效果不好。
2.比较谦虚地说明自己有一定的能力，但言之无物，有些空洞。
3.如实的介绍自己曾组织过活动，但不具体。
4.通过例举事例，来说明自己的能力，有理有据，效果最佳，使主试者了解其素质和能力。

（77）问题：你今后打算是什么？

回答：“我希望我能够在这个公司里长久地工作。根据自己的能力和表现，不断地增加工作中所担负的责任。”

点评：看看你真正想要得到的是什么，以判定你是否会长期在公司工作。明确你的个人目标和公司是否一致。

（78）问题：你为什么这么长时间没有工作？

回答：我花了很长一段时间对自己的经历进行了反省和总结，并仔细研究了目前的就业市场，以确定自己的目标和方向，当然我也有过一些工作机会，但我的目的不仅仅是找一份工作，我追求的是有发展前途的未来。今天来应聘贵公司，我觉得贵公司适合我的发展。

点评：判断你对难题的应变能力，以及你对实际生活中问题的判断和处理能力。

（79）问题：为什么要录用你？

回答：这是你要回答好的最重要的问题。根据公司目前的需要，强调你的背景优势，根据工作的需求叙述一下你的能力。如果你没有相关工作经验，强调你的其他工作经验和所受的教育，适合这个工作。

点评：确定你是不是最佳人选，看看你有没有自信心。

（80）问题：你为什么想要换工作？

回答：“我想进一步发挥我的能力”，或“我目前单位的发展机会非常有限。”

点评：这个问题是判断你的动机，和你处理问题的能力。切记，不要抱怨你过去或目前的雇主。

（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。

回答：举一个你在过去的工作中或生活中遇到的问题，说明你是如何解决该问题的。

点评：判断你对问题的分析能力，看看你有没有团队精神和克服困难的信心。这也是给你一个表现自我的机会。

（82）问题：你喜欢你们学校吗？你的老师怎么样？

回答：我很喜欢学校，那是我学习、生活了四年的地方，也是我成材、成熟的人生车站。四年中也碰到了许多好老师，对我思想上引导、学业上指导、能力上辅导，我从心里感谢他们。特别我们的英语老师，上课非常幽默，回想起来仍感到回味无穷。

点评：每个学生对这个问题一定要持积极肯定的态度。这是主考者考察应试者的个人品格的题目。作为一个具有高度思想觉悟和良好道德品质的现代大学生，尊师爱校是应有的品质。此外，人们普遍认为，一个不热爱母校、不尊敬老师的大学毕业生，也很难谈得上热爱就业单位，尊敬单位领导及老同志。因此，因充满激情地简单说明喜欢自己母校的原因，及老师对自己在学业和能力上的帮助和影响。

（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？

回答：我选择生活百科全书，因为此时人最基本的问题是解决生存问题。

点评：这是假设性问题，来测试应试者的想象力、解决问题的能力，目的看你有没有急才，思想有没有条理。

（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？

回答；我应该处理好其他事情，主动地去支援同伴。

点评：用人单位希望员工能更好地融入集体，勇于承担个人责任。要求员工在工作中应和睦相处，互相帮助，互相合作。一家外资公司总经理说：“可能这里不一定每个人都是一流的，但他们结合起来，绝对是一流的。”

其他问题

（85）问题：毕业后为何不马上工作（为何现在才应聘工作）

回答：
为了取得xx资格证书，故一直在复习应考，使应聘时更具实力。
参加了xx大学的短训班，使自己的xx水平提高。
花了很多时间了解就业市场和有关信息。

点评：要以肯定、积极、正面的活动进行回答为佳。如果没有任何活动，也可讲述这段时间自己的想法。只要有上进性，面试者会满意的。

（86）问题：你择业考虑的主要问题是什么？

回答：主要谈考虑应聘的职业对自己将来事业的发展，及发挥自己的专业所长。另外，良好的企业文化（工作氛围）能激发自己的能动性等等。

点评：凡是与物质利益有关的条件，如工资、福利、环境等等，最好少谈，即使问到，也要把握分寸，适可而止。

（87）问题：你觉得自己干这项工作是大材小用还是小材大用？

回答：我相信我能干好这项工作。我觉得自己既不是大材小用也不是小材大用，它正好适合我干。

点评：如果你对这项工作确实很感兴趣，那么不管情况怎样，你都应如上面回答。

（88）问题：你正在和其他公司洽谈吗？

回答：是的。

点评：
如果你的回答是否定的，那么你应征的希望必然削弱不少。
如果你没有同时应征其他公司，那么表示你的求职计划出了严重的错误。若确实在谈，你也不必告诉他们你正和谁接洽。只要让他们知道，如果他们想要你，最好得马上采取行动才行，认为你是值得给第二次面试机会的人选。

（89）问题：薪水和工作，哪个对你更重要？

回答：两者对我都很重要。因为薪水可以解决个人生存问题，是生活条件基本需要，工作是为了发展自己的能力。点评：此题是非A即B题，如果你希望获得一个既有高薪待遇，又有长期职业发展前途的工作的话，没必要非排除一个选择另一个。

（90）问题：这份工作起薪点不高，你不会介意吧？

回答：不介意。

点评：一般碰到这类问题都顺水推舟，照对方的意思回答，如果你有特别理由要说相反的话，也不妨鼓起勇气照说出来，但要言之有理，在对方大感意外之余，说不定会赞赏你有主见。可是一般来说，还是尽可能不要冒险。

（91）问题：你希望待遇月薪大约是多少金额？

回答：依贵公司的规定大概是什么样的薪金行情？

点评：若你心里没底的话，感到难回答，那么上面这一反问就行了，因一个有制度的公司不会因为你要求得多就多给，要求得少就少给。

（92）问题：你如何看待你原来的薪金问题

回答：我并不是说原来工作的单位不好，但工作几年下来的工资奖金没有增长，可能是他们的企业所决定的，但别人还以为我能力不够，现在，我到贵公司来应聘，薪金有所提高，算是自我价值的认定吧。”

点评：薪金问题一向是单位吸引人才的重要手段，也是求职者的追求目的之一，因此，薪金问题既是个敏感的问题，又是个重要问题，须小心处理。

（93）问题：请谈一下你期望的月薪要求

回答：如果我能到贵公司工作，这将是我跨出校门，第一次走上社会工作，我相信我自己的能力，如果能受聘这个职位我一定会非常努力的工作，因此每月xxxx元的工资是我个人的要求，但我更关心的是能找到一份工作来充分发挥我个人的能力。

点评：实际上用人单位决定录用你时，对你的待遇其实已基本确定。特别在一些国企跨国大公司中，对大学生的工资待遇公司都有了相关规定的，但也不是绝对不可更改的。此问也是面试者为了了解你对自己的估价。因此对月薪不能要求过高，但也要合理。如果你觉得单位给你的月薪偏低，可以将你的关注告诉单位。你要让单位觉得你是在同他们商议，而不是要挟。重点放在你关注的原因上。比如，你要租房、车费、生活费等基本开销或探亲等，希望单位算一下你的基本生活开销，那么效果会比简单地说你要多少多少工资要来得好些。

忌问：我不是名牌大学毕业生（研究生），你们要吗？

点评：此问话首先让人感到你缺少自信心，有一种自卑感。有的招聘单位招聘条件很醒目地提出，只招聘名牌大学毕业生（研究生），遇到这种情况，你要调节好自己的心态，以积极自信的态度前往应聘，讲出自己的优点，对应聘岗位的了解，希望公司不要以牌子取人，应注重真才实学，给你面试机会。

忌问：“外地生源要否？”

点评：一些外地学生或出于坦诚，或急于得到“兑现”，一到用人单位招聘摊位前劈头就提这么一个问题，弄得主试人无话可说。因为实际情况是，不是外地生源不要，也不是所有外地生源都要，而是要看应聘者的实际情况能否与招聘者要求相符合。这么简单地提问，很有可能同样简单地得到回绝。

忌问：“你单位招几个？”

点评：这种提问似乎无可厚非，但招聘者对此会从另外的角度认为，招一个也是招，招两个也是招，问题不在于招几个，而是应聘者有没有成为百分之一或二分之一或独一无二的竞争能力和实力。因为一百个名额要竞争，一个名额更要竞争。

忌问：“你们单位招女生吗？”

点评：这样提问的女生，首先自己先打了“折扣”，是一种缺乏自信心的表现。面对已明显表露出“胆怯”的女性，招聘单位若想拒绝，就正好“顺水推舟”。这时，如果这位女生面对主试人来一番非同凡响的慷慨陈词或巧妙的介绍，反倒会使主试人认真“考虑考虑。”

忌问：你们单位有住宿吗？

点评：对于在异地就业的毕业生，住宿问题是一个大问题，但在应聘中，什么问题都没谈，企业根本还没决定录用你，你就提出住宿问题，这是自信心不足的表现。何况，现在社会上租房也是很方便的一件事。

（94）问题：请问你还有问题要问吗？

回答：回答这个问题，大有学问。首先，你可以将你在面试中还没有机会提出的相关问题提出来。其次，进一步强调一下你在面试过程中没有机会谈到的个人优势。如果实在没有什么可以说的，也不要说没有问题。你可以问面试者下一次的面试（如果有的话）是什么时间？或者问面试者什么时候可以得到结果，以及什么时候可以打电话给他。如果你确定得到这份工作，这个时候你就应该对面试者这么说：“我很想得到这份工作。我认为我完全能够胜任这份工作。请给我这个机会。”最后，对面试者表示致谢，握手，告别。

点评：此问一般当面试者要结束面试时，常常会问的问题。
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1、我们先来了解面试官如何评判应聘者的工资，知己知彼才能对症下药啊！</summary></b>

一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下）

```
1、掌握的技术（通过笔试、项目经验、工作时间）
2、表达
3、学历
4、其他素质（如英语四六级等）
```

面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力）

[参与互动](https://github.com/yisainan/web-interview/issues/781)

</details>

<b><details><summary>2、当 HR 问：你对薪资有什么要求？</summary></b>

大家找工作，都希望找个高薪的，那我们如何和公司去谈薪酬呢？如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。这个问题确实是个比较难于回答的问题，处理不好的话，会影响面试的效果，但又是不可避免的一个现实问题。

对于这个问题，第一首先要知道程序员等级、技能、工资的绑定情况，因为我们前端工程师主要是看技术。技术实力决定了我们的月薪；第二要打探出公司能给出的薪资范围。在这个范围内争取高薪资。

回答提示：

```
第一步是了解对方可以提供的薪酬幅度是多少，这里的关键是善于发问，让对方多讲，而自己了解足够的信息。当经过几轮面试后，面试官会问应聘者：你还有什么想了解的问题吗？应聘者就可问：像你们这样的大企业都有自己的一套薪酬体系，请问可以简单介绍一下吗？面试官一般就会简单介绍一下，如果介绍得不是太详细，还可以问：贵公司的薪酬水平在同行业中的位置是怎样的？除了工资之外还有哪些奖金、福利和培训机会？试用期后工资的加幅是多少？等问题。从对方的回答中，你再对照一下市场行情心里就有底了。

第二步是根据以上信息，提出自己的期望薪酬。如果对自己想提的薪资还是把握不准，那也可以把问题抛给对方：我想请教一个问题，以我现在的经历、学历和您对我面试的了解，在公司的薪酬体系中大约能达到怎么样的水平？对方就会透露给你准备开的工资水平。
```

## 迂回战术求高薪

```
如果你对该公司开出的薪资标准不太满意，就可以尝试用探讨式、协商式的口气去争取高一些：比如我认为工作最重要的是合作开心，薪酬是其次的，不过我原来的月薪是××元，如果跳槽的话就希望自己能有点进步，如果不是让您太为难的话，您看这个工资是不是可以有一点提高？这时要看对方的口气是否可以松动，松动的话则可以再举出你值更高价的理由。

如果对方的口气坚决，则可以迂回争取试用期的缩短，比如说：我对自己是比较有自信的，您看能不能一步到位直接拿转正期的工资，或者把３个月的试用期缩短为１个月？额外工资多争取。

很多企业除了正式的工资以外，都会产生一些奖金、福利等额外工资，在这方面应聘者就要大胆争取了。应聘者要注意察言观色见好就收，不要过度要求，否则让对方破例后，到时你进来后对方也会以更高的要求来考核你，还可能答应了最后也不兑现。为了保险起见，应聘者最好让对方在接收函上写明薪酬、试用期限、上班时间等，这样可免去日后口说无凭的纠纷。

总之，好的薪水是要靠势力得到的,但多调查和多注意这方面的资讯,使自己在面试前做到对这个职位的大致薪水有个了解,就会使你不至于提太高或太低不切实际的要求,从而失去到手的工作。
```

[参与互动](https://github.com/yisainan/web-interview/issues/782)

</details>

<b><details><summary>3、HR 指责要薪太高怎么办？</summary></b>

想象下，当你实事求是的按照以上的方法报出自己的工资为 7000 元的时候，面试官呵呵笑道：“你是应届生，却要求 7000 元的工资，是不是太高了？”此时，你该怎么办？

回答提示：

```
1、北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的web前端平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)；
2、上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）；
3、我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）；
4、对技术狂热，会沿着前端道路一直往前走（强调自己对这份工作的热爱）；
5、再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。
```

[参与互动](https://github.com/yisainan/web-interview/issues/783)

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1、请你自我介绍一下你自己</summary></b>

回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。

回答样本：

```
1、我叫xxx,来自于xxx，从网上看得到公司招聘的这个职位，觉得非常适合自己的发展。所以来这里争取下这份工作。
2、接下来可以讲解自己的核心竞争力（最强的技能、最深入研究的知识领域、个性中最积极的部分）和闪光点（做过的最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。
3、先介绍到这里，面试官看看有什么问题，我可以再补充。
4、最后要说谢谢，任何企业都喜欢有礼貌的人！
```

注意：自曝其短（说自己的缺点）没有必要，自我介绍的时候千万不要和简历有冲突！

[参与互动](https://github.com/yisainan/web-interview/issues/719)

</details>

<b><details><summary>2、你觉得你个性上最大的优点是什么？</summary></b>

回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱、技术狂热、学习能力强、为人谦和。

[参与互动](https://github.com/yisainan/web-interview/issues/720)

</details>

<b><details><summary>3、说说你最大的缺点？</summary></b>

回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。

[参与互动](https://github.com/yisainan/web-interview/issues/721)

</details>

<b><details><summary>4、你对加班的看法？</summary></b>

回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。
回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。

[参与互动](https://github.com/yisainan/web-interview/issues/722)

</details>

<b><details><summary>5、你对薪资的要求？</summary></b>

回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。

回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多

回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。

回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。

[参与互动](https://github.com/yisainan/web-interview/issues/723)

</details>

<b><details><summary>6、在五年的时间内，你的职业规划？</summary></b>

回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的参考答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是 “我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。

[参与互动](https://github.com/yisainan/web-interview/issues/724)

</details>

<b><details><summary>7、你朋友对你的评价？</summary></b>

回答提示： 想从侧面了解一下你的性格及与人相处的问题。
回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。
回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“

[参与互动](https://github.com/yisainan/web-interview/issues/725)

</details>

<b><details><summary>8、你还有什么问题要问吗？</summary></b>

回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。

[参与互动](https://github.com/yisainan/web-interview/issues/726)

</details>

<b><details><summary>9、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</summary></b>

回答提示：一段时间发现工作不适合我，有两种情况：

1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；

2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。

[参与互动](https://github.com/yisainan/web-interview/issues/727)

</details>

<b><details><summary>10、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</summary></b>

回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；
② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；
③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。

[参与互动](https://github.com/yisainan/web-interview/issues/728)

</details>

<b><details><summary>11、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</summary></b>

回答提示：
① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决；
② 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。
③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。

[参与互动](https://github.com/yisainan/web-interview/issues/729)

</details>

<b><details><summary>12、如果你在这次考试中没有被录用，你怎么打算？</summary></b>

回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败.

第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我.

第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人.

第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质.

第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩.

第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争.

[参与互动](https://github.com/yisainan/web-interview/issues/730)

</details>

<b><details><summary>13、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</summary></b>

回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。

[参与互动](https://github.com/yisainan/web-interview/issues/731)

</details>

<b><details><summary>14、谈谈你对跳槽的看法？</summary></b>

回答提示：（1）正常的"跳槽"能促进人才合理流动，应该支持；
（2）频繁的跳槽对单位和个人双方都不利，应该反对。

[参与互动](https://github.com/yisainan/web-interview/issues/732)

</details>

<b><details><summary>15、工作中你难以和同事、上司相处，你该怎么办？</summary></b>

回答提示：
① 我会服从领导的指挥，配合同事的工作。
② 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。
③ 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。
④ 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！

[参与互动](https://github.com/yisainan/web-interview/issues/733)

</details>

<b><details><summary>16、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？

</summary></b>

回答提示：
① 成绩比较突出，得到领导的肯定是件好事情，以后更加努力
② 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。
③ 工作中，切勿伤害别人的自尊心
④ 不再领导前拨弄是非
⑤ 乐于助人对面

[参与互动](https://github.com/yisainan/web-interview/issues/734)

</details>

<b><details><summary>17、你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？</summary></b>

回答提示：请自行根据自己情况做回答，这个没有统一标准参考答案。

[参与互动](https://github.com/yisainan/web-interview/issues/735)

</details>

<b><details><summary>18、你对于我们公司了解多少？</summary></b>

回答提示：在去公司面试前上网查一下该公司主营业务。

[参与互动](https://github.com/yisainan/web-interview/issues/736)

</details>

<b><details><summary>19、请说出你选择这份工作的动机？你为什么选择我们公司？</summary></b>

回答提示：

```
1.面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！
2.面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的面试岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。
3.如果对这个行业确实很喜欢，要说出你对这个行业的认识与热爱。
```

[参与互动](https://github.com/yisainan/web-interview/issues/737)

</details>

<b><details><summary>20、你最擅长的技术方向是什么？</summary></b>

回答提示：说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。

[参与互动](https://github.com/yisainan/web-interview/issues/738)

</details>

<b><details><summary>21、你能为我们公司带来什么呢？</summary></b>

回答提示：

```
① 假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过专业的培训或者工作 X 年，立刻就可以上岗工作”。
② 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。
```

[参与互动](https://github.com/yisainan/web-interview/issues/739)

</details>

<b><details><summary>22、最能概括你自己的三个词是什么？</summary></b>

回答提示：我经常用的三个词是适应能力强，有责任心和做事有始终，结合具体例子向主考官解释。

[参与互动](https://github.com/yisainan/web-interview/issues/740)

</details>

<b><details><summary>23、你的业余爱好是什么？</summary></b>

回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。

[参与互动](https://github.com/yisainan/web-interview/issues/741)

</details>

<b><details><summary>24、作为被面试者给我打一下分</summary></b>

回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。

[参与互动](https://github.com/yisainan/web-interview/issues/742)

</details>

<b><details><summary>25、你怎么理解你应聘的职位？</summary></b>

回答提示：把岗位职责和任务及工作态度阐述一下

[参与互动](https://github.com/yisainan/web-interview/issues/743)

</details>

<b><details><summary>26、喜欢这份工作的哪一点？</summary></b>

回答提示：相信其实大家心中一定都有参考答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的参考答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。

[参与互动](https://github.com/yisainan/web-interview/issues/744)

</details>

<b><details><summary>27、为什么要离职?您在前一家公司的离职原因是什么?</summary></b>

回答提示：

```
① 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的参考答案最好是积极正面的。
② 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。
③ 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在；
④ 避免把“离职原因”说得太详细、太具体；
⑤ 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等；但也不能躲闪、回避，如“想换换环境”、“个人原因”等；
⑥ 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等；尽量使解释的理由为应聘者个人形象添彩；
```

回答样本：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个参考答案，而同一个参考答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。

分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个参考答案一般面试官还能接受。

[参与互动](https://github.com/yisainan/web-interview/issues/745)

</details>

<b><details><summary>28、说说你对行业、技术发展趋势的看法？</summary></b>

回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。

[参与互动](https://github.com/yisainan/web-interview/issues/746)

</details>

<b><details><summary>29、对工作的期望与目标何在？</summary></b>

回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的参考答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。

[参与互动](https://github.com/yisainan/web-interview/issues/747)

</details>

<b><details><summary>30、说说你的家庭。</summary></b>

回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。

[参与互动](https://github.com/yisainan/web-interview/issues/748)

</details>

<b><details><summary>31、就你申请的这个职位，你认为你还欠缺什么？</summary></b>

回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。

[参与互动](https://github.com/yisainan/web-interview/issues/749)

</details>

<b><details><summary>32、你欣赏哪种性格的人？</summary></b>

回答提示：诚实、不死板而且容易相处的人、有"实际行动"的人。

[参与互动](https://github.com/yisainan/web-interview/issues/750)

</details>

<b><details><summary>33、你通常如何处理別人的批评？</summary></b>

回答提示：① 沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评；② 我会等大家冷靜下来再讨论。

[参与互动](https://github.com/yisainan/web-interview/issues/751)

</details>

<b><details><summary>34、你怎样对待自己的失敗？</summary></b>

回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。

[参与互动](https://github.com/yisainan/web-interview/issues/752)

</details>

<b><details><summary>35、什么会让你有成就感？</summary></b>

回答提示：为贵公司竭力效劳；尽我所能，完成一个项目

[参与互动](https://github.com/yisainan/web-interview/issues/753)

</details>

<b><details><summary>36、眼下你生活中最重要的是什么？</summary></b>

回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。

[参与互动](https://github.com/yisainan/web-interview/issues/754)

</details>

<b><details><summary>37、你为什么愿意到我们公司来工作？</summary></b>

回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。

[参与互动](https://github.com/yisainan/web-interview/issues/755)

</details>

<b><details><summary>38、你和别人发生过争执吗？你是怎样解决的？</summary></b>

回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确参考答案。

[参与互动](https://github.com/yisainan/web-interview/issues/756)

</details>

<b><details><summary>39、问题：你做过的哪件事最令自己感到骄傲?</summary></b>

回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。

[参与互动](https://github.com/yisainan/web-interview/issues/757)

</details>

<b><details><summary>40、你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?</summary></b>

回答提示：

(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。

(2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。

(3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。

(4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。

(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。

[参与互动](https://github.com/yisainan/web-interview/issues/758)

</details>

<b><details><summary>41、对这项工作，你有哪些可预见的困难？</summary></b>

回答提示：

```
① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行；
② 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。”
```

分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。

第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。

第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。

[参与互动](https://github.com/yisainan/web-interview/issues/759)

</details>

<b><details><summary>42、如果我录用你，你将怎样开展工作？</summary></b>

回答提示：

```
① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法；
② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”
```

分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。

[参与互动](https://github.com/yisainan/web-interview/issues/760)

</details>

<b><details><summary>43、你希望与什么样的上级共事？</summary></b>

回答提示：

```
① 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会；
② 最好回避对上级具体的希望，多谈对自己的要求；
③ 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了
```

分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。

[参与互动](https://github.com/yisainan/web-interview/issues/761)

</details>

<b><details><summary>44、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</summary></b>

回答提示：

```
①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；
② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；
③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。
```

[参与互动](https://github.com/yisainan/web-interview/issues/762)

</details>

<b><details><summary>45、与上级意见不一是，你将怎么办？</summary></b>

回答提示：

```
① 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”
② 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”
```

分析：这个问题的标准参考答案是思路 1，如果用 2 的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。

[参与互动](https://github.com/yisainan/web-interview/issues/763)

</details>

<b><details><summary>46、你工作经验欠缺，如何能胜任这项工作？</summary></b>

回答提示：

```
① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答；
② 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业；
③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”
```

点评：这个问题思路中的参考答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。

[参与互动](https://github.com/yisainan/web-interview/issues/764)

</details>

<b><details><summary>47、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</summary></b>

回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。
据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。
有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。

[参与互动](https://github.com/yisainan/web-interview/issues/765)

</details>

<b><details><summary>48、项目中遇到困难，你怎么办？怎么回答</summary></b>

回答提示：自己能搞定的，就自己上网找资料；但如果比如在 2 个小时之内还没有头绪，就考虑问公司技术水平比较高的同事之类的，然后还要及时和项目经理沟通

那不浪费了 2 个小时时间 业务问题的话，谁清楚就问谁啊……即时沟通能够大大提高工作效率。

技术问题查资料，需求问题重新分析

还是写程序的时候有技术难点、技术难点又分普遍的技术难点、还是你个人不会做、

第一种这个要找项目负责人商量、甚至要找产品/运行或其他甲方沟通、

第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、

第三种的话、先自己查资料试着解决、不行就找人其他资讯、、

[参与互动](https://github.com/yisainan/web-interview/issues/766)

</details>

<b><details><summary>49、对前端界面工程师这个职位是怎么样理解的？</summary></b>

回答提示：

a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好

b. 参与项目，快速高质量完成实现效果图，精确到 1px；

c. 与团队成员，UI 设计，产品经理的沟通；

d. 做好的页面结构，页面重构和用户体验；

e. 处理 hack，兼容、写出优美的代码格式；

f. 针对服务器的优化、拥抱最新前端技术。

[参与互动](https://github.com/yisainan/web-interview/issues/767)

</details>

<b><details><summary>50、你在现在的团队处于什么样的角色，起到了什么明显的作用？</summary></b>

回答提示：请自行根据自己情况做回答，这个没有统一标准参考答案。

[参与互动](https://github.com/yisainan/web-interview/issues/768)

</details>

<b><details><summary>51、最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</summary></b>

面试时，经常会被面试官问到关于职业规划的问题，比如：你准备在我们公司做多久？你未来几年的职业规划是什么？等等。还没有进入公司，对公司工作环境还不太了解就被面试官问到这些问题，该怎么答才能合情有合理呢？

问：你准备在我们这家单位做多久？

答：

```
1. 这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的。
2．以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年。
```

问：未来五年的规划是怎样的？

答：

```
1.如果应聘成功，我至少会稳定的做两年，踏实的做好自己的本职工作。
2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。
3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。
```

当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。

大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。

[参与互动](https://github.com/yisainan/web-interview/issues/769)

</details>

<b><details><summary>52、如何向 HR 介绍你做过的项目</summary></b>

项目经验与工作经验是相辅相成的，但较之于工作经验，项目经验更侧重于表现求职者在某个专业领域内的技能水平（技能水平决定了工资水平）。因而，技术类岗招聘的时候，更注重项目经验。项目介绍是有套路的，面试时，要将简历中的项目准备好！

回答提示：

我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面：

```
1、项目名称
2、开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）；
3、项目描述（做什么的）；
4、项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）；
5、项目使用的技术（除了说现在使用的技术，还可以说项目进行了压力测试、兼容性处理、数据库的3F、未来还要放mysql集群技术、页面静态化技术、以提升自己在对方心目中的技术形象）；
6、项目的亮点；
7、在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。
8、项目体会（可以说说：多人协作、命名规范、模块划分）；
```

[参与互动](https://github.com/yisainan/web-interview/issues/770)

</details>

<b><details><summary>53、HR 贬低项目时你该怎么办</summary></b>

我们在上文讲解了如何向 HR 介绍项目。由于项目反映了技术，技术决定了薪资，所以面试官一般会把打压我们的项目变相打压我们技术，以达到打压我们薪资预期的目的，同时观察我们在打压环境中的表现来决定到底打压薪资到何种程度！所以，当 HR 说：“一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊”，各位面试者一定要冷静！来学学在 HR 贬低项目时的应对方法！

回答提示：

HR 说：一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊！如何应对，别慌，我们应该按下面的方法答：

```
1.项目实现也许花的时间不多，但是前期的构思、需求分析、页面设计等等准备工作是花了很多时间的。
2.项目大小和技术含量并不能够成正比，我们的项目，虽然小，但麻雀虽小，却五脏俱全。接着向面试官介绍你们团队在项目过程中所使用的技术等等。
3.项目大小主要是体现在功能上，有些功能客户并没有提出。如果后期客户有提出，我们也能够快速的实现。
```

[参与互动](https://github.com/yisainan/web-interview/issues/771)

</details>

<b><details><summary>54、项目经验少该怎么办</summary></b>

对于前端来说，技术水平是决定我们工资最重要的因素。技术水平是要通过我们的项目体现出来的，但项目经验少该怎么办？

回答提示：

```
1、项目经验是拿高工资最重要的一个指标。这反映了程序员的价值，也是用人单位给出薪资报价最重要的因素。所以面试者一定要重视项目。
2、简历中至少要写出3个项目。
3、项目可以适当包装。可以多说一些比较高端大气上档次的技术。
4、面试官问到简历中的项目细节你要能答上来。否则，就算是你做的，面试官因你答不上来也会认为不是你做的。所以要花时间，搞定写在简历上的项目模块。
5、项目抓亮点来说，可以对照企业的需求，将最有竞争力的点说清楚。这种能够加分的亮点一定要说到。
```

[参与互动](https://github.com/yisainan/web-interview/issues/772)

</details>

<b><details><summary>55、你学历低，为什么要录用你？</summary></b>

面试一份工作时，学历有时候是一块敲门砖。对于学历不高的面试者，如果 HR 问：你才高中学历，而现在大学生一大把，我们为什么要录用你？你如果学历真的很低，那该怎么回答呢？

回答提示：

```
1、通过自信的表现，有效的沟通，让面试官主动忽略这个问题。或者说是你把你最好的展现出来，让面试官信服，觉得你是合适的人选而不提及或忽略掉这个问题。
2、即使面试官提出来了，勇敢面对主动承认，赞同面试官的提问，确实学历较低，自已已经深刻认识此问题，也因为认识到这个事实，你才更加注重能力的培养，同时自己也在工作之余继续课堂学习，增加扎实的理论知识。同时说出你的学历提升打算，提升计划一定要与你现行的工作职位结合。
3、如果面试官对学历一直抓住不放，或作为必要条件，以退为进吧，委婉表达自己想得到职位的态度，并做好了放弃的心理准备。
```

总的来说，在面试的时候，表现出自信，从谈吐和沟通上，给面试官好印象。如果问到你学历的时候，表现出“学历不代表能力”的自信来就好，一般的企业不会把这个当做决定性因素，还是看综合素质。

[参与互动](https://github.com/yisainan/web-interview/issues/773)

</details>

<b><details><summary>56、你是不是年龄太大了？</summary></b>

都说 IT 行业是个吃青春饭的行业，你现在已经接近 30 岁了，你是不是年龄太大了？这个问题应该被问到的不多，但是万一真的被问到这个问题，你该如何作答呢？

回答提示：

```
1、 能不能做事才是大问题。而不是年龄。是不是有能力，试用期间可以检验。
2、 要表现出自己很喜欢这份工作，要长久的做下去（年龄大的人，工作经历多，接触的东西多，才能够在众多的经历中明确知道自己未来到底要走什么路）。要突出自己年龄大的优势，比如思想更成熟，眼界更开阔等等。
```

[参与互动](https://github.com/yisainan/web-interview/issues/774)

</details>

<b><details><summary>57、你太小了，你能承担项目吗？</summary></b>

虽说 IT 行业是个吃青春饭的行业，但是你年纪太小了，让人感觉不踏实。虽然我们最重要拼的是技术，但真的被问到这个问题，你该如何作答呢？

回答提示：

```
1、虽然我年纪小，但是我技术是没有问题的，也是有担当的。试用期间可以检验。
2、对于前端，我做过很多的项目，也有系统的学习过。并不比年纪大的人差。
3、正因为我年纪小，我对于工作有十足的干劲，我很想在这行好好的发展，也能承受比较强的工作压力。
```

[参与互动](https://github.com/yisainan/web-interview/issues/775)

</details>

<b><details><summary>58、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</summary></b>

回答提示：
前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。

- 1、实现界面交互
- 2、提升用户体验
- 3、有了 Node.js，前端可以实现服务端的一些事情

* 前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，
* 参与项目，快速高质量完成实现效果图，精确到 1px；
* 与团队成员，UI 设计，产品经理的沟通；
* 做好的页面结构，页面重构和用户体验；
* 处理 hack，兼容、写出优美的代码格式；
* 针对服务器的优化、拥抱最新前端技术。

其它相关的加分项：

1. 都使用和了解过哪些编辑器?都使用和了解过哪些日常工具?
2. 都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器?
3. 瀑布流布局或者流式布局是否有了解
4. HTML5 都有哪些新的 API?
5. 都用过什么代码调试工具?
6. 是否有接触过或者了解过重构。
7. 你遇到过比较难的技术问题是？你是如何解决的？

[参与互动](https://github.com/yisainan/web-interview/issues/776)

</details>

<b><details><summary>59.现如今面对如层出不穷的类库，说说你的感受</summary></b>

参考答案：百花齐放，百家争鸣的感觉。
说明社区活跃，这一片欣欣尚荣的风景，蛮好！

</details># [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

面试是一个非常重要的过程，有些人在这个过程中感到不知所措，或者做得不好，使自己在求职中因小失大，达不到成功。在求职过程中注意了以下基本礼仪和技巧，才能达到事半功倍，增强面试的有效性。

<b><details><summary>1、面试前准备</summary></b>

（1）穿着得体，干净

（2）对公司做简单的了解

（3）保证充足睡眠，保持自信

[参与互动](https://github.com/yisainan/web-interview/issues/777)

</details>

<b><details><summary>2、注意事项</summary></b>

(1)一旦约好面试时间，一定要提前 5-10 分钟到达地点，以表示求职者的诚意，给对方以信任感。

(2)面试时不要紧张，保持微笑，如果门关着，应先敲门，得到允许后再进去。开关门动作要轻。

(3) 对于面试官的问题要一一回答，可以适当点头，不要打断用人单位的问话或抢问抢答。回答问题是眼睛要注视面试官，切记不要左顾右盼。

[参与互动](https://github.com/yisainan/web-interview/issues/778)

</details>

<b><details><summary>3、谈话技巧　</summary></b>

(1)自我介绍在三分钟之内，口齿清晰，语言流利，吐字清晰。

(2) 注意听者的反应。比如，听者心不在焉，可能表示他对自己这段话没有兴趣，你得设法转移话题；侧耳倾听，可能说明由于自己音量过小使对方难于听清；皱眉、摆头可能表示自己言语有不当之处。根据对方的这些反应，就要适时地调整自己的语言、语调、语气、音量、修辞，包括陈述内容。这样才能取得良好的面试效果。

(3) 表示关注的手势。在与他人交谈中，一定要对对方的谈话表示关注，要表示出你在聚精会神地听。对方在感到自己的谈话被人关注和理解后，才能愉快专心地听取你的谈话，并对你产生好感。

[参与互动](https://github.com/yisainan/web-interview/issues/779)

</details>

<b><details><summary>4、回答问题的技巧　　</summary></b>

(1) 把握重点，简捷明了，条理清楚，有理有据。一般情况下回答问题要结论在先，议论在后，先将自己的中心意思表达清晰，然后再做叙述和论证。否则，长篇大论，会让人不得要领。面试时间有限，神经有些紧张，多余的话太多，容易走题，反倒会将主题冲淡或漏掉。

(2) 讲清原委，避免抽象。　用人单位提问总是想了解一些应试者的具体情况，切不可简单地仅以“是”和“否”作答。应针对所提问题的不同，有的需要解释原因，有的需要说明程度。不讲原委，过于抽象的回答，往往不会给主试者留下具体的印象。

(3) 确认提问内容，切忌答非所问。面试中，如果对用人单位提出的问题，一时摸不到边际，以致不知从何答起或难以理解对方问题的含义时，可将问题复述一遍，并先谈自己对这一问题的理解，请教对方以确认内容。对不太明确的问题，一定要搞清楚，这样才会有的放矢，不致答非所问。

(4) 有个人见解，有个人特色。用人单位有时接待应试者若干名，相同的问题问若干遍，类似的回答也要听若干遍。因此，用人单位会有乏味、枯燥之感。只有具有独到的个人见解和个人特色的回答，才会引起对方的兴趣和注意。

(5) 知之为知之，不知为不知。面试遇到自己不知、不懂、不会的问题时，回避闪烁，默不作声，牵强附会，不懂装懂的做法均不足取，诚恳坦率地承认自己的不足之处，反倒会赢得主试者的信任和好感。

[参与互动](https://github.com/yisainan/web-interview/issues/780)

</details>

总结：保持自信，做自我介绍时，时间应控制在三分钟之内，不要啰嗦，把自己取得过什么成就，或者在公司做过什么贡献，总结自己的优势时刻保持微笑。最后，紧张的同学，可以把面试官当做同事，面试是一个相互选择的过程，你找我我还不一定干呢。
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

> 转载自 微信小程序：高级前端面试-选择题

<b><details><summary>1.(单选题)下面代码的输出是什么 </summary></b>

```js
const name = "Lydia";
age = 21;

console.log(delete name);
console.log(delete age);
```

```
A: false, true
B: "Lydia", 21
C: true, true
D: undefined, undefined
```

参考答案: A

解析: 

delete 操作符返回一个布尔值: true 指删除成功，否则返回 false . 但是通过 var , const 或 let 关键字声明的变量无法用 delete 操作符来删除。

name 变量由 const 关键字声明，所以删除不成功: 返回 false 而我们设定 age 等于 21 时，我们实际上添加了一个名为 age 的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以 delete age 返回 true

[参与互动](https://github.com/yisainan/web-interview/issues/1012)

</details>

<b><details><summary>2.(单选题)我们需要向对象 person 添加什么，以致执行[…person]时获得形如['Lydia Hallie', 21]的输出？ </summary></b>

```js
const person = {
    name: 'Lydia Hallie',
    age: 21
}
[...person] // ['Lydia Hallie', 21]
```

```
A: 不需要，对象默认就是可迭代的
B: *[Symbol.iterator]() { for (let x in this) yield* this
[x]}
C: *[Symbol.iterator]() {yield* Object.values(this)}
D: *[Symbol.iterator]() { for (let x in this) yield this }
```

参考答案: C

解析: 

对象默认是不可迭代的。如果迭代规则被定义，则一个对象是可迭代的（ An iterable is an iterable if the iterator protocol is present)。我们可以通过添加迭代器 symbol [Symbol.iterator]来定义迭代规则，其返回一个 generator 对象，比如说构建一个 generator 函数 _[Symbol.iterator](){}。如果我们想要返回数组['Lydia Halli', 21] :yield_ Object.values(this), 这个 geneator 函数一定要 yield 对象 person 的 Object.values

[参与互动](https://github.com/yisainan/web-interview/issues/1013)

</details>

<b><details><summary>3.(单选题)下面代码的输出是什么 </summary></b>

```js
const set = new Set();

set.add(1);
set.add("Lydia");
set.add({
    name: "Lydia"
});

for (let item of set) {
    console.log(item + 2);
}
```

```
A: 3, NaN, NaN
B: 3, 7, NaN
C: 3, Lydia2, [Object object]2
D: "12", Lydia2, [Object object]2
```

参考答案: C

解析: 

“+”运算符不仅用于添加数值，还可以使用它来连接字符串。每当 JavaScript 引擎发现一个或多个值不是数字时，就会持数字强制为字符串。第一个是数字 1。1+2 返回数字 3。

但是，第二个是字符串“Lydia”。“Lydia”是一字符串，2 是一数字: 2 被强制转换为字符串。“Lydia”和“2”被连接起来，产生字符串“Lydia2”。

{name : "Lydia"}是一个对象。数字和对象都不是字符串，因此将二者都字符串化。每当我们对常规对象进行字符串化时，它就会变成[Object object]。与“2”串联的“[Object object]”成为“[Object object]2”。

[参与互动](https://github.com/yisainan/web-interview/issues/1014)

</details>

<b><details><summary>4.(单选题)下面代码的输出是什么 </summary></b>

```js
const settings = {
    username: 'lydiahallie',
    level: 19,
    health: 90
};
const data = JSON.stringify(settings, ['level', 'health']);
console.log(data);
```

```
A: "{"level":19, "health":90}"
B: "{"username": "lydiahallie"}"
C: "{"level", "health"]"
D: "{"username": "lydiahallie", "level":19, "health":90}"
```

参考答案: A

解析: 

JSON.stringify 的第二个参数是替代者（replacer）. 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。

如果替代者(replacer)是个数组，那么就只有包含在数组中的属性将会被转化为字符串。在本例中，只有名为'level'和'health'的属性被包括进来，'username'则被排除在外。data 就等于 "{"level":19, "health":90}"

而如果替代者(replacer)是个函数，这个函数将被对象的每个属性都调用一遍。函数返回的值会成为这个属性的值，最终体现在转化后的 JSON 字符串中（译者注: Chrome 下，经过实验，如果所有属性均返回同一个值的时候有异常，会直接将返回值作为结果输出而不会输出 JSON 字符串），而如果返回值为 undefined , 则该属性会被排除在外。

[参与互动](https://github.com/yisainan/web-interview/issues/1015)

</details>

<b><details><summary>5.(单选题)下面代码的输出是什么 </summary></b>

```js
const name = "Lydia";

console.log(name());
```

```
A: SyntaxError
B: ReferenceError
C: TypeError
D: undefined
```

参考答案: C

解析: 

变量 name 保存字符串的值，该字符串不是函数，因此无法调用。

当值不是预期类型时，到抛出 TypeError。JavaScript 期望 name 是一个函数，因为我们试图调用它。但它是一个字符串，因此抛出 TypeError : name is not a function

[参与互动](https://github.com/yisainan/web-interview/issues/1016)

</details>

<b><details><summary>6.(单选题)下面代码的输出是什么 </summary></b>

```js
console.log("🐭" + "🐍");
```

```
A: 🐭🐍
B:257548
C:A string containing their code points
D:Error
```

参考答案: A

解析: 

使用+运算符，您可以连接字符串。上述情况，我们将字符串"🐭" 与 字 符 串 "🐍"连 接 起 来 ， 产 生 🐭🐍

[参与互动](https://github.com/yisainan/web-interview/issues/1017)

</details>

<b><details><summary>7.(单选题)下面代码的输出是什么 </summary></b>

```js
let newList = [1, 2, 3].push(4);

console.log(newList.push(5));
```

```
A: [1,2,3,4,5]
B: [1,2,3,5]
C: [1,2,3,4]
D: Error
```

参考答案: D

解析: 

.push()方法返回数组的长度，而不是数组的本身。

[参与互动](https://github.com/yisainan/web-interview/issues/1018)

</details>

<b><details><summary>8.(单选题)下面代码的输出是什么 </summary></b>

```js
let name = "Lydia";

function getName() {
    console.log(name);
    let name = "Sarah";
}
getName();
```

```
A: Lydia
B: Sarah
C: undefined
D: ReferenceError
```

参考答案: D

解析: 

每个函数都有其自己的执行上下文。getName 函数首先在其自身的上下文（范围）内查找，以查看其是否包含我们尝试访问的变量 name。上述情况，getName函数包含其自己的 name 变量: 我们用 let 关键字和 Sarah 的值声明变量 name。

带有 let 关键字（和 const)的变量被提升，但是与 var 不同，它不会被初始化。在我们声明（初始化） 它们之前，无法访问它们。这称为“暂时性死区”。当我们尝试在声明变量之前访问变量时，JavaScript 会抛出 ReferenceError: Cannot access 'name' before initialization。

如果我们不在 getName 函数中声明 name 变量，则 javascript 引擎会查看原型链。会找到其外部作用域有一个名为 name 的变量，其值为 Lydia。在这种情况下，它
将打印 Lydia :

```js
let name = 'Lydia'

function getName()
console.log(name)
}
getName() // Lydia
```

[参与互动](https://github.com/yisainan/web-interview/issues/1019)

</details>

<b><details><summary>9.(单选题)下面代码的输出是什么 </summary></b>

```js
function getAge(...args) {
    console.log(typeof args);
}
getAge(21);
```

```
A: "number"
B: "array"
C: "object"
D: "NaN"
```

参考答案: C

解析: 

扩展运算符（...args )返回一个带参数的数组。 
数组是一个对象，因此typeof args返回object。

[参与互动](https://github.com/yisainan/web-interview/issues/1020)

</details>

<b><details><summary>10.(单选题)下面代码的输出是什么 </summary></b>

```js
[1, 2, 3, 4].reduce((x, y) => console.log(x, y))
```

```
A: 1 2 and 3 3 and 6 4 
B: 1 2 and 2 3 and 3 4
C: 1 undefined and 2 undefined and 3 undefined and 4 undefined
D: 1 2 and undefined 3 and undefined 4 
```

参考答案: D

解析: 

![001](../images/001.png)

reduce函数接收4个参数: 
• total (累加器）
• currentValue (当前值）
• currentIndex (当前索引）
• arr (源数组）

reduce 函数的返回值将会分配给累加器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。

reduce函数还有一个可选参数initialValue, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供initialValue , 则将使用数组中的第一个元素。

在上述例子, reduce方法接收的第一个参数(total)是 x, 第二个参数(currentValue)是 y。

在第一次调用时，累加器x为1 , 当 前 值'y'为 2  , 打印出累加器和当前值: 1 和 2。

在第二次调用时，我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回undefined。在下一次调用时，累加器为undefined , 当前值为'3'，因此undefined和3被打印出来。

在第三次调用时，回调函数依然没有返回值。累加器再次为 undefined , 当前值为“4”。undefined 和 4 被打印出来。

如果改造成以下代码：
```js
[1, 2, 3, 4].reduce((x, y) => { console.log(x, y); return x + y; }, 100)

// 打印
// 100 1
// 101 2
// 103 3
// 106 4
```

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>11.(单选题)下面代码的输出是什么 </summary></b>

```js
let a = 3;
let b = new Number(3)
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

```
A：true false true
B: false false true
C: true false false
D: false true true
```

参考答案：C

解析：

new Number ()是一个内置的函数构造函数。虽然它看起来像一个数字，但它并不是一个真正的数 字：它有一堆额外的功能，是一个对象。

当我们使用 == 运算符时，它只检查它是否具有相同的值。他们都有3的值，所以返回true

译者注：==会引发隐式类型转换，右侧的对象类型会自动转换为Number类型

然而，当我们使用 === 操作符是，类型和值都需要相等，Number()不是一个数字，是对象类型。两者都返回false

[参与互动](https://github.com/yisainan/web-interview/issues/1022)

</details>

<b><details><summary>12.(单选题）当我们这样做时会发生什么? </summary></b>

```js
function bark() {
    console.log('Woof!');
}
bark.animal = 'dog';
```

```
A：Nothing, this is totally fine!
B: SyntaxError. You cannot add properties to a function this way.
C: undefined
D: ReferenceError
```

参考答案：A

解析：

这在JavaScript中是可能的，因为函数也是对象！（ 原始类型之外的所有东西都是对象）

函数是一种特殊类型的对象。您自己编写的代码并不是实际的函数。该函数是具有属性的对象，此属性是可调用的。

[参与互动](https://github.com/yisainan/web-interview/issues/1023)

</details>

<b><details><summary>13.(单选题)下面代码的输出是什么 </summary></b>

```js
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};

const name = "Lydia";
name.giveLydiaPizza();
```

```
A: "Just give Lydia pizza already!"
B: TypeError: not a function
C: SyntaxError
D: undefined
```

参考答案：A

解析：

String是一个内置的构造函数，我们可以为它添加属性。 我刚给它的原型添加了一个方法。 原始类型的字符串自动转换为字符串对象，由字符串原型函数生成。 因此，所有字符串（字符串对象）都可以访问该方法！

当使用基本类型的字符串调用giveLydiaPizza时，实际上发生了下面的过程：

* 创建一个String的包装类型实例
* 在实例上调用substring方法
* 销毁实例

[参与互动](https://github.com/yisainan/web-interview/issues/1024)

</details>

<b><details><summary>14.(单选题)下面代码的输出是什么 </summary></b>

```js
const {
    name: myName
} = {
    name: 'Lydia'
}

console.log(name)
```

```
A："Lydia" 
B: "myName" 
C: undefined 
D: ReferenceError
```

参考答案：D

解析：

当我们从右侧的对象解构属性name时，我们将其值Lydia分配给名为myName的变量。

使用{name: myName}，我们是在告诉JavaScript我们要创建一个名为myName的新变量，并且其值是右侧对象的name属性的值。

当我们尝试打印name，一个未定义的变量时，就会引发 ReferenceError

[参与互动](https://github.com/yisainan/web-interview/issues/1025)

</details>

<b><details><summary>15.(单选题)下面代码的输出是什么 </summary></b>

```js
const name = 'Lydia'

console.log(name())
```

```
A：SyntaxError 
B: ReferenceError 
C: TypeError 
D: undefined
```

参考答案：C

解析：

变量name保存字符串的值，该字符串不是函数，因此无法调用。

当值不是预期类型时，到抛出TypeErrors。JavaScript期望name是一个函数，因为我们试图调用它。但它是一个字符串，因此抛出TypeError : name is not a function

当你编写了一些非有效的JavaScript时，会拋出语法错误，例如当你把return这个词写成retrun时。当Script无法找到您尝试访问的值的引用时，抛出ReferenceErrors

[参与互动](https://github.com/yisainan/web-interview/issues/1026)

</details>

<b><details><summary>16.(单选题)下面代码的输出是什么 </summary></b>

```js
var status = '🐰'
setTimeout(() => {
    const status = '🐎'
    const data = {
        status: '🐍'
        getStatus() {
            return this.status
        }
    }
    console.log(data.getStatus())
    console.log(data.getStatus.call(this))
}, 0)
```

```
A：'🐍' and '🐎'
B: '🐍' and '🐰'
C: '🐎' and '🐰'
D: '🐰' and '🐰'
```

参考答案：B

解析：

this关键字的指向取决于使用它的位置。在函数中, 比如 getStatus, this指向的是调用它的对象, 上述例子中data对象调用了 getStatus因此this指向的就是data对象, 当我们打印this.status时, data对象
的 status属性被打印, 即'🐍'。

使用call方法, 可以更政this指向的对象。data.getStatus.call(this)是将this的指向由data对象更改为全局对象。在全局对象上, 有一个名为 status的变量, 其值为'🐰'。因此打印this.status时, 会打印'🐰'

[参与互动](https://github.com/yisainan/web-interview/issues/1027)

</details>

<b><details><summary>17.(单选题)下面代码的输出是什么 </summary></b>

```js
const person = {
    name: 'Lydia',
    age: 21
}

let city = person.city
city = 'Amsterdam'
console.log(person)
```

```
A：{ name: "Lydia", age: 21}
B: { name: "Lydia", age: 21, city: "Amsterdam"}
C: { name: "Lydia", age: 21, city: undefined }
D: "Amsterdam"
```

参考答案：A

解析：

我们将变量city设置为等于person对象上名为city的属性的值。这个对象上沒有名为city的属性，因此变量city 的值为 undefined。

请注意，我们没有引用person对象本身，只是将变量city设置为等于person对象上city属性的当前值。
然后，我们将city设置为等于字符串"Amsterdam'。这不会更改person对象：没有对该对象的引用。因此打印person对象时，会返回未修改的对象。

[参与互动](https://github.com/yisainan/web-interview/issues/1028)

</details>

<b><details><summary>18.(单选题)下面代码的输出是什么 </summary></b>

```js
function sum(numl, num2 = numl) {
    console.log(numl + num2)
}
sum(10)
```

```
A：NaN
B: 20
C: ReferenceError
D: undefined
```

参考答案：B

解析：

您可以将默认参数的值设置为函数的另一个参数，只要另一个参数定义在其之前即可。我们将值10传递给sum函数。如果sum函数只接收1个参数，则意味看没有传递 num2 的 值 . 这 种 情 况 下 的 值 等 于 传 递 的 值 10。num2 的默认值是num1 的值，即10 。 num1  + num2 返回 20。

如果您尝试将默认参数的值设置为后面定义的参数，则可能导致参数的值尚未初始化，从而引发错误。比如：

```js
function test(m = n, n = 2) {
    console.log(m, n)
}
test() // Uncaught ReferenceEmor: Cannot access 
test(3) // 3 2
test(3, 4) // 3 4
```

[参与互动](https://github.com/yisainan/web-interview/issues/1029)

</details>

<b><details><summary>19.(单选题)下面代码的输出是什么 </summary></b>

```js
function* generatorOne() {
    yield ['a', 'b', 'c'];
}

function* generatorTwo() {
    yield*['a', 'b', 'c'];
}

const one = generatorOne()
const two = generatorTwo()

console.log(one.next().value)
console.log(two.next().value)
```

```
A：a and a
B: a and undefined 
C: ['a', 'b', 'c'] and a
D: a and ['a', 'b', 'c']
```

参考答案：C

解析：

通过yield关键字, 我们在Generator函数里执行yield表达式. 通过yield*关键字，我们可以在一个Generator函数里面执行（yield表达式）另一个Generator 函数，或可遍历的对象(如数组).

在函数generatorOne中，我们通过yield关键字yield 了一个完整的数组['a', 'b', 'c']。函数one通过next方法返回的对象的value属性的值（one.next().value)等价于数组['a', 'b', 'c']

```js
console.log(one.next().value) // ['a', 'b', 'c'] 
console.log(one.next().value) // undefined
```

在函数generatorTwo中，我们使用yield*关键字。就相当于函数two第一个yield的值, 等价于在迭代器中第一个yield的值。数组 ['a', 'b', 'c'] 就是个迭代器. 第一个 yield的值就是a , 所以我们第_次调用two.next().value 时，就返回 a。

```js
console.log(two.next().value) // 'a'
console.log(two.next().value) // 'b'
console.log(two.next().value) // 'c'
console.log(two.next().value) // underfined
```

[参与互动](https://github.com/yisainan/web-interview/issues/1030)

</details>

<b><details><summary>20.(单选题)下面代码的输出是什么 </summary></b>

```js
const set = new Set([1, 1, 2, 3, 4]);
console.log(set);
```

```
A：[1,1, 2, 3, 4]
B: [1,2, 3, 4]
C: {1,1, 2, 3, 4}
D: {1, 2, 3, 4}
```

参考答案：D

解析：

Set对象是独一无 二 的 值 的 集 合 ： 也 就 是 说 同 一 在 其中仅出现一次。

我 们 传 入 了 数 组 [ 1 , 1 , 2 , 3 , 4 ] , 他 有 一个重复值以为一个集合里不能有两个重复的值，其中一个就被移除了。所以结果是{1, 2, 3, 4}.

[参与互动](https://github.com/yisainan/web-interview/issues/1031)

</details>

<b><details><summary>21.(单选题)下面代码的输出是什么 </summary></b>

```js
const shape = {
    radius: 10,
    diameter() {
        return this.radius * 2;
    },
    perimeter: () => 2 * Math.PI * this.radius
};

shape.diameter();
shape.perimeter();
```

```
A：20 and 62.83185307179586
B: 20 and NaN
C: 20 and 63
D: NaN and 63
```

参考答案：B

解析：

请注意, diameter 是普通函数, 而 perimeter 是箭头函数。对于箭头函数, this 关键字指向是它所在上下文(定义时的位置)的环境, 与普通函数不同! 这意味着当我们调用 perimeter 时, 它不是指向 shape 对象, 而是指其定义时的环境
( window)。没有值 radius 属性, 返回 undefined。

[参与互动](https://github.com/yisainan/web-interview/issues/1032)

</details>

<b><details><summary>22.(单选题)下面代码的输出是什么 </summary></b>

```js
const person = {
    name: "Lydia Hallie",
    hobbies: ["coding"]
};

function addHobby(hobby, hobbies = person.hobbies) {
    hobbies.push(hobby);
    return hobbies;
}

addHobby("running", []);
addHobby("dancing");
addHobby("baking", person.hobbies);
console.log(person.hobbies);
```

```
A：["coding"]
B: ["coding", "dancing"]
C: ["coding", "dancing", "baking"]
D: ["coding", "running", "dancing","baking"]
```

参考答案：C

解析：

函数 addHobby 接受两个参数，hobby 和有看对象 person 中数组 hobbies 默认值的 hobbies。

首先，我们调用函数 addHobby , 并给 hobby 传递'running'以及 hobbies 传递一个空数组。因为我们给 hobbies 传递了空数组，'running' 被 添加到这个空数组。

然后，我们调用函数 addHobby , 并给 hobby 传递'dancing'。我们不向 hobbies 传递值，因此它获取其默认值---对象 person 的属性 hobbies。我们向数组 person.hobbies push dancing

最后，我们调用函数 addHobby , 并向 hobby 传递值'baking'，并且向 hobbies 传递 person.hobbies。我们向数组 person.hobbies push dancing。

pushing dancing 和 baking 之后，person.hobbies 的值为['coding', 'dancing’，'baking']

[参与互动](https://github.com/yisainan/web-interview/issues/1033)

</details>

<b><details><summary>23.(单选题)下面代码的输出是什么 </summary></b>

```js
const myLifeSummedUp = ["a", "b", "c", "d"];

for (let item in myLifeSummedUp) {
    console.log(item);
}

for (let item of myLifeSummedUp) {
    console.log(item);
}
```

```
A：0 1 2 3 and 'a' 'b' 'c' 'd'
B: 'a' 'b' 'c' 'd' and 'a' 'b' 'c' 'd'
C: 0 1 2 3 and 0 1 2 3
D: 0 1 2 3 and {
    0: 'a',
    1: 'b',
    2: 'c',
    3: 'd'
}
```

参考答案：A

解析：

通过 for-in 循环，我们可以遍历一个对象自有的、继承的、可枚举的、非 symbol 的属性。在数组中，可枚举属性是数组元素的键，即它们的索引。类似于下面的这个对象：

```js
{
    0: 'a',
    1: 'b',
    2: 'c',
    3: 'd'
}
```

其中键则是可枚举属性，因此 0, 1, 2, 3 被记录。通过 for-of 循环，我们可以迭代可迭代对象（包括 Array，Map，Set，String，arguments 等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量 item，因此'a' 'b' 'c' 'd'被打印

[参与互动](https://github.com/yisainan/web-interview/issues/1034)

</details>

<b><details><summary>24.(单选题)下面代码的输出是什么 </summary></b>

```js
const myFunc = ({
    x,
    y,
    z
}) => {
    console.log(x, y, z);
};

myFunc(1, 2, 3);
```

```
A：1 2 3
B: {1: 1} {2:2} {3:3}
C: {1: undefined} undefined undefined
D: undefined undefined undefined
```

参考答案：D

解析：

myFunc 期望接收一个包含 x，y 和 z 属性的对象作为它的参数，因为我们仅仅传递三个单独的数字值（1, 2, 3）不是一个含有 x，y 和 z 属性的对象({x:1, y:2, z:3}), x, y 和 z 有着各自的默认值 undefined

[参与互动](https://github.com/yisainan/web-interview/issues/1035)

</details>

<b><details><summary>25.(单选题)输出什么 </summary></b>

```js
const colorConfig = {
    red: true,
    blue: false,
    green: true,
    black: true,
    yellow: false
};

const colors = ["pink", "red", "blue"];

console.log(colorConfig.colors[1]);
```

```
A：true
B: false
C: undefined
D: TypeError
```

参考答案：D

解析：

在 JavaScript 中，我们有两种访问对象属性的方法：括号表示法或点表示法。在此示例中，我们使用点表示法(colorConfig.colors) 代替括号表示法(colorConfig["colors"]) 。

使用点表示法，JavaScript 会尝试使用该确切名称在对象 上查找属性。在此示例中，JavaScript 尝试在 colorconfig 对象上找到名为 colors 的属性。没有名为"colors"的属性，因此返回"undefined"。然后，我们尝试使用[1]访问第一个元 素 的 值 。 我 们 无 法 对 未 定 义 的 值执 行 此 操 作 ， 因此会抛出 Cannot read property '1' of undefined。JavaScript 解释（或取消装箱）语句。当我们使用方括号表示法时，它会看到第一个左方括号[并一直进行下去， 直到找到右方括号]。只有这样，它才会评估该语句。
如果我们使用了 colorConfig [colors [1]], 它将返回 colorConfig 对象上 red 属性的值。

[参与互动](https://github.com/yisainan/web-interview/issues/1036)

</details>

<b><details><summary>26.(单选题)输出什么 </summary></b>

```js
const food = ["A", "B", "C", "D"];
const info = {
    favoriteFood: food[0]
};
info.favoriteFood = "E";
console.log(food);
```

```
A：['A','B','C','D']
B: ['E','B','C','D']
C: ['E', 'A', 'B','C','D']
D: ReferenceError
```

参考答案：A

解析：

我们将 info 对象上的 favoriteFood 属性的值设置为"E"。字符串是原始数据类型。在 javaScript 中，原始数据类型通过值起作用。在这种情况下. 我们将 info 对象上的 favoriteFood 属性

性的值设置为等于 food 数组中的第一个元素的值，"A"。字符串是原始数据类型， 并且通过值进行交互，我们更改 info 对象上 favoriteFood 属性的值。food 数组没有改变，因为 favoriteFood 的值只是该数组中第一个元素的值的复制，并且与该元素上的元素没有相同的内存引用 food[0]。当我们记录 food 时，它仍然是原始数组['A', 'B', 'C', 'D']

[参与互动](https://github.com/yisainan/web-interview/issues/1037)

</details>

<b><details><summary>27.(单选题)输出什么 </summary></b>

```js
const randomValue = 21;

function getInfo() {
    console.log(typeof randomValue);
    const randomValue = "Lydia Hallie";
}
getInfo();
```

```
A："number"
B: "string"
C: undefined
D: ReferenceError
```

参考答案：D

解析：

通过 const 关键字声明的变量在被初始化之前不可被引用：这被称之为暂时性死区。在函数 getlnfo 中，变量 randomValue 声明在 getlnfo 的作用域的词法环境中。
在想要对 typeof randomValue 进行 log 之前，变量 randomValue 仍未被初始化：错误 ReferenceError 被抛出! JS 引擎并不会根据作用域链网上寻找该变量，因为我们已经在 getlnfo 函数中声明了randomValue 变量。

[参与互动](https://github.com/yisainan/web-interview/issues/1038)

</details>

<b><details><summary>28.(单选题)以下哪—项会对对象 person有副作用？</summary></b>

```js
const person = {
    name: 'Lydia Hallie',
    address: {
        street: '100 Main St'
    }
};
Object.freeze(person);
```

```
A：person.name = "Evan Bacon" 
B: delete person.address
C: person.address.street = "101 Main St" 
D: person.pet = { name: "Mara"}
```

参考答案：C

解析：

便用方法Object.freeze对一个对象进行冻结。不能对属性进行添加，修改，删除。然而，它仅对对象进行浅冻结，意味着只有对象中的直接属性被冻结。如果属性是另一个object, 像案例中的address, address中的属性没有被冻结，仍然可以被修改。

[参与互动](https://github.com/yisainan/web-interview/issues/1039)

</details>

<b><details><summary>29.(单选题)输出什么？</summary></b>

```js
// module.js
export default () => 'Hello world'
export const name s 'Lydia'
// index.js
import * as data from './module'
console.log(data)
```

```
A：{ default: function default(), name: "Lydia"}  
B: { default: function default() }
C: { default: "Hello world", name: "Lydia"}
D: Global object of module.js 
```

参考答案：A

解析：

使用import * as name语法，我们将module.js文件中所有export导入到index, js文件中，并且创建了一个名为data的新对象。在module.js文件中，有两个导出：默认导出和命名导出，默认导出是一个返回字符串'Hello world'的函数，命名导出是一个名为name的变量，其值为字符串
'Lydia'。

data对象具有默认导出的default属性，其他属性具有指定exports的名称及其对应的值

[参与互动](https://github.com/yisainan/web-interview/issues/1040)

</details>

<b><details><summary>30.(单选题）我们怎样才能在indexjs中调用sum.js中的sum ?</summary></b>

```js
// sum.js
export default function sum(x) {
    return x + x;
}

// index.js
import * as sum from './sum';
```

```
A：sum(4)
B: sum.sum(4)
C: sum.default(4)
D: 默认导出不用*来导入，只能具名导出 
```

参考答案：C

解析：

使用符号*，我们引入文件中的所有值，包括默认和具分章 
名。如果我们有以下文件：

```js
// info.js
export const name = 'Lydia';
export const age = 21;
export default 'I love JavaScript';

// index.js
import * as info from './info';
console.log(info);
```

将会输出以下内容：

```js
{
    default: 'I love JavaScript',
    name: 'Lydia',
    age: 21
}
```

以sum为例，相当于以下形式引入值sum :

```js
{
    default: function sum(x) {
        return x + x
    }
}
```

我们可以通过调用sum.default来调用该函数

[参与互动](https://github.com/yisainan/web-interview/issues/1041)

</details>

<b><details><summary>31.(单选题)下面代码的输出是什么 </summary></b>

```js
function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}
const member = new Person("Lydia', 'Hallie");
Person.getFullName = () => this.firstName + this.lastName；
console.log(member.getFullName());
```

```
A: TypeError
B: SyntaxError
C: Lydia Hallie
D: undefined undefined
```

参考答案: A

解析：

您不能像使用常规对象那样向构造函数添加属性。如果要 
一次向所有对象添加功能，则必须使用原型。所以在这种 
情况下应该这样写：

```js
Person.prototype.getFullName = function() {
    return '${this.firstName} ${this.lastName}';
}
```

这样会使member.getFullName()是可用的，为什么样 
做是对的？假设我们将此方法添加到构造函数本身。也 
许不是每个Person实例都需要这种方法。这会浪费大量 
内存空间，因为它们仍然具有该属性，这占用了每个实 
的内存空间。相反，如果我们只将它添加到原型中, 我们只需将它放在内存中的一个位置，但它们都可以访问它！

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>32.(单选题)下面代码的输出是什么 </summary></b>

```js
const person = {
    name: 'Lydia',
    age: 21
}
let city = person.city
city = 'Amsterdam'
console.log(person)
```

```

A: { name: "Lydia",age: 21}
B: { name: "Lydia",age: 21,city: "Amsterdam"}
C: { name: "Lydia",age: 21,city: undefined}
D: "Amsterdam"
```

参考答案：A

解析：

我们将变量city设置为等于person对象上名为city的属性的值。 这个对象上没有名为city的属性， 因此变量city 的值为 undefined。
请注意， 我们没有引用person对象本身， 只是将变量city设置为等于person对象上city属性的当前值。然后，我们将city设置为等于字符串“Amsterdam”。
这不会更改person对象： 没有对该对象的引用。
因此打印person对象时， 会返回未修改的对象。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>33.(单选题)下面代码的输出是什么 </summary></b>

```js
(() => {
    let x, y;
    try {
        throw new Error。；
    } catch (x) {
        (x = 1), (y = 2);
        console.log(x);
    )
    console.log(x);
    console.log(y);
))()；
```

```
A: 1 undefined 2
B: undefined undefined undefined
C: 1 1 2
D: 1 undefined undefined
```

参考答案：A

解析：

catch块接收参数x。当我们传递参数时，这与变量的x不同。这个变量x是属于catch作用域的。
之后，我们将这个块级作用域的变量设置为1, 并设置变量y的值。现在，我们打印块级作用域的变量x , 它等于1。
在catch块之外，x仍然是undefined，而y是2。
我们想在catch块之外的console.log(x)时，它返回undefined , 而 y 返回 2。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>34.(单选题)下面代码的输出是什么 </summary></b>

```js
let num = 1;
const list = ['A', 'B', 'C', 'D'];
console.log(list[(num += 1)]);
```

```
A: B
B: C
C: SyntaxError
D: ReferenceError
```

参考答案：B

解析：

通过 += 操作符， 我们对值num进行加1操作。 num有初始值1, 因此1 + 1 的执行结果为2。 数组list的第二项为'C'， console.log(list[2]) 输出'C'

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>35.(单选题)下面代码的输出是什么 </summary></b>

```js
class Chameleon {
    static colorChange(newColor) {
        this.newColor = newColor;
    }
    constructor({
        newColor = 'green'
    } = {}) {
        this.newColor = newColor;
    }
}
const freddie = new Chameleon({
    newColor: 'purple'
})
freddie.colorChange('orange');
```

```
A: orange
B: purple
C: green
D: TypeError
```

参考答案：D

解析：
colorChange方法是静态的。静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。由于freddie是一个子级对象，函数不会传递，所以在freddie实例上不存在freddie方法：抛出TypeError。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>36.(单选题)下面代码的输出是什么 </summary></b>

```js
const user = {
    name: 'Lydia',
    age: 21
};
const admin = {
    admin: true,
    ...user
};
console.log(admin);
```

```
A: {
    admin: true,
    user: {
        name: "Lydia",
        age: 21
    }
}

B: {
    admin: true,
    name: "Lydia",
    age: 21
}

C: {
    admin: true,
    user: ["Lydia", 21]
}

D: {admin: true}
```

参考答案：B

解析：

扩展运算符... 为对象的组合提供了可能。 你可以复制对象中的键值对， 然后把它们加到另一个对象里去。 在本例中， 我们复制了user对象键值对，然后把它们加入到admin对象中。 admin对象就拥有了这些键值对, 
所以结果为 

```js
{
    admin: true,
    name: 'Lydia',
    age: 21
}
```

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>37.(单选题)下面代码的输出是什么 </summary></b>

```js
let newList = [1, 2, 3].push(4)
console.log(newList.push(5))
```

```
A: [1, 2, 3, 4, 5]
B: [1, 2, 3, 5]
C: [1, 2, 3, 4]
D: Error
```

参考答案：D

解析：

.push方法返回数组的长度，而不是数组本身！ 通过将newList 设置为[1, 2, 3].push(4), 实际上 newList 等于数组的新长度： 4。
然后， 尝试在newList上使用.push方法。 由于newList是数值4, 抛出Error。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>38.(单选题)下面代码的输出是什么 </summary></b>

```js
function compareMembers(person1, person2 = person) {
    if (person1 !== person2) {
        console.log('Not the same!')
    } else {
        console.log('They are the same!')
    }
}
const person = {
    name: 'Lydia'
}
compareMembers(person)
```

```
A: Not the same!
B: They are the same!
C: ReferenceError
D: SyntaxError
```

参考答案：B

解析：

对象通过引用传递。当我们检查对象的严格相等性（===）时，我们正在比较它们的引用。
我们将"person2"的默认值设置为“person”对象, 并将“person"对象作为"person1”的值传递。
这意味着两个值都引用内存中的同一位置，因此它们是相等的。
运行else语句中的代码块，并记录They are the same!

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>39.(单选题)下面代码的输出是什么 </summary></b>

```js
const box = {
    x: 10,
    y: 20
};
Object.freeze(box);
const shape = box;
shape.x = 100;
console.log(shape);
```

```
A: {x: 100, y:20}
B: {x: 10, y:20}
C: {x: 100}
D: ReferenceError
```

参考答案：B

解析：
Object.freeze使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。
当我们创建变量shape并将其设置为等于冻结对象box时 
shape指向的也是冻结对象。你可以使用Object.isFrozen检查一个对象是否被冻结, 上述情况, Object.isFrozen （ shape ）将返回 true。
由于shape被冻结，并且x的值不是对象，所以我们不能修改属性X。x仍然等于10 , {x ： 10 , y ： 20}被打印。
注意，上述例子我们对属性x进行修改, 可能会导致抛出TypeError异常（最常见但不仅限于严格模式下时）。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>40.(单选题)下面代码的输出是什么 </summary></b>

```js
const spookyltems = ['A', 'B', 'C'];
({
    item: spookyItems[3]
} = {
    item: 'D'
});
console.log(spookyltems);
```

```
A: ['A', 'B', 'C']
B: ['A', 'B', 'C', 'D']
C: ['A', 'B', 'C', {item: 'D'}]
D: ['A', 'B', 'C', "[object Object]"]
```

参考答案：B

解析：

通过解构对象们，我们可以从右手边的对象中拆出值，并且将拆出的值分配给左手边对象同名的属性。在这种情况下，我们将值'D'分配给spookyltems[3], 相当于我们正在篡改数组spookyltems , 我们给它添加了值'D'。当输出spookyltems时，结果为磅['A', 'B', 'C', 'D']

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>41.(单选题)下面代码的输出是什么 </summary></b>

```js
Promise.resolve(5)
```

```
A: 5
B: Promise {<pending>: 5}
C: Promise {<resolved>: 5}
D: Error
```

参考答案: C

解析：

我们可以将我们想要的任何类型的值传递Promise.resolve , 无论是否promise。该方法本身返回带有已解析值的Promise。如果您传递常规函数, 它将是具有常规值的已解决promise。如果你通过了promise , 它将是一个已经resolved的且带有传的值的promise。
上述情况，我们传了数字5 , 因此返回一个resolved状态的promise , resolve值为 5

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>42.(单选题)下面代码的输出是什么 </summary></b>

```js
class Counter {
    #number = 10
    increment() {
        this.#number++
    )
    getNum() {
        return this.#number
    )
}
const counter = new Counter()
counter.increment()
console.log(counter.#number)
```

```
A: 10
B: 11
C: undefined
D: SyntaxError
```

参考答案: D

解析：

在ES2020中，通过#我们可以给class添加私有变量。
在class的外部我们无法获取该值。当我们尝试输出counter.#number , 语法错误被抛出：我们无法在class Counter外部获取它！

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>43.(单选题)哪个选项不正确？ </summary></b>

```js
const bird = {
    size: 'small'
}；
const mouse = {
    name: 'Mickey',
    small: true
}；
```

```
A: mouse.bird.size
B: mouse[bird.size]
C: mouse[bird["sizen"]]
D: All of them are valid
```

参考答案: A

解析：

在JavaScript中，所有对象键都是字符串（ 除了 Symbol）。尽管有时我们可能不会给定字符串类型， 但它们总是被转换为字符串。 JavaScript解释语句。 当我们使用方括号表示法时， 它会看到第一个左括号［, 然后继续， 直到找到右括号］。 只有在那个时候， 它才会对这个语句求值。 

mouse[bird, size]: 首先它会对 bird.size 求值， 得到small。 mouse["small”]返回 true。

但是，使用点表示法，这不会发生。 mouse没有名为bird的键， 这意味着mouse.bird是undefined。 然后，我们使用点符号来询问size： mouse.bird.size 。由于mouse.bird是undefined, 我们实际上是在询问undefined.size。 这是无效的，并将抛出Cannot read Property 'size' of undefined

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>44.(单选题)下面代码的输出是什么 </summary></b>

```js
const one = (false || {} || null)
const two = (null || false || '')
const three = ([] || 0 || true)
console.log(one, two, three)
```

```
A: false null []
B: null "" true
C: {} "" []
D: null null true
```

参考答案: C

解析：

使用||运算符，我们可以返回第一个真值。如果所有值都是假值，则返回最后一个值。
（false || {} || null）: 空对象{}是一个真值。 
这是第一个（也是唯一的）真值，它将被返回。one等于{}

（null || false || ""）：所有值都是假值。这意味着返回传递的值'', two等于''。

（［］|| 0 || ""）: 空教组［］是一个真值。这是第一个返回的真值。three等于[]。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>45.(单选题)下面哪个选项将会返回6 </summary></b>

```js
function sumValues(x, y, z) {
    return x + y + z;
)
```

```
A: sumValues([...1, 2, 3])
B: sumValues([...[1, 2, 3]])
C: sumValues(...[1, 2, 3])
D: sumValues([1, 2, 3])
```

参考答案: 

解析：

通过展开操作符...， 我们可以暂开单个可迭代的元素。 函数sumValues function接收三个参数: x, y和z，[1, 2, 3] 的执行结果为1, 2, 3， 将会传递给函数：sumValues

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>46.(单选题)下面代码的输出是什么 </summary></b>

```js
class Dog {
    constructor(name) {
        this.name = name;
    )
}
Dog.prototype.bark = function() {
    console.log(`Woof I am ${this.name}`);
)；
const pet = new Dog("Mara");
pet.bark();
delete Dog.prototype.bark;

pet.bark();
```

```
A: "Woof I am Mara", TypeError
B: "Woof I am Mara","Woof I am Mara"
C: "Woof I am Mara", undefined
D: TypeError, TypeError
```

参考答案: A

解析：

我们可以用delete关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。在本例中，函数bark在执行了 delete Dog.prototype.bark后不可用，然而后面的代码还在调用它。
当我们尝试调用一个不存在的函数时TypeError 
异常被抛出。在本例中就是TypeError: pet.bark is not a function，因为 pet.bark 是 undefined

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>47.(单选题)下面代码的输出是什么 </summary></b>

```js
let num = 1;
const list = ["a", "b", "c", "d"];
console.log(list[(num += 1)]);
```

```
A: "b"
B: "c"
C: SyntaxError
D: ReferenceError
```

参考答案: B

解析：

通过 += 操作符， 我们对值num进行加1操作。 num有初始值1, 因此1 + 1 的执行结果为2。 数组list的第二项为"c"

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>48.(单选题)下面哪一项会对对象person有副作用 </summary></b>

```js
const person = {
    name: 'Lydia Hallie'
};
Object.seal（ person）;
```

```
A: person.name = "Evan Bacon"
B: person.age = 21
C: delete person.name
D: Object.assign(person,{ age: 21})
```

参考答案: A

解析：

使用Object.seal我们可以防止新属性被添加， 或者存在属性被移除。然而，你仍然可以对存在属性进行更改。

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>49.(单选题)下面代码的输出是什么 </summary></b>

```js
const set = new Set([1, 1, 2, 3, 4]);
console.log(set);
```

```
A: [1, 1, 2, 3, 4]
B: [1, 2, 3, 4]
C: {1, 1, 2, 3, 4}
D: {1, 2, 3, 4}
```

参考答案: D

解析：

Set对象是独一无二的值的集合： 也就是说同一个值在其中仅出现一次。
我们传入了数组[1, 1, 2, 3, 4], 他 有 一 个 重 复 值 为1
因为一个集合里不能有两个重复的值， 其中一个就被移除了。 所以结果是｛ 1, 2, 3, 4 }.

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>

<b><details><summary>50.(单选题)下面代码的输出是什么 </summary></b>

```js
const name = "Lydia Hallie";
console.log(!typeof name === 'object');
console.log(!typeof name === 'string');
```

```
A: false true
B: true false
C: false false
D: true true
```

参考答案: C

解析：

typeof name 返回 'string'。字符串 'string'
是一个truthy的值， 因此!typeof name返回一个布尔值false 。false === 'object'和false === 'string'
都返回false。（ 如果我们想检测一个值的类型， 这里我们应该用 !== 而不是!typeof）

[参与互动](https://github.com/yisainan/web-interview/issues/1021)

</details>
---
name: 兼容性问题模板
about: 这是一个用于发布兼容性问题的模板
title: "[兼容性] "
labels: 兼容性
assignees: ''

---


# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. JavaScript 以下哪条语句会产生运行错误 </summary></b>

A. var obj = (); B. var obj = []; C. var obj = {}; D. var obj = //; 

参考答案：AD

[参与互动](https://github.com/yisainan/web-interview/issues/543)

</details>

<b><details><summary>2. 以下哪些是 javascript 的全局函数</summary></b>

```
A. escape	函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。ECMAScript v3 反对使用该方法，应用使用 decodeURI() 和 decodeURIComponent() 替代它。
B. parseFloat	parseFloat() 函数可解析一个字符串，并返回一个浮点数。
该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。
C. eval	 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
D. setTimeout
E. alert
```

参考答案：ABC

[参与互动](https://github.com/yisainan/web-interview/issues/544)

</details>

<b><details><summary>3. 关于 IE 的 window 对象表述正确的有</summary></b>

```
A. window.opener属性本身就是指向window对象
B. window.reload()方法可以用来刷新当前页面  应该是location.reload或者window.location.reload
C. window.location="a.html"和window.location.href="a.html"的作用都是把当前页面替换成a.html页面
D. 定义了全局变量g;可以用window.g的方式来存取该变量
```

参考答案：ACD

[参与互动](https://github.com/yisainan/web-interview/issues/545)

</details>

<b><details><summary>4. 描述错误的是</summary></b>

```
A：HTTP状态码302表示暂时性转移
B:domContentLoaded事件早于onload事件
C: IE678不支持事件捕获
D:localStorage 存储的数据在电脑重启后丢失
```

参考答案：D

解析：

HTTP 状态码 302 表示被请求的资源暂时转移(Moved temporatily)，然后会给出一个转移后的 URL，而浏览器在处理服务器返回的 302 错误时，原则上会重新建立一个 TCP 连接，然后再取重定向后的 URL 的页面; 但是如果页面存在于缓存中，则不重新获取; 

onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片，flash 都已经加载完成了，domContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash。

C 正确，故选 D

[参与互动](https://github.com/yisainan/web-interview/issues/546)

</details>

<b><details><summary>5. 关于 link 和@import 的区别正确的是</summary></b>

```
A: link属于XHTML标签，而@import是CSS提供的;
B：页面被加载时，link会同时被加载，而后者引用的CSS会等到页面被加载完再加载
C：import只在IE5以上才能识别 而link是XHTML标签，无兼容问题
D: link方式的样式的权重高于@import的权重
```

参考答案：ABCD

[参与互动](https://github.com/yisainan/web-interview/issues/547)

</details>

<b><details><summary>6. 下面正确的是</summary></b>

```
A: 跨域问题能通过JsonP方案解决
B：不同子域名间仅能通过修改window.name解决跨域   还可以通过script标签src  jsonp等h5 Java split等
C：只有在IE中可通过iframe嵌套跨域
D：MediaQuery属性是进行视频格式检测的属性是做响应式的
```

参考答案：A

[参与互动](https://github.com/yisainan/web-interview/issues/548)

</details>

<b><details><summary>7. 一个.php 后缀的文件，可以在什么环境下执行</summary></b>

```
A mysql 数据库
B 浏览器
C apache 服务器
D Windows 系统
```

参考答案: C

解析:php 运行环境 apache

[参与互动](https://github.com/yisainan/web-interview/issues/603)

</details>

<b><details><summary>8.http 协议的默认端口号是</summary></b>

```
A 80
B 8888
C 8080
D 3306
```

参考答案: A

解析: 服务器安装好之后，默认端口号是 80

[参与互动](https://github.com/yisainan/web-interview/issues/604)

</details>

<b><details><summary>9.ajax 跨域的前端解决方案是哪个</summary></b>

```
A cors
B jsonp
C 服务器代理
D promise
```

参考答案: B

解析:jsonp 是使用标签的 src 属性链接资源接口，在 url 中传递回调函数，实现跨域请求

[参与互动](https://github.com/yisainan/web-interview/issues/605)

</details>

<b><details><summary>10.foo 对象有 att 属性，那么获取 att 属性的值，以下哪些做法是可以的</summary></b>

```
A foo("att")
B foo["att"]
C foo{"att"}
D foo[att]
```

参考答案: B

[参与互动](https://github.com/yisainan/web-interview/issues/606)

</details>

<b><details><summary>11. 下面说法正确的是</summary></b>

```
A setTimeout 函数是同步的
B setInterval 函数是异步的
C setTimeout(function( ) { } ,100) 会立即同步执行
D setInterval 函数会立即执行
```

参考答案: B

[参与互动](https://github.com/yisainan/web-interview/issues/607)

</details>

<b><details><summary>12. 下面哪个方法不属于数组操作方法?</summary></b>

```
A shift()
B pop()
C push()
D replace()
```

参考答案: D

[参与互动](https://github.com/yisainan/web-interview/issues/608)

</details>

<b><details><summary>13. 下面表示鼠标单击事件的是</summary></b>

```
A onclick
B onmouseover
C onmouseout
D onmousemove
```

参考答案: A

[参与互动](https://github.com/yisainan/web-interview/issues/609)

</details>

<b><details><summary>14. 以下代码, 当调用函数 func1 时，代码中打两个问号的地方，会弹出什么</summary></b>

```js
var v1 = 250;

function func1() {
    alert(v1); //？？
    var v1 = 350;
}
```

```
A 250
B 350
C undefined
D 以上都不对
```

参考答案: C

解析: 函数内部的 var v1 声明会提升到当前作用域顶部，但是赋值不会提升，所以 alert 的时候首先弹出当前作用域的 v1，值位 undefined

[参与互动](https://github.com/yisainan/web-interview/issues/610)

</details>

<b><details><summary>15. 下面哪个不是 js 的数据类型？</summary></b>

```
A int
B number
C string
D boolean
```

参考答案: A

[参与互动](https://github.com/yisainan/web-interview/issues/611)

</details>

<b><details><summary>16. 在 Javascript 中，需要声明一个整数类型的变量 num，以下哪个语句能实现上述要求？</summary></b>

```
A int num
B number num
C var num
D Integer num
```

参考答案: C

解析: var 关键字声明变量

[参与互动](https://github.com/yisainan/web-interview/issues/612)

</details>

<b><details><summary>17. 关于 Javascript 中数组的说法中，不正确的是：</summary></b>

```
A 数组的长度必须在创建时给定，之后便不能改变
B 由于数组是对象，因此创建数组时可以使用 new 运算符 当然也可以不用的
C 数组内元素的类型可以不同
D 数组可以在声明的同时进行初始化
```

参考答案: A

解析: js 数组长度是可以变化的

[参与互动](https://github.com/yisainan/web-interview/issues/613)

</details>

<b><details><summary>18. 以下关于 Javascript 中事件的描述中，不正确的是：</summary></b>

```
A onclick–鼠标单击事件
B onfocus–获取焦点事件
C onmouseover–鼠标指针移动到事件源对象上时触发的事件
D onsubmit–选择字段时触发的事件
```

参考答案: D

解析: change 需要选择的字段发生变化时才触发的事件

[参与互动](https://github.com/yisainan/web-interview/issues/614)

</details>

<b><details><summary>19. 表示表单提交事件的是：</summary></b>

```
A onmousemove
B onchange
C onclick
D onsubmit
```

参考答案: D

[参与互动](https://github.com/yisainan/web-interview/issues/615)

</details>

<b><details><summary>20.array 为数组对象，下面不是数组方法的为</summary></b>

```
A array.zero()
B array.map()
C array.filter()
D array.push()
```

参考答案: A

[参与互动](https://github.com/yisainan/web-interview/issues/616)

</details>

<b><details><summary>21. 使用 offsetWidth 获取 `<div style="border：1px solid red; width:200px"; >` 正确的数值为</summary></b>

```
A 199
B 197
C 198
D 202
```

参考答案: D

解析: offsetWidth 获取的时候包括了边框 并且不带 px 单位

[参与互动](https://github.com/yisainan/web-interview/issues/617)

</details>

<b><details><summary>22. 以下方法 1s 以后弹出 n 的值为( )</summary></b>

```js
var n = 10;
setInterval(function() {
    alert(n);
    var n = 100;
}, 1000);
```

```
A 10
B 100
C undefined
D 报错
```

参考答案: C

解析:
计时函数中，定义的变量 n 有声明提升，被提升到函数作用域顶部，即在 alert()之前，只提升声明，变量赋值位置不变，所以为 undefined

[参与互动](https://github.com/yisainan/web-interview/issues/618)

</details>

<b><details><summary>23. 选出有兼容性的方法或者属性( )</summary></b>

```
A event.cancelBubble
B getElementById
C getElementsByTagName
D nodeType
```

参考答案: A

解析: event.cancelBubble 是 IE 老版本取消事件冒泡的方式

[参与互动](https://github.com/yisainan/web-interview/issues/619)

</details>

<b><details><summary>24. 关于函数参数说法正确的是：（ ）</summary></b>

```
A 函数必须有参数
B 函数体中可以使用 arguments 来获取传递的实际参数值
C 函数必须有返回值
D 函数体中可以使用 parameters 来获取传递的实际参数
```

参考答案: B

解析: 可使用 arguments 在函数体中获取函数调用时的参数列表，在函数调用时，实参个数和形参个数可以不一致。

[参与互动](https://github.com/yisainan/web-interview/issues/620)

</details>

<b><details><summary>25. 以下代码 var t = 0 || 5，t 的值是( )</summary></b>

```
A true
B false
C 5
D 0
```

参考答案: C

解析: 逻辑或的应用 0 位 false

[参与互动](https://github.com/yisainan/web-interview/issues/621)

</details>

<b><details><summary>26. 下面不是用于创建一个新的对象的语句是</summary></b>

```
A var d = new Date();
B var f = ( );
C var o = new Object();
D var o = {title: "hello", author: "Tom"};
```

参考答案: B

[参与互动](https://github.com/yisainan/web-interview/issues/622)

</details>

<b><details><summary>27. 事件委托的好处是( )</summary></b>

```
A 减少了事件绑定的数量;对后来动态创建的元素依然有效
B 和普通事件的执行没什么区别
C 降低了程序执行效率
D 以上都不对
```

参考答案: A

[参与互动](https://github.com/yisainan/web-interview/issues/623)

</details>

<b><details><summary>28. 以下( )表达式产生一个 0~7 之间(含 0, 7)的随机整数</summary></b>

```
A Math.floor(Math.random()*6)
B Math.floor(Math.random()*7)
C Math. floor(Math.random()\*8)
D Math.ceil(Math.random()8)
```

参考答案: C

解析:
生成 min ~ max （包含 max）的随机数公式：
Math.floor(Math.random()(max - min+1) + min)

[参与互动](https://github.com/yisainan/web-interview/issues/624)

</details>

<b><details><summary>29. 要实现拖拽效果，需要用到以下哪些事件除了</summary></b>

```
A onmousedown
B onmouseup
C onmouseover
D onmousemove
```

参考答案: C

解析:
鼠标按下（onmousedown），鼠标移动（onmousemove），鼠标抬起（onmouseup）

[参与互动](https://github.com/yisainan/web-interview/issues/625)

</details>

<b><details><summary>30. 要检测值是否为 NaN，应使用 （ ）函数</summary></b>

```
A Number( )
B parseInt ( )
C IsNaN( )
D isNaN( )
```

参考答案: D

[参与互动](https://github.com/yisainan/web-interview/issues/626)

</details>

<b><details><summary>31. 下面哪个方法可以匹配数组是否含有某个值？</summary></b>

```
A sort()
B push()
C join()
D indexOf()
```

参考答案: D

[参与互动](https://github.com/yisainan/web-interview/issues/627)

</details>

<b><details><summary>32. 在 JavaScript 中, 执行下面的代码后，num 的值是 ( )</summary></b>

```js
var num = 0;
var t = num++ + num++;
```

```
A -1
B 0
C 2
D 13
```

参考答案: C

解析:
这个代码跟变量 t 没有关系，表达式中完成了两次 num 的自增，所以，结果是 2

[参与互动](https://github.com/yisainan/web-interview/issues/628)

</details>

<b><details><summary>33. 在 HTML 页面中，CSS 样式的属性名为 background-image 对应的 style 对象的属性名是( )</summary></b>

```
A background-image
B backgroundImage
C image
D background
```

参考答案: B

解析: 省略中间的-，后面的单词，首字母大写

[参与互动](https://github.com/yisainan/web-interview/issues/629)

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

<b><details><summary>1. Vue 实例的 data 属性，可以在哪些生命周期中获取到？</summary></b>

```

A. beforeCreate
B. created
C. beforeMount
D. mounted
```

正确参考答案》BCD

</details>

<b><details><summary>2. 下列对 Vue 原理的叙述，哪些是正确的？</summary></b>

```

A. Vue 中的数组变更通知，通过拦截数组操作方法而实现
B. 编译器目标是创建渲染函数，渲染函数执行后将得到 VNode 树
C. 组件内 data 发生变化时会通知其对应 watcher，执行异步更新
D. patching 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新
```

正确参考答案》 ABCD

</details>

<b><details><summary>3. 对于 Vue 中响应式数据原理的说法，下列哪项是不正确的？ </summary></b>

```

A. 采用数据劫持方式，即 Object. defineProperty() 劫持 data 中各属性，实现响应式数据
B. 视图中的变化会通过 watcher 更新 data 中的数据
C. 若 data 中某属性多次发生变化，watcher 仅会进入更新队列一次
D. 通过编译过程进行依赖收集
```

正确参考答案》BD

</details>

<b><details><summary>4. 下列说法不正确的是哪项？ </summary></b>

```

A. key 的作用主要是为了高效地更新虚拟 DOM
B. 若指定了组件的 template 选项，render 函数不会执行
C. 使用 vm. n e x t T i c k 可 以 确 保 获 得 D O M 异 步 更 新 的 结 果 D . 若 没 有 e l 选 项 ， v m . nextTick 可以确保获得 DOM 异步更新的结果 D. 若没有 el 选项，vm. nextTick可以确保获得DOM异步更新的结果D. 若没有el选项，vm. mount(dom) 可将 Vue 实例挂载于指定元素上
```

正确参考答案》B

</details>

<b><details><summary>5. 下列关于 Vuex 的描述，不正确的是哪项？ </summary></b>

```

A. Vuex 通过 Vue 实现响应式状态，因此只能用于 Vue
B. Vuex 是一个状态管理模式
C. Vuex 主要用于多视图间状态全局共享与管理
D. 在 Vuex 中改变状态，可以通过 mutations 和 actions
```

正确参考答案》D

</details>

<b><details><summary>6. 关于 Vue 组件间的参数传递，下列哪项是不正确的？</summary></b>

```

A. 若子组件给父组件传值，可使用 $emit 方法
B. 祖孙组件之间可以使用 provide 和 inject 方式跨层级相互传值
C. 若子组件使用 $emit(‘say’) 派发事件，父组件可使用 @say 监听
D. 若父组件给子组件传值，子组件可通过 props 接受数据
```

正确参考答案》B

</details>

<b><details><summary>7. 下列关于 vue-router 的描述，不正确的是哪项？ </summary></b>

```

A. vue-router 的常用模式有 hash 和 history 两种
B. 可通过 addRoutes 方法动态添加路由
C. 可通过 beforeEnter 对单个组件进行路由守卫
D. vue-router 借助 Vue 实现响应式的路由，因此只能用于 Vue
```

正确参考答案》 C

</details>

<b><details><summary>8. 下列说法不正确的是哪项？ </summary></b>

```

A. 可通过 this. p a r e n t 查 找 当 前 组 件 的 父 组 件 
B. 可 使 用 t h i s . parent 查找当前组件的父组件 B. 可使用 this. parent查找当前组件的父组件B. 可使用this. refs 查找命名子组件
C. 可使用 this. $children 按顺序查找当前组件的直接子组件
D. 可使用 $root 查找根组件，并可配合 children 遍历全部组件
```

正确参考答案》C

</details>

<b><details><summary>9. 下列关于 v-model 的说法，哪项是不正确的？</summary></b>

```

A. v-model 能实现双向绑定
B. v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据
C. v-model 是内置指令，不能用在自定义组件上
D. 对 input 使用 v-model，实际上是指定其 :value 和 :input
```

正确参考答案》C

</details>

<b><details><summary>10. 关于 Vue 的生命周期，下列哪项是不正确的？</summary></b>

```

A. DOM 渲染在 mounted 中就已经完成了
B. Vue 实例从创建到销毁的过程，就是生命周期
C. created 表示完成数据观测、属性和方法的运算和初始化事件，此时 $el 属性还未显示出来
D. 页面首次加载过程中，会依次触发 beforeCreate，created，beforeMount，mounted，beforeUpdate，updated
```

正确参考答案》D

</details>
# [返回主页](https://github.com/yisainan/web-interview/blob/master/README.md)

> [转载自 微信公众号：code秘密花园](https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&mid=2247490099&idx=1&sn=f438f76aa63b65a6e776f26e55b224db&source=41#wechat_redirect)
> [英文仓库地址：](https://github.com/lydiahallie/javascript-questions)
> [中文仓库地址：](https://github.com/ConardLi/javascript-questions/blob/master/zh-CN/README-zh_CN.md)


# JavaScript 进阶问题列表

我在我的 [Instagram](https://www.instagram.com/theavocoder) 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。

从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！
:muscle: :rocket: 我每周都会在这个仓库下更新新的问题。

答案在问题下方的折叠部分，点击即可展开问题。祝你好运 :heart:

---

###### 1. 输出是什么？

```javascript
function sayHi() {
  console.log(name)
  console.log(age)
  var name = 'Lydia'
  let age = 21
}

sayHi()
```

- A: `Lydia` 和 `undefined`
- B: `Lydia` 和 `ReferenceError`
- C: `ReferenceError` 和 `21`
- D: `undefined` 和 `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

在函数内部，我们首先通过 `var` 关键字声明了 `name` 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 `undefined`。因为当我们打印 `name` 变量时还没有执行到定义变量的位置，因此变量的值保持为 `undefined`。

通过 `let` 和 `const` 关键字声明的变量也会提升，但是和 `var` 不同，它们不会被<i>初始化</i>。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 `ReferenceError` 错误。

</p>
</details>

---

###### 2. 输出是什么？

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1)
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1)
}
```

- A: `0 1 2` 和 `0 1 2`
- B: `0 1 2` 和 `3 3 3`
- C: `3 3 3` 和 `0 1 2`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

由于 JavaScript 的事件循环，`setTimeout` 回调会在*遍历结束后*才执行。因为在第一个遍历中遍历 `i` 是通过 `var` 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 `++` 来每次递增 `i` 的值。当 `setTimeout` 回调执行的时候，`i` 的值等于 3。

在第二个遍历中，遍历 `i` 是通过 `let` 关键字声明的：通过 `let` 和 `const` 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，`i` 都有一个新值，并且每个值都在循环内的作用域中。

</p>
</details>

---

###### 3. 输出是什么？

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2
  },
  perimeter: () => 2 * Math.PI * this.radius
}

shape.diameter()
shape.perimeter()
```

- A: `20` and `62.83185307179586`
- B: `20` and `NaN`
- C: `20` and `63`
- D: `NaN` and `63`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

注意 `diameter` 的值是一个常规函数，但是 `perimeter` 的值是一个箭头函数。

对于箭头函数，`this` 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 `perimeter` 时，`this` 不是指向 `shape` 对象，而是它的周围作用域（在例子中是 `window`）。

在 `window` 中没有 `radius` 这个属性，因此返回 `undefined`。

</p>
</details>

---

###### 4. 输出是什么？

```javascript
+true;
!"Lydia";
```

- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

一元操作符加号尝试将 bool 转为 number。`true` 转换为 number 的话为 `1`，`false` 为 `0`。

字符串 `'Lydia'` 是一个真值，真值取反那么就返回 `false`。

</p>
</details>

---

###### 5. 哪一个是无效的？

```javascript
const bird = {
  size: 'small'
}

const mouse = {
  name: 'Mickey',
  small: true
}
```

- A: `mouse.bird.size`
- B: `mouse[bird.size]`
- C: `mouse[bird["size"]]`
- D: All of them are valid

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。

当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 `[` 并继续前进直到找到结束括号 `]`。只有这样，它才会计算语句的值。

`mouse[bird.size]`：首先计算 `bird.size`，这会得到 `small`。`mouse["small"]` 返回 `true`。

然后使用点语法的话，上面这一切都不会发生。`mouse` 没有 `bird` 这个 key，这也就意味着 `mouse.bird` 是 `undefined`。然后当我们使用点语法 `mouse.bird.size` 时，因为 `mouse.bird` 是 `undefined`，这也就变成了 `undefined.size`。这个行为是无效的，并且会抛出一个错误类似 `Cannot read property "size" of undefined`。

</p>
</details>

---


###### 6. 输出是什么？

```javascript
let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
```

- A: `Hello`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

在 JavaScript 中，当设置两个对象彼此相等时，它们会通过*引用*进行交互。

首先，变量 `c` 的值是一个对象。接下来，我们给 `d` 分配了一个和 `c` 对象相同的引用。

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

因此当我们改变其中一个对象时，其实是改变了所有的对象。

</p>
</details>

---

###### 7. 输出是什么？

```javascript
let a = 3
let b = new Number(3)
let c = 3

console.log(a == b)
console.log(a === b)
console.log(b === c)
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

`new Number()` 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。

当我们使用 `==` 操作符时，它只会检查两者是否拥有相同的*值*。因为它们的值都是 `3`，因此返回 `true`。

然后，当我们使用 `===` 操作符时，两者的值以及*类型*都应该是相同的。`new Number()` 是一个对象而不是 number，因此返回 `false`。

</p>
</details>

---

###### 8. 输出是什么？

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor
    return this.newColor
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor
  }
}

const freddie = new Chameleon({ newColor: 'purple' })
freddie.colorChange('orange')
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

`colorChange` 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 `Chameleon`），并且不能传递给实例。因为 `freddie` 是一个实例，静态方法不能被实例使用，因此抛出了 `TypeError` 错误。

</p>
</details>

---

###### 9. 输出是什么？

```javascript
let greeting
greetign = {} // Typo!
console.log(greetign)
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 `greeting` 写错成 `greetign` 时，JS 解释器实际在上浏览器中将它视为 `global.greetign = {}` （或者 `window.greetign = {}`）。

为了避免这个为题，我们可以使用 `"use strict"。这能确保当你声明变量时必须赋值。

</p>
</details>

---

###### 10. 当我们这么做时，会发生什么？

```javascript
function bark() {
  console.log('Woof!')
}

bark.animal = 'dog'
```

- A: 正常运行!
- B: `SyntaxError`. 你不能通过这种方式给函数增加属性。
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）

函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。

</p>
</details>

---

###### 11. 输出是什么？

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person("Lydia", "Hallie");
Person.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
}

console.log(member.getFullName());
```

- A: `TypeError`
- B: `SyntaxError`
- C: `Lydia Hallie`
- D: `undefined` `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：

```js
Person.prototype.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
}
```

这才会使 `member.getFullName()` 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 `Person` 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！

</p>
</details>

---

###### 12. 输出是什么？

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

const lydia = new Person('Lydia', 'Hallie')
const sarah = Person('Sarah', 'Smith')

console.log(lydia)
console.log(sarah)
```

- A: `Person {firstName: "Lydia", lastName: "Hallie"}` and `undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"}` and `Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"}` and `{}`
- D:`Person {firstName: "Lydia", lastName: "Hallie"}` and `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

对于 `sarah`，我们没有使用 `new` 关键字。当使用 `new` 时，`this` 引用我们创建的空对象。当未使用 `new` 时，`this` 引用的是**全局对象**（global object）。

我们说 `this.firstName` 等于 `"Sarah"`，并且 `this.lastName` 等于 `"Smith"`。实际上我们做的是，定义了 `global.firstName = 'Sarah'` 和 `global.lastName = 'Smith'`。而 `sarah` 本身是 `undefined`。

</p>
</details>

---

###### 13. 事件传播的三个阶段是什么？

- A: Target > Capturing > Bubbling
- B: Bubbling > Target > Capturing
- C: Target > Bubbling > Capturing
- D: Capturing > Target > Bubbling

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

在**捕获**（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到**目标**（target）元素后，**冒泡**（bubbling）才开始。

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</p>
</details>

---

###### 14. 所有对象都有原型。

- A: true
- B: false

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

除了**基本对象**（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 `.toString`。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。

</p>
</details>

---

###### 15. 输出是什么？

```javascript
function sum(a, b) {
  return a + b
}

sum(1, '2')
```

- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

JavaScript 是一种**动态类型语言**：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为**隐式类型转换**（implicit type coercion）。**Coercion** 是指将一种类型转换为另一种类型。

在本例中，JavaScript 将数字 `1` 转换为字符串，以便函数有意义并返回一个值。在数字类型（`1`）和字符串类型（`'2'`）相加时，该数字被视为字符串。我们可以连接字符串，比如 `"Hello" + "World"`，这里发生的是 `"1" + "2"`，它返回 `"12"`。

</p>
</details>

---

###### 16. 输出是什么？

```javascript
let number = 0
console.log(number++)
console.log(++number)
console.log(number)
```

- A: `1` `1` `2`
- B: `1` `2` `2`
- C: `0` `2` `2`
- D: `0` `1` `2`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

一元**后自增**运算符 `++`：

1. 返回值（返回 `0`）
2. 值自增（number 现在是 `1`）

一元**前自增**运算符 `++`：

1. 值自增（number 现在是 `2`）
2. 返回值（返回 `2`）

结果是 `0 2 2`.

</p>
</details>

---

###### 17. 输出是什么？

```javascript
function getPersonInfo(one, two, three) {
  console.log(one)
  console.log(two)
  console.log(three)
}

const person = 'Lydia'
const age = 21

getPersonInfo`${person} is ${age} years old`
```

- A: `"Lydia"` `21` `["", " is ", " years old"]`
- B: `["", " is ", " years old"]` `"Lydia"` `21`
- C: `"Lydia"` `["", " is ", " years old"]` `21`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！

</p>
</details>

---

###### 18. 输出是什么？

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!')
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.')
  } else {
    console.log(`Hmm.. You don't have an age I guess`)
  }
}

checkAge({ age: 18 })
```

- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。

题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。

这也是 `{ age: 18 } === { age: 18 }` 和 `{ age: 18 } == { age: 18 }` 都返回 `false` 的原因。

</p>
</details>

---

###### 19. 输出是什么？

```javascript
function getAge(...args) {
  console.log(typeof args)
}

getAge(21)
```

- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

扩展运算符（`...args`）会返回实参组成的数组。而数组是对象，因此 `typeof args` 返回 `"object"`。

</p>
</details>

---

###### 20. 输出是什么？

```javascript
function getAge() {
  'use strict'
  age = 21
  console.log(age)
}

getAge()
```

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

使用 `"use strict"`，你可以确保不会意外地声明全局变量。我们从来没有声明变量 `age`，因为我们使用 `"use strict"`，它将抛出一个引用错误。如果我们不使用 `"use strict"`，它就会工作，因为属性 `age` 会被添加到全局对象中了。

</p>
</details>

---

###### 21. 输出是什么？

```javascript
const sum = eval('10*10+5')
```

- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

代码以字符串形式传递进来，`eval` 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 `10 * 10 + 5`。这将返回数字 `105`。

</p>
</details>

---

###### 22. cool_secret 可访问多长时间？

```javascript
sessionStorage.setItem('cool_secret', 123)
```

- A: 永远，数据不会丢失。
- B: 当用户关掉标签页时。
- C: 当用户关掉整个浏览器，而不只是关掉标签页。
- D: 当用户关闭电脑时。

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

关闭 **tab 标签页** 后，`sessionStorage` 存储的数据才会删除。

如果使用 `localStorage`，那么数据将永远在那里，除非调用了 `localStorage.clear()`。

</p>
</details>

---

###### 23. 输出是什么？

```javascript
var num = 8
var num = 10

console.log(num)
```

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

使用 `var` 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。

你不能使用 `let` 或 `const` 来实现这一点，因为它们是块作用域的。

</p>
</details>

---

###### 24. 输出是什么？

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' }
const set = new Set([1, 2, 3, 4, 5])

obj.hasOwnProperty('1')
obj.hasOwnProperty(1)
set.has('1')
set.has(1)
```

- A: `false` `true` `false` `true`
- B: `false` `true` `true` `true`
- C: `true` `true` `false` `true`
- D: `true` `true` `true` `true`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 `obj.hasOwnProperty('1')` 也返回 `true`。

对于集合，它不是这样工作的。在我们的集合中没有 `'1'`：`set.has('1')` 返回 `false`。它有数字类型为 `1`，`set.has(1)` 返回 `true`。

</p>
</details>

---

###### 25. 输出是什么？

```javascript
const obj = { a: 'one', b: 'two', a: 'three' }
console.log(obj)
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。

</p>
</details>

---

###### 26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。

- A: true
- B: false
- C: it depends

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。

</p>
</details>

---

###### 27. 输出是什么？

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue
  console.log(i)
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

如果某个条件返回 `true`，则 `continue` 语句跳过本次迭代。

</p>
</details>

---

###### 28. 输出是什么？

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!'
}

const name = 'Lydia'

name.giveLydiaPizza()
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`String` 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象)都可以访问该方法！

</p>
</details>

---

###### 29. 输出是什么？

```javascript
const a = {}
const b = { key: 'b' }
const c = { key: 'c' }

a[b] = 123
a[c] = 456

console.log(a[b])
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

对象的键被自动转换为字符串。我们试图将一个对象 `b` 设置为对象 `a` 的键，且相应的值为 `123`。

然而，当字符串化一个对象时，它会变成 `"[object Object]"`。因此这里说的是，`a["[object Object]"] = 123`。然后，我们再一次做了同样的事情，`c` 是另外一个对象，这里也有隐式字符串化，于是，`a["[object Object]"] = 456`。

然后，我们打印 `a[b]`，也就是 `a["[object Object]"]`。之前刚设置为 `456`，因此返回的是 `456`。

</p>
</details>

---

###### 30. 输出是什么？

```javascript
const foo = () => console.log('First')
const bar = () => setTimeout(() => console.log('Second'))
const baz = () => console.log('Third')

bar()
foo()
baz()
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

我们有一个 `setTimeout` 函数，并首先调用它。然而，它是最后打印日志的。

这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 `WebAPI` 的东西。`WebAPI` 提供了 `setTimeout` 函数，也包含其他的，例如 DOM。

将 _callback_ 推送到 WebAPI 后，`setTimeout` 函数本身(但不是回调！)将从栈中弹出。

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

现在，`foo` 被调用，打印 `"First"`。

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` 从栈中弹出，`baz` 被调用. 打印 `"Third"`。

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 _queue_ 的地方。

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

这就是事件循环开始工作的地方。一个**事件循环**查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` 被调用，打印 `"Second"`，然后它被栈弹出。

</p>
</details>

---

###### 31. 当点击按钮时，event.target是什么？

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
```

- A: Outer `div`
- B: Inner `div`
- C: `button`
- D: 一个包含所有嵌套元素的数组。

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

导致事件的最深嵌套的元素是事件的 target。你可以通过 `event.stopPropagation` 来停止冒泡。

</p>
</details>

---

###### 32. 当您单击该段落时，日志输出是什么？

```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
```

- A: `p` `div`
- B: `div` `p`
- C: `p`
- D: `div`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

如果我们点击 `p`，我们会看到两个日志：`p` 和 `div`。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 `useCapture` 设置为 `true`）。它从嵌套最深的元素向外传播。

</p>
</details>

---

###### 33. 输出是什么？

```javascript
const person = { name: 'Lydia' }

function sayHi(age) {
  console.log(`${this.name} is ${age}`)
}

sayHi.call(person, 21)
sayHi.bind(person, 21)
```

- A: `undefined is 21` `Lydia is 21`
- B: `function` `function`
- C: `Lydia is 21` `Lydia is 21`
- D: `Lydia is 21` `function`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

使用这两种方法，我们都可以传递我们希望 `this` 关键字引用的对象。但是，`.call` 是**立即执行**的。

`.bind` 返回函数的**副本**，但带有绑定上下文！它不是立即执行的。

</p>
</details>

---

###### 34. 输出是什么？

```javascript
function sayHi() {
  return (() => 0)()
}

typeof sayHi()
```

- A: `"object"`
- B: `"number"`
- C: `"function"`
- D: `"undefined"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`sayHi` 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 `0`， 类型是 `number`

参考：只有7种内置类型：`null`，`undefined`，`boolean`，`number`，`string`，`object` 和 `symbol`。 ``function`` 不是一种类型，函数是对象，它的类型是``object``。

</p>
</details>

---

###### 35. 下面哪些值是 falsy?

```javascript
0
new Number(0)
('')
(' ')
new Boolean(false)
undefined
```

- A: `0`, `''`, `undefined`
- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`
- C: `0`, `''`, `new Boolean(false)`, `undefined`
- D: All of them are falsy

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

只有 6 种 [falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy) 值:



- `undefined`
- `null`
- `NaN`
- `0`
- `''` (empty string)
- `false`

`Function` 构造函数, 比如 `new Number` 和 `new Boolean`，是 [truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)。

</p>
</details>

---

###### 36. 输出是什么？

```javascript
console.log(typeof typeof 1)
```

- A: `"number"`
- B: `"string"`
- C: `"object"`
- D: `"undefined"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`typeof 1` 返回 `"number"`。
`typeof "number"` 返回 `"string"`。

</p>
</details>

---

###### 37. 输出是什么？

```javascript
const numbers = [1, 2, 3]
numbers[10] = 11
console.log(numbers)
```

- A: `[1, 2, 3, 7 x null, 11]`
- B: `[1, 2, 3, 11]`
- C: `[1, 2, 3, 7 x empty, 11]`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 "empty slots" 的东西。它们的值实际上是 `undefined`。你会看到以下场景：

`[1, 2, 3, 7 x empty, 11]`

这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同）

</p>
</details>

---

###### 38. 输出是什么？

```javascript
(() => {
  let x, y
  try {
    throw new Error()
  } catch (x) {
    (x = 1), (y = 2)
    console.log(x)
  }
  console.log(x)
  console.log(y)
})()
```

- A: `1` `undefined` `2`
- B: `undefined` `undefined` `undefined`
- C: `1` `1` `2`
- D: `1` `undefined` `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`catch` 代码块接收参数 `x`。当我们传递参数时，这与之前定义的变量 `x` 不同 。这个 `x` 是属于 `catch` 块级作用域的。

然后，我们将块级作用域中的变量赋值为 `1`，同时也设置了变量 `y` 的值。现在，我们打印块级作用域中的变量 `x`，值为 `1`。

`catch` 块之外的变量 `x` 的值仍为 `undefined`， `y` 的值为 `2`。当我们在 `catch` 块之外执行 `console.log(x)` 时，返回 `undefined`，`y` 返回 `2`。

</p>
</details>

---

###### 39. JavaScript 中的一切都是？

- A: 基本类型与对象
- B: 函数与对象
- C: 只有对象
- D: 数字与对象
-
<details><summary><b>答案</b></summary>
<p>

#### 答案: A

JavaScript 只有基本类型和对象。

基本类型包括 `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, `symbol`。

</p>
</details>

---

###### 40. 输出是什么？

```javascript
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur)
  },
  [1, 2]
)
```

- A: `[0, 1, 2, 3, 1, 2]`
- B: `[6, 1, 2]`
- C: `[1, 2, 0, 1, 2, 3]`
- D: `[1, 2, 6]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

`[1, 2]`是初始值。初始值将会作为首次调用时第一个参数 `acc` 的值。在第一次执行时， `acc` 的值是 `[1, 2]`， `cur` 的值是 `[0, 1]`。合并它们，结果为 `[1, 2, 0, 1]`。
第二次执行， `acc` 的值是 `[1, 2, 0, 1]`， `cur` 的值是 `[2, 3]`。合并它们，最终结果为 `[1, 2, 0, 1, 2, 3]`

</p>
</details>

---

###### 41. 输出是什么？

```javascript
!!null
!!''
!!1
```

- A: `false` `true` `false`
- B: `false` `false` `true`
- C: `false` `true` `true`
- D: `true` `true` `false`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`null` 是 [falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)。 `!null` 的值是 `true`。 `!true` 的值是 `false`。

`""` 是 [falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)。 `!""` 的值是 `true`。  `!true` 的值是 `false`。

`1` 是 [truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)。 `!1` 的值是 `false`。 `!false` 的值是 `true`。

</p>
</details>

---

###### 42. `setInterval` 方法的返回值是什么？

```javascript
setInterval(() => console.log('Hi'), 1000)
```

- A: 一个唯一的id
- B: 该方法指定的毫秒数
- C: 传递的函数
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`setInterval` 返回一个唯一的 id。此 id 可被用于 `clearInterval` 函数来取消定时。

</p>
</details>

---

###### 43. 输出是什么？

```javascript
[...'Lydia']
```

- A: `["L", "y", "d", "i", "a"]`
- B: `["Lydia"]`
- C: `[[], "Lydia"]`
- D: `[["L", "y", "d", "i", "a"]]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

string 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。

</p>
</details>

---

###### 44. 输出是什么?

```javascript
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
```

- A: `[0, 10], [10, 20]`
- B: `20, 20`
- C: `10, 20`
- D: `0, 10 and 10, 20`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

一般的函数在执行之后是不能中途停下的。但是，生成器函数却可以中途“停下”，之后可以再从停下的地方继续。当生成器遇到`yield`关键字的时候，会生成`yield`后面的值。注意，生成器在这种情况下不 _返回_ (_return_ )值，而是 _生成_ (_yield_)值。

首先，我们用`10`作为参数`i`来初始化生成器函数。然后使用`next()`方法一步步执行生成器。第一次执行生成器的时候，`i`的值为`10`，遇到第一个`yield`关键字，它要生成`i`的值。此时，生成器“暂停”，生成了`10`。

然后，我们再执行`next()`方法。生成器会从刚才暂停的地方继续，这个时候`i`还是`10`。于是我们走到了第二个`yield`关键字处，这时候需要生成的值是`i*2`，`i`为`10`，那么此时生成的值便是`20`。所以这道题的最终结果是`10,20`。


</p>
</details>

###### 45. 返回值是什么?

```javascript
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, "one");
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, "two");
});

Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
```

- A: `"one"`
- B: `"two"`
- C: `"two" "one"`
- D: `"one" "two"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

当我们向`Promise.race`方法中传入多个`Promise`时，会进行 _优先_ 解析。在这个例子中，我们用`setTimeout`给`firstPromise`和`secondPromise`分别设定了500ms和100ms的定时器。这意味着`secondPromise`会首先解析出字符串`two`。那么此时`res`参数即为`two`，是为输出结果。

</p>
</details>


---

###### 46. 输出是什么?

```javascript
let person = { name: "Lydia" };
const members = [person];
person = null;

console.log(members);
```

- A: `null`
- B: `[null]`
- C: `[{}]`
- D: `[{ name: "Lydia" }]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D


首先我们声明了一个拥有`name`属性的对象 `person`。

<img src="https://i.imgur.com/TML1MbS.png" width="200">

然后我们又声明了一个变量`members`. 将首个元素赋值为变量`person`。 当设置两个对象彼此相等时，它们会通过 _引用_ 进行交互。但是当你将引用从一个变量分配至另一个变量时，其实只是执行了一个 _复制_ 操作。（注意一点，他们的引用 _并不相同_!）

<img src="https://i.imgur.com/FSG5K3F.png" width="300">

接下来我们让`person`等于`null`。

<img src="https://i.imgur.com/sYjcsMT.png" width="300">

我们没有修改数组第一个元素的值，而只是修改了变量`person`的值,因为元素（复制而来）的引用与`person`不同。`members`的第一个元素仍然保持着对原始对象的引用。当我们输出`members`数组时，第一个元素会将引用的对象打印出来。

</p>
</details>

---

###### 47. 输出是什么?

```javascript
const person = {
  name: "Lydia",
  age: 21
};

for (const item in person) {
  console.log(item);
}
```

- A: `{ name: "Lydia" }, { age: 21 }`
- B: `"name", "age"`
- C: `"Lydia", 21`
- D: `["name", "Lydia"], ["age", 21]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

在`for-in`循环中,我们可以通过对象的key来进行迭代,也就是这里的`name`和`age`。在底层，对象的key都是字符串（如果他们不是Symbol的话）。在每次循环中，我们将`item`设定为当前遍历到的key.所以一开始，`item`是`name`，之后 `item`输出的则是`age`。

</p>
</details>

---

###### 48. 输出是什么?

```javascript
console.log(3 + 4 + "5");
```

- A: `"345"`
- B: `"75"`
- C: `12`
- D: `"12"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

当所有运算符的 _优先级_ 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符`+`，对于加法来说，结合顺序就是从左到右。

`3 + 4`首先计算，得到数字`7`.

由于类型的强制转换，`7 + '5'`的结果是`"75"`. JavaScript将`7`转换成了字符串，可以参考问题15.我们可以用`+`号把两个字符串连接起来。 `"7" + "5"` 就得到了`"75"`.

</p>
</details>

---

###### 49. `num`的值是什么?

```javascript
const num = parseInt("7*6", 10);
```

- A: `42`
- B: `"42"`
- C: `7`
- D: `NaN`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

只返回了字符串中第一个字母. 设定了 _进制_ 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),`parseInt` 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。

`*`就是不合法的数字字符。所以只解析到`"7"`，并将其解析为十进制的`7`. `num`的值即为`7`.

</p>
</details>

---

###### 50. 输出是什么?

```javascript
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
  return num * 2;
});
```

- A: `[]`
- B: `[null, null, null]`
- C: `[undefined, undefined, undefined]`
- D: `[ 3 x empty ]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

对数组进行映射的时候,`num`就是当前循环到的元素. 在这个例子中，所有的映射都是number类型，所以if中的判断`typeof num === "number"`结果都是`true`.map函数创建了新数组并且将函数的返回值插入数组。

但是，没有任何值返回。当函数没有返回任何值时，即默认返回`undefined`.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是`undefined`.

</p>
</details>

---

###### 51. 输出的是什么?

```javascript
function getInfo(member, year) {
  member.name = "Lydia";
  year = "1998";
}

const person = { name: "Sarah" };
const birthYear = "1997";

getInfo(person, birthYear);

console.log(person, birthYear);
```

- A: `{ name: "Lydia" }, "1997"`
- B: `{ name: "Sarah" }, "1998"`
- C: `{ name: "Lydia" }, "1998"`
- D: `{ name: "Sarah" }, "1997"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

普通参数都是 _值_ 传递的，而对象则不同，是 _引用_ 传递。所以说，`birthYear`是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的 _复制_ 。（可以参考问题46）

变量`birthYear`有一个对`"1997"`的引用，而传入的参数也有一个对`"1997"`的引用，但二者的引用并不相同。当我们通过给 `year`赋值`"1998"`来更新`year`的值的时候我们只是更新了`year`（的引用）。此时`birthYear`仍然是`"1997"`.

而`person`是个对象。参数`member`引用与之 _相同的_ 对象。当我们修改`member`所引用对象的属性时,`person`的相应属性也被修改了,因为他们引用了相同的对象. `person`的 `name`属性也变成了 `"Lydia"`.

</p>
</details>

---

###### 52. 输出是什么?

```javascript
function greeting() {
  throw "Hello world!";
}

function sayHi() {
  try {
    const data = greeting();
    console.log("It worked!", data);
  } catch (e) {
    console.log("Oh no an error!", e);
  }
}

sayHi();
```

- A: `"It worked! Hello world!"`
- B: `"Oh no an error: undefined`
- C: `SyntaxError: can only throw Error objects`
- D: `"Oh no an error: Hello world!`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

通过`throw`语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个<b>字符串</b>, 一个 <b>数字</b>, 一个 <b>布尔类型</b> 或者是一个 <b>对象</b>。在本例中，我们的异常是字符串`'Hello world'`.

通过 `catch`语句，我们可以设定当`try`语句块中抛出异常后应该做什么处理。在本例中抛出的异常是字符串`'Hello world'`. `e`就是这个字符串，因此被输出。最终结果就是`'Oh an error: Hello world'`.

</p>
</details>

---

###### 53. 输出是什么?

```javascript
function Car() {
  this.make = "Lamborghini";
  return { make: "Maserati" };
}

const myCar = new Car();
console.log(myCar.make);
```

- A: `"Lamborghini"`
- B: `"Maserati"`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

返回属性的时候，属性的值等于 _返回的_ 值，而不是构造函数中设定的值。我们返回了字符串 `"Maserati"`，所以 `myCar.make`等于`"Maserati"`.

</p>
</details>

---

###### 54. 输出是什么?

```javascript
(() => {
  let x = (y = 10);
})();

console.log(typeof x);
console.log(typeof y);
```

- A: `"undefined", "number"`
- B: `"number", "number"`
- C: `"object", "number"`
- D: `"number", "undefined"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`let x = y = 10;` 是下面这个表达式的缩写:

```javascript
y = 10;
let x = y;
```

我们设定`y`等于`10`时,我们实际上增加了一个属性`y`给全局对象(浏览器里的`window`, Nodejs里的`global`)。在浏览器中， `window.y`等于`10`.

然后我们声明了变量`x`等于`y`,也是`10`.但变量是使用 `let`声明的，它只作用于 _块级作用域_, 仅在声明它的块中有效；就是案例中的立即调用表达式(IIFE)。使用`typeof`操作符时, 操作值 `x`没有被定义：因为我们在`x`声明块的外部，无法调用它。这就意味着`x`未定义。未分配或是未声明的变量类型为`"undefined"`. `console.log(typeof x)`返回`"undefined"`.

而我们创建了全局变量`y`，并且设定`y`等于`10`.这个值在我们的代码各处都访问的到。 `y`已经被定义了，而且有一个`"number"`类型的值。 `console.log(typeof y)`返回`"number"`.

</p>
</details>

---

###### <a name=20190629></a>55. 输出是什么?

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.bark = function() {
  console.log(`Woof I am ${this.name}`);
};

const pet = new Dog("Mara");

pet.bark();

delete Dog.prototype.bark;

pet.bark();
```

- A: `"Woof I am Mara"`, `TypeError`
- B: `"Woof I am Mara"`,`"Woof I am Mara"`
- C: `"Woof I am Mara"`, `undefined`
- D: `TypeError`, `TypeError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

我们可以用`delete`关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。在本例中，函数`bark`在执行了`delete Dog.prototype.bark`后不可用, 然而后面的代码还在调用它。

当我们尝试调用一个不存在的函数时`TypeError`异常会被抛出。在本例中就是 `TypeError: pet.bark is not a function`，因为`pet.bark`是`undefined`.

</p>
</details>

---

###### 56. 输出是什么?

```javascript
const set = new Set([1, 1, 2, 3, 4]);

console.log(set);
```

- A: `[1, 1, 2, 3, 4]`
- B: `[1, 2, 3, 4]`
- C: `{1, 1, 2, 3, 4}`
- D: `{1, 2, 3, 4}`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

`Set`对象手机 _独一无二_ 的值：也就是说同一个值在其中仅出现一次。

我们传入了数组`[1, 1, 2, 3, 4]`，他有一个重复值`1`.以为一个集合里不能有两个重复的值，其中一个就被移除了。所以结果是 `{1, 2, 3, 4}`.

</p>
</details>

---

###### 57. 输出是什么?

```javascript
// counter.js
let counter = 10;
export default counter;
```

```javascript
// index.js
import myCounter from "./counter";

myCounter += 1;

console.log(myCounter);
```

- A: `10`
- B: `11`
- C: `Error`
- D: `NaN`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

引入的模块是 _只读_ 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。

当我们给`myCounter`增加一个值的时候会抛出一个异常： `myCounter`是只读的，不能被修改。

</p>
</details>

---

###### 58. 输出是什么?

```javascript
const name = "Lydia";
age = 21;

console.log(delete name);
console.log(delete age);
```

- A: `false`, `true`
- B: `"Lydia"`, `21`
- C: `true`, `true`
- D: `undefined`, `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`delete`操作符返回一个布尔值： `true`指删除成功，否则返回`false`. 但是通过 `var`, `const` 或 `let` 关键字声明的变量无法用 `delete` 操作符来删除。

`name`变量由`const`关键字声明，所以删除不成功:返回 `false`. 而我们设定`age`等于`21`时,我们实际上添加了一个名为`age`的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以`delete age`返回`true`.

</p>
</details>

---

###### 59. 输出是什么?

```javascript
const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;

console.log(y);
```

- A: `[[1, 2, 3, 4, 5]]`
- B: `[1, 2, 3, 4, 5]`
- C: `1`
- D: `[1]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

我们可以通过解构赋值来解析来自对象的数组或属性的值，比如说：

```javascript
[a, b] = [1, 2];
```

<img src="https://i.imgur.com/ADFpVop.png" width="200">

`a`的值现在是`1`，`b`的值现在是`2`.而在题目中，我们是这么做的:

```javascript
[y] = [1, 2, 3, 4, 5];
```

<img src="https://i.imgur.com/NzGkMNk.png" width="200">

也就是说，`y`等于数组的第一个值就是数字`1`.我们输出`y`， 返回`1`.

</p>
</details>

---

###### 60. 输出是什么?

```javascript
const user = { name: "Lydia", age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
```

- A: `{ admin: true, user: { name: "Lydia", age: 21 } }`
- B: `{ admin: true, name: "Lydia", age: 21 }`
- C: `{ admin: true, user: ["Lydia", 21] }`
- D: `{ admin: true }`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

扩展运算符`...`为对象的组合提供了可能。你可以复制对象中的键值对，然后把它们加到另一个对象里去。在本例中，我们复制了`user`对象键值对，然后把它们加入到`admin`对象中。`admin`对象就拥有了这些键值对，所以结果为`{ admin: true, name: "Lydia", age: 21 }`.

</p>
</details>

---

###### 61. 输出是什么?

```javascript
const person = { name: "Lydia" };

Object.defineProperty(person, "age", { value: 21 });

console.log(person);
console.log(Object.keys(person));
```

- A: `{ name: "Lydia", age: 21 }`, `["name", "age"]`
- B: `{ name: "Lydia", age: 21 }`, `["name"]`
- C: `{ name: "Lydia"}`, `["name", "age"]`
- D: `{ name: "Lydia"}`, `["age"]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

通过`defineProperty`方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用`defineProperty`方法给对象添加了一个属性之后，属性默认为 _不可枚举(not enumerable)_. `Object.keys`方法仅返回对象中 _可枚举(enumerable)_ 的属性，因此只剩下了`"name"`.

用`defineProperty`方法添加的属性默认不可变。你可以通过`writable`, `configurable` 和 `enumerable`属性来改变这一行为。这样的话， 相比于自己添加的属性，`defineProperty`方法添加的属性有了更多的控制权。

</p>
</details>

---

###### 62. 输出是什么?

```javascript
const settings = {
  username: "lydiahallie",
  level: 19,
  health: 90
};

const data = JSON.stringify(settings, ["level", "health"]);
console.log(data);
```

- A: `"{"level":19, "health":90}"`
- B: `"{"username": "lydiahallie"}"`
- C: `"["level", "health"]"`
- D: `"{"username": "lydiahallie", "level":19, "health":90}"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`JSON.stringify`的第二个参数是 _替代者(replacer)_. 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。

如果替代者(replacer)是个 _数组_ ，那么就只有包含在数组中的属性将会被转化为字符串。在本例中，只有名为`"level"` 和 `"health"` 的属性被包括进来， `"username"`则被排除在外。 `data` 就等于 `"{"level":19, "health":90}"`.

而如果替代者(replacer)是个 _函数_，这个函数将被对象的每个属性都调用一遍。
函数返回的值会成为这个属性的值，最终体现在转化后的JSON字符串中（译者注：Chrome下，经过实验，如果所有属性均返回同一个值的时候有异常，会直接将返回值作为结果输出而不会输出JSON字符串），而如果返回值为`undefined`，则该属性会被排除在外。

</p>
</details>

---

###### 63. 输出是什么?

```javascript
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```

- A: `10`, `10`
- B: `10`, `11`
- C: `11`, `11`
- D: `11`, `12`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

一元操作符 `++` _先返回_ 操作值, _再累加_ 操作值。`num1`的值是`10`, 因为`increaseNumber`函数首先返回`num`的值，也就是`10`，随后再进行 `num`的累加。

`num2`是`10`因为我们将 `num1`传入`increasePassedNumber`. `number`等于`10`（`num1`的值。同样道理，`++` _先返回_ 操作值, _再累加_ 操作值。） `number`是`10`，所以`num2`也是`10`.

</p>
</details>

---

###### 64. 输出什么?

```javascript
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log(x.number *= 2);
};

multiply();
multiply();
multiply(value);
multiply(value);
```

- A: `20`, `40`, `80`, `160`
- B: `20`, `40`, `20`, `40`
- C: `20`, `20`, `20`, `40`
- D: `NaN`, `NaN`, `20`, `40`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

在ES6中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 `"undefined"` ，那么参数的值将是默认值。上述例子中，我们将 `value` 对象进行了解构并传到一个新对象中，因此 `x` 的默认值为 `{number：10}` 。

默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。我们前两次调用 `multiply` 函数且不传递值，那么每一次 `x` 的默认值都为 `{number：10}` ，因此打印出该数字的乘积值为`20`。

第三次调用 `multiply` 时，我们传递了一个参数，即对象`value`。 `*=`运算符实际上是`x.number = x.number * 2`的简写，我们修改了`x.number`的值，并打印出值`20`。

第四次，我们再次传递`value`对象。 `x.number`之前被修改为`20`，所以`x.number * = 2`打印为`40`。

</p>
</details>

---

###### 65. 输出什么?

```javascript
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
```

- A: `1` `2` and `3` `3` and `6` `4`
- B: `1` `2` and `2` `3` and `3` `4`
- C: `1` `undefined` and `2` `undefined` and `3` `undefined` and `4` `undefined`
- D: `1` `2` and `undefined` `3` and `undefined` `4`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

`reducer` 函数接收4个参数:

1. Accumulator (acc) (累计器)
2. Current Value (cur) (当前值)
3. Current Index (idx) (当前索引)
4. Source Array (src) (源数组)

`reducer` 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。

`reducer` 函数还有一个可选参数`initialValue`, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供`initialValue`，则将使用数组中的第一个元素。

在上述例子，`reduce`方法接收的第一个参数(Accumulator)是`x`, 第二个参数(Current Value)是`y`。
 
在第一次调用时，累加器`x`为`1`，当前值`“y”`为`2`，打印出累加器和当前值：`1`和`2`。

例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回`undefined`。 在下一次调用时，累加器为`undefined`，当前值为“3”, 因此`undefined`和`3`被打印出。

在第四次调用时，回调函数依然没有返回值。 累加器再次为 `undefined` ，当前值为“4”。 `undefined`和`4`被打印出。
</p>
</details>
  
---

###### 66. 使用哪个构造函数可以成功继承`Dog`类?

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1 
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4 
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
```

- A: 1
- B: 2
- C: 3
- D: 4

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

在子类中，在调用`super`之前不能访问到`this`关键字。 如果这样做，它将抛出一个`ReferenceError`：1和4将引发一个引用错误。

使用`super`关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收`name`参数，因此我们需要将`name`传递给`super`。

`Labrador`类接收两个参数，`name`参数是由于它继承了`Dog`，`size`作为`Labrador`类的额外属性，它们都需要传递给`Labrador`的构造函数，因此使用构造函数2正确完成。
</p>
</details>

---

###### 67. 输出什么?

```javascript
// index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));

// sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
```

- A: `running index.js`, `running sum.js`, `3`
- B: `running sum.js`, `running index.js`, `3`
- C: `running sum.js`, `3`, `running index.js`
- D: `running index.js`, `undefined`, `running sum.js`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`import`命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。

这是CommonJS中`require（）`和`import`之间的区别。使用`require()`，您可以在运行代码时根据需要加载依赖项。 如果我们使用`require`而不是`import`，`running index.js`，`running sum.js`，`3`会被依次打印。

</p>
</details>

---

###### 68. 输出什么?

```javascript
console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
```

- A: `true`, `true`, `false`
- B: `false`, `true`, `false`
- C: `true`, `false`, `true`
- D: `true`, `true`, `true`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

每个`Symbol`都是完全唯一的。传递给`Symbol`的参数只是给`Symbol`的一个描述。 `Symbol`的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个`Symbol（'foo'）`，第二个`Symbol（'foo'）`, 这两个值是唯一的，彼此不相等，因此返回`false`。

</p>
</details>

---

###### 69. 输出什么?

```javascript
const name = "Lydia Hallie"
console.log(name.padStart(13))
console.log(name.padStart(2))
```

- A: `"Lydia Hallie"`, `"Lydia Hallie"`
- B: `"           Lydia Hallie"`, `"  Lydia Hallie"` (`"[13x whitespace]Lydia Hallie"`, `"[2x whitespace]Lydia Hallie"`)
- C: `" Lydia Hallie"`, `"Lydia Hallie"` (`"[1x whitespace]Lydia Hallie"`, `"Lydia Hallie"`)
- D: `"Lydia Hallie"`, `"Lyd"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

使用`padStart`方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串`Lydia Hallie`的长度为`12`, 因此`name.padStart（13）`在字符串的开头只会插入1（`13 - 12 = 1`）个空格。

如果传递给`padStart`方法的参数小于字符串的长度，则不会添加填充。

</p>
</details>

---

###### 70. 输出什么?

```javascript
console.log("🥑" + "💻");
```

- A: `"🥑💻"`
- B: `257548`
- C: A string containing their code points
- D: Error

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

使用`+`运算符，您可以连接字符串。 上述情况，我们将字符串`“🥑”`与字符串`”💻“`连接起来，产生`”🥑💻“`。

</p>
</details>

---

###### 71. 如何能打印出`console.log`语句后注释掉的值？

```javascript
function* startGame() {
  const answer = yield "Do you love JavaScript?";
  if (answer !== "Yes") {
    return "Oh wow... Guess we're gone here";
  }
  return "JavaScript loves you back ❤️";
}

const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ❤️
```

- A: `game.next("Yes").value` and `game.next().value`
- B: `game.next.value("Yes")` and `game.next.value()`
- C: `game.next().value` and `game.next("Yes").value`
- D: `game.next.value()` and `game.next.value("Yes")`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

`generator`函数在遇到`yield`关键字时会“暂停”其执行。 首先，我们需要让函数产生字符串`Do you love JavaScript?`，这可以通过调用`game.next().value`来完成。上述函数的第一行就有一个`yield`关键字，那么运行立即停止了，`yield`表达式本身没有返回值，或者说总是返回`undefined`, 这意味着此时变量 `answer` 为`undefined`

`next`方法可以带一个参数，该参数会被当作上一个 `yield` 表达式的返回值。当我们调用`game.next("Yes").value`时，先前的 `yield` 的返回值将被替换为传递给`next()`函数的参数`"Yes"`。此时变量 `answer` 被赋值为 `"Yes"`，`if`语句返回`false`，所以`JavaScript loves you back ❤️`被打印。

</p>
</details>

---

###### 72. 输出什么?

```javascript
console.log(String.raw`Hello\nworld`);
```

- A: `Hello world!`
- B: `Hello` <br />&nbsp; &nbsp; &nbsp;`world`
- C: `Hello\nworld`
- D: `Hello\n` <br /> &nbsp; &nbsp; &nbsp;`world`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

`String.raw`函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（`\n`，`\v`，`\t`等）。但反斜杠可能造成问题，因为你可能会遇到下面这种类似情况：

```javascript
const path = `C:\Documents\Projects\table.html`
String.raw`${path}`
```

这将导致：

`"C:DocumentsProjects able.html"`

直接使用`String.raw`
```javascript
String.raw`C:\Documents\Projects\table.html`
```
它会忽略转义字符并打印：`C:\Documents\Projects\table.html`

上述情况，字符串是`Hello\nworld`被打印出。

</p>
</details>

---

###### 73. 输出什么?

```javascript
async function getData() {
  return await Promise.resolve("I made it!");
}

const data = getData();
console.log(data);
```

- A: `"I made it!"`
- B: `Promise {<resolved>: "I made it!"}`
- C: `Promise {<pending>}`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

异步函数始终返回一个promise。`await`仍然需要等待promise的解决：当我们调用`getData()`并将其赋值给`data`，此时`data`为`getData`方法返回的一个挂起的promise，该promise并没有解决。

如果我们想要访问已解决的值`"I made it!"`，可以在`data`上使用`.then()`方法：

`data.then(res => console.log(res))`

这样将打印 `"I made it!"`

</p>
</details>

---

###### 74. 输出什么?

```javascript
function addToList(item, list) {
  return list.push(item);
}

const result = addToList("apple", ["banana"]);
console.log(result);
```

- A: `['apple', 'banana']`
- B: `2`
- C: `true`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`push()`方法返回新数组的长度。一开始，数组包含一个元素（字符串`"banana"`），长度为1。 在数组中添加字符串`"apple"`后，长度变为2，并将从`addToList`函数返回。

`push`方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在push `item`之后返回`list`。

</p>
</details>

---

###### 75. 输出什么?

```javascript
const box = { x: 10, y: 20 };

Object.freeze(box);

const shape = box;
shape.x = 100;
console.log(shape)
```

- A: `{ x: 100, y: 20 }`
- B: `{ x: 10, y: 20 }`
- C: `{ x: 100 }`
- D: `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`Object.freeze`使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。

当我们创建变量`shape`并将其设置为等于冻结对象`box`时，`shape`指向的也是冻结对象。你可以使用`Object.isFrozen`检查一个对象是否被冻结，上述情况，`Object.isFrozen（shape）`将返回`true`。

由于`shape`被冻结，并且`x`的值不是对象，所以我们不能修改属性`x`。 `x`仍然等于`10`，`{x：10，y：20}`被打印。

注意，上述例子我们对属性`x`进行修改，可能会导致抛出TypeError异常（最常见但不仅限于严格模式下时）。

</p>
</details>

---

###### 76. 输出什么?

```javascript
const { name: myName } = { name: "Lydia" };

console.log(name);
```

- A: `"Lydia"`
- B: `"myName"`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

当我们从右侧的对象解构属性`name`时，我们将其值`Lydia`分配给名为`myName`的变量。

使用`{name：myName}`，我们是在告诉JavaScript我们要创建一个名为`myName`的新变量，并且其值是右侧对象的`name`属性的值。

当我们尝试打印`name`，一个未定义的变量时，就会引发`ReferenceError`。

</p>
</details>

---

###### 77. 以下是个纯函数么?

```javascript
function sum(a, b) {
  return a + b;
}
```

- A: Yes
- B: No

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

纯函数一种若输入参数相同，则永远会得到相同输出的函数。

`sum`函数总是返回相同的结果。 如果我们传递`1`和`2`，它将总是返回`3`而没有副作用。 如果我们传递`5`和`10`，它将总是返回`15`，依此类推，这是纯函数的定义。

</p>
</details>

---

###### 78. 输出什么?

```javascript
const add = () => {
  const cache = {};
  return num => {
    if (num in cache) {
      return `From cache! ${cache[num]}`;
    } else {
      const result = num + 10;
      cache[num] = result;
      return `Calculated! ${result}`;
    }
  };
};

const addFunction = add();
console.log(addFunction(10));
console.log(addFunction(10));
console.log(addFunction(5 * 2));
```

- A: `Calculated! 20` `Calculated! 20` `Calculated! 20`
- B: `Calculated! 20` `From cache! 20` `Calculated! 20`
- C: `Calculated! 20` `From cache! 20` `From cache! 20`
- D: `Calculated! 20` `From cache! 20` `Error`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

`add`函数是一个记忆函数。 通过记忆化，我们可以缓存函数的结果，以加快其执行速度。上述情况，我们创建一个`cache`对象，用于存储先前返回过的值。

如果我们使用相同的参数多次调用`addFunction`函数，它首先检查缓存中是否已有该值，如果有，则返回缓存值，这将节省执行时间。如果没有，那么它将计算该值，并存储在缓存中。

我们用相同的值三次调用了`addFunction`函数：

在第一次调用，`num`等于`10`时函数的值尚未缓存，if语句`num in cache`返回`false`，else块的代码被执行：`Calculated! 20`，并且其结果被添加到缓存对象，`cache`现在看起来像`{10：20}`。

第二次，`cache`对象包含`10`的返回值。 if语句 `num in cache` 返回`true`，`From cache! 20`被打印。

第三次，我们将`5 * 2`(值为10)传递给函数。 `cache`对象包含`10`的返回值。 if语句 `num in cache` 返回`true`，`From cache! 20`被打印。

</p>
</details>

---

###### <a name=20190726></a>79. 输出什么?

```javascript
const myLifeSummedUp = ["☕", "💻", "🍷", "🍫"]

for (let item in myLifeSummedUp) {
  console.log(item)
}

for (let item of myLifeSummedUp) {
  console.log(item)
}
```

- A: `0` `1` `2` `3` and `"☕"` ` "💻"` `"🍷"` `"🍫"`
- B: `"☕"` ` "💻"` `"🍷"` `"🍫"` and `"☕"` ` "💻"` `"🍷"` `"🍫"`
- C: `"☕"` ` "💻"` `"🍷"` `"🍫"` and `0` `1` `2` `3`
- D:  `0` `1` `2` `3` and `{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

通过`for-in`循环，我们可以遍历一个对象**自有的**、**继承的**、**可枚举的**、**非Symbol的**属性。 在数组中，可枚举属性是数组元素的“键”， 即它们的索引。 类似于下面这个对象：

`{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`

其中键则是可枚举属性，因此 `0`，`1`，`2`，`3`被记录。

通过`for-of`循环，我们可以迭代**可迭代对象**（包括 `Array`，`Map`，`Set`，`String`，`arguments`等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量`item`, 因此`“☕”`，`“💻“`，`”🍷”`，`“🍫“`被打印。

</p>
</details>

---

###### 80. 输出什么?

```javascript
const list = [1 + 2, 1 * 2, 1 / 2]
console.log(list)
```

- A: `["1 + 2", "1 * 2", "1 / 2"]`
- B: `["12", 2, 0.5]`
- C: `[3, 2, 0.5]`
- D:  `[1, 1, 1]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

数组元素可以包含任何值。 数字，字符串，布尔值，对象，数组，`null`，`undeifned`, 以及其他表达式，如日期，函数和计算。

元素将等于返回的值。 `1 + 2`返回`3`，`1 * 2`返回'2`，'1 / 2`返回`0.5`。

</p>
</details>

---

###### 81. 输出什么?

```javascript
function sayHi(name) {
  return `Hi there, ${name}`
}

console.log(sayHi())
```

- A: `Hi there, `
- B: `Hi there, undefined`
- C: `Hi there, null`
- D:  `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

默认情况下，如果不给函数传参，参数的值将为`undefined`。 上述情况，我们没有给参数`name`传值。 `name`等于`undefined`，并被打印。

在ES6中，我们可以使用默认参数覆盖此默认的`undefined`值。 例如：

`function sayHi（name =“Lydia”）{...}`

在这种情况下，如果我们没有传递值或者如果我们传递`undefined`，`name`总是等于字符串`Lydia`

</p>
</details>

---

###### 82. 输出什么?

```javascript
var status = "😎"

setTimeout(() => {
  const status = "😍"

  const data = {
    status: "🥑",
    getStatus() {
      return this.status
    }
  }

  console.log(data.getStatus())
  console.log(data.getStatus.call(this))
}, 0)
```

- A: `"🥑"` and `"😍"`
- B: `"🥑"` and `"😎"`
- C: `"😍"` and `"😎"`
- D: `"😎"` and `"😎"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

`this`关键字的指向取决于使用它的位置。 在**函数**中，比如`getStatus`，`this`指向的是调用它的对象，上述例子中`data`对象调用了`getStatus`，因此`this`指向的就是`data`对象。 当我们打印`this.status`时，`data`对象的`status`属性被打印，即`"🥑"`。

使用`call`方法，可以更改`this`指向的对象。`data.getStatus.call(this)`是将`this`的指向由`data`对象更改为全局对象。在全局对象上，有一个名为`status`的变量，其值为`”😎“`。 因此打印`this.status`时，会打印`“😎”`。
</p>
</details>

---

###### 83. 输出什么?

```javascript
const person = {
  name: "Lydia",
  age: 21
}

let city = person.city
city = "Amsterdam"

console.log(person)
```

- A: `{ name: "Lydia", age: 21 }`
- B: `{ name: "Lydia", age: 21, city: "Amsterdam" }`
- C: `{ name: "Lydia", age: 21, city: undefined }`
- D: `"Amsterdam"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

我们将变量`city`设置为等于`person`对象上名为`city`的属性的值。 这个对象上没有名为`city`的属性，因此变量`city`的值为`undefined`。

请注意，我们没有引用`person`对象本身，只是将变量`city`设置为等于`person`对象上`city`属性的当前值。

然后，我们将`city`设置为等于字符串`“Amsterdam”`。 这不会更改person对象：没有对该对象的引用。

因此打印`person`对象时，会返回未修改的对象。

</p>
</details>

---

###### 84. 输出什么?

```javascript
function checkAge(age) {
  if (age < 18) {
    const message = "Sorry, you're too young."
  } else {
    const message = "Yay! You're old enough!"
  }

  return message
}

console.log(checkAge(21))
```

- A: `"Sorry, you're too young."`
- B: `"Yay! You're old enough!"`
- C: `ReferenceError`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

`const`和`let`声明的变量是具有**块级作用域**的，块是大括号（`{}`）之间的任何东西, 即上述情况`if / else`语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出`ReferenceError`。

</p>
</details>

---

###### 85. 什么样的信息将被打印?

```javascript
fetch('https://www.website.com/api/user/1')
  .then(res => res.json())
  .then(res => console.log(res))
```

- A: `fetch`方法的结果
- B: 第二次调用`fetch`方法的结果
- C: 前一个`.then()`中回调方法返回的结果
- D: 总是`undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

第二个`.then`中`res`的值等于前一个`.then`中的回调函数返回的值。 你可以像这样继续链接`.then`，将值传递给下一个处理程序。

</p>
</details>

---

###### 86. 哪个选项是将`hasName`设置为`true`的方法，前提是不能将`true`作为参数传递?

```javascript
function getName(name) {
  const hasName = //
}
```

- A: `!!name`
- B: `name`
- C: `new Boolean(name)`
- D: `name.length`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

使用逻辑非运算符`!`，将返回一个布尔值，使用`!! name`，我们可以确定`name`的值是真的还是假的。 如果`name`是真实的，那么`!name`返回`false`。 `!false`返回`true`。

通过将`hasName`设置为`name`，可以将`hasName`设置为等于传递给`getName`函数的值，而不是布尔值`true`。

`new Boolean（true）`返回一个对象包装器，而不是布尔值本身。

`name.length`返回传递的参数的长度，而不是布尔值`true`。

</p>
</details>

###### 87. 输出什么?

```javascript
console.log("I want pizza"[0])
```

- A: `"""`
- B: `"I"`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

可以使用方括号表示法获取字符串中特定索引的字符，字符串中的第一个字符具有索引0，依此类推。 在这种情况下，我们想要得到索引为0的元素，字符`'I'`被记录。

请注意，IE7及更低版本不支持此方法。 在这种情况下，应该使用`.charAt（）`

</p>
</details>

---

###### 88. 输出什么?

```javascript
function sum(num1, num2 = num1) {
  console.log(num1 + num2)
}

sum(10)
```

- A: `NaN`
- B: `20`
- C: `ReferenceError`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B

您可以将默认参数的值设置为函数的另一个参数，只要另一个参数定义在其之前即可。 我们将值`10`传递给`sum`函数。 如果`sum`函数只接收1个参数，则意味着没有传递`num2`的值，这种情况下，`num1`的值等于传递的值`10`。 `num2`的默认值是`num1`的值，即`10`。 ```num1 + num2```返回`20`。

如果您尝试将默认参数的值设置为后面定义的参数，则可能导致参数的值尚未初始化，从而引发错误。比如：
```js
function test(m = n, n = 2) {
	console.log(m, n)
}
test() // Uncaught ReferenceError: Cannot access 'n' before initialization
test(3) // 3 2
test(3, 4) // 3 4
```

</p>
</details>

---

###### 89. 输出什么?

```javascript
// module.js 
export default () => "Hello world"
export const name = "Lydia"

// index.js 
import * as data from "./module"

console.log(data)
```

- A: `{ default: function default(), name: "Lydia" }`
- B: `{ default: function default() }`
- C: `{ default: "Hello world", name: "Lydia" }`
- D: Global object of `module.js`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

使用`import * as name`语法，我们将`module.js`文件中所有`export`导入到`index.js`文件中，并且创建了一个名为`data`的新对象。 在`module.js`文件中，有两个导出：默认导出和命名导出。 默认导出是一个返回字符串“Hello World”的函数，命名导出是一个名为`name`的变量，其值为字符串`“Lydia”`。

`data`对象具有默认导出的`default`属性，其他属性具有指定exports的名称及其对应的值。

</p>
</details>

---

###### 90. 输出什么?

```javascript
class Person {
  constructor(name) {
    this.name = name
  }
}

const member = new Person("John")
console.log(typeof member)
```

- A: `"class"`
- B: `"function"`
- C: `"object"`
- D: `"string"`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

类是构造函数的语法糖，如果用构造函数的方式来重写`Person`类则将是：

```javascript
function Person() {
  this.name = name
}
```

通过`new`来调用构造函数，将会生成构造函数`Person`的实例，对实例执行`typeof`关键字将返回`"object"`，上述情况打印出`"object"`。

</p>
</details>

---

###### 91. 输出什么?

```javascript
let newList = [1, 2, 3].push(4)

console.log(newList.push(5))
```

- A: `[1, 2, 3, 4, 5]`
- B: `[1, 2, 3, 5]`
- C: `[1, 2, 3, 4]`
- D: `Error`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

`.push`方法返回数组的长度，而不是数组本身！ 通过将`newList`设置为`[1,2,3].push(4)`，实际上`newList`等于数组的新长度：`4`。

然后，尝试在`newList`上使用`.push`方法。 由于`newList`是数值`4`，抛出TypeError。

</p>
</details>

---

###### 92. 输出什么?

```javascript
function giveLydiaPizza() {
  return "Here is pizza!"
}

const giveLydiaChocolate = () => "Here's chocolate... now go hit the gym already."

console.log(giveLydiaPizza.prototype)
console.log(giveLydiaChocolate.prototype)
```

- A: `{ constructor: ...}` `{ constructor: ...}` 
- B: `{}` `{ constructor: ...}` 
- C: `{ constructor: ...}` `{}`
- D: `{ constructor: ...}` `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

常规函数，例如`giveLydiaPizza`函数，有一个`prototype`属性，它是一个带有`constructor`属性的对象（原型对象）。 然而，箭头函数，例如`giveLydiaChocolate`函数，没有这个`prototype`属性。 尝试使用`giveLydiaChocolate.prototype`访问`prototype`属性时会返回`undefined`。

</p>
</details>

---

###### 93. 输出什么?

```javascript
const person = {
  name: "Lydia",
  age: 21
}

for (const [x, y] of Object.entries(person)) {
  console.log(x, y)
}
```

- A: `name` `Lydia` and `age` `21`
- B: `["name", "Lydia"]` and `["age", 21]` 
- C: `["name", "age"]` and `undefined`
- D: `Error`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A
`Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组，上述情况返回一个二维数组，数组每个元素是一个包含键和值的数组：

`[['name'，'Lydia']，['age'，21]]`

使用`for-of`循环，我们可以迭代数组中的每个元素，上述情况是子数组。 我们可以使用`const [x，y]`在`for-of`循环中解构子数组。 `x`等于子数组中的第一个元素，`y`等于子数组中的第二个元素。

第一个子阵列是`[“name”，“Lydia”]`，其中`x`等于`name`，而`y`等于`Lydia`。
第二个子阵列是`[“age”，21]`，其中`x`等于`age`，而`y`等于`21`。

</p>
</details>

---

###### 94. 输出什么?

```javascript
function getItems(fruitList, ...args, favoriteFruit) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
```

- A: `["banana", "apple", "pear", "orange"]`
- B: `[["banana", "apple"], "pear", "orange"]` 
- C: `["banana", "apple", ["pear"], "orange"]`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D

`... args`是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，**并且只能作为最后一个参数**。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。

```javascript
function getItems(fruitList, favoriteFruit, ...args) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
```

上述例子是有效的，将会返回数组：`[ 'banana', 'apple', 'orange', 'pear' ]`
</p>
</details>



###### <a name=20190817></a>95. 输出什么?

```javascript
function nums(a, b) {
  if
  (a > b)
  console.log('a is bigger')
  else 
  console.log('b is bigger')
  return 
  a + b
}

console.log(nums(4, 2))
console.log(nums(1, 2))
```

- A: `a is bigger`, `6` and `b is bigger`, `3`
- B: `a is bigger`, `undefined` and `b is bigger`, `undefined`
- C: `undefined` and `undefined`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B


在JavaScript中，我们不必显式地编写分号(`;`)，但是JavaScript引擎仍然在语句之后自动添加分号。这称为**自动分号插入**。例如，一个语句可以是变量，或者像`throw`、`return`、`break`这样的关键字。

在这里，我们在新的一行上写了一个`return`语句和另一个值`a + b `。然而，由于它是一个新行，引擎并不知道它实际上是我们想要返回的值。相反，它会在`return`后面自动添加分号。你可以这样看:

```javascript
  return;
  a + b
```

这意味着永远不会到达`a + b`，因为函数在`return`关键字之后停止运行。如果没有返回值，就像这里，函数返回`undefined`。注意，在`if/else`语句之后没有自动插入!

</p>
</details>

---

###### 96. 输出什么?

```javascript
class Person {
  constructor() {
    this.name = "Lydia"
  }
}

Person = class AnotherPerson {
  constructor() {
    this.name = "Sarah"
  }
}

const member = new Person()
console.log(member.name)
```

- A: `"Lydia"`
- B: `"Sarah"`
- C: `Error: cannot redeclare Person`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B


我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将`Person`设置为`AnotherPerson`。 这个构造函数的名字是`Sarah`，所以新的`Person`实例`member`上的name属性是`Sarah`。


</p>
</details>

---

###### 97. 输出什么?

```javascript
const info = {
  [Symbol('a')]: 'b'
}

console.log(info)
console.log(Object.keys(info))
```

- A: `{Symbol('a'): 'b'}` and `["{Symbol('a')"]`
- B: `{}` and `[]`
- C: `{ a: "b" }` and `["a"]`
- D: `{Symbol('a'): 'b'}` and `[]`

<details><summary><b>答案</b></summary>
<p>

#### 答案: D


`Symbol`类型是不可枚举的。`Object.keys`方法返回对象上的所有可枚举的键属性。`Symbol`类型是不可见的，并返回一个空数组。 记录整个对象时，所有属性都是可见的，甚至是不可枚举的属性。

这是`Symbol`的众多特性之一：除了表示完全唯一的值（防止对象意外名称冲突，例如当使用2个想要向同一对象添加属性的库时），您还可以`隐藏`这种方式对象的属性（尽管不完全。你仍然可以使用`Object.getOwnPropertySymbols()`方法访问 `Symbol`。

</p>
</details>

---

###### 98. 输出什么?

```javascript
const getList = ([x, ...y]) => [x, y]
const getUser = user => { name: user.name, age: user.age }

const list = [1, 2, 3, 4]
const user = { name: "Lydia", age: 21 }

console.log(getList(list))
console.log(getUser(user))
```

- A: `[1, [2, 3, 4]]` and `undefined`
- B: `[1, [2, 3, 4]]` and `{ name: "Lydia", age: 21 }`
- C: `[1, 2, 3, 4]` and `{ name: "Lydia", age: 21 }`
- D: `Error` and `{ name: "Lydia", age: 21 }`

<details><summary><b>答案</b></summary>
<p>

#### 答案: A

`getList`函数接收一个数组作为其参数。 在`getList`函数的括号之间，我们立即解构这个数组。 您可以将其视为：

 `[x, ...y] = [1, 2, 3, 4]`
 

使用剩余的参数`... y`，我们将所有剩余参数放在一个数组中。 在这种情况下，其余的参数是`2`，`3`和`4`。 `y`的值是一个数组，包含所有其余参数。 在这种情况下，`x`的值等于`1`，所以当我们打印`[x，y]`时，会打印`[1，[2,3,4]]`。

 `getUser`函数接收一个对象。对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须在圆括号之间编写它，否则不会返回任何值!下面的函数将返回一个对象:

```const getUser = user => ({ name: user.name, age: user.age })```

由于在这种情况下不返回任何值，因此该函数返回`undefined`。

</p>
</details>

---

###### 99. 输出什么?

```javascript
const name = "Lydia"

console.log(name())
```

- A: `SyntaxError`
- B: `ReferenceError`
- C: `TypeError`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C


变量`name`保存字符串的值，该字符串不是函数，因此无法调用。

当值不是预期类型时，会抛出`TypeErrors`。 JavaScript期望`name`是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出`TypeError`：`name is not a function`

当你编写了一些非有效的JavaScript时，会抛出语法错误，例如当你把`return`这个词写成`retrun`时。
当JavaScript无法找到您尝试访问的值的引用时，抛出`ReferenceErrors`。

</p>
</details>

---

###### 100. 输出什么?

```javascript
// 🎉✨ This is my 100th question! ✨🎉

const output = `${[] && 'Im'}possible!
You should${'' && `n't`} see a therapist after so much JavaScript lol`
```

- A: `possible! You should see a therapist after so much JavaScript lol`
- B: `Impossible! You should see a therapist after so much JavaScript lol`
- C: `possible! You shouldn't see a therapist after so much JavaScript lol`
- D: `Impossible! You shouldn't see a therapist after so much JavaScript lol`

<details><summary><b>答案</b></summary>
<p>

#### 答案: B


`[]`是一个真值。 使用`&&`运算符，如果左侧值是真值，则返回右侧值。 在这种情况下，左侧值`[]`是一个真值，所以返回`Im`。

`""`是一个假值。 如果左侧值是假的，则不返回任何内容。 `n't`不会被退回。

</p>
</details>

---

###### 101.输出什么?

```javascript
const one = (false || {} || null)
const two = (null || false || "")
const three = ([] || 0 || true)

console.log(one, two, three)
```

- A: `false` `null` `[]`
- B: `null` `""` `true`
- C: `{}` `""` `[]`
- D: `null` `null` `true`

<details><summary><b>答案</b></summary>
<p>

#### 答案: C

使用`||`运算符，我们可以返回第一个真值。 如果所有值都是假值，则返回最后一个值。

`（false || {} || null）`：空对象`{}`是一个真值。 这是第一个（也是唯一的）真值，它将被返回。`one`等于`{}`。

`（null || false ||“”）`：所有值都是假值。 这意味着返回传递的值`""`。 `two`等于`""`。

`（[] || 0 ||“”）`：空数组`[]`是一个真值。 这是第一个返回的真值。 `three`等于`[]`。

</p>
</details>
# web-interview

<p align="left">
  <a href="https://github.com/yisainan/web-interview/issues"><img src="https://img.shields.io/github/issues/yisainan/web-interview" alt="issues"></a>
  <a href="https://github.com/yisainan/web-interview/stargazers"><img src="https://img.shields.io/github/stars/yisainan/web-interview" alt="stars"></a>
  <a href="https://github.com/yisainan/web-interview/network/members"><img src="https://img.shields.io/github/forks/yisainan/web-interview" alt="forks"></a>  
</p>

<!-- 
// 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣
-->

🚀 欢迎`Star`与分享，后续会不断更新。[gitee版本阅读更流畅，点击阅读](https://gitee.com/qiilee/web-interview)  
🇨🇳 最后更新日期：2️⃣0️⃣2️⃣2️⃣`/`0️⃣1️⃣`/`2️⃣7️⃣
   

## 目录

<b><details><summary>💡 介绍</summary></b>

1、本仓库是面向 web 前端开发者准备面试使用；知识在于积累，切勿刷题作面霸！

2、如何成为一名合格的前端开发工程师呢？

首先前端基础一定要精（三大基础：html, css, js），其他基于这些扩展出来的框架（三大框架：vue，react，angular）一定要广。底层精，上层广，这就是一名合格的前端开发工程师。

3、建议阅读

- [写给前端面试者](https://github.com/amfe/article/issues/5)

🙏 建议自己先有个思考的过程，有了自己的答案或者疑问再看解析进行对比；仓库将持续更新，欢迎 <b>Star</b>，如有内容错误或改进意见，欢迎 [issue](https://github.com/yisainan/web-interview/issues/new?assignees=&labels=Bug&template=---------.md&title=%5Bbug%5D+) 或 pr。

</details>

<b><details><summary>🐭 HTML</summary></b>

- [详情](./content/HTML.md)
- [浏览器](./content/浏览器.md)

</details>

<b><details><summary>🐮 CSS</summary></b>

- [详情](./content/CSS.md)

</details>

<b><details><summary>🐯 JS</summary></b>

- [js 基础](./content/js/js.md)
- [es6](./content/js/es6.md)
- [jquery](./content/js/jquery.md)
- [node](./content/js/node.md)
- [Ajax](./content/js/Ajax.md)
- [算法](./content/js/算法.md)

</details>

<b><details><summary>🐰 Vue + React</summary></b>

- Vue
  - [Vue](./content/vue/vue.md)
  - [fe-interview-vue](./content/vue/fe-interview-vue.md)

- React
  - [React](./content/react/React.md)
  - [reactjs-interview-questions](./content/react/reactjs-interview-questions.md)
  - [fe-interview-react](./content/react/fe-interview-react.md)

</details>

<b><details><summary>🐉 Angular</summary></b>

- [详情](./content/Angular.md)

</details>

<b><details><summary>🐍 微信小程序</summary></b>

- [详情](./content/微信小程序.md)

</details>

<b><details><summary>🐎 选择题</summary></b>

- [详情](./content/选择题/js.md)
- [JavaScript专项练习](./content/选择题/JavaScript专项练习.md)

</details>

<b><details><summary>🐐 编程题</summary></b>

- [js 基础](./content/编程题/js.md)
- [js 原型](./content/编程题/prototype.md)
- [es6](./content/编程题/es6.md)
- [变量提升](./content/编程题/变量提升.md)

</details>

<b><details><summary>🙊 兼容性问题</summary></b>

- [详情](./content/兼容性问题.md)

</details>

<b><details><summary>🐔 大厂高频题</summary></b>

- [详情](./content/大厂高频题.md)

</details>

<b><details><summary>🐶 网络及安全防护</summary></b>

- [详情](./content/网络及安全防护.md)

</details>

<b><details><summary>🐷 框架/工程/项目</summary></b>

- [详情](./content/框架工程项目.md)

</details>

<b><details><summary>❓ 软技能</summary></b>

- [常问的非技术问题](./content/软技能/非技术问题.md)
- [面试技巧及注意事项](./content/软技能/面试技巧及注意事项.md)
- [谈钱不伤感情，如何在面试中争取高薪](./content/软技能/谈钱不伤感情，如何在面试中争取高薪.md)

</details>

<b><details><summary>📝 前端简历</summary></b>

- [如何写好前端简历](./content/简历/如何写好前端简历.md)
- [获取简历模板](./content/简历/获取简历模板.md)

</details>

<b><details><summary>👬 贡献者</summary></b>

[按照本仓库收集时间排序，如有侵权请联系删除](https://github.com/yisainan/web-interview/projects/3#column-6811772)

</details>

<b><details><summary>📜 License</summary></b>

本仓库遵循 MIT 协议，转载请注明出处。

[![MIT](https://img.shields.io/github/license/yisainan/web-interview)](https://github.com/yisainan/web-interview/blob/master/LICENSE)

</details>

<br/>

<!-- # 本周经典（每周日更新）

繁忙的一周又过去了，这几道题你看了吗？


<br/> -->

## 参与互动

每道题目的下面，新增了**参与互动**功能，以"面试题"为中心，大家利用碎片时间一起思考讨论，维护好我们的题库，面试时才能更好的回馈自己！

因个人精力有限，部分面试题暂无答案，欢迎小伙伴们在 issues [给出答案](https://github.com/yisainan/web-interview/projects/3#column-6811844)

<br/>

<!-- ## 我来出题

大家都参与进来，才能使项目更加完善。详见：[出题步骤](https://github.com/yisainan/web-interview/issues/813)

<br/> -->

## 学习交流

关注微信公众号「**[前端面试秘籍](https://open.weixin.qq.com/qr/code?username=web-interview)**」，可以

1. 获取更多 web 前端及其他 IT 技术的优质资源(含简历模板)
2. 加入微信群学习交流

加油~同学！将来的你一定会感谢现在拼命努力的自己！

<!-- ![二维码](./images/qrcode_001.jpg) -->

<br/>

## 我的推荐

#### 前端
- [新蜂商城Vue3 版本](https://github.com/newbee-ltd/newbee-mall-vue3-app)
- [JavaScript开发者应懂的33个概念](https://github.com/stephentian/33-js-concepts)
- [前端技能汇总](https://github.com/JacksonTian/fks)
- [微信小程序开发资源汇总](https://github.com/justjavac/awesome-wechat-weapp)
- [Vue相关开源项目库汇总](https://github.com/opendigg/awesome-github-vue)
- [GitHub最全的前端资源汇总仓库](https://github.com/helloqingfeng/Awsome-Front-End-learning-resource)
- [React Native指南汇集了各类react-native学习资源、开源App和组件](https://github.com/reactnativecn/react-native-guide)

#### 后端
- [《Node.js 包教不包会》](https://github.com/alsotang/node-lessons)
- [Spring Boot 教程、技术栈示例代码，快速简单上手教程](https://github.com/ityouknow/spring-boot-examples)
- [Python初学者（零基础学习Python、Python入门）书籍、视频、资料、社区推荐](https://github.com/Yixiaohan/codeparkshare)
- [Go 语言学习资料索引](https://github.com/unknwon/go-study-index)

#### 其他
- [学习资料分享](https://github.com/small-sweet)
- [程序员考公指南](https://github.com/coder2gwy/coder2gwy)
- [开源项目挣钱实用手册](https://github.com/wizicer/FinancialSupportForOpenSource)
- [程序员如何优雅的挣零花钱](https://github.com/easychen/howto-make-more-money)
- [程序员要有自己的云服务器](https://www.aliyun.com/minisite/goods?userCode=yc6paakd)---
name: 选择题模板
about: 这是一个用于发布选择题的模板
title: "[选择题] "
labels: 选择题
assignees: ''

---


---
name: Ajax面试题模板
about: 这是一个用于发布ajax面试题的模板
title: "[ajax] "
labels: Ajax
assignees: ''

---


---
name: Angular面试题模板
about: 这是一个用于发布angularjs面试题的模板
title: "[angular] "
labels: Angular
assignees: ''

---


---
name: CSS面试题模板
about: 这是一个用于发布css面试题的模板
title: "[css] "
labels: CSS
assignees: ''

---


